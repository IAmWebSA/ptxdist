Index: TODO.ptx
===================================================================
--- a/TODO.ptx	(revision 0)
+++ b/TODO.ptx	(revision 675)
@@ -0,0 +1,6 @@
+2.6.11-rc4: 
+
+- smc91x is broken
+- fix i2c, check changes in i2c-sensors.h
+
+
Index: kernel/gpio.c
===================================================================
--- a/kernel/gpio.c	(revision 0)
+++ b/kernel/gpio.c	(revision 675)
@@ -0,0 +1,533 @@
+/*
+ * linux/kernel/gpio.c
+ *
+ * (C) 2004 Robert Schwebel, Pengutronix
+ * 
+ * modified by Benedikt Spranger, Pengutronix
+ * modified by Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+#include <linux/parser.h>
+
+#define DRIVER_NAME "gpio"
+
+static char mapping[255] = "";
+
+MODULE_AUTHOR("John Lenz, Robert Schwebel");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Generic GPIO Infrastructure");
+module_param_string(mapping, mapping, sizeof(mapping), 0);
+MODULE_PARM_DESC(mapping,
+"period delimited options string to map GPIO pins to userland:\n"
+"\n"
+"	<pin>:[out|in][hi|lo]\n"
+"\n"
+"	example: mapping=5:out:hi.8:in\n"	
+);
+
+static ssize_t gpio_show_level(struct class_device *dev, char *buf);
+static ssize_t gpio_store_level(struct class_device *dev, const char *buf, size_t size);
+static ssize_t gpio_show_policy(struct class_device *dev, char *buf);
+
+struct gpio_properties {
+	unsigned int       pin_nr;
+	unsigned char      policy;	/* GPIO_xxx */
+	char               pin_level;	/* -1=tristate, 0, 1 */
+	char               owner[20];
+	struct gpio_device *gpio_dev;
+};
+
+struct gpio_device {
+	spinlock_t lock; 		/* protects the props field */
+	struct gpio_properties props;
+	struct class_device class_dev;
+	struct list_head list;
+};
+#define to_gpio_device(d) container_of(d, struct gpio_device, class_dev)
+
+static LIST_HEAD(gpio_list);
+static rwlock_t gpio_list_lock = RW_LOCK_UNLOCKED;
+
+/* gpio_device is static, so we don't have to free it here */
+static void gpio_class_release(struct class_device *dev)
+{
+	return;
+}
+
+static struct class gpio_class = {
+	.name		= "gpio",
+	.release	= gpio_class_release,
+};
+
+
+/* 
+ * Attribute: /sys/class/gpio/gpioX/level 
+ */
+static struct class_device_attribute attr_gpio_level = {
+	.attr = { .name = "level", .mode = 0644, .owner = THIS_MODULE },
+	.show = gpio_show_level,
+	.store = gpio_store_level,
+};
+
+static ssize_t gpio_show_level(struct class_device *dev, char *buf)
+{
+	struct gpio_device *gpio_dev = to_gpio_device(dev);
+	ssize_t ret_size = 0;
+	
+	spin_lock(&gpio_dev->lock);
+	if (!(gpio_dev->props.policy & GPIO_OUTPUT))
+                gpio_dev->props.pin_level = gpio_get_pin(gpio_dev->props.pin_nr);
+	
+	ret_size += sprintf(buf, "%i\n", gpio_dev->props.pin_level);
+	spin_unlock(&gpio_dev->lock);
+
+	return ret_size;
+}
+
+static ssize_t gpio_store_level(struct class_device *dev, const char *buf, size_t size)
+{
+	struct gpio_device *gpio_dev = to_gpio_device(dev);
+	long value;
+	
+	spin_lock(&gpio_dev->lock);
+	if (!(gpio_dev->props.policy & GPIO_OUTPUT)) {
+                spin_unlock(&gpio_dev->lock);
+		return -EINVAL;
+        }
+	
+	value = simple_strtol(buf, NULL, 10);
+	
+	if (value) value = 1;
+	gpio_dev->props.pin_level = value;
+
+	/* set real hardware */
+	switch (value) {
+		case 0:  gpio_clear_pin(gpio_dev->props.pin_nr); 
+			 gpio_dir_output(gpio_dev->props.pin_nr); 
+			 break;
+		case 1:  gpio_set_pin(gpio_dev->props.pin_nr); 
+			 gpio_dir_output(gpio_dev->props.pin_nr);
+			 break;
+		default: break;
+	}
+	spin_unlock(&gpio_dev->lock);
+	return size;
+}
+
+/* 
+ * Attribute: /sys/class/gpio/gpioX/policy 
+ */
+static struct class_device_attribute attr_gpio_policy = {
+	.attr = { .name = "policy", .mode = 0444, .owner = THIS_MODULE },
+	.show = gpio_show_policy,
+	.store = NULL, 
+};
+
+static ssize_t gpio_show_policy(struct class_device *dev, char *buf)
+{
+	struct gpio_device *gpio_dev = to_gpio_device(dev);
+	ssize_t ret_size = 0;
+	
+	spin_lock(&gpio_dev->lock);
+	if (gpio_dev->props.policy & GPIO_USER)
+	    ret_size += sprintf(buf,"userspace\n");
+	else
+	    ret_size += sprintf(buf,"kernel\n");
+	spin_unlock(&gpio_dev->lock);
+
+	return ret_size;
+}
+
+static int gpio_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	char *p = page;
+	int size = 0;
+	struct gpio_device *gpio_dev;
+	struct list_head *lact, *ltmp;
+
+	if (off != 0)
+		goto end;
+
+	p += sprintf(p, "GPIO   POLICY       DIRECTION    OWNER\n");
+	read_lock(&gpio_list_lock);
+	list_for_each_safe(lact, ltmp, &gpio_list) {
+		gpio_dev = list_entry(lact, struct gpio_device, list);
+		spin_lock(&gpio_dev->lock);
+		p += sprintf(p, "%3i:   ", gpio_dev->props.pin_nr);
+	
+		if (gpio_dev->props.policy & GPIO_USER)
+		    p += sprintf(p, "user space   ");
+		else 
+		    p += sprintf(p, "kernel       ");
+
+		if (gpio_dev->props.policy & GPIO_OUTPUT)
+		    p += sprintf(p, "output       ");
+		else
+		    p += sprintf(p, "input        ");
+		
+		p += sprintf(p, "%s\n", gpio_dev->props.owner);
+		spin_unlock(&gpio_dev->lock);
+	}
+	read_unlock(&gpio_list_lock);
+end:
+	size = (p - page);
+	if (size <= off + count)
+		*eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size > count)
+		size = count;
+	if (size < 0)
+		size = 0;
+
+	return size;
+}
+
+/** 
+ * request_gpio - register a new object of gpio_device class.  
+ *
+ * @pin_nr:     GPIO pin which is registered
+ * @owner:      name of the driver that owns this pin
+ * @policy:     set policy for this pin, which is one of these: 
+ * 		- GPIO_USER or GPIO_KERNEL
+ * 		- GPIO_INPUT or GPIO_OUTPUT
+ * 		For user space registered pins a sysfs entry is added. 
+ * @init_level: initially configured pin level
+ */
+int request_gpio(unsigned int pin_nr, const char *owner,
+		 unsigned char policy, unsigned char init_level)
+{
+	int rc;
+	struct gpio_device *gpio_dev;
+	struct list_head *lact, *ltmp;
+
+	write_lock(&gpio_list_lock);
+	list_for_each_safe(lact, ltmp, &gpio_list) {
+		gpio_dev = list_entry(lact, struct gpio_device, list);
+		if (pin_nr == gpio_dev->props.pin_nr) {
+			printk(KERN_ERR "gpio pin %i is already used by %s\n",
+			       pin_nr, gpio_dev->props.owner);
+			write_unlock(&gpio_list_lock);
+			return -EBUSY;
+		}
+	}
+	
+	gpio_dev = kmalloc(sizeof(struct gpio_device), GFP_KERNEL);
+	
+	if (unlikely(!gpio_dev)) {
+		printk(KERN_ERR "%s: couldn't allocate memory\n", DRIVER_NAME);
+		write_unlock(&gpio_list_lock);
+		return -ENOMEM;
+	}
+	
+	gpio_dev->props.pin_nr = pin_nr;
+	INIT_LIST_HEAD(&gpio_dev->list);
+	list_add_tail(&gpio_dev->list, &gpio_list);
+	write_unlock(&gpio_list_lock);
+	
+	spin_lock_init(&gpio_dev->lock);
+	gpio_dev->props.policy = policy;
+	gpio_dev->props.pin_level = init_level;
+	gpio_dev->props.gpio_dev = gpio_dev;
+	
+	strncpy(gpio_dev->props.owner, owner, 20);
+
+	memset(&gpio_dev->class_dev, 0, sizeof(gpio_dev->class_dev));
+	gpio_dev->class_dev.class = &gpio_class;
+	snprintf(gpio_dev->class_dev.class_id, BUS_ID_SIZE, "gpio%i", pin_nr);
+
+	rc = class_device_register(&gpio_dev->class_dev);
+	if (unlikely(rc)) {
+		printk(KERN_ERR "%s: class registering failed\n", DRIVER_NAME);
+		kfree(gpio_dev);
+		return rc;
+	}
+
+	/* register the attributes */
+	if (policy & GPIO_USER)
+		class_device_create_file(&gpio_dev->class_dev, 
+					 &attr_gpio_level);
+	
+	class_device_create_file(&gpio_dev->class_dev, &attr_gpio_policy);
+
+	/* set real hardware */
+	spin_lock(&gpio_dev->lock);
+	if (policy & GPIO_OUTPUT) {
+		switch (init_level) {
+			case 0: gpio_clear_pin(pin_nr); break;
+			case 1: gpio_set_pin(pin_nr); break;
+			default: break; 
+		}
+		gpio_dir_output(pin_nr); 
+	}
+	spin_unlock(&gpio_dev->lock);
+	
+	printk(KERN_INFO "registered gpio%i\n", pin_nr);
+
+	return 0;
+}
+EXPORT_SYMBOL(request_gpio);
+
+
+/**
+ * free_gpio - unregisters a object of gpio_properties class.
+ *
+ * @pin_nr: pin number to free. 
+ *
+ * Unregisters a previously registered via request_gpio object.
+ */
+void free_gpio(unsigned int pin_nr)
+{
+	struct gpio_device *gpio_dev;
+	struct list_head *lact, *ltmp;
+	
+	write_lock(&gpio_list_lock);
+	list_for_each_safe(lact, ltmp, &gpio_list) {
+		gpio_dev = list_entry(lact, struct gpio_device, list);
+		if (pin_nr == gpio_dev->props.pin_nr) {
+
+			printk(KERN_INFO "unregistering gpio pin %i\n", pin_nr);
+
+			/* unregister attributes */
+			if (gpio_dev->props.policy & GPIO_USER)
+				class_device_remove_file(&gpio_dev->class_dev,
+							 &attr_gpio_level);
+
+                        list_del(&gpio_dev->list);
+                        write_unlock(&gpio_list_lock);
+                        class_device_unregister(&gpio_dev->class_dev);
+                        kfree(gpio_dev);
+
+			return;
+		}
+	}
+	write_unlock(&gpio_list_lock);
+	return;
+}
+EXPORT_SYMBOL(free_gpio);
+
+
+static struct sysdev_class gpio_sysclass = {
+	set_kset_name("gpio"),
+};
+
+static struct sys_device gpio_sys_device = {
+	.id		= 0,
+	.cls		= &gpio_sysclass,
+};
+
+
+enum { 
+	Opt_in, 
+	Opt_out_high, 
+	Opt_out_low, 
+	Opt_err,
+};
+	
+
+static match_table_t tokens = 
+{
+	{Opt_in, "%u:in"},
+	{Opt_out_high,"%u:out:hi"},
+	{Opt_out_low,"%u:out:lo"},
+	{Opt_err, NULL}
+};
+
+
+/**
+ * gpio_setup - parses string and registers gpio
+ *
+ * @s: string to parse
+ *
+ */
+static int gpio_setup(char *s)
+{
+	char *pin_nr_str;
+	int pin_nr;
+	unsigned char policy;
+	unsigned char init_level;
+	substring_t args[MAX_OPT_ARGS];
+	int token;
+
+        init_level = 0;
+        policy = GPIO_USER;
+
+        token = match_token(s, tokens, args);
+        switch(token) {
+                /* global fallthrough */
+        case Opt_out_high:
+                init_level = 1;
+        case Opt_out_low:
+                policy |= GPIO_OUTPUT;
+        case Opt_in:
+                pin_nr_str = args[0].from;
+                pin_nr = simple_strtoull(pin_nr_str, &pin_nr_str, 0);
+                break;
+			
+        default:
+                printk(KERN_ERR "%s: Unrecognized option \"%s\"\n", DRIVER_NAME, s);
+                return -EINVAL;
+        }
+
+        if (request_gpio(pin_nr, "kernel", policy, init_level) != 0) {
+                printk(KERN_ERR "%s: could not register GPIO pins!\n",
+                       DRIVER_NAME);
+                return -EIO;
+        }
+        
+	return 0;
+}
+
+
+/**
+ * called by sysfs framework on behalf of the user, to map gpio pin to userspace
+ */
+static ssize_t gpio_map_store(struct class *class, const char *buf, size_t count)
+{
+        int ret;
+        char *tmp;
+
+        /* fist '\n' at the end of the buffer? */
+        if (((char *)memchr(buf, '\n', count) - buf + 1) != count)
+                return -EINVAL;
+
+        tmp = (char *)kmalloc(count, GFP_KERNEL);
+        if (!tmp)
+                return -ENOMEM;
+
+        /* override the '\n' with end-of-string '\0' */
+        strncpy(tmp, buf, count);
+        *(tmp + count - 1) = '\0';
+
+        ret = gpio_setup(tmp);
+
+        kfree(tmp);
+        
+        return ret ? ret : count;
+}
+
+
+/**
+ * called by sysfs framework on behalf of the user, to unmap gpio pin from userspace
+ */
+static ssize_t gpio_unmap_store(struct class *class, const char *buf, size_t count)
+{
+	struct gpio_device *gpio_dev;
+	struct list_head *lact, *ltmp;
+        char *end;
+        int pin_nr;
+
+        pin_nr = (int)simple_strtol(buf, &end, 10);
+
+        /* stuff after pin-number */
+        if ((end - buf + 1) != count)
+                return -EINVAL;
+
+	write_lock(&gpio_list_lock);
+	list_for_each_safe(lact, ltmp, &gpio_list) {
+		gpio_dev = list_entry(lact, struct gpio_device, list);
+		if (pin_nr == gpio_dev->props.pin_nr) {
+
+			printk(KERN_INFO "unregistering gpio pin %i\n", pin_nr);
+
+			/* unregister attributes */
+			if (! (gpio_dev->props.policy & GPIO_USER)) {
+                                return -EACCES;
+                        }
+                        class_device_remove_file(&gpio_dev->class_dev,
+                                                 &attr_gpio_level);
+
+                        list_del(&gpio_dev->list);
+                        write_unlock(&gpio_list_lock);
+                        class_device_unregister(&gpio_dev->class_dev);
+                        kfree(gpio_dev);
+
+			return count;
+		}
+	}
+	write_unlock(&gpio_list_lock);
+
+        printk(KERN_ERR "could not unregister gpio pin %i\n", pin_nr);
+        return -ENXIO;
+}
+
+static CLASS_ATTR(map_gpio,     0200,   NULL,   gpio_map_store);
+static CLASS_ATTR(unmap_gpio,   0200,   NULL,   gpio_unmap_store);
+
+
+static int __init gpio_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Initialising gpio device class.\n");
+
+	ret = class_register(&gpio_class);
+        if (ret) {
+		printk(KERN_ERR "%s: couldn't register class, exiting\n", DRIVER_NAME);
+		goto out_class;
+	}
+
+	ret = sysdev_class_register(&gpio_sysclass);
+	if (ret) {
+		printk(KERN_ERR "%s: couldn't register sysdev class, exiting\n", DRIVER_NAME);
+		goto out_sysdev_class;
+	}
+
+	ret = sysdev_register(&gpio_sys_device);
+	if (ret) {
+		printk(KERN_ERR "%s: couldn't register sysdev, exiting\n", DRIVER_NAME);
+		goto out_sysdev_register;
+	}
+
+        ret = class_create_file(&gpio_class, &class_attr_map_gpio);
+        if (ret) {
+		printk(KERN_ERR "%s: couldn't register class attribute, exiting\n", DRIVER_NAME);
+                goto out_class_create_file_map_gpio;
+        }
+        
+        ret = class_create_file(&gpio_class, &class_attr_unmap_gpio);
+        if (ret) {
+		printk(KERN_ERR "%s: couldn't register class attribute, exiting\n", DRIVER_NAME);
+                goto out_class_create_file_unmap_gpio;
+        }
+
+        if (!create_proc_read_entry ("gpio", 0, 0, gpio_read_proc, NULL)) {
+		printk(KERN_ERR "%s: couldn't register proc entry, exiting\n", DRIVER_NAME);
+                ret = -1;
+		goto out_proc;
+	}
+
+	return ret;
+
+out_proc:
+        class_remove_file(&gpio_class, &class_attr_unmap_gpio);
+out_class_create_file_unmap_gpio:
+        class_remove_file(&gpio_class, &class_attr_map_gpio);
+out_class_create_file_map_gpio:
+	sysdev_unregister(&gpio_sys_device);
+out_sysdev_register:
+	sysdev_class_unregister(&gpio_sysclass);
+out_sysdev_class:
+	class_unregister(&gpio_class);
+out_class:
+	return ret;
+}
+
+module_init(gpio_init);
Index: kernel/Makefile
===================================================================
--- a/kernel/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/kernel/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -26,6 +26,7 @@
 obj-$(CONFIG_KPROBES) += kprobes.o
 obj-$(CONFIG_SYSFS) += ksysfs.o
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
+obj-$(CONFIG_GPIO) += gpio.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
Index: include/asm-arm/mach/mmc.h
===================================================================
--- a/include/asm-arm/mach/mmc.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/asm-arm/mach/mmc.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -13,3 +13,19 @@
 };
 
 #endif
+/*
+ *  linux/include/asm-arm/mach/mmc.h
+ */
+#ifndef ASMARM_MACH_MMC_H
+#define ASMARM_MACH_MMC_H
+
+#include <linux/mmc/protocol.h>
+
+struct mmc_platform_data {
+	unsigned int mclk;			/* mmc base clock rate */
+	unsigned int ocr_mask;			/* available voltages */
+	u32 (*translate_vdd)(struct device *, unsigned int);
+	unsigned int (*status)(struct device *);
+};
+
+#endif
Index: include/asm-arm/arch-pxa/gpio.h
===================================================================
--- a/include/asm-arm/arch-pxa/gpio.h	(revision 0)
+++ b/include/asm-arm/arch-pxa/gpio.h	(revision 675)
@@ -0,0 +1,50 @@
+/*
+ * linux/include/asm-arm/arch-pxa/gpio.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ARM_PXA_GPIO_H
+#define __ARM_PXA_GPIO_H
+
+#include <linux/kernel.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+
+#define DEBUG 1
+
+static inline void gpio_set_pin(int gpio_nr)
+{
+	GPSR(gpio_nr) |= GPIO_bit(gpio_nr);
+	return;
+}
+
+static inline void gpio_clear_pin(int gpio_nr)
+{
+	GPCR(gpio_nr) |= GPIO_bit(gpio_nr);
+	return;
+}
+
+static inline void gpio_dir_input(int gpio_nr)
+{
+	GPDR(gpio_nr) &= ~GPIO_bit(gpio_nr);
+	return;
+}
+
+static inline void gpio_dir_output(int gpio_nr)
+{
+	GPDR(gpio_nr) |= GPIO_bit(gpio_nr);
+	return;
+}
+
+static inline int gpio_get_pin(int gpio_nr)
+{
+	return GPLR(gpio_nr) & GPIO_bit(gpio_nr) ? 1:0;
+}
+
+
+#endif
Index: include/asm-arm/arch-pxa/pnp2110.h
===================================================================
--- a/include/asm-arm/arch-pxa/pnp2110.h	(revision 0)
+++ b/include/asm-arm/arch-pxa/pnp2110.h	(revision 675)
@@ -0,0 +1,47 @@
+/*
+ * linux/include/asm-arm/arch-pxa/pnp2110.h
+ *
+ * (c) 2004 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _INCLUDE_ASMARM_ARCHPXA_PNP2110_H_
+#define _INCLUDE_ASMARM_ARCHPXA_PHP2110_H_
+
+/* 
+ * Ethernet chip (SMSC91C111)
+ */
+
+#define GPIO_PNP2110_ETH		0
+#define PNP2110_10_ETH_PHYS		(0x2C000300)		/* Rev. 1.0: 0x2C000300 */
+#define PNP2110_20_ETH_PHYS		(PXA_CS1_PHYS+0x0300)	/* Rev. 2.0: 0x04000300 */
+#define PNP2110_ETH_SIZE		(0x1000)
+#define PNP2110_ETH_IRQ			IRQ_GPIO(GPIO_PNP2110_ETH)
+#define PNP2110_ETH_IRQ_EDGE		IRQT_RISING
+
+/*
+ * virtual to physical conversion macros
+ */
+#define PNP2110_P2V(x)		((x) - PNP2110_FPGA_PHYS + PNP2110_FPGA_VIRT)
+#define PNP2110_V2P(x)		((x) - PNP2110_FPGA_VIRT + PNP2110_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __PNP2110_REG(x)	(*((volatile unsigned long *)PNP2110_P2V(x)))
+#else
+#  define __PNP2110_REG(x)	PNP2110_P2V(x)
+#endif
+
+#endif
Index: include/asm-arm/arch-pxa/csb226.h
===================================================================
--- a/include/asm-arm/arch-pxa/csb226.h	(revision 0)
+++ b/include/asm-arm/arch-pxa/csb226.h	(revision 675)
@@ -0,0 +1,49 @@
+/*
+ * linux/include/asm-arm/arch-pxa/csb226.h
+ *
+ * (c) 2003 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _INCLUDE_ASMARM_ARCHPXA_CSB226_H_
+#define _INCLUDE_ASMARM_ARCHPXA_CSB226_H_
+
+#include <asm/arch/pxa-regs.h>
+/* 
+ * GPIOs 
+ */
+#define GPIO_CSB226_ETH		14
+
+/* 
+ * ethernet chip (CS8900) 
+ */
+#define CSB226_ETH_PHYS		PXA_CS2_PHYS	/* 0x08000000 */
+#define CSB226_ETH_VIRT		(0xf8000000)
+#define CSB226_ETH_SIZE		(1*1024*1024)
+#define CSB226_ETH_IRQ		IRQ_GPIO(GPIO_CSB226_ETH)
+#define CSB226_ETH_IRQ_EDGE	GPIO_RISING_EDGE
+
+/*
+ * USB disconnect interrupt & USB on/off GPIO
+ */
+#define GPIO_CSB226_USB_DISC		42	/* USB disconnect           */
+#define GPIO_CSB226_USB_ONOFF		45	/* switch on/off USB pullup */
+#define CSB226_USB_DISC_IRQ		IRQ_GPIO(GPIO_CSB226_USB_DISC)
+#define CSB226_USB_DISC_IRQ_EDGE	IRQT_RISING
+
+/*
+ * virtual to physical conversion macros
+ */
+#define CSB226_P2V(x)		((x) - CSB226_FPGA_PHYS + CSB226_FPGA_VIRT)
+#define CSB226_V2P(x)		((x) - CSB226_FPGA_VIRT + CSB226_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __CSB226_REG(x)	(*((volatile unsigned long *)CSB226_P2V(x)))
+#else
+#  define __CSB226_REG(x)	CSB226_P2V(x)
+#endif
+
+#endif
Index: include/asm-arm/arch-pxa/i2c-pxa.h
===================================================================
--- a/include/asm-arm/arch-pxa/i2c-pxa.h	(revision 0)
+++ b/include/asm-arm/arch-pxa/i2c-pxa.h	(revision 675)
@@ -0,0 +1,76 @@
+/*
+ *  i2c_pxa.h
+ *
+ *  Copyright (C) 2002 Intrinsyc Software Inc.
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+#ifndef _I2C_PXA_H_
+#define _I2C_PXA_H_
+
+struct i2c_algo_pxa_data
+{
+	void (*write_byte) (u8 value);
+	u8   (*read_byte) (void);
+	void (*start) (void);
+	void (*repeat_start) (void);
+	void (*stop) (void);
+	void (*abort) (void);
+	int  (*wait_bus_not_busy) (void);
+	int  (*wait_for_interrupt) (int wait_type);
+	void (*transfer) (int lastbyte, int receive, int midbyte);
+	void (*reset) (void);
+
+	int udelay;
+	int timeout;
+};
+
+#define DEF_TIMEOUT	     3
+#define BUS_ERROR	       (-EREMOTEIO)
+#define ACK_DELAY	       0       /* time to delay before checking bus error */
+#define MAX_MESSAGES	    65536   /* maximum number of messages to send */
+
+#define I2C_SLEEP_TIMEOUT       2       /* time to sleep for on i2c transactions */
+#define I2C_RETRY	       (-2000) /* an error has occurred retry transmit */
+#define I2C_TRANSMIT		1
+#define I2C_RECEIVE		0
+#define I2C_PXA_SLAVE_ADDR      0x1    /* slave pxa unit address */
+#define I2C_ICR_INIT	    (ICR_BEIE | ICR_IRFIE | ICR_ITEIE | ICR_GCD | ICR_SCLE) /* ICR initialization value */
+/* ICR initialize bit values 
+*		       
+*  15. FM       0 (100 Khz operation)
+*  14. UR       0 (No unit reset)
+*  13. SADIE    0 (Disables the unit from interrupting on slave addresses 
+*				       matching its slave address)
+*  12. ALDIE    0 (Disables the unit from interrupt when it loses arbitration 
+*				       in master mode)
+*  11. SSDIE    0 (Disables interrupts from a slave stop detected, in slave mode)  
+*  10. BEIE     1 (Enable interrupts from detected bus errors, no ACK sent)
+*  9.  IRFIE    1 (Enable interrupts from full buffer received)
+*  8.  ITEIE    1 (Enables the I2C unit to interrupt when transmit buffer empty)
+*  7.  GCD      1 (Disables i2c unit response to general call messages as a slave) 
+*  6.  IUE      0 (Disable unit until we change settings)
+*  5.  SCLE     1 (Enables the i2c clock output for master mode (drives SCL)   
+*  4.  MA       0 (Only send stop with the ICR stop bit)
+*  3.  TB       0 (We are not transmitting a byte initially)
+*  2.  ACKNAK   0 (Send an ACK after the unit receives a byte)
+*  1.  STOP     0 (Do not send a STOP)
+*  0.  START    0 (Do not send a START)
+*
+*/
+
+#define I2C_ISR_INIT	    0x7FF  /* status register init */
+/* I2C status register init values 
+ *
+ * 10. BED      1 (Clear bus error detected)
+ * 9.  SAD      1 (Clear slave address detected)
+ * 7.  IRF      1 (Clear IDBR Receive Full)
+ * 6.  ITE      1 (Clear IDBR Transmit Empty)
+ * 5.  ALD      1 (Clear Arbitration Loss Detected)
+ * 4.  SSD      1 (Clear Slave Stop Detected)
+ */
+
+#endif
Index: include/asm-arm/arch-pxa/innokom.h
===================================================================
--- a/include/asm-arm/arch-pxa/innokom.h	(revision 0)
+++ b/include/asm-arm/arch-pxa/innokom.h	(revision 675)
@@ -0,0 +1,68 @@
+/*
+ * linux/include/asm-arm/arch-pxa/innokom.h
+ *
+ * (c) 2003 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _INCLUDE_ASMARM_ARCHPXA_INNOKOM_H_
+#define _INCLUDE_ASMARM_ARCHPXA_INNOKOM_H_
+
+/*
+ * SW Update Button
+ */
+#define GPIO_INNOKOM_SW_UPDATE		11
+#define INNOKOM_SW_UPDATE_IRQ		IRQ_GPIO(GPIO_INNOKOM_SW_UPDATE)
+#define INNOKOM_SW_UPDATE_IRQ_EDGE	IRQT_FALLING
+
+/*
+ * Reset Button
+ */
+#define GPIO_INNOKOM_RESET		3
+#define INNOKOM_RESET_IRQ		IRQ_GPIO(GPIO_INNOKOM_RESET)
+#define INNOKOM_RESET_IRQ_EDGE		IRQT_FALLING
+
+/* 
+ * ethernet chip (SMSC91C111) 
+ */
+#define GPIO_INNOKOM_ETH		59
+#define INNOKOM_ETH_PHYS		PXA_CS5_PHYS	/* phys 0x14000000  */
+#define INNOKOM_ETH_VIRT		(0xf0000000)
+#define INNOKOM_ETH_SIZE		(1*1024*1024)
+#define INNOKOM_ETH_IRQ			IRQ_GPIO(GPIO_INNOKOM_ETH)
+#define INNOKOM_ETH_IRQ_EDGE		IRQT_RISING
+
+/*
+ * USB disconnect interrupt & USB on/off GPIO
+ */
+#define GPIO_INNOKOM_USB_DISC		42	/* USB disconnect           */
+#define GPIO_INNOKOM_USB_ONOFF		45	/* switch on/off USB pullup */
+#define INNOKOM_USB_DISC_IRQ		IRQ_GPIO(GPIO_INNOKOM_USB_DISC)
+#define INNOKOM_USB_DISC_IRQ_EDGE	IRQT_RISING
+
+/*
+ * virtual to physical conversion macros
+ */
+#define INNOKOM_P2V(x)		((x) - INNOKOM_FPGA_PHYS + INNOKOM_FPGA_VIRT)
+#define INNOKOM_V2P(x)		((x) - INNOKOM_FPGA_VIRT + INNOKOM_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __INNOKOM_REG(x)	(*((volatile unsigned long *)INNOKOM_P2V(x)))
+#else
+#  define __INNOKOM_REG(x)	INNOKOM_P2V(x)
+#endif
+
+#endif
Index: include/asm-arm/arch-pxa/irqs.h
===================================================================
--- a/include/asm-arm/arch-pxa/irqs.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/asm-arm/arch-pxa/irqs.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -141,6 +141,15 @@
 #define IRQ_S1_BVD1_STSCHG	(IRQ_BOARD_END + 54)
 
 /*
+ * fpbus specific IRQs
+ *
+ * set FPBUS_IRQ_START appropriate
+ */
+#define FPBUS_IRQ_START		IRQ_BOARD_START
+#define FPBUS_IRQ(x)		(FPBUS_IRQ_START + (x))
+#define FPBUS_IRQ_END		(FPBUS_IRQ(32))
+
+/*
  * Figure out the MAX IRQ number.
  *
  * If we have an SA1111, the max IRQ is S1_BVD1_STSCHG+1.
@@ -151,6 +160,8 @@
 #elif defined(CONFIG_ARCH_LUBBOCK) || \
       defined(CONFIG_MACH_MAINSTONE)
 #define NR_IRQS			(IRQ_BOARD_END)
+#elif defined(CONFIG_FPBUS)
+#define NR_IRQS			(FPBUS_IRQ_END)
 #else
 #define NR_IRQS			(IRQ_BOARD_START)
 #endif
Index: include/asm-arm/arch-pxa/trizeps2.h
===================================================================
--- a/include/asm-arm/arch-pxa/trizeps2.h	(revision 0)
+++ b/include/asm-arm/arch-pxa/trizeps2.h	(revision 675)
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-arm/arch-pxa/trizeps2.h
+ *
+ * (c) 2004 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _INCLUDE_ASMARM_ARCHPXA_TRIZEPS2_H_
+#define _INCLUDE_ASMARM_ARCHPXA_TRIZEPS2_H_
+
+/*
+ * virtual to physical conversion macros
+ */
+#define TRIZEPS2_P2V(x)		((x) - TRIZEPS2_FPGA_PHYS + TRIZEPS2_FPGA_VIRT)
+#define TRIZEPS2_V2P(x)		((x) - TRIZEPS2_FPGA_VIRT + TRIZEPS2_FPGA_PHYS)
+
+#ifndef __ASSEMBLY__
+#  define __TRIZEPS2_REG(x)	(*((volatile unsigned long *)TRIZEPS2_P2V(x)))
+#else
+#  define __TRIZEPS2_REG(x)	TRIZEPS2_P2V(x)
+#endif
+
+#endif
Index: include/asm-arm/arch-pxa/system.h
===================================================================
--- a/include/asm-arm/arch-pxa/system.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/asm-arm/arch-pxa/system.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -10,9 +10,14 @@
  * published by the Free Software Foundation.
  */
 
+#ifndef __SYSTEM_H
+#define __SYSTEM_H
+
 #include "hardware.h"
 #include "pxa-regs.h"
 
+extern void printascii(const char *);
+
 static inline void arch_idle(void)
 {
 	cpu_do_idle();
@@ -32,3 +37,4 @@
 	}
 }
 
+#endif /* __SYSTEM_H */
Index: include/linux/fpbus.h
===================================================================
--- a/include/linux/fpbus.h	(revision 0)
+++ b/include/linux/fpbus.h	(revision 675)
@@ -0,0 +1,82 @@
+/*
+ * fpbus_fpga.h
+ *
+ */
+
+#ifndef __FPBUS_H
+#define __FPBUS_H
+
+#include <linux/firmware.h>
+
+#define CORE_TAG        	0x50494900
+#define DEVICE_TAG      	0x50494901
+#define END_TAG         	0x50494902
+
+#define FTAG_DEV_ID_SIZE        16
+
+#define FPBUS_IRQ_REAL		(1 << 30)
+#define FPBUS_IRQ_MULTIPLEX	(1 << 31)
+#define FPBUS_IRQ_MASK		(0x000000ff)
+
+
+struct ftag_core {
+        u32  	ftag_core;
+        char	firmware_revision[16];
+        u32	version_number;
+        u32	compile_date;
+        u32	dummy[2];
+} __attribute__((packed));
+
+struct ftag_dev {
+        u32	ftag_dev;
+        char	dev_id[FTAG_DEV_ID_SIZE];
+        u32	dev_sub_id;
+        u16	interface_revision;
+        u16	ip_revision;
+        u32	base_address;
+        u32	size;
+	u32	interrupt;
+        u32	dummy[1];
+} __attribute__((packed));
+
+struct ftag_end {
+        u32	ftag_end;
+} __attribute__((packed));
+
+
+struct fpbus_unit_info {
+	unsigned int	interface_revision;
+	unsigned int	ip_revision;
+	unsigned int	fpga_clock;
+};
+
+
+struct altera_serial_config {
+        unsigned int     data0;
+        unsigned int     dclk;
+        unsigned int     conf_done;
+        unsigned int     nconfig;
+        unsigned int     nstatus;
+};
+
+struct fpga_info {
+        int     (*fw_loader)(struct platform_device             *pdev,
+			     const struct firmware              *fw);
+
+#define FPBUS_DEV_TYPE_ALTERA_SERIAL 0x1
+	int dev_type;
+
+        union {
+                struct altera_serial_config                     altera_serial;
+        } fw_loader_cfg;
+
+        char    *fw_file;
+};
+
+
+extern int fpbus_upload_firmware	(struct platform_device *pdev);
+
+extern int fpga_fw_loader_altera_serial (struct platform_device *pdev,
+					 const struct firmware  *fw);
+
+#endif /* __FPBUS_H */
Index: include/linux/can.h
===================================================================
--- a/include/linux/can.h	(revision 0)
+++ b/include/linux/can.h	(revision 675)
@@ -0,0 +1,211 @@
+/*
+ * linux/include/linux/can.h
+ *
+ * Copyright (C) 2004, 2005
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Marc Kleine-Budde, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CAN_H
+#define CAN_H
+
+#define ND2D(_ndev)		(_ndev->class_dev.dev)
+
+#define CAN_ID_EXT_MASK   	0x1FFFFFFF	/* contains CAN id */
+#define CAN_ID_STD_MASK   	0x000007FF
+#define CAN_FLAG_ALL      	0x20000000	/* filter all messages */
+#define CAN_FLAG_RTR      	0x40000000	/* remote transmission flag*/
+#define CAN_FLAG_EXTENDED 	0x80000000	/* extended frame */
+
+
+/* Even : get (world access), odd : set (root access) */
+#define CAN_IS_SET(cmd)	(!((cmd) & 0x1))
+#define CAN_IS_GET(cmd)	((cmd) & 0x1)
+
+#define SIOCSCANBAUDRATE	(SIOCPROTOPRIVATE + 0)
+#define SIOCGCANBAUDRATE	(SIOCPROTOPRIVATE + 1)
+#define SIOCSCANMODE		(SIOCPROTOPRIVATE + 2)
+#define SIOCGCANSTATE		(SIOCPROTOPRIVATE + 3)
+
+#define SIOCCANFIST		(SIOCPROTOPRIVATE + 0)
+#define SIOCCANLAST		(SIOCGCANSTATE)
+
+
+enum CAN_BAUD {
+   /*!
+   ** Baudrate 10 kBit/sec
+   */
+   CAN_BAUD_10K = 0,
+
+   /*!
+   ** Baudrate 20 kBit/sec
+   */
+   CAN_BAUD_20K,
+
+   /*!
+   ** Baudrate 50 kBit/sec
+   */
+   CAN_BAUD_50K,
+
+   /*!
+   ** Baudrate 100 kBit/sec
+   */
+   CAN_BAUD_100K,
+
+   /*!
+   ** Baudrate 125 kBit/sec
+   */
+   CAN_BAUD_125K,
+
+   /*!
+   ** Baudrate 250 kBit/sec
+   */
+   CAN_BAUD_250K,
+
+   /*!
+   ** Baudrate 500 kBit/sec
+   */
+   CAN_BAUD_500K,
+
+   /*!
+   ** Baudrate 800 kBit/sec
+   */
+   CAN_BAUD_800K,
+
+   /*!
+   ** Baudrate 1 MBit/sec
+   */
+   CAN_BAUD_1M,
+
+   /*!
+   ** Max value, beside CAN_BAUD_BTR
+   */
+   CAN_BAUD_MAX,
+
+
+   /*!
+   ** Use values for btr0, btr1 and btr2
+   */
+   CAN_BAUD_BTR = 0x80,
+};
+
+
+enum CAN_MODE {
+   /*!   Set controller in Stop mode (no reception / transmission possible)
+   */
+   CAN_MODE_STOP = 0,
+
+   /*!   Set controller into normal operation
+   */
+   CAN_MODE_START,
+
+   /*!	Start Autobaud Detection
+   */
+   CAN_MODE_AUTO_BAUD,
+
+   /*!	Set controller into Sleep mode
+   */
+   CAN_MODE_SLEEP
+};
+
+
+enum CAN_STATE {
+	/*!
+	**	CAN controller is active, no errors
+	*/
+	CAN_STATE_ACTIVE    = 0,
+
+	/*!
+	**	CAN controller is in stopped mode
+	*/
+	CAN_STATE_STOPPED,
+
+	/*!
+	**	CAN controller is in Sleep mode
+	*/
+	CAN_STATE_SLEEPING,
+
+	/*!
+	**	CAN controller is active, warning level is reached
+	*/
+	CAN_STATE_BUS_WARN  = 6,
+
+ 	/*!
+	**	CAN controller is error passive
+	*/
+	CAN_STATE_BUS_PASSIVE,
+
+	/*!
+	**	CAN controller went into Bus Off
+	*/
+	CAN_STATE_BUS_OFF,
+
+	/*!
+	**	General failure of physical layer detected (if supported by hardware)
+	*/
+	CAN_STATE_PHY_FAULT = 10,
+
+	/*!
+	**	Fault on CAN-H detected (Low Speed CAN)
+	*/
+	CAN_STATE_PHY_H,
+
+	/*!
+	**	Fault on CAN-L detected (Low Speed CAN)
+	*/
+	CAN_STATE_PHY_L,
+
+	CAN_STATE_ERR_BIT   = 0x10,
+	CAN_STATE_ERR_STUFF = 0x20,
+	CAN_STATE_ERR_FORM  = 0x30,
+	CAN_STATE_ERR_CRC   = 0x40,
+	CAN_STATE_ERR_ACK   = 0x50
+};
+
+
+struct can_baudrate {
+	enum CAN_BAUD	baudrate;
+	u8		btr[3];
+};
+
+union can_settings {
+	enum CAN_MODE	mode;
+	enum CAN_STATE	state;
+};
+
+/**
+ * struct can_frame - describes a CAN frame and flags
+ *
+ * @can_id:	identifier, see CAN_ID_xxx flags for upper bits
+ * @can_dlc:	0...8 FIXME
+ * @payload:	contains the CAN message FIXME
+ */ 
+struct can_frame {
+	u32	can_id;
+	int	can_dlc;
+	union {
+		u64	msgbits;
+		u32	dword[2];
+		u8	byte[8];
+	} payload;
+};
+
+
+struct net_device *alloc_candev(int sizeof_priv);
+
+#endif /* CAN_H */
Index: include/linux/mmc/card.h
===================================================================
--- a/include/linux/mmc/card.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/mmc/card.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -90,3 +90,86 @@
 #define mmc_card_release_host(c)	mmc_release_host((c)->host)
 
 #endif
+/*
+ *  linux/include/linux/mmc/card.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Card driver specific definitions.
+ */
+#ifndef LINUX_MMC_CARD_H
+#define LINUX_MMC_CARD_H
+
+#include <linux/mmc/mmc.h>
+
+struct mmc_cid {
+	unsigned int		manfid;
+	unsigned int		serial;
+	char			prod_name[8];
+	unsigned char		hwrev;
+	unsigned char		fwrev;
+	unsigned char		month;
+	unsigned char		year;
+};
+
+struct mmc_csd {
+	unsigned char		mmc_prot;
+	unsigned short		cmdclass;
+	unsigned short		tacc_clks;
+	unsigned int		tacc_ns;
+	unsigned int		max_dtr;
+	unsigned int		read_blkbits;
+	unsigned int		capacity;
+};
+
+struct mmc_host;
+
+/*
+ * MMC device
+ */
+struct mmc_card {
+	struct list_head	node;		/* node in hosts devices list */
+	struct mmc_host		*host;		/* the host this device belongs to */
+	struct device		dev;		/* the device */
+	unsigned int		rca;		/* relative card address of device */
+	unsigned int		state;		/* (our) card state */
+#define MMC_STATE_PRESENT	(1<<0)
+#define MMC_STATE_DEAD		(1<<1)
+	struct mmc_cid		cid;		/* card identification */
+	struct mmc_csd		csd;		/* card specific */
+};
+
+#define mmc_card_dead(c)	((c)->state & MMC_STATE_DEAD)
+#define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
+
+#define mmc_card_name(c)	((c)->cid.prod_name)
+#define mmc_card_id(c)		((c)->dev.bus_id)
+
+#define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
+#define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)
+#define mmc_set_drvdata(c,d)	dev_set_drvdata(&(c)->dev, d)
+
+/*
+ * MMC device driver (e.g., Flash card, I/O card...)
+ */
+struct mmc_driver {
+	struct device_driver drv;
+	int (*probe)(struct mmc_card *);
+	void (*remove)(struct mmc_card *);
+	int (*suspend)(struct mmc_card *, u32);
+	int (*resume)(struct mmc_card *);
+};
+
+extern int mmc_register_driver(struct mmc_driver *);
+extern void mmc_unregister_driver(struct mmc_driver *);
+
+static inline int mmc_card_claim_host(struct mmc_card *card)
+{
+	return __mmc_claim_host(card->host, card);
+}
+
+#define mmc_card_release_host(c)	mmc_release_host((c)->host)
+
+#endif
Index: include/linux/mmc/mmc.h
===================================================================
--- a/include/linux/mmc/mmc.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/mmc/mmc.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -28,7 +28,95 @@
 #define MMC_RSP_CRC	(1 << 3)		/* expect valid crc */
 #define MMC_RSP_BUSY	(1 << 4)		/* card may send busy */
 
+	unsigned int		retries;	/* max number of retries */
+	unsigned int		error;		/* command error */
+
+#define MMC_ERR_NONE	0
+#define MMC_ERR_TIMEOUT	1
+#define MMC_ERR_BADCRC	2
+#define MMC_ERR_FIFO	3
+#define MMC_ERR_FAILED	4
+#define MMC_ERR_INVALID	5
+
+	struct mmc_data		*data;		/* data segment associated with cmd */
+	struct mmc_request	*req;		/* assoicated request */
+};
+
+struct mmc_data {
+	unsigned int		timeout_ns;	/* data timeout (in ns, max 80ms) */
+	unsigned int		timeout_clks;	/* data timeout (in clocks) */
+	unsigned int		blksz_bits;	/* data block size */
+	unsigned int		blocks;		/* number of blocks */
+	struct request		*rq;		/* request structure */
+	unsigned int		error;		/* data error */
+	unsigned int		flags;
+
+#define MMC_DATA_WRITE	(1 << 8)
+#define MMC_DATA_READ	(1 << 9)
+#define MMC_DATA_STREAM	(1 << 10)
+
+	unsigned int		bytes_xfered;
+
+	struct mmc_command	*stop;		/* stop command */
+	struct mmc_request	*req;		/* assoicated request */
+};
+
+struct mmc_request {
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+	struct mmc_command	*stop;
+
+	void			*done_data;	/* completion data */
+	void			(*done)(struct mmc_request *);/* completion function */
+};
+
+struct mmc_host;
+struct mmc_card;
+
+extern int mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
+extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
+
+extern int __mmc_claim_host(struct mmc_host *host, struct mmc_card *card);
+
+static inline void mmc_claim_host(struct mmc_host *host)
+{
+	__mmc_claim_host(host, (struct mmc_card *)-1);
+}
+
+extern void mmc_release_host(struct mmc_host *host);
+
+#endif
 /*
+ *  linux/include/linux/mmc/mmc.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef MMC_H
+#define MMC_H
+
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+struct request;
+struct mmc_data;
+struct mmc_request;
+
+struct mmc_command {
+	u32			opcode;
+	u32			arg;
+	u32			resp[4];
+	unsigned int		flags;		/* expected response type */
+#define MMC_RSP_NONE	(0 << 0)
+#define MMC_RSP_SHORT	(1 << 0)
+#define MMC_RSP_LONG	(2 << 0)
+#define MMC_RSP_MASK	(3 << 0)
+#define MMC_RSP_CRC	(1 << 3)		/* expect valid crc */
+#define MMC_RSP_BUSY	(1 << 4)		/* card may send busy */
+
+/*
  * These are the response types, and correspond to valid bit
  * patterns of the above flags.  One additional valid pattern
  * is all zeros, which means we don't expect a response.
Index: include/linux/mmc/host.h
===================================================================
--- a/include/linux/mmc/host.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/mmc/host.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -64,11 +64,113 @@
 struct mmc_host {
 	struct device		*dev;
 	struct mmc_host_ops	*ops;
+	void			*priv;
 	unsigned int		f_min;
 	unsigned int		f_max;
 	u32			ocr_avail;
 	char			host_name[8];
 
+	/* private data */
+	struct mmc_ios		ios;		/* current io bus settings */
+	u32			ocr;		/* the current OCR setting */
+
+	struct list_head	cards;		/* devices attached to this host */
+
+	wait_queue_head_t	wq;
+	spinlock_t		lock;		/* card_busy lock */
+	struct mmc_card		*card_busy;	/* the MMC card claiming host */
+	struct mmc_card		*card_selected;	/* the selected MMC card */
+
+	struct work_struct	detect;
+};
+
+extern struct mmc_host *mmc_alloc_host(int extra, struct device *);
+extern int mmc_add_host(struct mmc_host *);
+extern void mmc_remove_host(struct mmc_host *);
+extern void mmc_free_host(struct mmc_host *);
+
+#define mmc_priv(x)	((void *)((x) + 1))
+#define mmc_dev(x)	((x)->dev)
+
+extern int mmc_suspend_host(struct mmc_host *, u32);
+extern int mmc_resume_host(struct mmc_host *);
+
+extern void mmc_detect_change(struct mmc_host *);
+extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
+
+#endif
+
+/*
+ *  linux/include/linux/mmc/host.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Host driver specific definitions.
+ */
+#ifndef LINUX_MMC_HOST_H
+#define LINUX_MMC_HOST_H
+
+#include <linux/mmc/mmc.h>
+
+struct mmc_ios {
+	unsigned int	clock;			/* clock rate */
+	unsigned short	vdd;
+
+#define	MMC_VDD_150	0
+#define	MMC_VDD_155	1
+#define	MMC_VDD_160	2
+#define	MMC_VDD_165	3
+#define	MMC_VDD_170	4
+#define	MMC_VDD_180	5
+#define	MMC_VDD_190	6
+#define	MMC_VDD_200	7
+#define	MMC_VDD_210	8
+#define	MMC_VDD_220	9
+#define	MMC_VDD_230	10
+#define	MMC_VDD_240	11
+#define	MMC_VDD_250	12
+#define	MMC_VDD_260	13
+#define	MMC_VDD_270	14
+#define	MMC_VDD_280	15
+#define	MMC_VDD_290	16
+#define	MMC_VDD_300	17
+#define	MMC_VDD_310	18
+#define	MMC_VDD_320	19
+#define	MMC_VDD_330	20
+#define	MMC_VDD_340	21
+#define	MMC_VDD_350	22
+#define	MMC_VDD_360	23
+
+	unsigned char	bus_mode;		/* command output mode */
+
+#define MMC_BUSMODE_OPENDRAIN	1
+#define MMC_BUSMODE_PUSHPULL	2
+
+	unsigned char	power_mode;		/* power supply mode */
+
+#define MMC_POWER_OFF		0
+#define MMC_POWER_UP		1
+#define MMC_POWER_ON		2
+};
+
+struct mmc_host_ops {
+	void	(*request)(struct mmc_host *host, struct mmc_request *req);
+	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
+};
+
+struct mmc_card;
+struct device;
+
+struct mmc_host {
+	struct device		*dev;
+	struct mmc_host_ops	*ops;
+	unsigned int		f_min;
+	unsigned int		f_max;
+	u32			ocr_avail;
+	char			host_name[8];
+
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
 	unsigned short		max_hw_segs;	/* see blk_queue_max_hw_segments */
Index: include/linux/mmc/protocol.h
===================================================================
--- a/include/linux/mmc/protocol.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/mmc/protocol.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -201,3 +201,206 @@
 
 #endif  /* MMC_MMC_PROTOCOL_H */
 
+/*
+ * Header for MultiMediaCard (MMC)
+ *
+ * Copyright 2002 Hewlett-Packard Company
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * HEWLETT-PACKARD COMPANY MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ * Many thanks to Alessandro Rubini and Jonathan Corbet!
+ *
+ * Based strongly on code by:
+ *
+ * Author: Yong-iL Joh <tolkien@mizi.com>
+ * Date  : $Date: 2002/06/18 12:37:30 $
+ *
+ * Author:  Andrew Christian
+ *          15 May 2002
+ */
+
+#ifndef MMC_MMC_PROTOCOL_H
+#define MMC_MMC_PROTOCOL_H
+
+/* Standard MMC commands (3.1)           type  argument     response */
+   /* class 1 */
+#define	MMC_GO_IDLE_STATE         0   /* bc                          */
+#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
+#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
+#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
+#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
+#define MMC_SEND_STATUS	         13   /* ac   [31:16] RCA        R1  */
+#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+
+  /* class 2 */
+#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
+#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
+
+  /* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
+
+  /* class 4 */
+#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
+#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
+
+  /* class 6 */
+#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
+#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
+#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */
+
+  /* class 5 */
+#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE                37   /* ac                      R1b */
+
+  /* class 9 */
+#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
+
+  /* class 7 */
+#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
+
+  /* class 8 */
+#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1b */
+
+/*
+  MMC status in R1
+  Type
+  	e : error bit
+	s : status bit
+	r : detected and set for the actual command response
+	x : detected and set during command execution. the host must poll
+            the card by sending status command in order to read these bits.
+  Clear condition
+  	a : according to the card state
+	b : always related to the previous command. Reception of
+            a valid command will clear it (with a delay of one command)
+	c : clear by read
+ */
+
+#define R1_OUT_OF_RANGE		(1 << 31)	/* er, c */
+#define R1_ADDRESS_ERROR	(1 << 30)	/* erx, c */
+#define R1_BLOCK_LEN_ERROR	(1 << 29)	/* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
+#define R1_ERASE_PARAM		(1 << 27)	/* ex, c */
+#define R1_WP_VIOLATION		(1 << 26)	/* erx, c */
+#define R1_CARD_IS_LOCKED	(1 << 25)	/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	(1 << 24)	/* erx, c */
+#define R1_COM_CRC_ERROR	(1 << 23)	/* er, b */
+#define R1_ILLEGAL_COMMAND	(1 << 22)	/* er, b */
+#define R1_CARD_ECC_FAILED	(1 << 21)	/* ex, c */
+#define R1_CC_ERROR		(1 << 20)	/* erx, c */
+#define R1_ERROR		(1 << 19)	/* erx, c */
+#define R1_UNDERRUN		(1 << 18)	/* ex, c */
+#define R1_OVERRUN		(1 << 17)	/* ex, c */
+#define R1_CID_CSD_OVERWRITE	(1 << 16)	/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
+#define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
+#define R1_ERASE_RESET		(1 << 13)	/* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)    	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_APP_CMD		(1 << 7)	/* sr, c */
+
+/* These are unpacked versions of the actual responses */
+
+struct _mmc_csd {
+	u8  csd_structure;
+	u8  spec_vers;
+	u8  taac;
+	u8  nsac;
+	u8  tran_speed;
+	u16 ccc;
+	u8  read_bl_len;
+	u8  read_bl_partial;
+	u8  write_blk_misalign;
+	u8  read_blk_misalign;
+	u8  dsr_imp;
+	u16 c_size;
+	u8  vdd_r_curr_min;
+	u8  vdd_r_curr_max;
+	u8  vdd_w_curr_min;
+	u8  vdd_w_curr_max;
+	u8  c_size_mult;
+	union {
+		struct { /* MMC system specification version 3.1 */
+			u8  erase_grp_size;
+			u8  erase_grp_mult;
+		} v31;
+		struct { /* MMC system specification version 2.2 */
+			u8  sector_size;
+			u8  erase_grp_size;
+		} v22;
+	} erase;
+	u8  wp_grp_size;
+	u8  wp_grp_enable;
+	u8  default_ecc;
+	u8  r2w_factor;
+	u8  write_bl_len;
+	u8  write_bl_partial;
+	u8  file_format_grp;
+	u8  copy;
+	u8  perm_write_protect;
+	u8  tmp_write_protect;
+	u8  file_format;
+	u8  ecc;
+};
+
+#define MMC_VDD_145_150	0x00000001	/* VDD voltage 1.45 - 1.50 */
+#define MMC_VDD_150_155	0x00000002	/* VDD voltage 1.50 - 1.55 */
+#define MMC_VDD_155_160	0x00000004	/* VDD voltage 1.55 - 1.60 */
+#define MMC_VDD_160_165	0x00000008	/* VDD voltage 1.60 - 1.65 */
+#define MMC_VDD_165_170	0x00000010	/* VDD voltage 1.65 - 1.70 */
+#define MMC_VDD_17_18	0x00000020	/* VDD voltage 1.7 - 1.8 */
+#define MMC_VDD_18_19	0x00000040	/* VDD voltage 1.8 - 1.9 */
+#define MMC_VDD_19_20	0x00000080	/* VDD voltage 1.9 - 2.0 */
+#define MMC_VDD_20_21	0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22	0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23	0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24	0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25	0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26	0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27	0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28	0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29	0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30	0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31	0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32	0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33	0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34	0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35	0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36	0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+#define MMC_CARD_BUSY	0x80000000	/* Card Power up status bit */
+
+
+/*
+ * CSD field definitions
+ */
+
+#define CSD_STRUCT_VER_1_0  0           /* Valid for system specification 1.0 - 1.2 */
+#define CSD_STRUCT_VER_1_1  1           /* Valid for system specification 1.4 - 2.2 */
+#define CSD_STRUCT_VER_1_2  2           /* Valid for system specification 3.1       */
+
+#define CSD_SPEC_VER_0      0           /* Implements system specification 1.0 - 1.2 */
+#define CSD_SPEC_VER_1      1           /* Implements system specification 1.4 */
+#define CSD_SPEC_VER_2      2           /* Implements system specification 2.0 - 2.2 */
+#define CSD_SPEC_VER_3      3           /* Implements system specification 3.1 */
+
+#endif  /* MMC_MMC_PROTOCOL_H */
+
Index: include/linux/i2c-id.h
===================================================================
--- a/include/linux/i2c-id.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/i2c-id.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -202,6 +202,7 @@
 #define I2C_ALGO_SGI	0x160000        /* SGI algorithm                */
 #define I2C_ALGO_AU1550	0x170000        /* Au1550 PSC algorithm		*/
 
+#define I2C_ALGO_PXA	0x200000	/* Intel PXA I2C algorithm  */
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
 #define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
Index: include/linux/socket.h
===================================================================
--- a/include/linux/socket.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/socket.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -180,6 +180,7 @@
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
 #define AF_LLC		26	/* Linux LLC			*/
+#define AF_CAN		30	/* CAN Bus                      */
 #define AF_BLUETOOTH	31	/* Bluetooth sockets 		*/
 #define AF_MAX		32	/* For now.. */
 
@@ -212,6 +213,7 @@
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
 #define PF_LLC		AF_LLC
+#define PF_CAN		AF_CAN
 #define PF_BLUETOOTH	AF_BLUETOOTH
 #define PF_MAX		AF_MAX
 
Index: include/linux/if_ether.h
===================================================================
--- a/include/linux/if_ether.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/include/linux/if_ether.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -84,6 +84,7 @@
 #define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
 #define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
 #define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_CAN	0x000C		/* CAN Bus                      */
 #define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
 #define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
 #define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
Index: include/linux/gpio.h
===================================================================
--- a/include/linux/gpio.h	(revision 0)
+++ b/include/linux/gpio.h	(revision 675)
@@ -0,0 +1,25 @@
+/*
+ * include/linux/gpio.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __GPIO_H
+#define __GPIO_H
+
+#include "asm/arch/gpio.h"
+
+/* Values for policy */
+#define GPIO_USER       (1<<0)
+#define GPIO_OUTPUT     (1<<1)
+
+int request_gpio(unsigned int pin_nr, const char *owner,
+		 unsigned char policy, unsigned char init_level);
+
+void free_gpio(unsigned int pin_nr);
+
+#endif
Index: net/Kconfig
===================================================================
--- a/net/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/net/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -45,6 +45,31 @@
 
 	  If unsure, say N.
 
+config CAN
+	tristate "CAN Bus Support"
+	default N
+	help
+	  The CAN (Controller Area Network) bus is a bus used on embedded
+	  systems to connect microcontrollers in a rugged way. If you have
+	  any kind of CAN interface card in your system chose Y or M here. 
+
+config CAN_RAW
+	tristate "raw can protocol"
+	depends on CAN
+	default N
+	help
+	  If you enable this option a module can_raw.o is built which offers
+	  raw access to the CAN bus; you can open sockets with AF_CAN and
+	  CAN_PROTO_RAW. 
+
+config CAN_VCAN
+	tristate "vcan"
+	depends on CAN
+	default N
+	help
+	  vcan is a loopback device for the Linux CAN layer; it offers a virtual
+	  can channel which can be used similar to the network loopback device. 
+
 config NETLINK_DEV
 	tristate "Netlink device emulation"
 	help
Index: net/can/test/canecho.c
===================================================================
--- a/net/can/test/canecho.c	(revision 0)
+++ b/net/can/test/canecho.c	(revision 675)
@@ -0,0 +1,116 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include <libgen.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "can.h"
+
+extern int optind, opterr, optopt;
+
+static int	s = -1;
+static int	running = 1;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "Usage: %s [can-interface]\n", prg);
+}
+
+void sigterm(int signo)
+{
+	printf("got signal %d\n", signo);
+	running = 0;
+}
+
+int main(int argc, char **argv)
+{
+	int family = PF_CAN, type = SOCK_RAW, proto = CAN_PROTO_RAW;
+	int opt;
+	struct sockaddr_can addr;
+	struct can_frame frame;
+	int nbytes, i;
+	int verbose = 0;
+	struct ifreq ifr;
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+
+	while ((opt = getopt(argc, argv, "f:t:p:v")) != -1) {
+		switch (opt) {
+			case 'f':
+				family = atoi(optarg);
+				break;
+
+			case 't':
+				type = atoi(optarg);
+				break;
+
+			case 'p':
+				proto = atoi(optarg);
+				break;
+
+			case 'v':
+				verbose = 1;
+				break;
+
+			case '?':
+				break;
+
+			default:
+				fprintf(stderr, "Unknown option %c\n", opt);
+				break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+	
+	printf("interface = %s, family = %d, type = %d, proto = %d\n",
+			argv[optind], family, type, proto);
+	if ((s = socket(family, type, proto)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family = family;
+	strcpy(ifr.ifr_name, argv[optind]);
+	ioctl(s, SIOCGIFINDEX, &ifr);
+	addr.can_ifindex = ifr.ifr_ifindex;
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	while (running) {
+		if ((nbytes = read(s, &frame, sizeof(frame))) < 0) {
+			perror("read");
+			return 1;
+		}
+		if (verbose) {
+			printf("%04x: ", frame.can_id);
+			if (frame.can_id & CAN_FLAG_RTR) {
+				printf("remote request");
+			} else {
+				printf("[%d]", frame.can_dlc);
+				for (i = 0; i < frame.can_dlc; i++) {
+					printf(" %02x", frame.payload.byte[i]);
+				}
+			}
+			printf("\n");
+		}
+		frame.can_id++;
+		write(s, &frame, sizeof(frame));
+	}
+
+	return 0;
+}
Index: net/can/test/tst-raw.c
===================================================================
--- a/net/can/test/tst-raw.c	(revision 0)
+++ b/net/can/test/tst-raw.c	(revision 675)
@@ -0,0 +1,86 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "can.h"
+
+int main(int argc, char **argv)
+{
+    int s;
+    int family = PF_CAN, type = SOCK_RAW, proto = CAN_PROTO_RAW;
+    int opt;
+    struct sockaddr_can addr;
+    unsigned char buf[4096];
+    int nbytes, i;
+    struct ifreq ifr;
+
+    struct iovec bufs[] = {
+	{ "abc", 4 },
+	{ "def", 4 },
+	{ "0123456", 8 },
+	{ "xyz", 4 },
+    };
+
+    while ((opt = getopt(argc, argv, "f:t:p:")) != -1) {
+	switch (opt) {
+	case 'f':
+	    family = atoi(optarg);
+	    break;
+	case 't':
+	    type = atoi(optarg);
+	    break;
+	case 'p':
+	    proto = atoi(optarg);
+	    break;
+	default:
+	    fprintf(stderr, "Unknown option %c\n", opt);
+	    break;
+	}
+    }
+
+    printf("family = %d, type = %d, proto = %d\n", family, type, proto);
+    if ((s = socket(family, type, proto)) < 0) {
+	perror("socket");
+	return 1;
+    }
+
+    strcpy(ifr.ifr_name, "vcan2");
+    ioctl(s, SIOCGIFINDEX, &ifr);
+    addr.can_family = family;
+    addr.can_ifindex = ifr.ifr_ifindex;
+
+    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+	perror("bind");
+	return 1;
+    }
+#if 0
+    if (write(s, "abc", 4) < 0) {
+	perror("write");
+	return 1;
+    }
+#endif
+    if (writev(s, bufs, sizeof(bufs)/sizeof(*bufs)) < 0) {
+	perror("writev");
+	return 1;
+    }
+    if ((nbytes = read(s, buf, 4096)) < 0) {
+	perror("read");
+	return 1;
+    } else {
+	printf("%d bytes read\n", nbytes);
+	for (i = 0; i < nbytes; i++) {
+	    printf(" %02x", buf[i]);
+	    if (i % 16 == 15 || i == nbytes - 1)
+		putchar('\n');
+	}
+    }    
+
+    return 0;
+}
Index: net/can/test/can.h
===================================================================
--- a/net/can/test/can.h	(revision 0)
+++ b/net/can/test/can.h	(revision 675)
@@ -0,0 +1,129 @@
+/*
+ * can.h (userspace)
+ *
+ * Copyright (C) 2004, 2005
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Marc Kleine-Budde, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CAN_H
+#define CAN_H
+
+#define CAN_ID_EXT_MASK   0x1FFFFFFF	/* contains CAN id */
+#define CAN_ID_STD_MASK   0x000007FF
+#define CAN_FLAG_ALL      0x20000000	/* filter all messages */
+#define CAN_FLAG_RTR      0x40000000	/* remote transmission flag*/
+#define CAN_FLAG_EXTENDED 0x80000000	/* extended frame */
+
+#define CANIOCTYPE 0x23
+
+#define SIOCSCANBAUDRATE	(SIOCPROTOPRIVATE + 0)
+#define SIOCGCANBAUDRATE	(SIOCPROTOPRIVATE + 1)
+
+enum CAN_BAUD {
+   /*!
+   ** Baudrate 10 kBit/sec
+   */
+   CAN_BAUD_10K = 0,
+
+   /*!
+   ** Baudrate 20 kBit/sec
+   */
+   CAN_BAUD_20K,
+
+   /*!
+   ** Baudrate 50 kBit/sec
+   */
+   CAN_BAUD_50K,
+
+   /*!
+   ** Baudrate 100 kBit/sec
+   */
+   CAN_BAUD_100K,
+
+   /*!
+   ** Baudrate 125 kBit/sec
+   */
+   CAN_BAUD_125K,
+
+   /*!
+   ** Baudrate 250 kBit/sec
+   */
+   CAN_BAUD_250K,
+
+   /*!
+   ** Baudrate 500 kBit/sec
+   */
+   CAN_BAUD_500K,
+
+   /*!
+   ** Baudrate 800 kBit/sec
+   */
+   CAN_BAUD_800K,
+
+   /*!
+   ** Baudrate 1 MBit/sec
+   */
+   CAN_BAUD_1M,
+
+   /*!
+   ** Max value, beside CAN_BAUD_BTR
+   */
+   CAN_BAUD_MAX,
+
+   /*!
+   ** Use values for btr0, btr1 and btr2
+   */
+   CAN_BAUD_BTR = 0x80,
+};
+
+
+struct can_baudrate {
+	enum CAN_BAUD	baudrate;
+	u8		btr[3];
+};
+
+
+
+#define AF_CAN		30	/* CAN Bus                      */
+#define PF_CAN		AF_CAN
+
+enum CAN_PROTO {
+	CAN_PROTO_RAW,
+/* 	CAN_PROTO_FOO, */
+/* 	CAN_PROTO_BAR, */
+	CAN_PROTO_MAX,
+};
+
+struct sockaddr_can {
+    sa_family_t  can_family;
+    int          can_ifindex;
+    int          can_id;
+};
+
+struct can_frame {
+	int	can_id;
+	int	can_dlc;
+	union {
+		unsigned long long	msgbits;
+		unsigned long		dword[2];
+		unsigned char		byte[8];
+	} payload;
+};
+
+#endif /* CAN_H */
Index: net/can/test/candump.c
===================================================================
--- a/net/can/test/candump.c	(revision 0)
+++ b/net/can/test/candump.c	(revision 675)
@@ -0,0 +1,113 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include <libgen.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "can.h"
+
+extern int optind, opterr, optopt;
+
+static int	s = -1;
+static int	running = 1;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "Usage: %s [can-interface]\n", prg);
+	fprintf(stderr, "Options: -f <family> (default PF_CAN = %d)\n", PF_CAN);
+	fprintf(stderr, "         -t <type>   (default SOCK_RAW = %d)\n", SOCK_RAW);
+	fprintf(stderr, "         -p <proto>  (default CAN_PROTO_RAW = %d)\n", CAN_PROTO_RAW);
+}
+
+void sigterm(int signo)
+{
+	running = 0;
+}
+
+int main(int argc, char **argv)
+{
+	int family = PF_CAN, type = SOCK_RAW, proto = CAN_PROTO_RAW;
+	int opt;
+	struct sockaddr_can addr;
+	struct can_frame frame;
+	int nbytes, i;
+	struct ifreq ifr;
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+
+	while ((opt = getopt(argc, argv, "f:t:p:m:v:")) != -1) {
+		switch (opt) {
+			case 'f':
+				family = atoi(optarg);
+				break;
+
+			case 't':
+				type = atoi(optarg);
+				break;
+
+			case 'p':
+				proto = atoi(optarg);
+				break;
+
+			case '?':
+				break;
+
+			default:
+				fprintf(stderr, "Unknown option %c\n", opt);
+				break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+	
+	printf("interface = %s, family = %d, type = %d, proto = %d\n",
+			argv[optind], family, type, proto);
+	if ((s = socket(family, type, proto)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family = family;
+	strncpy(ifr.ifr_name, argv[optind], sizeof(ifr.ifr_name));
+	ioctl(s, SIOCGIFINDEX, &ifr);
+	addr.can_ifindex = ifr.ifr_ifindex;
+	addr.can_id = CAN_FLAG_ALL;
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	while (running) {
+		if ((nbytes = read(s, &frame, sizeof(struct can_frame))) < 0) {
+			perror("read");
+			return 1;
+		} else {
+			if (frame.can_id & CAN_FLAG_EXTENDED)
+				printf("<%08x> ", frame.can_id & CAN_ID_EXT_MASK);
+			else
+				printf("<%03x> ", frame.can_id & CAN_ID_STD_MASK);
+
+			printf("[%d] ", frame.can_dlc);
+			for (i = 0; i < frame.can_dlc; i++) {
+				printf("%02x ", frame.payload.byte[i]);
+			}
+			if (frame.can_id & CAN_FLAG_RTR)
+				printf("remote request");
+			printf("\n");
+		}
+	}
+
+	return 0;
+}
Index: net/can/test/cansend.c
===================================================================
--- a/net/can/test/cansend.c	(revision 0)
+++ b/net/can/test/cansend.c	(revision 675)
@@ -0,0 +1,112 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include <libgen.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "can.h"
+
+extern int optind, opterr, optopt;
+static int	running = 1;
+
+void sigterm(int signo)
+{
+	running = 0;
+}
+
+int main(int argc, char **argv)
+{
+	int family = PF_CAN, type = SOCK_RAW, proto = CAN_PROTO_RAW;
+	struct sockaddr_can addr;
+	int s, opt, ret, i;
+	struct can_frame frame;
+	int verbose = 0;
+	int num = 0;
+	struct ifreq ifr;
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+
+	while ((opt = getopt(argc, argv, "f:t:p:vi:")) != -1) {
+		switch (opt) {
+			case 'f':
+				family = atoi(optarg);
+				break;
+
+			case 't':
+				type = atoi(optarg);
+				break;
+
+			case 'p':
+				proto = atoi(optarg);
+				break;
+
+			case 'v':
+				verbose = 1;
+				break;
+			
+			case 'i':
+				frame.can_id = atoi(optarg);
+
+			case '?':
+				break;
+
+			default:
+				fprintf(stderr, "Unknown option %c\n", opt);
+				break;
+		}
+	}
+	
+	if (argv[optind] == NULL) {
+		fprintf(stderr, "No Interface supplied\n");
+		exit(-1);
+	}
+
+	printf("interface = %s, family = %d, type = %d, proto = %d\n",
+	       argv[optind], family, type, proto);
+	if ((s = socket(family, type, proto)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family = family;
+	strcpy(ifr.ifr_name, argv[optind]);
+	ret = ioctl(s, SIOCGIFINDEX, &ifr);
+	printf("ioctl: %d ", ret);
+	addr.can_ifindex = ifr.ifr_ifindex;
+	addr.can_id = frame.can_id;
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	if (argv[optind+1] != NULL) {
+		frame.can_dlc = strlen(argv[optind+1]);
+		frame.can_dlc = frame.can_dlc > 8 ? 8 : frame.can_dlc;
+		strncpy(frame.payload.byte, argv[optind+1],8);
+	} else {
+		frame.can_dlc = 0;
+	}
+
+	printf("id: %d ",frame.can_id);
+	printf("dlc: %d\n",frame.can_dlc);
+	for(i = 0; i < frame.can_dlc; i++)
+		printf("0x%02x ",frame.payload.byte[i]);
+	printf("\n");
+
+	num = 1;
+	while (num--) {
+		ret = write(s, &frame, sizeof(frame));
+	}
+
+	close(s);
+	return 0;
+}
Index: net/can/test/Makefile
===================================================================
--- a/net/can/test/Makefile	(revision 0)
+++ b/net/can/test/Makefile	(revision 675)
@@ -0,0 +1,24 @@
+CFLAGS    = -O2 -Wall -Wno-parentheses -fno-strict-aliasing
+
+PROGRAMS = \
+	tst-raw	\
+	candump	\
+	canecho \
+	cansend	\
+	canconfig
+
+all: $(PROGRAMS)
+
+clean:
+	rm -f $(PROGRAMS) *.o
+
+distclean: clean
+	rm -f .depend
+
+depend dep:
+	$(CC) $(CFLAGS) -M *.c > .depend
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
Index: net/can/can_raw.h
===================================================================
--- a/net/can/can_raw.h	(revision 0)
+++ b/net/can/can_raw.h	(revision 675)
@@ -0,0 +1,39 @@
+/*
+ * net/can/can_raw.h
+ *
+ * Copyright (C) 2004, 2005
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef RAW_H
+#define RAW_H
+
+#include "pf_can.h"
+
+#define SOL_CAN_RAW	(SOL_CAN_BASE + CAN_PROTO_RAW)
+
+/* enum RAW_SOCKOPT { */
+/* 	CAN_RAW_FILTER = 0, */
+/* }; */
+
+/* struct can_raw_filter { */
+/*     unsigned int mask, value; */
+/* }; */
+
+#endif
Index: net/can/pf_can.c
===================================================================
--- a/net/can/pf_can.c	(revision 0)
+++ b/net/can/pf_can.c	(revision 675)
@@ -0,0 +1,364 @@
+/*
+ * linux/net/can/pf_can.c
+ *
+ * Copyright (C) 2004, 2005
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Marc Kleine-Budde, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* #define DEBUG 1 */
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <net/sock.h>
+
+#include "pf_can.h"
+
+#define VERSION "1.0"
+static char banner[] __initdata = KERN_INFO "Protocol Family CAN " VERSION "\n";
+
+MODULE_LICENSE("GPL");
+
+#ifdef DEBUG
+#define SHOWSKB(x) show_skb x
+#define SHOWCANFRAME
+#else
+#define SHOWSKB(x)
+#undef SHOWCANFRAME
+#endif
+
+static int __init pf_can_init(void);
+static void __exit pf_can_exit(void);
+static int can_create(struct socket *sock, int protocol);
+static int can_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *pt);
+
+static struct packet_type can_packet = {
+	.type = __constant_htons(ETH_P_CAN),
+	.func = can_rcv,
+};
+
+static struct net_proto_family can_family_ops = {
+	.family = PF_CAN,
+	.create = can_create,
+	.owner = THIS_MODULE,
+};
+
+static int __init pf_can_init(void)
+{
+	printk(banner);
+
+	sock_register(&can_family_ops);
+	dev_add_pack(&can_packet);
+
+	return 0;
+}
+
+static void __exit pf_can_exit(void)
+{
+	dev_remove_pack(&can_packet);
+	sock_unregister(PF_CAN);
+}
+
+static struct can_proto *can_protos[CAN_PROTO_MAX];
+
+int can_proto_register(int proto_num, struct can_proto *cp)
+{
+	if (proto_num < 0 || proto_num >= CAN_PROTO_MAX)
+		return -EINVAL;
+
+	if (can_protos[proto_num])
+		return -EALREADY;
+
+	can_protos[proto_num] = cp;
+
+	return 0;
+}
+
+void can_proto_unregister(int proto_num)
+{
+	if (proto_num >= 0 && proto_num < CAN_PROTO_MAX)
+		can_protos[proto_num] = NULL;
+}
+
+
+static void can_sk_free(struct sock *sk)
+{
+	struct can_opt *co = can_sk(sk);
+
+	if (co)
+		kfree(co);
+}
+
+
+static int can_create(struct socket *sock, int protocol)
+{
+	struct sock *sk;
+	struct can_opt *co;
+	int err;
+
+	pr_debug("PF_CAN: can_create: socket %p, type %d, proto %d\n",
+		 sock, sock->type, protocol);
+
+	err = -EPROTONOSUPPORT;
+	switch (sock->type) {
+	case SOCK_SEQPACKET:
+		switch (protocol) {
+/* 		case CAN_PROTO_FOO: */
+/* 			break; */
+		default:
+			goto exit;
+		}
+		break;
+	case SOCK_DGRAM:
+		switch (protocol) {
+/* 		case CAN_PROTO_BAR: */
+/* 			break; */
+		default:
+			goto exit;
+		}
+		break;
+	case SOCK_RAW:
+		switch (protocol) {
+		case CAN_PROTO_RAW:
+			break;
+		default:
+			goto exit;
+		}
+		break;
+	default:
+		goto exit;
+		break;
+	}
+
+	pr_debug("PF_CAN: looking up proto %d in can_protos[]\n", protocol);
+#if defined(CONFIG_KMOD)
+	if (!can_protos[protocol]) {
+		char module_name[30];
+		sprintf(module_name, "can-proto-%d", protocol);
+		request_module(module_name);
+	}
+#endif
+	if (!can_protos[protocol] ||
+	    !try_module_get(can_protos[protocol]->owner))
+		goto exit;
+
+
+	err = -ENOMEM;
+	if (!(sk = sk_alloc(PF_CAN, GFP_KERNEL, 1, NULL)))
+		goto exit;
+
+	sock_init_data(sock, sk);
+	sk_set_owner(sk, can_protos[protocol]->owner);
+	sock->state = SS_UNCONNECTED;
+	sock->ops = can_protos[protocol]->ops;
+
+	/* sk->sk_state = CAN_NONE; */	/* FIXME: */
+	sk->sk_type     = SOCK_RAW;
+	sk->sk_family   = PF_CAN;
+	sk->sk_protocol = protocol;
+	sk->sk_destruct = can_sk_free;
+
+	co = sk->sk_protinfo = kmalloc(sizeof(*co), GFP_KERNEL);
+	if (!co)
+		goto exit_kfree;
+	memset(co, 0, sizeof(*co));
+	co->sk = sk;
+	err = 0;
+
+	module_put(can_protos[protocol]->owner);
+
+	pr_debug("PF_CAN: created sock: %p\n", sk);
+
+	return 0;
+
+ exit:
+	return err;
+ exit_kfree:
+	kfree(sk);
+	goto exit;
+}
+
+struct rcv_list {
+	struct rcv_list *next;
+	struct net_device *dev;
+	int can_id;
+	void (*func) (struct sk_buff *, void *);
+	void *data;
+};
+
+static struct rcv_list *head = NULL;
+
+/* FIXME: use list.h (mkl) */
+/*        protect list     */
+int can_rx_register(struct net_device *dev, int can_id,
+		    void (*func) (struct sk_buff *, void *), void *data)
+{
+	struct rcv_list *p;
+	int err;
+
+	pr_debug("PF_CAN: %s: dev 0x%p, id 0x%03x, callback 0x%p, data 0x%p\n",
+		 __FUNCTION__, dev, can_id, func, data);
+	
+	/* insert   (dev,canid) -> (func,data) */
+	err = -ENOMEM;
+	if (!(p = kmalloc(sizeof(struct rcv_list), GFP_KERNEL)))
+		goto exit;
+	p->next = head;
+	p->dev = dev;
+	p->can_id = can_id;
+	p->func = func;
+	p->data = data;
+	head = p;
+
+	err = 0;
+ exit:
+	return err;
+}
+
+void can_rx_unregister(struct net_device *dev, int can_id,
+		       void (*func) (struct sk_buff *, void *), void *data)
+{
+	struct rcv_list *p, **q;
+
+	for (q = &head; (p = *q); q = &p->next) {
+		if (p->dev == dev /* && p->can_id == can_id */		/* removed can_id compare, would never match (mkl) */
+		    && p->func == func && p->data == data) {
+			*q = p->next;
+			pr_debug("PF_CAN: %s: dev 0x%p, id 0x%03x, callback 0x%p, data 0x%p\n",
+				 __FUNCTION__, dev, can_id, func, data);
+			kfree(p);
+			return;
+		}
+	}
+	printk(KERN_ERR "PF_CAN: rx_unregister: socket not found\n");
+}
+
+static int can_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *pt)
+{
+	int can_id;
+	struct rcv_list *p;
+	struct can_frame *cf = (struct can_frame *)skb->data;
+#ifdef SHOWCANFRAME
+	char showcan[MAX_SHOWCAN];
+#endif
+
+	pr_debug("PF_CAN: %s: received skbuff on device %d, ptype 0x%04x, can_id 0x%03x\n",
+		 __FUNCTION__, dev->ifindex, ntohs(pt->type), cf->can_id);
+
+	SHOWSKB(skb);
+
+#ifdef SHOWCANFRAME
+	show_cframe((struct can_frame *)skb->data, showcan);
+	printk("PF_CAN: can_rcv: received CAN frame %s\n", showcan);
+#endif
+
+	/* extract can_id from the received frame */
+	can_id = cf->can_id;
+
+	/* find all entries for (dev,can_id) */
+	for (p = head; p; p = p->next) {
+		if (p->dev == dev && (p->can_id == -1
+				      || p->can_id == (can_id & (CAN_FLAG_EXTENDED | CAN_ID_EXT_MASK)))) {
+			struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);
+			pr_debug("PF_CAN: can_rcv: skbuff %p cloned to %p\n", skb, clone);
+			if (clone)
+				p->func(clone, p->data);
+		}
+	}
+	pr_debug("PF_CAN: can_rcv: freeing skbuff %p\n", skb);
+	kfree_skb(skb);
+
+	return 0;
+}
+
+
+void show_skb(struct sk_buff *skb)
+{
+	unsigned char *p;
+
+	printk("  skbuff at %p:\n    dev: %d\n    proto: %04x\n"
+	       "    users: %d  dataref %d\n"
+	       "    nr_frags: %d\n"
+	       "    h,d,t,e,l: %p %+d %+d %+d, %d\n   ",
+	       skb, skb->dev ? skb->dev->ifindex : -1, ntohs(skb->protocol),
+	       atomic_read(&skb->users),
+	       atomic_read(&(skb_shinfo(skb)->dataref)),
+	       skb_shinfo(skb)->nr_frags, skb->head, skb->data - skb->head,
+	       skb->tail - skb->head, skb->end - skb->head, skb->len);
+	for (p = skb->head; p < skb->end; p++) {
+		if (p > skb->head && (p - skb->head) % 32 == 0)
+			printk("\n   ");
+		printk(" %02x", *p);
+	}
+	printk("\n");
+}
+EXPORT_SYMBOL(show_skb);
+
+void show_msg(struct msghdr *msg, int size)
+{
+	int i, j;
+
+	printk("  socket name:");
+	for (i = 0; i < msg->msg_namelen; i++)
+		printk(" %02x", ((unsigned char *)msg->msg_name)[i]);
+	printk("\n");
+	printk("  size: %d, flags: %x\n", size, msg->msg_flags);
+
+	for (i = 0; i < msg->msg_iovlen; i++) {
+		struct iovec *iov = msg->msg_iov + i;
+		printk("  [%d]", i);
+		for (j = 0; j < iov->iov_len && --size >= 0; j++)
+			printk(" %02x", ((unsigned char *)iov->iov_base)[j]);
+		printk("\n");
+	}
+}
+
+void show_cframe(struct can_frame *cframe, char *cfstring)
+{
+	int i, dlc;
+
+	dlc = cframe->can_dlc <= 8 ? cframe->can_dlc : 8;
+
+	if (cframe->can_id & CAN_FLAG_EXTENDED)
+		cfstring += sprintf(cfstring, "<0x%08lX> [%X] ",
+				    (unsigned long)(cframe->can_id & CAN_ID_EXT_MASK), dlc);
+	else
+		cfstring += sprintf(cfstring, "<%03lX> [%X] ",
+				    (unsigned long)(cframe->can_id & 0xFFF), dlc);
+
+	for (i = 0; i < dlc; i++)
+		cfstring += sprintf(cfstring, "0x%02x ", cframe->payload.byte[i]);
+
+	if (cframe->can_id & CAN_FLAG_RTR)
+		sprintf(cfstring, "(RTR)");
+}
+
+EXPORT_SYMBOL(can_proto_register);
+EXPORT_SYMBOL(can_proto_unregister);
+EXPORT_SYMBOL(can_rx_register);
+EXPORT_SYMBOL(can_rx_unregister);
+
+module_init(pf_can_init);
+module_exit(pf_can_exit);
Index: net/can/vcan.c
===================================================================
--- a/net/can/vcan.c	(revision 0)
+++ b/net/can/vcan.c	(revision 675)
@@ -0,0 +1,200 @@
+/*
+ * net/can/vcan.c
+ *
+ * Copyright (C) 2004 
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+
+#include "pf_can.h"
+
+static char banner[] __initdata = KERN_INFO "VCAN loopback interface for PF_CAN 1.0\n";
+
+MODULE_LICENSE("GPL");
+
+#define NDEVICES 4
+
+#ifdef DEBUG
+#define SHOWSKB(x) show_skb(x)
+#else
+#define SHOWSKB(x)
+#endif
+
+static int vcan_init(struct net_device *dev);
+
+static struct net_device vcan_devs[NDEVICES] = {
+	{.init = vcan_init,.name = "vcan%d"},
+	{.init = vcan_init,.name = "vcan%d"},
+	{.init = vcan_init,.name = "vcan%d"},
+	{.init = vcan_init,.name = "vcan%d"},
+};
+
+static int vcan_open(struct net_device *dev)
+{
+	printk("VCAN: vcan_open %p (%s)\n", dev, dev->name);
+
+//  MOD_INC_USE_COUNT;
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int vcan_stop(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+//  MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static void vcan_rx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+
+	skb->protocol = htons(ETH_P_CAN);
+	skb->dev = dev;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	pr_debug("VCAN: vcan_rx: received skbuff on interface %d\n", dev->ifindex);
+	SHOWSKB(skb);
+
+	netif_rx(skb);
+}
+
+static int vcan_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+
+#ifdef SHOWCANFRAME
+	char showcan[MAX_SHOWCAN];
+
+	show_cframe((struct can_frame *)skb->data, showcan);
+	printk("VCAN: %s: loopback CAN frame %s\n", dev->name, showcan);
+#endif
+
+	pr_debug("VCAN: vcan_tx: sending skbuff on interface %d\n", dev->ifindex);
+	SHOWSKB(skb);
+
+	if (atomic_read(&skb->users) != 1) {
+		struct sk_buff *old_skb = skb;
+		skb = skb_clone(old_skb, GFP_ATOMIC);
+		pr_debug("  freeing old skbuff %p, using new skbuff %p\n", old_skb,
+		     skb);
+		kfree_skb(old_skb);
+		if (!skb) {
+			return 0;
+		}
+	} else
+		skb_orphan(skb);
+
+	stats->tx_packets++;
+	stats->tx_bytes += skb->len;
+	vcan_rx(skb, dev);
+	return 0;
+}
+
+static int vcan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	printk("ioctl: %p %d %p\n", dev, cmd, rq);
+	return 0;
+}
+
+static int vcan_rebuild_header(struct sk_buff *skb)
+{
+	pr_debug("vcan_rebuild_header on skbuff %p\n", skb);
+	show_skb(skb);
+	return 0;
+}
+
+static int vcan_header(struct sk_buff *skb, struct net_device *dev,
+		       unsigned short type, void *daddr, void *saddr,
+		       unsigned int len)
+{
+	pr_debug("vcan_header on skbuff %p device %p\n", skb, dev);
+	show_skb(skb);
+	return 0;
+}
+
+static struct net_device_stats *vcan_get_stats(struct net_device *dev)
+{
+	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	return stats;
+}
+
+static int vcan_init(struct net_device *dev)
+{
+	pr_debug("vcan_init %p (%s)\n", dev, dev->name);
+
+	ether_setup(dev);
+
+	dev->priv = kmalloc(sizeof(struct net_device_stats), GFP_KERNEL);
+	if (!dev->priv)
+		return -ENOMEM;
+	memset(dev->priv, 0, sizeof(struct net_device_stats));
+
+	dev->open = vcan_open;
+	dev->stop = vcan_stop;
+	dev->set_config = NULL;
+	dev->hard_start_xmit = vcan_tx;
+	dev->do_ioctl = vcan_ioctl;
+	dev->get_stats = vcan_get_stats;
+
+	dev->mtu = 4 + 4 + 8;
+	dev->flags = IFF_LOOPBACK;
+	dev->hard_header = vcan_header;
+	dev->rebuild_header = vcan_rebuild_header;
+	dev->hard_header_cache = NULL;
+	dev->type = ARPHRD_LOOPBACK;
+
+	SET_MODULE_OWNER(dev);
+
+	return 0;
+}
+
+int __init init_module(void)
+{
+	int i, ndev = 0, result;
+
+	printk(banner);
+
+	for (i = 0; i < NDEVICES; i++) {
+		if ((result = register_netdev(vcan_devs + i)))
+			printk(KERN_ERR "vcan: error %d registering interface %s\n",
+			     result, vcan_devs[i].name);
+		else {
+			pr_debug("vcan: successfully registered interface %s\n",
+			     vcan_devs[i].name);
+			ndev++;
+		}
+	}
+	return ndev ? 0 : -ENODEV;
+}
+
+void __exit cleanup_module(void)
+{
+	int i;
+	for (i = 0; i < NDEVICES; i++)
+		unregister_netdev(vcan_devs + i);
+}
Index: net/can/can_raw.c
===================================================================
--- a/net/can/can_raw.c	(revision 0)
+++ b/net/can/can_raw.c	(revision 675)
@@ -0,0 +1,441 @@
+/*
+ * net/can/can_raw.c
+ *
+ * Copyright (C) 2004, 2005
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Marc-Kleine-Budde, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#define DEBUG 1
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <net/sock.h>
+
+#include "pf_can.h"
+#include "can_raw.h"
+
+static char banner[] __initdata = KERN_INFO "RAW sockets for PF_CAN 1.0\n";
+
+MODULE_LICENSE("GPL");
+
+#ifdef DEBUG
+#define SHOWSKB(x) show_skb(x)
+#else
+#define SHOWSKB(x)
+#endif
+
+static int raw_release(struct socket *sock);
+static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len);
+static unsigned int raw_poll(struct file *file, struct socket *sock,
+			     poll_table * wait);
+static int raw_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
+static int raw_setsockopt(struct socket *sock, int level, int optname,
+			  char *optval, int optlen);
+static int raw_getsockopt(struct socket *sock, int level, int optname,
+			  char *optval, int *optlen);
+static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t len);
+static int raw_recvmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t len, int flags);
+static void raw_rcv(struct sk_buff *skb, void *data);
+
+static struct proto_ops raw_ops = {
+	.family 	= PF_CAN,
+	.release 	= raw_release,
+	.bind 		= raw_bind,
+	.connect 	= sock_no_connect,
+	.socketpair 	= sock_no_socketpair,
+	.accept 	= sock_no_accept,
+	.getname 	= sock_no_getname,
+	.poll 		= raw_poll,
+	.ioctl 		= raw_ioctl,
+	.listen 	= sock_no_listen,
+	.shutdown 	= sock_no_shutdown,
+	.setsockopt 	= raw_setsockopt,
+	.getsockopt 	= raw_getsockopt,
+	.sendmsg 	= raw_sendmsg,
+	.recvmsg 	= raw_recvmsg,
+	.mmap 		= sock_no_mmap,
+	.sendpage 	= sock_no_sendpage,
+};
+
+static struct can_proto raw_proto = {
+	.ops	= &raw_ops,
+	.owner	= THIS_MODULE,
+};
+
+static int __init raw_init(void)
+{
+	printk(banner);
+	can_proto_register(CAN_PROTO_RAW, &raw_proto);
+	return 0;
+}
+
+static void __exit raw_exit(void)
+{
+	can_proto_unregister(CAN_PROTO_RAW);
+}
+
+static int raw_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct can_opt *co = can_sk(sk);
+	int canid = -1;
+	int err = 0;
+
+	pr_debug("RAW: raw_release: socket: %p sk:%p\n", sock,sock->sk);
+
+	if (!sk) {
+		pr_debug(KERN_DEBUG "RAW: raw_release: no sk available for socket [%p].\n", sock);
+		goto exit;
+	}
+
+	/* FIXME: check sock status (mkl) */
+
+
+	if (co->raw_dev) {
+		can_rx_unregister(co->raw_dev, canid, raw_rcv, sk);
+		dev_put(co->raw_dev);
+	}
+	co->raw_dev = NULL;
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	skb_queue_purge(&sk->sk_receive_queue);
+	sock_put(sk);
+
+ exit:
+	return err;
+}
+
+static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct net_device *dev;
+	struct can_opt *co = can_sk(sk);
+	int canid, err;
+
+	lock_sock(sk);
+
+	pr_debug(KERN_DEBUG "RAW: raw_bind: socket %p to interface number %d\n", sock, addr->can_ifindex);
+
+	err = -EINVAL;
+	if (addr->can_family != AF_CAN) {
+		goto exit;
+	}
+
+	/* FIXME: check if sock is alredy bind (mkl) */
+
+	dev = dev_get_by_index(addr->can_ifindex);
+	err = -ENODEV;
+	if (!dev) {
+		printk(KERN_ERR "could not find interface number %d\n", addr->can_ifindex);
+		goto exit;
+	}
+	co->raw_dev = dev;
+	
+	if (addr->can_id & CAN_FLAG_ALL)
+		canid = -1;
+	else
+		canid = addr->can_id & (CAN_FLAG_EXTENDED | CAN_ID_EXT_MASK);
+
+	err = can_rx_register(dev, canid, raw_rcv, sk);
+	if (err)
+		goto exit;
+	err = 0;
+
+	/* FIXME: set sock to bind state (mkl) */
+
+ exit:
+	release_sock(sk);
+	return err;
+}
+
+static unsigned int raw_poll(struct file *file, struct socket *sock,
+			     poll_table * wait)
+{
+	struct sock *sk = sock->sk;
+	unsigned int mask = 0;
+
+	if (!sk) {
+		pr_debug(KERN_DEBUG
+		     "RAW: raw_poll: no sk available for socket [%p].\n",
+		     sock);
+		return -EOPNOTSUPP;
+	}
+
+	poll_wait(file, sk->sk_sleep, wait);
+
+	if (!skb_queue_empty(&sk->sk_receive_queue))
+		mask |= POLLIN | POLLRDNORM;
+	mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+
+static int raw_process_ioctl(struct ifreq *ifr, unsigned int cmd)
+{
+	struct net_device	*dev;
+	int			err;
+
+	/* Permissions are already checked in raw_ioctl() before calling us.
+	 * The copy_to/from_user() of ifr is also dealt with in there */
+
+	/* Make sure the device exist */
+	if ((dev = __dev_get_by_name(ifr->ifr_name)) == NULL)
+		return -ENODEV;
+
+	err = -EOPNOTSUPP;
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+	case SIOCGCANBAUDRATE:
+	case SIOCSCANMODE:
+	case SIOCGCANSTATE:
+		if (dev->do_ioctl) {
+			if (netif_device_present(dev))
+				err = dev->do_ioctl(dev, ifr, cmd);
+			else	
+				err = -ENODEV;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return err;
+}
+
+
+static int raw_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{	
+	struct sock	*sk = sock->sk;
+	struct ifreq 	ifr;
+	void __user	*argp = (void __user *)arg;
+	int		err;
+
+	/* lock_sock(sk); FIXME: (mkl) */
+
+	err = -EFAULT;
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+	case SIOCGCANBAUDRATE:
+	case SIOCSCANMODE:
+	case SIOCGCANSTATE:
+		/* If command is `set a parameter', check if
+		 * the user has the right to do it */
+		if (CAN_IS_SET(cmd) && !capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			goto exit_unlock;
+		}
+
+		if (copy_from_user(&ifr, argp, sizeof(struct ifreq))) {
+			goto exit_unlock;
+		}
+		
+		dev_load(ifr.ifr_name);
+		rtnl_lock();
+		err = raw_process_ioctl(&ifr, cmd);
+		rtnl_unlock();
+
+		if (!err 
+		    && CAN_IS_GET(cmd)
+		    && copy_to_user(argp, &ifr, sizeof(struct ifreq))) {
+			goto exit_unlock;
+		}
+
+		break;
+
+	case SIOCGIFADDR:
+	case SIOCSIFADDR:
+	case SIOCGIFDSTADDR:
+	case SIOCSIFDSTADDR:
+	case SIOCGIFBRDADDR:
+	case SIOCSIFBRDADDR:
+	case SIOCGIFNETMASK:
+	case SIOCSIFNETMASK:
+	case SIOCGIFMETRIC:
+	case SIOCSIFMETRIC:
+		err = -EINVAL;
+		break;
+
+	default:
+		err = dev_ioctl(cmd, argp);
+	}
+
+ exit_unlock:
+	/* release_sock(sk); FIXME: (mkl) */
+	return err;
+}
+
+static int raw_setsockopt(struct socket *sock, int level, int optname,
+			  char *optval, int optlen)
+{
+	int err;
+
+	err = -EINVAL;
+	if (level != SOL_CAN_RAW)
+		goto exit;
+
+	err = -ENOPROTOOPT;
+	switch (optname) {
+	default:
+		goto exit;
+	}
+
+ exit:
+	return err;
+}
+
+static int raw_getsockopt(struct socket *sock, int level, int optname,
+			  char *optval, int *optlen)
+{
+	int err;
+
+	err = -EINVAL;
+	if (level != SOL_CAN_RAW)
+		goto exit;
+
+	err = -ENOPROTOOPT;
+	switch (optname) {
+	default:
+		goto exit;
+	}
+
+ exit:
+	return err;
+}
+
+static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t len)
+{
+	struct sock *sk = sock->sk;
+	struct can_opt *co = can_sk(sk);
+	struct sk_buff *skb;
+	int err;
+
+	if (!sk) {
+		pr_debug(KERN_DEBUG
+		     "RAW: raw_sendmsg: no sk available for socket [%p].\n", sock);
+		return -EOPNOTSUPP;
+	}
+
+	/* FIXME: check if sock is opened (mkl) */
+
+	pr_debug("RAW: raw_sendmsg: socket %p\n", sock);
+#if 0
+	show_msg(msg, size);
+#endif
+	skb = alloc_skb(len, GFP_KERNEL);
+	if ((err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) < 0) {
+		kfree_skb(skb);
+		return err;
+	}
+
+	skb->dev = co->raw_dev;
+	if (!skb->dev) {
+		printk(KERN_ERR "RAW: raw_sendmsg: device not found: socket unbound?\n");
+		return -ESRCH;
+	}
+
+	pr_debug("RAW: raw_sendmsg: sending skbuff to interface %d\n", co->raw_dev->ifindex);
+	SHOWSKB(skb);
+
+	dev_queue_xmit(skb);
+
+	return len;
+}
+
+static int raw_recvmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	int error = 0;
+	int noblock;
+	int err;
+
+	if (!sk) {
+		pr_debug(KERN_DEBUG
+		     "RAW: raw_recvmsg: no sk available for socket [%p].\n",
+		     sock);
+		return -EOPNOTSUPP;
+	}
+
+	pr_debug("RAW: raw_recvmsg: socket %p\n", sock);
+
+	noblock = flags & MSG_DONTWAIT;
+	flags &= ~MSG_DONTWAIT;
+	if (!(skb = skb_recv_datagram(sk, flags, noblock, &error))) {
+		return error;
+	}
+
+	pr_debug("RAW: raw_recvmsg: delivering skbuff %p\n", skb);
+	SHOWSKB(skb);
+
+	if (skb->len < len)
+		len = skb->len;
+	if ((err = memcpy_toiovec(msg->msg_iov, skb->data, len)) < 0) {
+		skb_free_datagram(sk, skb);
+		return err;
+	}
+
+	pr_debug("RAW: raw_recvmsg: freeing sock %p, skbuff %p\n", sk, skb);
+	skb_free_datagram(sk, skb);
+
+#if 0
+	show_msg(msg, size);
+#endif
+	return len;
+}
+
+static void raw_rcv(struct sk_buff *skb, void *data)
+{
+	struct sock *sk = (struct sock *)data;
+	int error;
+
+	if (!sk) {
+		pr_debug(KERN_DEBUG "RAW: raw_rcv: no sk available\n");
+		return;
+	}
+
+	if (!skb) {
+		pr_debug(KERN_DEBUG "RAW: raw_rcv: no skb available\n");
+		return;
+	}
+
+	pr_debug("RAW: raw_rcv: received skbuff for sock %p\n", sk);
+	SHOWSKB(skb);
+
+	if ((error = sock_queue_rcv_skb(sk, skb)) < 0) {
+		pr_debug("RAW: raw_rcv: sock_queue_rcv_skb failed: %d\n", error);
+		pr_debug("RAW: raw_rcv: freeing skbuff %p\n", skb);
+		kfree_skb(skb);
+	}
+}
+
+module_init(raw_init);
+module_exit(raw_exit);
Index: net/can/pf_can.h
===================================================================
--- a/net/can/pf_can.h	(revision 0)
+++ b/net/can/pf_can.h	(revision 675)
@@ -0,0 +1,89 @@
+/*
+ * linux/net/can/pf_can.h
+ *
+ * Copyright (C) 2004, 2005
+ *
+ * - Jan Kiszka, Uni Hannover
+ * - Robert Schwebel, Benedikt Spranger, Pengutronix
+ * - Uwe Koppe, MicroControl GmbH 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PF_CAN_H
+#define PF_CAN_H
+
+#ifdef __KERNEL__
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#endif
+
+#include <linux/can.h>
+
+enum CAN_PROTO {
+	CAN_PROTO_RAW,
+/* 	CAN_PROTO_FOO, */
+/* 	CAN_PROTO_BAR, */
+	CAN_PROTO_MAX,
+};
+
+#define SOL_CAN_BASE 100
+
+struct sockaddr_can {
+    sa_family_t  can_family;
+    int          can_ifindex;
+    int          can_id;
+};
+
+#define MAX_SHOWCAN sizeof("<00000000> [0] 00 11 22 33 44 55 66 77 (RTR)")+1
+
+#ifdef __KERNEL__
+
+struct raw_opt {
+	struct net_device	*dev;	/* device associated with socket */
+/* 	struct can_raw_filter	filter; */
+};
+
+struct can_proto {
+	struct proto_ops	*ops;
+	struct module		*owner;
+};
+
+struct can_opt {
+	struct sock             *sk;
+	union {
+		struct raw_opt	raw;
+	} proto;
+};
+
+#define raw_dev	proto.raw.dev
+
+#define can_sk(__sk) ((struct can_opt *)(__sk)->sk_protinfo)
+
+int can_proto_register(int proto_num, struct can_proto *cp);
+void can_proto_unregister(int proto_num);
+
+int can_rx_register(struct net_device *dev, int can_id,
+		    void (*func)(struct sk_buff *, void *), void *data);
+void can_rx_unregister(struct net_device *dev, int can_id,
+		       void (*func)(struct sk_buff *, void *), void *data);
+
+struct net_device *alloc_candev(int sizeof_priv);
+
+void show_skb(struct sk_buff *skb);
+void show_msg(struct msghdr *msg, int size);
+void show_cframe(struct can_frame *cframe, char *string);
+#endif
+
+#endif /* PF_CAN_H */
Index: net/can/Makefile
===================================================================
--- a/net/can/Makefile	(revision 0)
+++ b/net/can/Makefile	(revision 675)
@@ -0,0 +1,10 @@
+#
+# Makefile for the Linux CAN Network layer.
+#
+
+obj-$(CONFIG_CAN)      += can.o
+obj-$(CONFIG_CAN_RAW)  += can_raw.o
+obj-$(CONFIG_CAN_VCAN) += vcan.o
+
+can-objs		:= pf_can.o can_generic.o
+
Index: net/can/can_generic.c
===================================================================
--- a/net/can/can_generic.c	(revision 0)
+++ b/net/can/can_generic.c	(revision 675)
@@ -0,0 +1,47 @@
+/*
+ * linux/net/can/can_generic.c
+ *
+ * Copyright (C) 2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+
+static int can_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if ((new_mtu < 0) || (new_mtu > 8))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+
+static void can_setup(struct net_device *dev) {
+	dev->type		= ARPHRD_VOID;
+	dev->change_mtu		= can_change_mtu;
+	dev->mtu		= 8;		/* can_mtu */
+	dev->tx_queue_len	= 100;
+	
+	/* New-style flags. */
+	dev->flags		= IFF_NOARP;
+}
+
+struct net_device *alloc_candev(int sizeof_priv)
+{
+	return alloc_netdev(sizeof_priv, "can%d", can_setup);
+}
+EXPORT_SYMBOL(alloc_candev);
Index: net/Makefile
===================================================================
--- a/net/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/net/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -22,6 +22,7 @@
 obj-y				+= ipv6/
 endif
 obj-$(CONFIG_PACKET)		+= packet/
+obj-$(CONFIG_CAN)		+= can/
 obj-$(CONFIG_NET_KEY)		+= key/
 obj-$(CONFIG_NET_SCHED)		+= sched/
 obj-$(CONFIG_BRIDGE)		+= bridge/
Index: CHANGELOG.ptx
===================================================================
--- a/CHANGELOG.ptx	(revision 0)
+++ b/CHANGELOG.ptx	(revision 675)
@@ -0,0 +1,33 @@
+2005-03-03	Robert Schwebel <r.schwebel@pengutronix.de>
+
+		- ported from 2.6.11-rc4-pxa3
+
+2005-02-16	Robert Schwebel <r.schwebel@pengutronix.de>
+
+		- ported from 2.6.9-rc2-trunk to 2.6.11-rc4
+
+2004-06-30	Robert Schwebel <r.schwebel@pengutronix.de>
+
+		- fixed compiler options for gcc 3.4 (short-load-bytes)
+		- released 2.6.7-mtd20040622-ptx4
+
+2004-06-29	Robert Schwebel <r.schwebel@pengutronix.de>
+
+		- fixed MTD, it works again now
+		- released 2.6.7-mtd20040622-ptx3 
+
+2004-06-27	Robert Schwebel <r.schwebel@pengutronix.de>
+
+		- MTD problem still needs fixing (some memory 
+		  was not set to 0 after being allocated)
+		- Fixed network driver for PNP2110
+
+2004-06-24	Robert Schwebel <r.schwebel@pengutronix.de>
+
+		- ported 2.6.0-rmk2-ptx1 to 2.6.7
+		- added 20040622 MTD snapshot release
+		- we still see strange effects which lets us not 
+		  mount JFFS2 partitions from the old innokom 
+		  correctly
+		- in 2.4, 2.4.26-vrs2-pxa1-ptx4 has our current 
+		  stuff. This has to be ported to this release. 
Index: init/Kconfig
===================================================================
--- a/init/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/init/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -352,6 +352,18 @@
 	  no dummy operations need be executed.
 	  Zero means use compiler's default.
 
+config GPIO
+	bool "GPIO pin support"
+	default y if ARM || PPC
+	default n
+	help
+	  Enabling this option adds support for generic GPIO pins. Most
+	  System-on-Chip processors have this kind of pins.
+
+	  FIXME: write more documentation. 
+
+	  If unsure, say N. 
+
 endmenu		# General setup
 
 config TINY_SHMEM
Index: init/main.c
===================================================================
--- a/init/main.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/init/main.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -421,6 +421,7 @@
  * Interrupts are still disabled. Do necessary setups, then
  * enable them
  */
+
 	lock_kernel();
 	page_address_init();
 	printk(linux_banner);
Index: arch/arm/kernel/setup.c
===================================================================
--- a/arch/arm/kernel/setup.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/arch/arm/kernel/setup.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -677,8 +677,9 @@
 	struct tag *tags = (struct tag *)&init_tags;
 	struct machine_desc *mdesc;
 	char *from = default_command_line;
-
+	
 	setup_processor();
+	
 	mdesc = setup_machine(machine_arch_type);
 	machine_name = mdesc->name;
 
Index: arch/arm/Kconfig
===================================================================
--- a/arch/arm/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/arch/arm/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -351,6 +351,8 @@
 	depends on FOOTBRIDGE_HOST || ARCH_SHARK
 	default y
 
+source "drivers/fpbus/Kconfig"
+
 config FIQ
 	bool
 	depends on ARCH_ACORN || ARCH_L7200
@@ -729,6 +731,8 @@
 
 source "drivers/mmc/Kconfig"
 
+source "drivers/can/Kconfig"
+
 source "arch/arm/Kconfig.debug"
 
 source "security/Kconfig"
Index: arch/arm/boot/bootp/bootp.lds
===================================================================
--- a/arch/arm/boot/bootp/bootp.lds	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/arch/arm/boot/bootp/bootp.lds	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -1,30 +0,0 @@
-/*
- *  linux/arch/arm/boot/bootp/bootp.lds
- *
- *  Copyright (C) 2000-2002 Russell King
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-  . = 0;
-  .text : {
-   _stext = .;
-   *(.start)
-   *(.text)
-   initrd_size = initrd_end - initrd_start;
-   _etext = .;
-  }
-  
-  .stab 0 : { *(.stab) }
-  .stabstr 0 : { *(.stabstr) }
-  .stab.excl 0 : { *(.stab.excl) }
-  .stab.exclstr 0 : { *(.stab.exclstr) }
-  .stab.index 0 : { *(.stab.index) }
-  .stab.indexstr 0 : { *(.stab.indexstr) }
-  .comment 0 : { *(.comment) }
-}
Index: arch/arm/boot/compressed/head-xscale.S
===================================================================
--- a/arch/arm/boot/compressed/head-xscale.S	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/arch/arm/boot/compressed/head-xscale.S	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -47,3 +47,8 @@
                orr     r7, r7, #(MACH_TYPE_GTWX5715 & 0xff00)
 #endif
 
+#ifdef CONFIG_ARCH_PXA_PNP2110
+	@ FIXME: fix bootloader, then remove...
+	mov     r7, #(MACH_TYPE_PNP2110 & 0xFF00)
+	add     r7, r7, #(MACH_TYPE_PNP2110 & 0xFF)
+#endif
Index: arch/arm/configs/pnp2110v2_defconfig
===================================================================
--- a/arch/arm/configs/pnp2110v2_defconfig	(revision 0)
+++ b/arch/arm/configs/pnp2110v2_defconfig	(revision 675)
@@ -0,0 +1,871 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-pxa1
+# Thu Mar  3 09:18:55 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_GPIO=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+
+#
+# Intel PXA2xx Implementations
+#
+# CONFIG_ARCH_CSB226 is not set
+# CONFIG_ARCH_INNOKOM is not set
+# CONFIG_ARCH_LOGODL is not set
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_MACH_MAINSTONE is not set
+CONFIG_ARCH_PXA_PNP2110=y
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_PXA_SHARPSL is not set
+# CONFIG_ARCH_TRIZEPS2 is not set
+# CONFIG_ARCH_PXA_PNP2110_V1 is not set
+CONFIG_ARCH_PXA_PNP2110_V2=y
+CONFIG_PXA25x=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_MINICACHE=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_XSCALE_PMU=y
+
+#
+# General setup
+#
+CONFIG_FPBUS=y
+CONFIG_FPBUS_NGE=m
+CONFIG_FPBUS_NGE_DATA0=25
+CONFIG_FPBUS_NGE_DCLK=23
+CONFIG_FPBUS_NGE_CONF_DONE=27
+CONFIG_FPBUS_NGE_NCONFIG=26
+CONFIG_FPBUS_NGE_NSTATUS=24
+CONFIG_FPBUS_NGE_CS3=0x7FF1
+CONFIG_FPBUS_NGE_CS4=0x38F1
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="console=ttyS0,115200 mem=64M"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PNP2110=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_SHARP_SL is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_CAN=m
+CONFIG_CAN_RAW=m
+CONFIG_CAN_VCAN=m
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+# CONFIG_SMC91X_OLD is not set
+# CONFIG_SMC91X_NAPI is not set
+# CONFIG_SMC91X_HAL is not set
+# CONFIG_CIRRUS is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=m
+CONFIG_BLK_DEV_IDE=m
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=m
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=m
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_FZKIDE=m
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_SA1100_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_PXA=m
+
+#
+# Hardware Sensors Chip support
+#
+CONFIG_I2C_SENSOR=m
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+CONFIG_SENSORS_EEPROM=m
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+CONFIG_SENSOR_X1226_RTC=m
+CONFIG_SENSOR_X1226_EEPROM=m
+# CONFIG_SENSOR_ST24CXX is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+CONFIG_I2C_DEBUG_CHIP=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+CONFIG_MINIX_FS=m
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-15"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# CAN support
+#
+# CONFIG_CANDEVICES is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
Index: arch/arm/configs/trizeps2_defconfig
===================================================================
--- a/arch/arm/configs/trizeps2_defconfig	(revision 0)
+++ b/arch/arm/configs/trizeps2_defconfig	(revision 675)
@@ -0,0 +1,706 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_ADIFCC is not set
+# CONFIG_ARCH_ANAKIN is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_SHARK is not set
+
+#
+# CLPS711X/EP721X Implementations
+#
+
+#
+# Epxa10db
+#
+
+#
+# Footbridge Implementations
+#
+
+#
+# IOP3xx Implementation Options
+#
+# CONFIG_ARCH_IOP310 is not set
+# CONFIG_ARCH_IOP321 is not set
+
+#
+# IOP3xx Chipset Features
+#
+
+#
+# Intel PXA250/210 Implementations
+#
+# CONFIG_ARCH_CSB226 is not set
+# CONFIG_ARCH_PXA_IDP is not set
+CONFIG_ARCH_INNOKOM=y
+# CONFIG_ARCH_LOGODL is not set
+# CONFIG_ARCH_LUBBOCK is not set
+CONFIG_ARCH_TRIZEPS2=y
+
+#
+# SA11x0 Implementations
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_MINICACHE=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_XSCALE_PMU=y
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_DEBUG=y
+# CONFIG_TCIC is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/nfs mem=32M ip=dhcp console=ttyS0,19200"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_INNOKOM=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG=y
+
+#
+# Protocols
+#
+# CONFIG_ISAPNP is not set
+# CONFIG_PNPBIOS is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_NET_SB1000 is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_PCMCIA_WAVELAN is not set
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+CONFIG_HERMES=y
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+CONFIG_PCMCIA_HERMES=y
+# CONFIG_AIRO_CS is not set
+# CONFIG_PCMCIA_ATMEL is not set
+# CONFIG_PCMCIA_WL3501 is not set
+CONFIG_NET_WIRELESS=y
+# CONFIG_HOSTAP is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN_BOOL is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_TSLIBDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_DZ is not set
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+
+#
+# L3 serial bus support
+#
+# CONFIG_L3 is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_GSS is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+# CONFIG_MCP is not set
+
+#
+# Console Switches
+#
+# CONFIG_SWITCHES is not set
+
+#
+# USB support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
Index: arch/arm/configs/pnp2110_defconfig
===================================================================
--- a/arch/arm/configs/pnp2110_defconfig	(revision 0)
+++ b/arch/arm/configs/pnp2110_defconfig	(revision 675)
@@ -0,0 +1,859 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-pxa1
+# Thu Mar  3 09:19:21 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_GPIO=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+
+#
+# Intel PXA2xx Implementations
+#
+# CONFIG_ARCH_CSB226 is not set
+# CONFIG_ARCH_INNOKOM is not set
+# CONFIG_ARCH_LOGODL is not set
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_MACH_MAINSTONE is not set
+CONFIG_ARCH_PXA_PNP2110=y
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_PXA_SHARPSL is not set
+# CONFIG_ARCH_TRIZEPS2 is not set
+CONFIG_ARCH_PXA_PNP2110_V1=y
+# CONFIG_ARCH_PXA_PNP2110_V2 is not set
+CONFIG_PXA25x=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_MINICACHE=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_XSCALE_PMU=y
+
+#
+# General setup
+#
+# CONFIG_FPBUS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+CONFIG_PREEMPT=y
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="console=ttyS0,115200 mem=64M"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PNP2110=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_SHARP_SL is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_CAN is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+# CONFIG_SMC91X_OLD is not set
+# CONFIG_SMC91X_NAPI is not set
+CONFIG_SMC91X_HAL=y
+# CONFIG_CIRRUS is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=m
+CONFIG_BLK_DEV_IDE=m
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=m
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=m
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_FZKIDE=m
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_SA1100_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_PXA=m
+
+#
+# Hardware Sensors Chip support
+#
+CONFIG_I2C_SENSOR=m
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+CONFIG_SENSORS_EEPROM=m
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSOR_X1226_RTC is not set
+# CONFIG_SENSOR_X1226_EEPROM is not set
+# CONFIG_SENSOR_ST24CXX is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+CONFIG_I2C_DEBUG_CHIP=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+CONFIG_MINIX_FS=m
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-15"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# CAN support
+#
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
Index: arch/arm/configs/csb226_defconfig
===================================================================
--- a/arch/arm/configs/csb226_defconfig	(revision 0)
+++ b/arch/arm/configs/csb226_defconfig	(revision 675)
@@ -0,0 +1,771 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc4-pxa1-svn
+# Wed Feb 16 21:18:23 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_GPIO=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+
+#
+# Intel PXA2xx Implementations
+#
+CONFIG_ARCH_CSB226=y
+# CONFIG_ARCH_INNOKOM is not set
+# CONFIG_ARCH_LOGODL is not set
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_MACH_MAINSTONE is not set
+# CONFIG_ARCH_PXA_PNP2110 is not set
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_PXA_SHARPSL is not set
+# CONFIG_ARCH_TRIZEPS2 is not set
+CONFIG_PXA25x=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_MINICACHE=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_XSCALE_PMU=y
+
+#
+# General setup
+#
+# CONFIG_FPBUS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/nfs mem=32M ip=dhcp console=ttyS0,19200"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_SHARP_SL is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_CAN is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+# CONFIG_CIRRUS is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_PXA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSOR_X1226_RTC is not set
+# CONFIG_SENSOR_X1226_EEPROM is not set
+# CONFIG_SENSOR_ST24CXX is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+CONFIG_USB_GADGET_PXA2XX=y
+CONFIG_USB_PXA2XX=y
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# CAN support
+#
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
Index: arch/arm/configs/innokom_defconfig
===================================================================
--- a/arch/arm/configs/innokom_defconfig	(revision 0)
+++ b/arch/arm/configs/innokom_defconfig	(revision 675)
@@ -0,0 +1,769 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc4-pxa1-svn
+# Wed Feb 16 21:44:09 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_GPIO=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_PXA=y
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+
+#
+# Intel PXA2xx Implementations
+#
+# CONFIG_ARCH_CSB226 is not set
+CONFIG_ARCH_INNOKOM=y
+# CONFIG_ARCH_LOGODL is not set
+# CONFIG_ARCH_LUBBOCK is not set
+# CONFIG_MACH_MAINSTONE is not set
+# CONFIG_ARCH_PXA_PNP2110 is not set
+# CONFIG_ARCH_PXA_IDP is not set
+# CONFIG_PXA_SHARPSL is not set
+# CONFIG_ARCH_TRIZEPS2 is not set
+CONFIG_PXA25x=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_XSCALE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_MINICACHE=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+CONFIG_XSCALE_PMU=y
+
+#
+# General setup
+#
+# CONFIG_FPBUS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/nfs mem=32M ip=dhcp console=ttyS0,19200"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_INNOKOM=y
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_SHARP_SL is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_CAN is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+# CONFIG_CIRRUS is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_PXA=y
+CONFIG_SERIAL_PXA_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_PXA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSOR_X1226_RTC is not set
+# CONFIG_SENSOR_X1226_EEPROM is not set
+# CONFIG_SENSOR_ST24CXX is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+CONFIG_DEVFS_DEBUG=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+CONFIG_USB_GADGET_PXA2XX=y
+CONFIG_USB_PXA2XX=y
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# CAN support
+#
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
Index: arch/arm/mach-pxa/Kconfig
===================================================================
--- a/arch/arm/mach-pxa/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/arch/arm/mach-pxa/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -5,6 +5,18 @@
 choice
 	prompt "Select target board"
 
+config ARCH_CSB226
+	bool "Cogent CSB226"
+	select PXA25x
+
+config ARCH_INNOKOM
+	bool "Auerswald Innokom"
+	select PXA25x
+
+config ARCH_LOGODL
+	bool "Logotronic LogoDL"
+	select PXA25x
+
 config ARCH_LUBBOCK
 	bool "Intel DBPXA250 Development Platform"
 	select PXA25x
@@ -14,6 +26,10 @@
 	select PXA27x
 	select IWMMXT
 
+config ARCH_PXA_PNP2110
+	bool "SSV PNP/2110-3V Platform"
+	select PXA25x
+
 config ARCH_PXA_IDP
 	bool "Accelent Xscale IDP"
 	select PXA25x
@@ -26,6 +42,10 @@
 	  Sharp SL-C700 (Corgi), SL-C750 (Shepherd) or a
 	  Sharp SL-C760 (Husky) handheld computer.
 
+config ARCH_TRIZEPS2
+	bool "Keith & Koep Trizeps2"
+	select PXA25x
+
 endchoice
 
 endmenu
@@ -42,6 +62,15 @@
 	bool "Enable Sharp SL-C760 (Husky) Support"
 	depends PXA_SHARPSL
 
+choice
+	depends on ARCH_PXA_PNP2110
+	prompt "Select pnp2110 version"
+config ARCH_PXA_PNP2110_V1
+	bool "Version 1"
+config ARCH_PXA_PNP2110_V2
+        bool "Version 2"
+endchoice
+
 config PXA25x
 	bool
 	help
Index: arch/arm/mach-pxa/csb226.c
===================================================================
--- a/arch/arm/mach-pxa/csb226.c	(revision 0)
+++ b/arch/arm/mach-pxa/csb226.c	(revision 675)
@@ -0,0 +1,143 @@
+/*
+ *  linux/arch/arm/mach-pxa/csb226.c
+ *
+ * (c) 2002, 2003 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/irq.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/csb226.h>
+
+#include "generic.h"
+
+#if 0
+#include <linux/sched.h>
+#include <asm/types.h>
+#endif
+
+static void __init csb226_init_irq(void)
+{
+	pxa_init_irq();
+
+}
+
+/*
+ * Ressource entries for onboard devices
+ */
+
+static struct resource cs8900_resources[] = {
+        [0] = {
+                .start  = CSB226_ETH_PHYS,
+                .end    = CSB226_ETH_PHYS + CSB226_ETH_SIZE - 1,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = CSB226_ETH_IRQ,
+                .end    = CSB226_ETH_IRQ,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device cs8900_device = {
+	.name		= "cs8900",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(cs8900_resources),
+	.resource	= cs8900_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&cs8900_device,
+};
+
+static int __init csb226_init(void)
+{
+	/* add device entries */
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+__initcall(csb226_init);
+
+#if 0
+// obsolete in 2.6...? [RSC]
+static void __init
+fixup_csb226(struct machine_desc *desc, struct param_struct *params,
+		char **cmdline, struct meminfo *mi)
+{
+	/* we probably want to get this information from the bootloader later */
+	SET_BANK (0, 0xa0000000, 64*1024*1024); 
+	mi->nr_banks      = 1;
+}
+#endif
+
+/* memory mapping */ 
+static struct map_desc csb226_io_desc[] __initdata = {
+	/* virtual         physical         length           domain */
+	{ CSB226_ETH_VIRT, CSB226_ETH_PHYS, CSB226_ETH_SIZE, MT_DEVICE }, /* CS8900 LAN controller   */
+};
+
+
+static void __init csb226_map_io(void)
+{
+	pxa_map_io();
+	iotable_init(csb226_io_desc, ARRAY_SIZE(csb226_io_desc));
+
+	/* This enables the BTUART */
+	CKEN |= CKEN7_BTUART;
+	pxa_gpio_mode(GPIO42_BTRXD_MD);
+	pxa_gpio_mode(GPIO43_BTTXD_MD);
+	pxa_gpio_mode(GPIO44_BTCTS_MD);
+	pxa_gpio_mode(GPIO45_BTRTS_MD);
+
+	/* This is for the CS8900 chip select */
+	pxa_gpio_mode(GPIO78_nCS_2_MD);
+
+	/* setup sleep mode values */
+	PWER  = 0x00000002;
+	PFER  = 0x00000000;
+	PRER  = 0x00000002;
+	PGSR0 = 0x00008000;
+	PGSR1 = 0x003F0202;
+	PGSR2 = 0x0001C000;
+	PCFR |= PCFR_OPDE;
+}
+
+
+MACHINE_START(CSB226, "Cogent CSB226 Development Platform")
+	MAINTAINER("Robert Schwebel, Pengutronix")
+	BOOT_MEM(0xa0000000, 0x40000000, io_p2v(0x40000000))
+	BOOT_PARAMS(0xa0000100)
+	MAPIO(csb226_map_io)
+	INITIRQ(csb226_init_irq)
+	.timer = &pxa_timer,
+MACHINE_END
Index: arch/arm/mach-pxa/pnp2110.c
===================================================================
--- a/arch/arm/mach-pxa/pnp2110.c	(revision 0)
+++ b/arch/arm/mach-pxa/pnp2110.c	(revision 675)
@@ -0,0 +1,243 @@
+/*
+ *  linux/arch/arm/mach-pxa/pnp2110.c
+ *
+ *  Copyright (C) 2005 (C) 2003 SSV Marco Hasewinkel, Embedded Systems
+ *  Copyright (C) 2005 (C) 2004, 2005 Pengutronix, Robert Schwebel
+ * 
+ *  Support for the SSV PNP/2110-3V Platform.
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/fpbus.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/irq.h>
+#include <asm/arch/pnp2110.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "generic.h"
+
+/* 
+ * FIXME: RSC: 
+ * 
+ * - fix memory tag in bootloader
+ *
+ * - direction for GPIOs: 
+ *	set_GPIO_IRQ_edge(1 ,GPIO_RISING_EDGE);	 GPIO1 = EXT IRQ 
+ *
+ */
+
+/* 
+ * Interrupt Initialisation
+ */
+static void __init pnp2110_init_irq(void)
+{
+	pxa_init_irq();
+	/* put into ressource!!! */
+	set_irq_type(PNP2110_ETH_IRQ, PNP2110_ETH_IRQ_EDGE);
+}
+
+/*
+ * Ressource entries for onboard devices
+ */
+static struct resource smc91x_resources[2];
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+#define FPGA_NGE_TAG_LIST_START 0x10000000
+#define FPGA_NGE_TAG_LIST_STOP  0x100000FF
+#define FPGA_NGE_IRQ		255 /* FIXME */
+#define FPBUS_NGE_DATA0		25
+#define FPBUS_NGE_DCLK		23
+#define FPBUS_NGE_CONF_DONE	27
+#define FPBUS_NGE_NCONFIG	26
+#define FPBUS_NGE_NSTATUS	24
+
+static struct resource  nge_fpga_resources[] = {
+        [0] = {
+                .start  = FPGA_NGE_IRQ,
+                .end    = FPGA_NGE_IRQ,
+                .flags  = IORESOURCE_IRQ,
+        },
+        [1] = {
+                .start  = FPGA_NGE_TAG_LIST_START,
+                .end    = FPGA_NGE_TAG_LIST_STOP,
+                .flags  = IORESOURCE_MEM,
+        },
+};
+
+struct fpga_info nge_fpga_info = {
+	.dev_type = FPBUS_DEV_TYPE_ALTERA_SERIAL,
+	.fw_loader_cfg.altera_serial = {
+		.data0 	   = FPBUS_NGE_DATA0,
+		.dclk 	   = FPBUS_NGE_DCLK,
+		.conf_done = FPBUS_NGE_CONF_DONE,
+		.nconfig   = FPBUS_NGE_NCONFIG,
+		.nstatus   = FPBUS_NGE_NSTATUS,
+	},
+};
+
+static struct platform_device nge_fpga_device = {
+        .name           = "fpbus",
+        .id             = 0,
+        .dev            = {
+                .platform_data  = &nge_fpga_info,
+        },
+        .num_resources  = ARRAY_SIZE(nge_fpga_resources),
+        .resource       = nge_fpga_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&smc91x_device,
+	&nge_fpga_device,
+};
+
+/*
+ * Specific Board Initialisation
+ */
+static int __init pnp2110_init(void)
+{
+	u32 *smsc;
+
+	/* 
+	 * Probe for SMSC network chips: different board revisions 
+	 * of the PNP2110 have different locations and parameters. We
+	 * probe it here and let the driver use the ressources.  
+	 *
+	 * FIXME: invent a command line based mechanism for that... [RSC]
+	 */
+
+	memset(smc91x_resources,0,sizeof(smc91x_resources));
+
+	smsc = ioremap(0x04000300, 16);
+	if (smsc) {
+		if (((*(smsc+0x3)) & 0xFF000000) == 0x33000000) {
+			smc91x_resources[0].start = 0x04000300;
+			smc91x_resources[0].end   = 0x0400030F;
+			smc91x_resources[0].flags = IORESOURCE_MEM | IORESOURCE_MEM_32BIT;
+			smc91x_resources[1].start = IRQ_GPIO(0);
+			smc91x_resources[1].end   = IRQ_GPIO(0);
+			smc91x_resources[1].flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE;
+			printk("found smc91x in 32bit mode\n");
+			iounmap(smsc);
+			goto found;
+		}
+		iounmap(smsc);
+	}
+	smsc = ioremap(0x2C000300, 16);
+	if (smsc) {
+		if (((*(smsc+0x3)) & 0xFF000000) == 0x33000000) {
+			smc91x_resources[0].start = 0x2C000300;
+			smc91x_resources[0].end   = 0x2C00030F;
+			smc91x_resources[0].flags = IORESOURCE_MEM | IORESOURCE_MEM_16BIT;
+			smc91x_resources[1].start = IRQ_GPIO(0);
+			smc91x_resources[1].end   = IRQ_GPIO(0);
+			smc91x_resources[1].flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE;
+			printk("found smc91x in 16bit mode\n");
+		}
+		iounmap(smsc);
+	}
+found:
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(pnp2110_init);
+
+#if 0
+static struct map_desc pnp2110_io_desc[] __initdata = {
+/*  virtual           physical          length            type                           */
+  { PNP2110_ETH_VIRT, PNP2110_ETH_PHYS, PNP2110_ETH_SIZE, MT_DEVICE }, /* ETH SMSC 91111 */
+};
+#endif
+
+static void __init pnp2110_map_io(void)
+{
+	pxa_map_io();
+//	iotable_init(pnp2110_io_desc, ARRAY_SIZE(pnp2110_io_desc));
+
+#warning "FIXME: put the alternate function setup into serial driver"
+
+	/* Enable the BTUART */
+	CKEN |= CKEN7_BTUART;
+	pxa_gpio_mode(GPIO42_BTRXD_MD);
+	pxa_gpio_mode(GPIO43_BTTXD_MD);
+	pxa_gpio_mode(GPIO44_BTCTS_MD);
+	pxa_gpio_mode(GPIO45_BTRTS_MD);
+
+	/* Enable the STUART */
+	CKEN |= CKEN5_STUART;
+	pxa_gpio_mode(GPIO46_STRXD_MD);
+	pxa_gpio_mode(GPIO47_STTXD_MD);
+
+//	pxa_gpio_mode(GPIO33_nCS_5_MD);	/* SMSC network chip */
+
+	/* setup sleep mode values */
+	PWER  = 0x00000002;
+	PFER  = 0x00000000;
+	PRER  = 0x00000002;
+	PGSR0 = 0x00008000;
+	PGSR1 = 0x003F0202;
+	PGSR2 = 0x0001C000;
+	PCFR |= PCFR_OPDE;
+
+	/* PCMCIA Socket 0 Timing - SSV has the ethernet chip located there */
+	/* FIXME: put this into boot loader */
+	MCMEM0 = 0x00000000;
+	MECR   = 0x00000003;
+}
+
+static void __init
+pnp2110_fixup(struct machine_desc *desc, 
+              struct tag *tag,
+	      char **cmdline, struct meminfo *mi)
+{
+	/* FIXME: put this into bootloader */
+	SET_BANK(0, 0xa0000000, (64*1024*1024));
+	mi->nr_banks = 1;
+
+}
+
+MACHINE_START(PNP2110, "SSV PNP/2110-3V Platform")
+	MAINTAINER("Robert Schwebel, Pengutronix")
+	BOOT_MEM(0xa0000000, 0x40000000, io_p2v(0x40000000))
+	BOOT_PARAMS(0xa0000100)
+	FIXUP(pnp2110_fixup)
+	MAPIO(pnp2110_map_io)
+	INITIRQ(pnp2110_init_irq)
+	.timer = &pxa_timer,
+MACHINE_END
+
Index: arch/arm/mach-pxa/leds-logodl.c
===================================================================
--- a/arch/arm/mach-pxa/leds-logodl.c	(revision 0)
+++ b/arch/arm/mach-pxa/leds-logodl.c	(revision 675)
@@ -0,0 +1,135 @@
+/*
+ * (C) 2002 Abraham van der Merwe <abraham@2d3d.co.za>
+ * (C) 2003 August Hoerandl <august.hoerandl@gmx.at>, Logotronic GmbH
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+
+#include "leds.h"
+
+#define CFG_LED_A_BIT           (1<<18)
+#define CFG_LED_A_SR            GPSR0
+#define CFG_LED_A_CR            GPCR0
+
+#define CFG_LED_B_BIT           (1<<16)
+#define CFG_LED_B_SR            GPSR1
+#define CFG_LED_B_CR            GPCR1
+
+static int status_led6 = 0;
+static int status_led7 = 0;
+
+static void led6_on(void)    { CFG_LED_A_CR = CFG_LED_A_BIT; status_led6 = 1; } 
+static void led6_off(void)   { CFG_LED_A_SR = CFG_LED_A_BIT; status_led6 = 0; }
+static void led6_invert(void) 
+{
+	if (status_led6) 
+		led6_off(); 
+	else             
+		led6_on();    
+}
+
+#define led7_on()   { CFG_LED_B_CR = CFG_LED_B_BIT; status_led7 = 1; } 
+#define led7_off()  { CFG_LED_B_SR = CFG_LED_B_BIT; status_led7 = 1; } 
+
+
+static int claimed;
+
+void logodl_leds_event (led_event_t evt)
+{
+   unsigned long flags;
+
+   local_irq_save (flags);
+
+   switch (evt)
+	 {
+#ifdef CONFIG_LEDS_CPU
+		/* turn off CPU load LED */
+	  case led_idle_start:
+		if (!claimed) led7_off ();
+		break;
+
+		/* turn on CPU load LED */
+	  case led_idle_end:
+		if (!claimed) led7_on ();
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_TIMER
+		/* toggle heartbeat LED */
+	  case led_timer:
+		if (!claimed) led6_invert ();
+		break;
+#endif
+
+		/* start: turn on LEDs and set claimed to 0 */
+	  case led_start:
+		led6_on ();
+		led7_on ();
+		claimed = 0;
+		break;
+
+		/* stop: turn off LEDs */
+	  case led_stop:
+		led6_off ();
+		led7_off ();
+		break;
+
+		/* override CPU load & timer LEDs */
+	  case led_claim:
+		claimed = 1;
+		break;
+
+		/* restore CPU load & timer LEDs */
+	  case led_release:
+		claimed = 0;
+		break;
+
+		/* direct LED access (must be previously claimed) */
+
+		/* led7 */
+	  case led_green_on:
+		if (claimed) led7_on ();
+		break;
+
+	  case led_green_off:
+		if (claimed) led7_off ();
+		break;
+
+		/* led6 -- at the moment this is actually also green */
+	  case led_red_on:
+		if (claimed) led6_on ();
+		break;
+
+	  case led_red_off:
+		if (claimed) led6_off ();
+		break;
+
+	  default:
+		break;
+	}
+
+   local_irq_restore (flags);
+}
Index: arch/arm/mach-pxa/innokom.c
===================================================================
--- a/arch/arm/mach-pxa/innokom.c	(revision 0)
+++ b/arch/arm/mach-pxa/innokom.c	(revision 675)
@@ -0,0 +1,196 @@
+/*
+ *  linux/arch/arm/mach-pxa/innokom.c
+ *
+ * (c) 2004 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/irq.h>
+#include <asm/arch/innokom.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "generic.h"
+
+/*
+ * Interrupt Handler for Software Update button
+ */
+static irqreturn_t sw_update_handler(int irq, void* dev_id,struct pt_regs* regs)
+{
+	printk("software update button pressed (I'm the dummy irq handler)\n");
+	printk("USIR0  = %08x\n", USIR0);
+	printk("UDCCR  = %08x\n", UDCCR);
+	printk("UDCCS0 = %08x\n", UDCCS0);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Interrupt Handler for Reset button
+ */
+static irqreturn_t reset_handler(int irq, void* dev_id,struct pt_regs* regs)
+{
+	return IRQ_HANDLED;
+}
+
+
+/* 
+ * Interrupt Initialisation
+ */
+static void __init innokom_init_irq(void)
+{
+	pxa_init_irq();
+	
+	set_irq_type(INNOKOM_SW_UPDATE_IRQ, INNOKOM_SW_UPDATE_IRQ_EDGE);
+	set_irq_type(INNOKOM_RESET_IRQ, INNOKOM_RESET_IRQ_EDGE);
+	set_irq_type(INNOKOM_ETH_IRQ, INNOKOM_ETH_IRQ_EDGE);
+	set_irq_type(INNOKOM_USB_DISC_IRQ, INNOKOM_USB_DISC_IRQ_EDGE);
+}
+
+/*
+ * Ressource entries for onboard devices
+ */
+
+static struct resource smc91x_resources[] = {
+        [0] = {
+                .start  = INNOKOM_ETH_PHYS,
+                .end    = INNOKOM_ETH_PHYS + INNOKOM_ETH_SIZE - 1,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = INNOKOM_ETH_IRQ,
+                .end    = INNOKOM_ETH_IRQ,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+static struct resource innokom_switches_resources[] = {
+        [0] = {
+                .start  = INNOKOM_SW_UPDATE_IRQ,
+                .end    = INNOKOM_SW_UPDATE_IRQ,
+                .flags  = IORESOURCE_IRQ,
+        },
+        [1] = {
+                .start  = INNOKOM_RESET_IRQ,
+                .end    = INNOKOM_RESET_IRQ,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device innokom_switches_device = {
+	.name		= "innokom switches",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(innokom_switches_resources),
+	.resource	= innokom_switches_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&smc91x_device,
+	&innokom_switches_device,
+};
+
+/*
+ * Specific Board Initialisation
+ */
+static int __init innokom_init(void)
+{
+	/* init innokom irqs */
+
+	/* reset button */
+	if (request_irq(INNOKOM_RESET_IRQ, &reset_handler, 0, "reset button", NULL))
+		printk(KERN_INFO "innokom: can't get assigned irq %i\n (reset button)",INNOKOM_RESET_IRQ);
+	else
+		set_irq_type(INNOKOM_RESET_IRQ, INNOKOM_RESET_IRQ_EDGE);
+
+	/* sw update button */
+	if (request_irq(INNOKOM_SW_UPDATE_IRQ, &sw_update_handler, 0, "software update button", NULL))
+		printk(KERN_INFO "innokom: can't get assigned irq %i (sw update button)\n", INNOKOM_SW_UPDATE_IRQ);
+	else
+		set_irq_type(INNOKOM_SW_UPDATE_IRQ, INNOKOM_SW_UPDATE_IRQ_EDGE);
+
+	/* smc91111 ethernet irq */
+//	set_irq_type(INNOKOM_ETH_IRQ, INNOKOM_ETH_IRQ_EDGE);
+
+	/* USB disconnect irq */
+//	set_irq_type(INNOKOM_USB_DISC_IRQ, INNOKOM_USB_DISC_IRQ_EDGE);
+
+	/* add device entries */
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(innokom_init);
+
+/* memory mapping */
+static struct map_desc innokom_io_desc[] __initdata = {
+/*  virtual           physical          length            type                           */
+  { INNOKOM_ETH_VIRT, INNOKOM_ETH_PHYS, INNOKOM_ETH_SIZE, MT_DEVICE }, /* ETH SMSC 91111 */
+};
+
+static void __init innokom_map_io(void)
+{
+	pxa_map_io();
+	iotable_init(innokom_io_desc, ARRAY_SIZE(innokom_io_desc));
+
+	/* Enable the BTUART */
+	CKEN |= CKEN7_BTUART;
+	pxa_gpio_mode(GPIO42_BTRXD_MD);
+	pxa_gpio_mode(GPIO43_BTTXD_MD);
+	pxa_gpio_mode(GPIO44_BTCTS_MD);
+	pxa_gpio_mode(GPIO45_BTRTS_MD);
+
+	pxa_gpio_mode(GPIO33_nCS_5_MD);	/* SMSC network chip */
+
+	/* setup sleep mode values */
+	PWER  = 0x00000002;
+	PFER  = 0x00000000;
+	PRER  = 0x00000002;
+	PGSR0 = 0x00008000;
+	PGSR1 = 0x003F0202;
+	PGSR2 = 0x0001C000;
+	PCFR |= PCFR_OPDE;
+}
+
+MACHINE_START(INNOKOM, "Auerswald Innokom")
+	MAINTAINER("Robert Schwebel, Pengutronix")
+	BOOT_MEM(0xa0000000, 0x40000000, io_p2v(0x40000000))
+	BOOT_PARAMS(0xa0000100)
+	MAPIO(innokom_map_io)
+	INITIRQ(innokom_init_irq)
+	.timer = &pxa_timer,
+MACHINE_END
Index: arch/arm/mach-pxa/logodl.c
===================================================================
--- a/arch/arm/mach-pxa/logodl.c	(revision 0)
+++ b/arch/arm/mach-pxa/logodl.c	(revision 675)
@@ -0,0 +1,95 @@
+/*
+ * (C) 2002 Abraham van der Merwe <abraham@2d3d.co.za>
+ * (C) 2003 August Hoerandl <august.hoerandl@gmx.at>, Logotronic GmbH
+ * (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix 
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include "generic.h"
+
+#define CFG_LED_A_BIT           (1<<18)
+#define CFG_LED_A_SR            GPSR0
+#define CFG_LED_A_CR            GPCR0
+
+#define CFG_LED_B_BIT           (1<<16)
+#define CFG_LED_B_SR            GPSR1
+#define CFG_LED_B_CR            GPCR1
+
+static int __init logodl_init(void)
+{
+	return 0;
+}
+
+__initcall(logodl_init);
+
+static void __init
+logodl_fixup(struct machine_desc *desc, struct param_struct *params,
+             char **cmdline, struct meminfo *mi)
+{
+	/* we probably want to get this information from the bootloader later */
+	SET_BANK (0, 0x08000000, 4*1024*1024);
+	mi->nr_banks      = 1;
+}
+
+static void __init logodl_init_irq(void)
+{
+	pxa_init_irq();
+}
+
+static struct map_desc logodl_io_desc[] __initdata = {
+	/* virtual             	physical		length            type */
+	{LOGODL_UART_VIRT,	LOGODL_UART_PHYS,	LOGODL_UART_SIZE, 0, 1, 0, 0 },
+	{LOGODL_USB_VIRT,	LOGODL_USB_PHYS,	LOGODL_USB_SIZE,  0, 1, 0, 0 },
+	{LOGODL_ETH_VIRT,	LOGODL_ETH_PHYS,	LOGODL_ETH_SIZE,  0, 1, 0, 0 },
+	{LOGODL_CPLD_VIRT,	LOGODL_CPLD_PHYS,	LOGODL_CPLD_SIZE, 0, 1, 0, 0 },
+	LAST_DESC
+};
+
+static void __init logodl_map_io(void)
+{
+	pxa_map_io();
+	iotable_init(logodl_io_desc);
+}
+
+
+MACHINE_START(LOGODL, "Logotronic DL")
+	MAINTAINER("August Hoerandl, Logotronic; Robert Schwebel, Pengutronix")
+	BOOT_MEM(0x08000000, 0x40000000, io_p2v(0x40000000))
+	BOOT_PARAMS(0x08000100)
+	FIXUP(logodl_fixup)
+	MAPIO(logodl_map_io)
+	INITIRQ(logodl_init_irq)
+	INITTIME(pxa_init_time)
+MACHINE_END
Index: arch/arm/mach-pxa/trizeps2.c
===================================================================
--- a/arch/arm/mach-pxa/trizeps2.c	(revision 0)
+++ b/arch/arm/mach-pxa/trizeps2.c	(revision 675)
@@ -0,0 +1,107 @@
+/*
+ *  linux/arch/arm/mach-pxa/trizeps2.c
+ *
+ * (c) 2004 Robert Schwebel <r.schwebel@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/irq.h>
+//#include <asm/arch/irqs.h>
+#include <asm/arch/trizeps2.h>
+
+#include "generic.h"
+
+/* 
+ * Interrupt Initialisation
+ */
+static void __init trizeps2_init_irq(void)
+{
+	pxa_init_irq();
+	
+}
+
+static struct platform_device *devices[] __initdata = {
+};
+
+/*
+ * Specific Board Initialisation
+ */
+static int __init trizeps2_init(void)
+{
+	char buf[255];
+
+	sprintf(buf,"trizeps2_init\n"); printascii(buf);
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+
+subsys_initcall(trizeps2_init);
+
+/* memory mapping */
+static struct map_desc trizeps2_io_desc[] __initdata = {
+/*  virtual           physical          length            type                           */
+// { INNOKOM_ETH_VIRT, INNOKOM_ETH_PHYS, INNOKOM_ETH_SIZE, MT_DEVICE }, /* ETH SMSC 91111 */
+};
+
+static void __init trizeps2_map_io(void)
+{
+	pxa_map_io();
+	//iotable_init(trizeps2_io_desc, ARRAY_SIZE(trizeps2_io_desc));
+
+	/* Enable the BTUART */
+	CKEN |= CKEN7_BTUART;
+	pxa_gpio_mode(GPIO42_BTRXD_MD);
+	pxa_gpio_mode(GPIO43_BTTXD_MD);
+	pxa_gpio_mode(GPIO44_BTCTS_MD);
+	pxa_gpio_mode(GPIO45_BTRTS_MD);
+
+	//pxa_gpio_mode(GPIO33_nCS_5_MD);	/* SMSC network chip */
+
+	/* setup sleep mode values */
+	PWER  = 0x00000002;
+	PFER  = 0x00000000;
+	PRER  = 0x00000002;
+	PGSR0 = 0x00008000;
+	PGSR1 = 0x003F0202;
+	PGSR2 = 0x0001C000;
+	PCFR |= PCFR_OPDE;
+}
+
+MACHINE_START(TRIZEPS2, "Keith & Koep Trizeps2")
+	MAINTAINER("Robert Schwebel, Pengutronix")
+	BOOT_MEM(0xa0000000, 0x40000000, io_p2v(0x40000000))
+	BOOT_PARAMS(0xa0000100)
+	MAPIO(trizeps2_map_io)
+	INITIRQ(trizeps2_init_irq)
+	INITTIME(pxa_init_time)
+MACHINE_END
Index: arch/arm/mach-pxa/Makefile
===================================================================
--- a/arch/arm/mach-pxa/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/arch/arm/mach-pxa/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -8,13 +8,19 @@
 obj-$(CONFIG_PXA27x) += pxa27x.o
 
 # Specific board support
+obj-$(CONFIG_ARCH_CSB226)  += csb226.o
+obj-$(CONFIG_ARCH_INNOKOM) += innokom.o
+obj-$(CONFIG_ARCH_LOGODL)  += logodl.o
 obj-$(CONFIG_ARCH_LUBBOCK) += lubbock.o
 obj-$(CONFIG_MACH_MAINSTONE) += mainstone.o
+obj-$(CONFIG_ARCH_PXA_PNP2110) += pnp2110.o
 obj-$(CONFIG_ARCH_PXA_IDP) += idp.o
 obj-$(CONFIG_PXA_SHARPSL)	+= corgi.o corgi_ssp.o ssp.o
+obj-$(CONFIG_ARCH_TRIZEPS2)+= trizeps2.o
 
 # Support for blinky lights
 led-y := leds.o
+led-$(CONFIG_ARCH_LOGODL)  += leds-logodl.o
 led-$(CONFIG_ARCH_LUBBOCK) += leds-lubbock.o
 led-$(CONFIG_MACH_MAINSTONE) += leds-mainstone.o
 led-$(CONFIG_ARCH_PXA_IDP) += leds-idp.o
Index: Makefile
===================================================================
--- a/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -1,9 +1,12 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION =
+EXTRAVERSION = -pxa2
 NAME=Woozy Numbat
 
+print-%:
+	@echo "$* is \"$($*)\""
+
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
 # More info can be located in ./README
@@ -189,8 +192,9 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+# ARCH		?= $(SUBARCH)
+ARCH		?= arm
+CROSS_COMPILE	?= arm-softfloat-linux-gnu-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
Index: drivers/fpbus/Kconfig
===================================================================
--- a/drivers/fpbus/Kconfig	(revision 0)
+++ b/drivers/fpbus/Kconfig	(revision 675)
@@ -0,0 +1,32 @@
+#
+# fpbus configuration
+#
+
+config FPBUS
+	tristate "fpbus"
+	default n
+	select FPBUS_IRQDEMUX
+	help
+	  This is a bus driver for in-FPGA devices. It can be autoprobed. 
+
+	  FIXME: More documentation has to be written.  
+
+	  If you don't know what to do here, say N.
+
+config FPBUS_IRQDEMUX
+	bool "fpbus irq-dispatcher"
+	depends on FPBUS
+
+config FPBUS_NGE_CS3
+	hex "MSC timing (CS3)"
+	depends on FPBUS
+	default "0x7FF1"
+	help
+	  MSC timing (CS3)
+
+config FPBUS_NGE_CS4
+	hex "MSC timing (CS4)"
+	depends on FPBUS
+	default "0x38F1"
+	help
+	  MSC timing (CS4)
Index: drivers/fpbus/fpbus.c
===================================================================
--- a/drivers/fpbus/fpbus.c	(revision 0)
+++ b/drivers/fpbus/fpbus.c	(revision 675)
@@ -0,0 +1,651 @@
+/*
+ * drivers/fpbus/fpbus.c 
+ *
+ * Copyright (C) 2004 Robert Schwebel <rsc@pengutronix.de>, Pengutronix
+ *                    modified by Benedikt Spranger, Pengutronix
+ *               2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *                    Sascha Hauer <sha@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the version 2 of the GNU General
+ * Public License as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ *
+ */
+
+#define	DEBUG
+#define	FAKE_ROM
+
+#include <linux/autoconf.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fpbus.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/io.h>
+
+#define DRIVERNAME	"fpbus"
+
+struct unit_name {
+	char			name[FTAG_DEV_ID_SIZE];
+	unsigned int		nr;
+};
+
+struct fpbus_private {
+	unsigned long		base_addr;
+	struct unit_name	*names;
+};
+
+static int msc_cs3 = CONFIG_FPBUS_NGE_CS3;
+module_param(msc_cs3, int, 0400);
+MODULE_PARM_DESC(msc_cs3, "MSC timing value (CS3)");
+
+static int msc_cs4 = CONFIG_FPBUS_NGE_CS4;
+module_param(msc_cs4, int, 0400);
+MODULE_PARM_DESC(msc_cs4, "MSC timing value (CS4)");
+
+static char *firmware = NULL;
+module_param(firmware, charp, 0400);
+MODULE_PARM_DESC(firmware, "firmware filename");
+
+static struct platform_device	*fpbus_pdev = NULL;	/* FIXME: HACK (mkl) */
+
+
+static inline void fpga_set_timing(void)
+{
+	msc_cs3 &= 0xFFFF;
+	msc_cs4 &= 0xFFFF;
+	
+	MSC1 &= 0x0000FFFF;
+	MSC1 |= msc_cs3 << 16;
+	MSC2 &= 0xFFFF0000;
+	MSC2 |= msc_cs4;
+
+        return;
+}
+
+
+static int fpbus_post_fw_setup(struct platform_device	*pdev)
+{
+	struct resource		*res;
+	struct ftag_core	*tag_core;
+	struct fpbus_private	*priv;
+	void			*addr;
+	int			err;
+
+	err = -ENODEV;
+        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        if (!res) {
+		goto exit;
+	}
+
+	err = -ENOMEM;
+	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "cound not allocate mem for private data structure.\n");
+		goto exit;
+	}
+
+	err = -EBUSY;
+	if (!request_mem_region(res->start, res->end - res->start + 1, DRIVERNAME))
+		goto exit_kfree;
+	dev_set_drvdata(&pdev->dev, priv);
+
+
+	err = -ENOMEM;
+	addr = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!addr)
+		goto exit_release;
+	priv->base_addr = (unsigned long)addr;
+	tag_core = (struct ftag_core *)addr;
+
+	err = -ENODEV;
+#ifndef FAKE_ROM
+	if (tag_core->ftag_core != CORE_TAG) {
+		dev_err(&pdev->dev, "CORE_TAG not found, aborting!\n");
+		goto exit_iounmap;
+	}
+#endif
+	err = 0;
+
+ exit:
+	return err;
+	
+ exit_iounmap:
+	iounmap((unsigned long *)addr);
+ exit_release:
+	release_mem_region(res->start, res->end - res->start + 1);
+ exit_kfree:
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(priv);
+
+	goto exit;
+}
+
+#ifdef FAKE_ROM
+static u32	fpga_rom_fake[] = {
+	/* FTAG_CORE */
+	0x50494900,
+	0x46452F31,			/* FE/1 */
+	0x32333435,			/* 2345 */
+	0x362F3738,			/* 6/78 */
+	0x39000000,			/* 9 */
+	0x00000001,			/* Version number */
+	0x004e0118,			/* compile date */
+	0x00000000,			/* dummy */
+	0x00000000,			/* dummy */
+
+	/* FTAG_DEV - irq demultiplexer */
+	0x50494901,
+	0x75627066,			/* fpbu */
+	0x72692d73,			/* s-ir */
+	0x6d656471,			/* qdem */
+	0x00007875,			/* x */
+	0x00000000,			/* dev_sub_id */
+	0x00010001,			/* ip revision / interface revision*/
+	0x10000100,			/* base_address */
+	0x00000100,			/* size */
+	FPBUS_IRQ_REAL | 0x00000010,	/* IRQ */
+	0x00000000,			/* dummy */
+
+	/* FTAG_DEV - can-chip */
+	0x50494901,
+	0x736f696e,			/* nios */
+	0x006e6163,			/* can  */
+	0x00000000,			/* 0x0  */
+	0x00000000,			/* 0x0  */
+	0x00000000,			/* dev_sub_id */
+	0x00010001,			/* ip revision / interface revision*/
+	0x10000400,			/* base_address */
+	0x00000200,			/* size */
+	FPBUS_IRQ_REAL | IRQ_GPIO(67),	/* irq */
+	0x00000000,			/* dummy */
+
+	/* FTAG_DEV - glitch detection */
+	0x50494901,
+	0x2d65676e,			/* nge- */
+	0x74696c67,			/* glit */
+	0x00006863,			/* ch   */
+	0x00000000,			/* 0x0	*/
+	0x00000000,			/* dev_sub_id */
+	0x00010001,			/* ip_revision / interface revision */
+	0x10000c00,			/* base_address */
+	0x00000110,			/* size */
+	FPBUS_IRQ_MULTIPLEX | 0x0,	/* irq */
+	0x00000000,			/* dummy */
+	
+	/* FTAG_END */
+	0x50494902,
+};
+#endif
+
+
+static void fpbus_unit_release(struct device *dev)
+{
+/*         struct platform_device  *pdev = to_platform_device(dev); */
+	struct fpbus_private 	*priv = dev_get_drvdata(dev);
+
+	if (priv)
+		kfree(priv);
+
+	return;
+}
+
+
+/* FIXME: HACK (mkl) */
+static void fpbus_unregister_children(struct platform_device	*pdev)
+{
+	struct platform_device	*child_pdev;
+	struct device *child, *tmp;
+
+	/* FIXME: HACK (mkl) */
+	list_for_each_entry_safe(child, tmp, &pdev->dev.children, node) {
+		child_pdev = to_platform_device(child);
+		platform_device_unregister(child_pdev);
+	}
+
+	return;
+}
+
+
+static int calculate_size(struct ftag_dev *start_tag, struct ftag_dev **tag_dev_next)
+{
+	struct ftag_dev	*tag_dev;
+	u32		*tag;
+	int		size;
+
+	size =    sizeof(struct platform_device)
+		+ sizeof(struct fpbus_unit_info)
+		+ sizeof(struct resource) * 2;		/* one for IRQ and first mem-window */
+
+	for (tag = (u32 *)(start_tag + 1); *tag != END_TAG; /* nix */) {
+		switch (*tag) {
+		case DEVICE_TAG:
+			tag_dev = (struct ftag_dev *)tag;
+
+			/*
+			 * dev_sub_id == 0 or == 1 signalizes the beginning of a new device
+			 */
+			if (tag_dev->dev_sub_id == 0 || tag_dev->dev_sub_id == 1)
+				goto found_next_dev;
+
+			size += sizeof(struct resource);
+
+			tag = (u32 *)++tag_dev;
+			break;
+
+		default:
+			goto exit_nodev;
+		}
+	}
+
+ found_next_dev:
+	*tag_dev_next = (struct ftag_dev *)tag;
+	return size;
+
+ exit_nodev:
+	*tag_dev_next = NULL;
+	return -ENODEV;
+}
+
+
+static int do_parse_and_register_devices(struct platform_device *parent_pdev, u32 *start_tag, int nr_units, struct unit_name *base_name)
+{
+	struct platform_device	*unit_pdev;
+	struct fpbus_unit_info	*unit_info;
+	struct resource		*unit_res;
+
+	struct unit_name	*cur_name, *free_name = base_name;
+
+	struct ftag_core	*tag_core;
+	struct ftag_dev		*tag_dev, *tag_dev_next;
+
+	u32			*tag;
+	int			size, err;
+	unsigned int		irq;
+
+	err = -ENODEV;
+	for (tag = start_tag; *tag != END_TAG; /* nix */ ) {
+		switch (*tag) {
+		case CORE_TAG:
+			tag_core = (struct ftag_core *)tag;
+			tag = (u32 *)++tag_core;
+			break;
+
+		case DEVICE_TAG:
+			tag_dev = (struct ftag_dev *)tag;
+			
+			dev_dbg(&parent_pdev->dev, "found unit, dev_id %s", tag_dev->dev_id);
+
+			size = calculate_size(tag_dev, &tag_dev_next);
+			if (size < 0) {
+				err = size;
+				goto exit_unregister;	/* FIXME */
+			}
+			
+			unit_pdev = (struct platform_device *)kmalloc(size, GFP_KERNEL);
+			if (!unit_pdev) {
+				err = -ENOMEM;
+				goto exit_unregister;	/* FIXME */
+			}
+			memset(unit_pdev, 0, size);
+			unit_info = (struct fpbus_unit_info *)(unit_pdev + 1);
+			unit_res = (struct resource *)(unit_info + 1);
+			unit_pdev->resource = unit_res;
+			dev_dbg(&parent_pdev->dev, "unit %s: allocated %d byes (0x%p-0x%p), unit_pdev 0x%p, unit_info 0x%p, unit_res 0x%p\n",
+				tag_dev->dev_id,
+				size, unit_pdev, (void *)unit_pdev + size,
+				unit_pdev, unit_info, unit_res);
+
+			/* setup unit info */
+			unit_info->interface_revision = tag_dev->interface_revision;
+			unit_info->ip_revision = tag_dev->ip_revision;
+			unit_pdev->dev.platform_data = unit_info;
+
+
+			/*
+			 * we look in the array of names if we already have a unit with this name
+			 */
+			for (cur_name = base_name; cur_name < free_name; cur_name++) {
+				/*
+				 * match!
+				 * increment name usage counter
+				 */
+				if(!strncmp((cur_name)->name, tag_dev->dev_id, sizeof(tag_dev->dev_id))) {
+					cur_name->nr++;
+					break;
+				}
+			}
+
+			/*
+			 * no match
+			 * add new name to the list of known names
+			 */
+			if (cur_name == free_name ) {
+				strlcpy(cur_name->name, tag_dev->dev_id, sizeof(cur_name->name));
+				free_name++;				/* increment offset to next free unit_name */
+			}
+
+
+			/*
+			 * link name to pdev
+			 * set id of new born device 
+			 * set fpga as parent of new born device
+			 * set release function
+			 */
+			unit_pdev->name	       = cur_name->name;
+			unit_pdev->id          = cur_name->nr;
+			unit_pdev->dev.parent  = &parent_pdev->dev;
+			unit_pdev->dev.release = fpbus_unit_release;
+			dev_dbg(&parent_pdev->dev, "unit %s, id %d\n", tag_dev->dev_id, unit_pdev->id);
+
+			/*
+			 * set IRQ of new born device
+			 */
+			if (tag_dev->interrupt & FPBUS_IRQ_REAL) {
+				irq = tag_dev->interrupt & FPBUS_IRQ_MASK;
+			} else if (tag_dev->interrupt & FPBUS_IRQ_MULTIPLEX) {
+				irq = FPBUS_IRQ((tag_dev->interrupt & FPBUS_IRQ_MASK));
+			} else {
+				irq = -1;	/* FIXME: no IRQ, what to do (mkl) */
+			}
+						
+			unit_res->start          = unit_res->end = irq;
+			unit_res->flags          = IORESOURCE_IRQ;
+			unit_pdev->num_resources = 1;			/* at the moment, only one resource (the IRQ) */
+			
+			if (tag_dev->interrupt & FPBUS_IRQ_REAL) {
+				dev_dbg(&parent_pdev->dev, "unit %s, found real irq %i, using resource at 0x%p\n",
+					tag_dev->dev_id,
+					tag_dev->interrupt & FPBUS_IRQ_MASK,
+					unit_res);
+			} else {
+				dev_dbg(&parent_pdev->dev, "unit %s, found multiplexed irq %i/%i, using resource at 0x%p\n",
+					tag_dev->dev_id,
+					tag_dev->interrupt & FPBUS_IRQ_MASK,
+					irq,
+					unit_res);
+			}
+
+			unit_res++;
+
+
+			for (/* nix */; tag_dev < tag_dev_next; tag_dev++) {
+				/*
+				 * add current mem-window to resources block of new born device
+				 * und increment resource counter
+				 */
+				unit_res->start = tag_dev->base_address;
+				unit_res->end   = tag_dev->base_address + tag_dev->size - 1;
+				unit_res->flags = IORESOURCE_MEM;
+				unit_pdev->num_resources++;
+				dev_dbg(&parent_pdev->dev, "found iomem start 0x%08x, size %i, using resource at 0x%p\n",
+					tag_dev->base_address, tag_dev->size, unit_res);
+				unit_res++;
+			}
+			
+			err = platform_device_register(unit_pdev);
+			if (err) {
+				dev_err(&parent_pdev->dev, "unable to register platform_device (%d)!\n", err);
+				goto exit_kfree;
+			}
+			
+			/*
+			 * done, working on this tag, next one please!
+			 */
+			tag = (u32 *)tag_dev_next;
+			break;
+
+		default:
+			dev_err(&parent_pdev->dev, "unknown tag 0x%08x found, aborting!\n", *tag);
+			goto exit_unregister;
+		}
+	}
+
+
+	err = 0;
+ exit:
+	return err;
+ exit_kfree:
+	kfree(unit_pdev);
+ exit_unregister:
+	fpbus_unregister_children(parent_pdev);
+	goto exit;
+}
+
+
+static int fpbus_get_nr_units(u32 *start_tag)
+{
+	struct ftag_core	*tag_core;
+	struct ftag_dev		*tag_dev;
+	u32			*tag;
+	int			nr_units = 0;
+	int			err;
+
+	for (tag = start_tag; *tag != END_TAG; /* nix */ ) {
+		switch (*tag) {
+		case CORE_TAG:
+			tag_core = (struct ftag_core *)tag;
+			tag = (u32 *)++tag_core;
+			break;
+		case DEVICE_TAG:
+			tag_dev = (struct ftag_dev *)tag;
+			/* 
+			 * units with exactly 1 mem window have dev_sub_id == 0
+			 * units with more mem windows have dev_sub_id > 0
+			 * only count the first tag of multi-mem-window unit
+			 *
+			 */
+			if (tag_dev->dev_sub_id == 0 || tag_dev->dev_sub_id == 1) {
+				nr_units++;
+			}
+
+			tag = (u32 *)++tag_dev;
+			break;
+		default:
+			err = -ENODEV;
+			goto exit;
+			break;
+		}
+	}
+
+	return nr_units;
+
+ exit:
+	return err;
+}
+
+
+static int fpbus_parse_fpga_config(struct platform_device	*pdev)
+{
+	struct fpbus_private 	*priv = dev_get_drvdata(&pdev->dev);
+	struct unit_name	*names;
+
+	u32			*start_tag;
+	int			nr_units;
+	int			size;
+        int                     err;
+
+#ifndef FAKE_ROM
+	start_tag = (u32 *)priv->base_addr;
+#else
+	start_tag = fpga_rom_fake;
+#endif
+
+	if (!start_tag) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	
+	nr_units = fpbus_get_nr_units(start_tag);
+	if (nr_units < 0) {
+		err = nr_units;
+		goto exit;
+	}
+	dev_dbg(&pdev->dev, "found %d units in FPGA config rom\n", nr_units);
+
+	size = nr_units * sizeof(struct unit_name);
+	names = (struct unit_name *)kmalloc(size, GFP_KERNEL);
+	if (!names) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	memset(names, 0, size);
+	priv->names = names;
+
+	err = do_parse_and_register_devices(pdev, start_tag, nr_units, names);
+	if (err)
+		goto exit_kfree;
+
+	err = 0;
+
+ exit:
+	return err;
+ exit_kfree:
+	kfree(names);
+
+	goto exit;
+}
+
+
+static int fpbus_drv_probe (struct device *dev)
+{
+        struct platform_device  *pdev = to_platform_device(dev);
+        struct fpga_info        *inf;
+        int                     err;
+
+	/* FIXME: HACK (mkl) */
+	err = -EBUSY;
+	if (fpbus_pdev) {
+		goto exit;
+	}
+
+        inf = dev->platform_data;
+        err = -ENOMEM;
+        if (!inf)
+                goto exit;
+
+        err = -EINVAL;
+	switch(inf->dev_type) {
+	case FPBUS_DEV_TYPE_ALTERA_SERIAL:
+		inf->fw_loader = fpga_fw_loader_altera_serial;
+		break;
+	default:
+                dev_err(&pdev->dev, "no firmware loader specified, aborting!\n");
+                goto exit;
+	}	
+
+        inf->fw_file = firmware;
+
+        err = fpbus_upload_firmware(pdev);
+	if (err)
+		goto exit;
+
+	err = fpbus_post_fw_setup(pdev);
+	if (err)
+		goto exit;
+
+	/* FIXME: HACK (mkl) */
+	fpbus_pdev = pdev;
+	err = 0;
+
+exit:
+	return err;
+}
+
+
+static int fpbus_drv_remove(struct device *dev)
+{
+        struct platform_device  *pdev = to_platform_device(dev);
+	struct fpbus_private 	*priv = dev_get_drvdata(dev);
+	struct resource 	*res;
+
+	dev_set_drvdata(dev, NULL);
+
+	iounmap((void *)priv->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	kfree(priv);
+
+	/* FIXME: HACK (mkl) */
+	fpbus_pdev = NULL;
+
+	return 0;
+}
+
+static struct device_driver     fpbus_driver = {
+	.name		= DRIVERNAME,
+	.bus		= &platform_bus_type,
+	.probe		= fpbus_drv_probe,
+	.remove		= fpbus_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= fpbus_drv_suspend,
+	.resume		= fpbus_drv_resume,
+#endif
+};
+
+static int __init fpbus_init(void)
+{
+        int     err;
+
+	if (!firmware) {
+		printk(KERN_ERR "No firmware file specified!\n");
+		err = -EINVAL;
+		goto exit;
+	}
+		
+        fpga_set_timing();
+
+        err = driver_register(&fpbus_driver);
+	if (err) {
+		goto exit;
+	}
+
+	/* FIXME: HACK (mkl) */
+	err = -ENODEV;
+//	if (!fpbus_pdev) {
+		goto exit_unregister;
+//	}
+
+	/* FIXME: HACK (mkl) */
+	err = fpbus_parse_fpga_config(fpbus_pdev);
+	if (err)
+		goto exit_unregister;
+
+	err = 0;
+
+ exit:
+        return err;
+
+ exit_unregister:
+	driver_unregister(&fpbus_driver);
+	goto exit;
+}
+
+
+static void __exit fpbus_exit(void)
+{
+	/* FIXME: HACK (mkl) */
+	fpbus_unregister_children(fpbus_pdev);
+
+        driver_unregister(&fpbus_driver);
+
+	return;
+}
+
+module_init(fpbus_init);
+module_exit(fpbus_exit);
+
+MODULE_LICENSE("GPL v2");
Index: drivers/fpbus/fwloader.c
===================================================================
--- a/drivers/fpbus/fwloader.c	(revision 0)
+++ b/drivers/fpbus/fwloader.c	(revision 675)
@@ -0,0 +1,197 @@
+/*
+ * fwloader.c 
+ *
+ * Copyright (C) 2004 Robert Schwebel <rsc@pengutronix.de>, Pengutronix
+ *                    modified by Benedikt Spranger, Pengutronix
+ *               2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *                    Sascha Hauer <sha@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/autoconf.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+
+#include <linux/fpbus.h>
+#include <linux/gpio.h>
+
+#include <asm/delay.h>
+
+
+int fpga_fw_loader_altera_serial(struct platform_device *pdev,
+				 const struct firmware  *fw)
+{
+        struct fpga_info                *inf    = pdev->dev.platform_data;
+        struct altera_serial_config     *config = &inf->fw_loader_cfg.altera_serial;
+
+        char    *fpga_name      = pdev->name;
+	size_t  size            = fw->size;
+	u8      *buf            = fw->data;
+
+        int     data0           = config->data0;
+        int     dclk            = config->dclk;
+        int     conf_done       = config->conf_done;
+        int     nconfig         = config->nconfig;
+        int     nstatus         = config->nstatus;
+
+	int     bits_transferred= 0;
+	int     err, ret;
+	int     timeout;
+
+
+	dev_info(&pdev->dev, "transferring %i bytes into FPGA (altera serial)\n", size);
+
+	err = -ENOMEM;
+	/* request gpio pins and initialize */
+	ret = request_gpio(nconfig, fpga_name, GPIO_OUTPUT, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting GPIO pin %d\n", nconfig);
+		goto err_nconfig;
+	}
+
+	ret = request_gpio(data0, fpga_name, GPIO_OUTPUT, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting GPIO pin %d\n", data0);
+		goto err_data0;
+	}
+
+	ret = request_gpio(dclk, fpga_name, GPIO_OUTPUT, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting GPIO pin %d\n", dclk);
+		goto err_dclk;
+	}
+
+	ret = request_gpio(nstatus, fpga_name, 0, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting GPIO pin %d\n", nstatus);
+		goto err_nstatus;
+	}
+
+	ret = request_gpio(conf_done, fpga_name, 0, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting GPIO pin %d\n", conf_done);
+		goto err_conf_done;
+	}
+	
+	/* positive edge after > 40 us low time initiates data transfer */
+	udelay(50);
+	gpio_set_pin(nconfig);
+
+	/* positive edge on nSTATUS indicates that device is ready */
+	timeout = 50;
+	while (!gpio_get_pin(nstatus) && (timeout--))
+		udelay(1);
+	
+	err = -ENODEV;
+	if (timeout == 0)	{
+		dev_err(&pdev->dev, "Timeout while waiting for device ready\n");
+		goto err_conf_done;
+	}
+
+	/* wait > 1 us until transfer starts */
+	udelay(2);
+
+	dev_info(&pdev->dev, "loading:\n");
+	while (!gpio_get_pin(conf_done)) {
+		
+		if (*buf & 0x1)
+			gpio_set_pin(data0);
+		else
+			gpio_clear_pin(data0);
+
+		udelay(1); 			/* FIXME: > 7 ns            */
+		gpio_set_pin(dclk); 	        /* valid on positive edge   */
+		udelay(1); 			/* FIXME: > 4 ns            */
+		gpio_clear_pin(dclk);
+		*buf >>= 1;
+		if (!(++bits_transferred % 8))
+			buf++;
+
+		if(!(bits_transferred % 8192)) /* . per  1kiB */
+			dev_dbg(&pdev->dev, ".");
+
+		if (bits_transferred > size * 8)
+			break;
+	}
+
+	dev_info(&pdev->dev, "done\n");
+
+	/*
+	 * we are either finished or have tried to tranfer more than
+	 * size bytes
+	 */
+	
+	err = -ENODEV;
+	if (!gpio_get_pin(conf_done)) {
+		dev_err(&pdev->dev, "device didn't finish configuation after firmware was transferred\n");
+		goto err_conf_done;
+	}
+	
+	dev_info(&pdev->dev, "FPGA configured.\n");
+
+	err = 0;
+	/* fallthrough */
+
+err_conf_done:
+	free_gpio(conf_done);
+err_nstatus:
+	free_gpio(nstatus);
+err_dclk:
+	free_gpio(dclk);
+err_data0:
+	free_gpio(data0);
+err_nconfig:
+	free_gpio(nconfig);
+
+	return err;
+        }
+EXPORT_SYMBOL(fpga_fw_loader_altera_serial);
+
+
+int fpbus_upload_firmware(struct platform_device *pdev)
+{
+        struct fpga_info        *inf = pdev->dev.platform_data;
+	const struct firmware   *fw_entry;
+	int ret;
+
+	/* request firmware */
+	dev_dbg(&pdev->dev, "requesting firmware (%s)\n", inf->fw_file);
+	if ((ret = request_firmware(&fw_entry, inf->fw_file, &pdev->dev))) {
+		dev_err(&pdev->dev, "requesting firmware failed (error=%i), aborting.\n", ret);
+		goto exit;
+	}
+
+        /* load firmware into FPGA */
+	dev_dbg(&pdev->dev, "loading firmware into FPGA\n");
+	if ((ret = inf->fw_loader(pdev, fw_entry))) {
+		dev_err(&pdev->dev, "loading firmware failed!\n");
+		ret = -EIO;
+                goto exit_release_firmware;
+	}
+
+        ret = 0;
+        /* fallthough */
+
+ exit_release_firmware:
+        release_firmware(fw_entry);
+ exit:
+        return ret;
+}
+EXPORT_SYMBOL(fpbus_upload_firmware);
+
+MODULE_LICENSE("GPL v2");
+
Index: drivers/fpbus/fpbus-irqdemux.c
===================================================================
--- a/drivers/fpbus/fpbus-irqdemux.c	(revision 0)
+++ b/drivers/fpbus/fpbus-irqdemux.c	(revision 675)
@@ -0,0 +1,277 @@
+/*
+ * drivers/fpbus/fpbus-irqdemux.c 
+ *
+ * Copyright (C) 2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the version 2 of the GNU General
+ * Public License as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+#define DRIVERNAME	"fpbus-irqdemux"
+
+#define FID_IRQ		(0x0)
+#define	FID_MASK	(0x4)
+#define FID_ACK		(0x8)
+
+#if 1
+#define DEBUG_IRQ(fmt...)	printk(fmt)
+#else
+#define DEBUG_IRQ(fmt...)	do { } while (0)
+#endif
+
+/* FIXME: HACK (mkl) */
+struct platform_device	*fid_pdev = NULL;
+
+struct fid_private {
+	unsigned long	base_addr;
+};
+
+static inline u32 fid_read_reg(unsigned long base, int reg)
+{
+	volatile unsigned int val;
+
+	val = *(volatile u32 *)(base + reg);
+
+	pr_debug("(%s) base 0x%08lx, reg 0x%x, val 0x%08x\n",
+		 __FUNCTION__, base, reg, val);
+
+	return val;
+}
+
+static inline void fid_write_reg(unsigned long base, int reg, u32 val)
+{
+	pr_debug("(%s) base 0x%08lx, reg 0x%x, val 0x%08x\n",
+		 __FUNCTION__, base, reg, val);
+
+	*(volatile u32 *)(base + reg) = val;
+}
+
+
+static void fid_ack_irq(unsigned int irq)
+{
+	struct fid_private 	*priv = dev_get_drvdata(&fid_pdev->dev);
+
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+
+	u32 reg_ack = fid_read_reg(priv->base_addr, FID_ACK);
+	fid_write_reg(priv->base_addr, FID_ACK, reg_ack | (1 << (irq - FPBUS_IRQ(0))));
+}
+
+
+static void fid_mask_irq(unsigned int irq)
+{
+	struct fid_private 	*priv = dev_get_drvdata(&fid_pdev->dev);
+
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+
+	u32 reg_mask = fid_read_reg(priv->base_addr, FID_MASK);
+	fid_write_reg(priv->base_addr, FID_MASK, reg_mask & ~(1 << (irq - FPBUS_IRQ(0))));
+}
+
+
+static void fid_unmask_irq(unsigned int irq)
+{
+	struct fid_private 	*priv = dev_get_drvdata(&fid_pdev->dev);
+
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+
+	u32 reg_mask = fid_read_reg(priv->base_addr, FID_MASK);
+	fid_write_reg(priv->base_addr, FID_MASK, reg_mask | (1 << (irq - FPBUS_IRQ(0))));
+}
+
+
+static int fid_irq_type(unsigned int _irq, unsigned int type)
+{
+/* 	unsigned int irq_type = 0, irq, reg, bit; */
+
+	if (type & __IRQT_RISEDGE) {
+		DEBUG_IRQ("rising edges\n");
+	}
+	if (type & __IRQT_FALEDGE) {
+		DEBUG_IRQ("falling edges\n");
+	}
+	if (type & __IRQT_LOWLVL) {
+		DEBUG_IRQ("low level\n");
+	}
+	if (type & __IRQT_HIGHLVL) {
+		DEBUG_IRQ("high level\n");
+	}
+
+	return 0;
+}
+
+
+
+static struct irqchip fid_chip = {
+	.ack	= fid_ack_irq,
+	.mask	= fid_mask_irq,
+	.unmask = fid_unmask_irq,
+	.type	= fid_irq_type,
+};
+
+
+static void fid_demux_handler(unsigned int irq_unused, struct irqdesc *desc, struct pt_regs *regs)
+{
+	struct fid_private 	*priv = dev_get_drvdata(&fid_pdev->dev);
+	unsigned int 		mask, irq;
+
+	mask = fid_read_reg(priv->base_addr, FID_IRQ);
+	irq = FPBUS_IRQ(0);
+
+	desc = irq_desc + irq;
+	while (mask) {
+		if (mask & 1) {
+			DEBUG_IRQ("handling irq %d\n", irq);
+			desc->handle(irq, desc, regs);
+		}
+		irq++;
+		desc++;
+		mask >>= 1;
+	}
+
+	return;
+}
+
+
+static int fid_drv_probe(struct device *dev)
+{
+        struct platform_device  *pdev = to_platform_device(dev);
+	struct resource		*res;
+	struct fid_private	*priv;
+	void			*addr;
+	unsigned int		fpbus_irq, irq;
+	int			err;
+
+	return -1;
+	
+	/* FIXME: HACK (mkl) */
+	err = -EBUSY;
+	if (fid_pdev) {
+		goto exit;
+	}
+
+	err = -ENODEV;
+        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	fpbus_irq = platform_get_irq(pdev, 0);
+        if (!res || !fpbus_irq) {
+		goto exit;
+	}
+
+	err = -ENOMEM;
+	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "cound not allocate mem for private data structure.\n");
+		goto exit;
+	}
+
+	err = -EBUSY;
+	if (!request_mem_region(res->start, res->end - res->start + 1, DRIVERNAME))
+		goto exit_kfree;
+	dev_set_drvdata(&pdev->dev, priv);
+
+
+	err = -ENOMEM;
+	addr = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!addr)
+		goto exit_release;
+	priv->base_addr = (unsigned long)addr;
+	err = 0;
+
+	/* Mask all interrupts initially */
+	fid_write_reg(priv->base_addr, FID_MASK, 0);
+
+	for (irq = FPBUS_IRQ(0); irq < FPBUS_IRQ(32); irq++) {
+		set_irq_chip(irq, &fid_chip);
+		set_irq_handler(irq, do_edge_IRQ);			/* FIXME: edge or level disscuss with FZK (mkl) */
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	set_irq_chained_handler(fpbus_irq, fid_demux_handler);
+
+	/* FIXME: HACK (mkl) */
+	fid_pdev = pdev;
+
+ exit:
+	return err;
+	
+ exit_iounmap:
+	iounmap((unsigned long *)addr);
+ exit_release:
+	release_mem_region(res->start, res->end - res->start + 1);
+ exit_kfree:
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(priv);
+
+	goto exit;
+}
+
+static int fid_drv_remove(struct device *dev)
+{
+        struct platform_device  *pdev = to_platform_device(dev);
+	struct fid_private 	*priv = dev_get_drvdata(dev);
+	struct resource 	*res;
+
+	dev_set_drvdata(dev, NULL);
+
+	/* FIXME: shutdown IRQs, unregister handler, etc (mkl) */
+
+	iounmap((void *)priv->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	kfree(priv);
+
+	/* FIXME: HACK (mkl) */
+	fid_pdev = NULL;
+
+	return 0;
+}
+
+
+static struct device_driver fid_driver = {
+	.name		= DRIVERNAME,
+	.bus		= &platform_bus_type,
+	.probe		= fid_drv_probe,
+	.remove		= fid_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= fid_drv_suspend,
+	.resume		= fid_drv_resume,
+#endif
+};
+
+
+static int __init fpbus_irqdemux_init(void)
+{
+	return driver_register(&fid_driver);
+}
+
+static void __exit fpbus_irqdemux_exit(void)
+{
+	driver_unregister(&fid_driver);
+}
+
+module_init(fpbus_irqdemux_init);
+module_exit(fpbus_irqdemux_exit);
+
+MODULE_LICENSE("GPL v2");
Index: drivers/fpbus/Makefile
===================================================================
--- a/drivers/fpbus/Makefile	(revision 0)
+++ b/drivers/fpbus/Makefile	(revision 675)
@@ -0,0 +1,9 @@
+#
+# Makefile for the fpbus specific drivers.
+#
+
+obj-$(CONFIG_FPBUS)		+= fpbus.o
+obj-$(CONFIG_FPBUS)		+= fwloader.o
+
+obj-$(FPBUS_IRQDEMUX)		+= fpbus-irqdemux.o
+
Index: drivers/Kconfig
===================================================================
--- a/drivers/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -58,4 +58,6 @@
 
 source "drivers/infiniband/Kconfig"
 
+source "drivers/can/Kconfig"
+
 endmenu
Index: drivers/mtd/maps/Makefile
===================================================================
--- a/drivers/mtd/maps/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mtd/maps/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -17,6 +17,7 @@
 obj-$(CONFIG_MTD_DILNETPC)	+= dilnetpc.o
 obj-$(CONFIG_MTD_ELAN_104NC)	+= elan-104nc.o
 obj-$(CONFIG_MTD_EPXA10DB)	+= epxa10db-flash.o
+obj-$(CONFIG_MTD_INNOKOM)	+= innokom.o
 obj-$(CONFIG_MTD_IQ80310)	+= iq80310.o
 obj-$(CONFIG_MTD_L440GX)	+= l440gx.o
 obj-$(CONFIG_MTD_AMD76XROM)	+= amd76xrom.o
@@ -72,3 +73,4 @@
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
+obj-$(CONFIG_MTD_PNP2110)	+= pnp2110.o
Index: drivers/mtd/maps/Kconfig
===================================================================
--- a/drivers/mtd/maps/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mtd/maps/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -139,6 +139,20 @@
 	  This provides a driver for the on-board flash of the Intel
 	  'Lubbock' XScale evaluation board.
 
+config MTD_INNOKOM
+	tristate "CFI Flash device mapped on Auerswald Innokom"
+	depends on ARCH_INNOKOM && MTD_PARTITIONS && MTD_COMPLEX_MAPPINGS
+	help
+	  This provides a driver for the on-board flash of the 
+	  Auerswald Innokom board. 
+
+config MTD_PNP2110
+	tristate "CFI Flash device mapped on PNP/2110"
+	depends on ARCH_PXA_PNP2110 && MTD_PARTITIONS && MTD_COMPLEX_MAPPINGS
+	help
+	  This provides a driver for the on-board flash of the SSV PNP2110 
+	  module. For more details about the board see http://www.dnp.com. 
+
 config MTD_OCTAGON
 	tristate "JEDEC Flash device mapped on Octagon 5066 SBC"
 	depends on X86 && MTD_JEDEC && MTD_COMPLEX_MAPPINGS
Index: drivers/mtd/maps/pnp2110.c
===================================================================
--- a/drivers/mtd/maps/pnp2110.c	(revision 0)
+++ b/drivers/mtd/maps/pnp2110.c	(revision 675)
@@ -0,0 +1,153 @@
+/*
+ * Map driver for the SSV PNP/2110-3V platform.
+ *
+ * Author:	Marco Hasewinkel
+ * Copyright:	(C) 2003 SSV Embedded Systems
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/pnp2110.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+/* This window is probed for flash devices */
+#define WINDOW_ADDR 	0x00000000
+#define WINDOW_SIZE 	(32*1024*1024)
+
+#define PNP2110_VPP_GPIO 16
+
+static void 
+pnp2110_set_vpp(struct map_info *map, int on)
+{
+	/* GPIO16: 1=Vpp on   0=Vpp off */
+	if (on)
+		GPSR(PNP2110_VPP_GPIO) |= GPIO_bit(PNP2110_VPP_GPIO);
+	else
+		GPCR(PNP2110_VPP_GPIO) |= GPIO_bit(PNP2110_VPP_GPIO);
+} 
+
+static struct map_info pnp2110_map = {
+	.name		= "PNP/2110-3V flash",
+	.size		= WINDOW_SIZE,
+	.phys		= WINDOW_ADDR,
+	.set_vpp	= pnp2110_set_vpp,
+};
+
+static struct mtd_partition pnp2110_partitions[] = {
+	{
+		name:		"Bootloader",
+		size:		0x00020000,
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE  /* force read-only */
+	},{
+		name:		"Bootloader env",
+		size:		0x00020000,
+		offset:		0x00020000,
+		mask_flags:	MTD_WRITEABLE  /* force read-only */
+	},{
+		name:		"Filesystem space",
+		size:		MTDPART_SIZ_FULL,
+		offset:		0x00040000
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+static struct mtd_partition *parsed_parts;
+
+static int __init init_pnp2110(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	char *part_type = "static";
+
+	pnp2110_map.bankwidth = (BOOT_DEF & 1) ? 2 : 4;
+
+	/* Map flash chips */
+	pnp2110_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	if (!pnp2110_map.virt) {
+		printk("Failed to ioremap flash device\n");
+		return -ENOMEM;
+	}
+	pnp2110_map.cached = __ioremap(pnp2110_map.phys, WINDOW_SIZE, L_PTE_CACHEABLE, 1);
+	if (!pnp2110_map.cached)
+		printk(KERN_WARNING "Failed to ioremap cached %s\n", pnp2110_map.name);
+
+	/* Use the default flash access functions */
+	simple_map_init(&pnp2110_map);
+
+	/* MTD probing */
+	printk( "Probing PNP2110 flash at physical address 0x%08x (%d-bit bankwidth)\n",
+		WINDOW_ADDR, pnp2110_map.bankwidth * 8 );
+	mymtd = do_map_probe("cfi_probe", &pnp2110_map);
+	if (!mymtd) {
+		iounmap((void *)pnp2110_map.virt);
+		if (pnp2110_map.cached)
+			iounmap(pnp2110_map.cached);
+		return -EIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	/* Parse partitions */
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	} else {
+		parts = pnp2110_partitions;
+		nb_parts = NB_OF(pnp2110_partitions);
+	}
+	if (nb_parts) {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	} else {
+		add_mtd_device(mymtd);
+	}
+
+	pnp2110_set_vpp(&pnp2110_map, 0);
+	GPDR(PNP2110_VPP_GPIO) |= GPIO_bit(PNP2110_VPP_GPIO); /* output */
+	
+	return 0;
+}
+
+static void __exit cleanup_pnp2110(void)
+{
+	GPDR(16) &= ~GPIO_bit(16); /* input */
+	
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (pnp2110_map.map_priv_1)
+		iounmap((void *)pnp2110_map.map_priv_1);
+
+	return;
+}
+
+module_init(init_pnp2110);
+module_exit(cleanup_pnp2110);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Marco Hasewinkel, SSV; Robert Schwebel, Pengutronix");
+MODULE_DESCRIPTION("MTD map driver for SSV PNP/2110");
+
Index: drivers/mtd/maps/innokom.c
===================================================================
--- a/drivers/mtd/maps/innokom.c	(revision 0)
+++ b/drivers/mtd/maps/innokom.c	(revision 675)
@@ -0,0 +1,181 @@
+/*
+ * Map driver for the Auerswald Innokom platform.
+ *
+ * Authors:	Kai-Uwe Bloem, Robert Schwebel, Nicolas Pitre
+ * Copyright:	(C) 2001 MontaVista Software Inc.
+ *              (C) 2003 Pengutronix 
+ *		(C) 2003 Auerswald GmbH & Co. KG
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/arch/pxa-regs.h>
+
+#define WINDOW_ADDR 	0
+#define	WINDOW_SIZE	(128*1024*1024)	/* 2 Flashes in PXA nCS banks #0, #1 */
+
+static struct map_info innokom_map = {
+	.name		= "Innokom flash",
+	.size		= WINDOW_SIZE,
+	.phys		= WINDOW_ADDR,
+//	.set_vpp	=
+};
+
+static struct mtd_partition innokom_partitions_16M[] = {
+	{
+		.name	=	"U-Boot",
+		.size	=	0x00040000,	/* 256 kB                   */
+		.offset	=	0x00000000,
+		/* mask_flags:	MTD_WRITEABLE	   force read-only          */
+	},{
+		.name	=	"Firmware-1",
+		.size	=	0x000C0000,	/* 768 kB                   */ 
+		.offset	=	0x00040000,
+	},{
+		.name	=	"Firmware-2",
+		.size	=	0x00800000,	/* 8 MB                     */
+		.offset	=	0x00100000,
+	},{
+		.name	=	"Data",
+		.size	=	0x00700000,	/* 7 MB                     */
+		.offset	=	0x00900000
+	}
+};
+
+#if 0
+static struct mtd_partition innokom_partitions_32M[] = {
+	{
+		name:		"U-Boot",
+		size:		0x00040000,	/* 256 kB                   */
+		offset:		0x00000000,
+		/* mask_flags:	MTD_WRITEABLE	   force read-only          */
+	},{
+		name:		"Firmware-1",
+		size:		0x007E0000,	/* 8 MB - 128 kB            */ 
+		offset:		0x00040000,
+	},{
+		name:		"Firmware-2",
+		size:		0x007E0000,	/* 8 MB - 128 kB            */
+		offset:		0x00820000,
+	},{
+		name:		"Data",
+		size:		0x01000000,	/* 16 MB                    */
+		offset:		0x01000000
+	}
+};
+#endif
+
+static struct mtd_partition innokom_partitions_64M[] = {
+	{
+		name:		"U-Boot",
+		size:		0x00040000,	/* 256 kB                   */
+		offset:		0x00000000,
+		/* mask_flags:	MTD_WRITEABLE	   force read-only          */
+	},{
+		name:		"Firmware-1",
+		size:		0x00FE0000,	/* 16 MB - 128 kB           */ 
+		offset:		0x00040000,
+	},{
+		name:		"Firmware-2",
+		size:		0x00FE0000,	/* 16 MB - 128 kB           */
+		offset:		0x01020000,
+	},{
+		name:		"Data",
+		size:		0x02000000,	/* 32 MB                    */
+		offset:		0x02000000
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+static struct mtd_partition *parsed_parts;
+
+static int __init init_innokom(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	char *part_type = "static";
+
+	innokom_map.bankwidth = (BOOT_DEF & 1) ? 2 : 4;
+	printk( "Probing Auerswald Innokom flash at physical address 0x%08x (%d-bits bankwidth)\n",
+		WINDOW_ADDR, innokom_map.bankwidth * 8 );
+	/* FIXME: RS: is the "align" parameter (last one) correct? I
+	 * could not find an example for it... */
+	innokom_map.map_priv_1 = (unsigned long)__ioremap(WINDOW_ADDR, WINDOW_SIZE, 0, 0);
+	if (!innokom_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("cfi_probe", &innokom_map);
+	if (!mymtd) {
+		iounmap((void *)innokom_map.map_priv_1);
+		return -ENXIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+
+	} else switch (mymtd->size) {
+		case 64*1024*1024:
+			parts = innokom_partitions_64M;
+			part_type = "static (64M)";
+			nb_parts = NB_OF(innokom_partitions_64M);
+			break;
+		case 32*1024*1024:
+#if 0
+			parts = innokom_partitions_32M;
+			part_type = "static (32M)";
+			nb_parts = NB_OF(innokom_partitions_32M);
+			break;
+#endif
+		case 16*1024*1024:
+			parts = innokom_partitions_16M;
+			part_type = "static (16M)";
+			nb_parts = NB_OF(innokom_partitions_16M);
+			break;
+		default:
+			printk(KERN_WARNING "Can't derive partitioning from MTD size, using 16M as default\n");
+			parts = innokom_partitions_16M;
+			part_type = "static (default)";
+			nb_parts = NB_OF(innokom_partitions_16M);
+			break;
+	}
+	if (nb_parts) {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	} else {
+		add_mtd_device(mymtd);
+	}
+	return 0;
+}
+
+static void __exit cleanup_innokom(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (innokom_map.map_priv_1)
+		iounmap((void *)innokom_map.map_priv_1);
+	return;
+}
+
+module_init(init_innokom);
+module_exit(cleanup_innokom);
+
Index: drivers/can/sja1000.c
===================================================================
--- a/drivers/can/sja1000.c	(revision 0)
+++ b/drivers/can/sja1000.c	(revision 675)
@@ -0,0 +1,312 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <asm/io.h>
+#include <linux/can.h>
+#include "sja1000.h"
+
+static int sja1000_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	struct sja1000_dev *dev = netdev_priv(ndev);
+	unsigned char fir;
+	int i;
+
+	printk ("%s\n", __FUNCTION__);	
+
+	if ( !(dev->read_reg(dev, SJASR) & SJA_SR_TBS) ) {
+		printk("buffer full\n");
+		netif_stop_queue(ndev);
+		return 0;
+	}
+
+	fir = frame->can_dlc & FIR_DLC_MASK;
+
+	if( frame->can_id & CAN_FLAG_RTR )
+		fir |= FIR_RTR;
+
+	if (frame->can_id & CAN_FLAG_EXTENDED) {
+		printk("sending extended frame\n");
+		dev->write_reg(dev,SJA_TXID1, frame->can_id >> 21);
+		dev->write_reg(dev,SJA_TXID2, frame->can_id >> 13);
+		dev->write_reg(dev,SJA_TXID3, frame->can_id >> 5);
+		dev->write_reg(dev,SJA_TXID3, frame->can_id << 3);
+
+		for(i=0; i<frame->can_dlc; i++)
+			dev->write_reg(dev,SJA_DATA_EFF(i), frame->payload.byte[i]);
+		fir |= FIR_EXT;
+	} else {
+		printk("sending standard frame\n");
+		dev->write_reg(dev, SJA_TXID1, frame->can_id >> 3);
+		dev->write_reg(dev, SJA_TXID2, frame->can_id << 5);
+		for(i=0; i<frame->can_dlc; i++)
+			dev->write_reg(dev,SJA_DATA_SFF(i), frame->payload.byte[i]);
+	}
+
+	dev->write_reg(dev,SJA_FIR, fir);
+	dev->write_reg(dev,SJACMR, SJA_CMR_TR);
+	
+	ndev->trans_start = jiffies;
+	dev_kfree_skb(skb);
+	
+	return 0;
+}
+
+static void sja1000_tx_timeout(struct net_device *dev)
+{
+	printk ("%s\n", __FUNCTION__);
+}
+
+static void sja1000_read_msg(struct net_device *ndev)
+{
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	int i;
+	struct sja1000_dev *dev = netdev_priv(ndev);
+	unsigned char fir;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	skb->dev = ndev;
+
+	frame = (struct can_frame *)skb_put(skb,sizeof(struct can_frame));
+
+	fir = dev->read_reg(dev, SJA_FIR);
+
+	frame->can_dlc = fir & FIR_DLC_MASK;
+	
+	if( fir & FIR_EXT) {
+		frame->can_id =  dev->read_reg(dev, SJA_TXID1) << 19;
+		frame->can_id |= dev->read_reg(dev, SJA_TXID2) << 11;
+		frame->can_id =  dev->read_reg(dev, SJA_TXID3) << 5;
+		frame->can_id |= dev->read_reg(dev, SJA_TXID4) >> 3;
+		frame->can_id |= CAN_FLAG_EXTENDED;
+		for(i=0; i<frame->can_dlc; i++)
+			frame->payload.byte[i] = dev->read_reg(dev, SJA_DATA_EFF(i));
+	} else {
+		frame->can_id =  dev->read_reg(dev, SJA_TXID1) << 3;
+		frame->can_id |= dev->read_reg(dev, SJA_TXID2) >> 5;
+		for(i=0; i<frame->can_dlc; i++)
+			frame->payload.byte[i] = dev->read_reg(dev, SJA_DATA_SFF(i));
+	}
+	
+	if( fir & FIR_RTR)
+		frame->can_id |= CAN_FLAG_RTR;
+
+	printk("received pkt: id: %u dlc: %u data: ",
+	      frame->can_id,frame->can_dlc);
+
+	for(i=0; i<frame->can_dlc; i++)
+		printk("%2x ",frame->payload.byte[i]);
+	printk("\n");
+
+	dev->write_reg(dev, SJACMR, SJA_CMR_RRB);
+
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	netif_rx(skb);
+}
+
+static irqreturn_t sja1000_interrupt(int irq, void *dev_id, 
+				     struct pt_regs *regs)
+{
+	struct net_device *ndev = (struct net_device *) dev_id;
+	struct sja1000_dev *dev = netdev_priv(ndev);
+	unsigned char irq_status;
+
+	irq_status = dev->read_reg(dev, SJAIR);
+
+	if ((irq_status & (SJA_IR_WUI | SJA_IR_DOI | SJA_IR_EI | SJA_IR_TI | SJA_IR_RI)) == 0)
+		return IRQ_NONE;
+
+	printk ("%s: 0x%02x\n", __FUNCTION__,irq_status);
+
+	do {
+		if (irq_status & SJA_IR_RI) {
+			printk("receive irq\n");
+			sja1000_read_msg(ndev);
+		}
+
+		if ((irq_status & SJA_IR_TI) != 0) { 
+			printk("transmit irq\n");
+			if( dev->read_reg(dev, SJASR) & SJA_SR_TBS )
+				netif_start_queue(ndev);
+			else
+				printk("transmit irq and buffer full!?\n");
+		}
+
+		if ((irq_status & (SJA_IR_EI|SJA_IR_DOI)) != 0) { 
+			printk("Error: status register: 0x%x irq_register: 0x%02x\n",
+				dev->read_reg(dev, SJASR), irq_status);
+		}
+
+		irq_status = dev->read_reg(dev, SJAIR);
+
+	} while(irq_status & ( SJA_IR_WUI | SJA_IR_DOI | SJA_IR_EI | SJA_IR_TI | SJA_IR_RI));
+
+	return IRQ_HANDLED;
+}
+
+static int sja1000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+//	int err;
+	printk("ioctl: %p %d %p\n", dev, cmd, rq);
+
+#if 0       
+	if (! netif_device_present(dev)) return -ENODEV;
+	switch (cmd) 
+	{
+	default:
+		err = -EOPNOTSUPP;
+	}
+#endif  
+	return 0;
+
+}
+
+static int sja1000_open(struct net_device *ndev)
+{
+	struct sja1000_dev *dev = netdev_priv(ndev);
+	int ret;
+	printk ("%s\n", __FUNCTION__);
+	netif_start_queue(ndev);
+       
+	/* Grab the IRQ */
+      	ret = request_irq(ndev->irq, &sja1000_interrupt, SA_SHIRQ, ndev->name, ndev);
+      	if (ret) {
+		ret = -ENODEV;
+      		goto err_out;
+	}
+
+	dev->open = 1;
+
+	return 0;
+err_out:
+	return ret;
+}
+
+static int sja1000_stop(struct net_device *ndev)
+{
+	struct sja1000_dev *dev = netdev_priv(ndev);
+	printk("%s\n", __FUNCTION__);
+
+	free_irq(ndev->irq, ndev);
+
+	/* disable interrupts */
+	dev->write_reg(dev, 4, 0x0);
+
+	netif_stop_queue(ndev);
+	dev->open = 0;
+	return 0;
+}
+
+struct sja1000_dev *alloc_sja1000dev(void)
+{
+	struct sja1000_dev *dev;
+	struct net_device *ndev;
+	printk("%s\n",__FUNCTION__);
+
+	ndev = alloc_candev(sizeof(struct sja1000_dev));
+	if (!ndev) {
+		printk("sja1000: could not allocate device.\n");
+		return NULL;
+	}
+	
+	dev = netdev_priv(ndev);
+	dev->ndev = ndev;
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_sja1000dev);
+
+static void sja1000_chip_config(struct sja1000_dev *dev)
+{
+	int i = 10;
+
+	printk("%s\n",__FUNCTION__);
+	/* go to reset mode */
+	do {
+		dev->write_reg(dev, SJACR, SJA_CR_RR);
+		if( dev->read_reg(dev, SJACR) & SJA_CR_RR )
+			break;
+		udelay(100);
+	} while( i-- );
+	
+	if( !i)
+		printk("resetting chip failed\n");
+
+	/* FIXME: device-specific */
+	dev->write_reg(dev,SJACDR,SJA_CDR_PELICAN); 
+	dev->write_reg(dev,SJAOCR,0x5e); 
+	
+	/* set default baudrate */
+	/* FIXME */
+	dev->write_reg(dev, SJABTR0, 0x03);
+	dev->write_reg(dev, SJABTR1, 0x1c);
+
+	/* acceptance mask (accept everything) */
+	dev->write_reg(dev, 20, 0xff);
+	dev->write_reg(dev, 21, 0xff);
+	dev->write_reg(dev, 22, 0xff);
+	dev->write_reg(dev, 23, 0xff);
+	
+	/* enable interrupts */
+	dev->write_reg(dev, 4, 0xff);
+
+	/* leave reset mode */
+	do {
+		dev->write_reg(dev, SJACR, 0);
+		if( !(dev->read_reg(dev, SJACR) & SJA_CR_RR) )
+			break;
+		udelay(100);
+	} while( i-- );
+	
+	if( !i)
+		printk("leaving reset mode failed\n");
+
+}
+
+int sja1000_register(struct sja1000_dev *dev)
+{
+	struct net_device *ndev = dev->ndev;
+	int ret;
+
+	printk("%s\n",__FUNCTION__);
+
+	ndev->irq = dev->irq;
+
+	ndev->base_addr = dev->base;
+
+	ndev->open = sja1000_open;
+	ndev->stop = sja1000_stop;
+	ndev->hard_start_xmit = sja1000_hard_start_xmit;
+	ndev->tx_timeout = sja1000_tx_timeout;
+	ndev->do_ioctl = sja1000_ioctl;
+
+	sja1000_chip_config(dev);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		printk("register_netdev failed\n");
+		return -1;
+	}
+	
+	return 0;
+}
+EXPORT_SYMBOL(sja1000_register);
+
+void sja1000_deregister(struct sja1000_dev *dev)
+{
+	struct net_device *ndev = dev->ndev;
+
+	printk ("%s\n", __FUNCTION__);
+
+	unregister_netdev(ndev);
+
+	free_netdev(ndev);
+}
+EXPORT_SYMBOL(sja1000_deregister);
Index: drivers/can/ixxatcan.c
===================================================================
--- a/drivers/can/ixxatcan.c	(revision 0)
+++ b/drivers/can/ixxatcan.c	(revision 675)
@@ -0,0 +1,144 @@
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/crc32.h>
+#include <asm/io.h>
+#include "sja1000.h"
+
+#define DRV_NAME "ixxatcan"
+
+typedef enum {
+	IXXATCAN = 0,
+} board_t;
+
+static struct pci_device_id ixxatcan_pci_tbl[] = {
+	{0x10b5, 0x9050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, IXXATCAN },
+};
+MODULE_DEVICE_TABLE (pci, ixxatcan_pci_tbl);
+
+unsigned char ixxatcan_read_reg(struct sja1000_dev *dev,unsigned long reg)
+{
+	return *(volatile unsigned char*)(dev->base + reg);
+}
+
+void ixxatcan_write_reg(struct sja1000_dev *dev,unsigned long reg,unsigned char val)
+{
+	*(volatile unsigned char*)(dev->base + reg) = val;
+}
+
+static int __devinit ixxatcan_init_one (struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	int ret;
+	struct sja1000_dev *dev;
+	unsigned long *ioaddr;
+	unsigned long mmio_start, mmio_end, mmio_flags, mmio_len;
+
+	printk("%s\n",__FUNCTION__);
+
+	ret = pci_enable_device (pdev);
+	if (ret)
+		goto err_out;
+
+	ret = pci_request_regions (pdev, DRV_NAME);
+	if (ret)
+		goto err_out;
+
+	mmio_start = pci_resource_start (pdev, 2);
+	mmio_end = pci_resource_end (pdev, 2);
+	mmio_flags = pci_resource_flags (pdev, 2);
+	mmio_len = pci_resource_len (pdev, 2);
+	printk("start: 0x%08lx, end: 0x%08lx,flags: 0x%08lx, len: 0x%08lx\n",
+			mmio_start,mmio_end,mmio_flags,mmio_len);
+
+	ioaddr = ioremap (mmio_start, mmio_len);
+	if (ioaddr == NULL) {
+		printk (KERN_ERR "%s: cannot remap MMIO, aborting\n", pci_name(pdev));
+		ret = -EIO;
+		goto err_out;
+	}
+
+	dev = (struct sja1000_dev*)alloc_sja1000dev();
+	if( !dev )
+		goto err_out;
+	
+	dev->read_reg = ixxatcan_read_reg;
+	dev->write_reg = ixxatcan_write_reg;
+	dev->irq = pdev->irq;
+	dev->base = (unsigned long)ioaddr;
+
+	pci_set_drvdata (pdev, dev);
+
+	sja1000_register(dev);
+
+	return 0;
+err_out:
+	return -ENODEV;
+}
+
+static void __devexit ixxatcan_remove_one (struct pci_dev *pdev)
+{
+	struct sja1000_dev *dev = pci_get_drvdata(pdev);
+	printk("%s\n",__FUNCTION__);
+
+	sja1000_deregister(dev);
+
+	if (dev->base)
+		iounmap ((void *)dev->base);
+
+	pci_set_drvdata (pdev, NULL);
+
+	pci_release_regions (pdev);
+
+}
+
+#ifdef CONFIG_PM
+static int ixxatcan_suspend (struct pci_dev *pdev, u32 state)
+{
+	printk("%s\n",__FUNCTION__);
+	return 0;
+}
+
+
+static int ixxatcan_resume (struct pci_dev *pdev)
+{
+	printk("%s\n",__FUNCTION__);
+	return 0;
+}
+#endif
+
+static struct pci_driver ixxatcan_pci_driver = {
+	.name		= DRV_NAME,
+	.id_table	= ixxatcan_pci_tbl,
+	.probe		= ixxatcan_init_one,
+	.remove		= __devexit_p(ixxatcan_remove_one),
+#ifdef CONFIG_PM
+	.suspend	= ixxatcan_suspend,
+	.resume		= ixxatcan_resume,
+#endif /* CONFIG_PM */
+};
+
+
+static int __init ixxatcan_init_module (void)
+{
+	printk ("ixxatcan initializing\n");
+
+	return pci_module_init (&ixxatcan_pci_driver);
+}
+
+
+static void __exit ixxatcan_cleanup_module (void)
+{
+	pci_unregister_driver (&ixxatcan_pci_driver);
+}
+
+module_init(ixxatcan_init_module);
+module_exit(ixxatcan_cleanup_module);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sascha Hauer, Pengutronix");
Index: drivers/can/Kconfig
===================================================================
--- a/drivers/can/Kconfig	(revision 0)
+++ b/drivers/can/Kconfig	(revision 675)
@@ -0,0 +1,19 @@
+menu "CAN support"
+
+config CANDEVICES
+	depends on CAN
+	bool "CAN device support"
+
+config NIOSCAN
+	depends on CANDEVICES
+	tristate "Nios CAN device support"
+
+config SJA1000
+	depends on CANDEVICES
+	tristate "Support for Philips SJA1000 chips"
+
+config IXXAT
+	depends on SJA1000
+	tristate "IXXAT CAN device support"
+
+endmenu
Index: drivers/can/nioscan.c
===================================================================
--- a/drivers/can/nioscan.c	(revision 0)
+++ b/drivers/can/nioscan.c	(revision 675)
@@ -0,0 +1,731 @@
+/*
+ * drivers/can/nioscan.c
+ *
+ * Copyright (C) 2005 Sascha Hauer <sha@pengutronix.de>, Pengutronix
+ *                    Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* #define DEBUG	1 */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/can.h>
+
+#include <asm/io.h>
+
+#define CARDNAME "nioscan"
+
+#define TX_TIMEOUT  (6*HZ)
+
+#define NIOS_LENGTH 		(0x0000)
+#define NIOS_ID 		(0x0004)
+#define NIOS_DATA_0_3 		(0x0008)
+#define NIOS_DATA_4_7 		(0x000C)
+#define NIOS_TIMING 		(0x0010)
+#define NIOS_INTMASK 		(0x0014)
+#define NIOS_STATUS 		(0x0018)
+#define NIOS_ERROR_COUNT 	(0x001C)
+#define NIOS_VERSION		(0x0020)
+#define NIOS_FILTER_MASK 	(0x0200)
+#define NIOS_FILTER_IDENTIFIER	(0x0204)
+
+/*
+ * Bit definitionss of Data Lengh Code Reg
+ */
+#define NIOS_RTR 		(1<<4)
+
+/*
+ * Bit definitionss of Identifier Reg
+ */
+#define NIOS_EXTID 		(1<<29)
+
+/*
+ * Bit Definitions of Timing Reg
+ */
+#define NIOS_TIME_PRESCALE_OFFS	16		// offset of prescale value
+#define NIOS_TIME_TIMEA_OFFS	8		// offset of timeA value
+#define NIOS_TIME_TIMEB_OFFS	0		// offset of timeB value
+#define NIOS_TIME_SET_PRESCALE	(1<<31)		// mask prescale value set
+#define NIOS_TIME_SET_TIMEA    	(1<<15)		// mask timea value set
+#define NIOS_TIME_SET_TIMEB    	(1<<7)		// mask timeb value set
+
+#define NIOS_TIME_NORMAL_MODE	(1<<24)		// mask normal mode
+
+/*
+ * Bit Definitions of Interrupt Mask Reg
+ */
+#define NIOS_INTMASK_SET	(1 << 31)	// set interrupt mask
+#define NIOS_RX_FULL		(1 << 29)	// receive buffer full 
+#define NIOS_RX_OVFL		(1 << 28)	// receive buffer overflow
+#define NIOS_RX_NEMPTY		(1 << 27)	// receive buffer not empty
+#define NIOS_TX_FULL		(1 << 26)	// transmit buffer full
+#define NIOS_TX_OVFL		(1 << 25)	// transmit buffer overflow
+#define NIOS_TX_EMPTY		(1 << 24)	// transmit buffer empty
+#define NIOS_ERRMASK_SET	(1 << 7)	// set error mask
+#define NIOS_ERR_WARN		(1 << 1)	// error warning
+#define NIOS_ERR_BUSOFF		(1 << 0)	// error bus off
+
+static const u32 nios_int_mask          = NIOS_RX_OVFL  | NIOS_TX_OVFL | NIOS_RX_NEMPTY | NIOS_TX_EMPTY;
+static const u32 nios_int_mask_abnormal = NIOS_RX_OVFL  | NIOS_TX_OVFL;
+static const u32 nios_err_mask          = NIOS_ERR_WARN | NIOS_ERR_BUSOFF;
+
+/*
+ * Bit Definitions of Status Reg
+ */
+#define NIOS_RX_BUSY		(1 << 31)	// receive busy
+#define NIOS_TX_BUSY		(1 << 30)	// transmit busy
+#define NIOS_RX_BUFFER_FULL	(1 << 23)	// receive buffer full
+#define NIOS_TX_BUFFER_FULL	(1 << 22)	// transmit buffer full
+#define NIOS_RX_POINTER_RESET	(1 << 23)	// reset receive pointer
+#define NIOS_TX_POINTER_RESET	(1 << 15)	// reset transmit pointer
+#define NIOS_RX_NEXT_VALUE	(1 << 7)	// receive fifo next value
+#define NIOS_ERR_PASSIVE	(1 << 3)	// error passive mode
+#define NIOS_ERR_ACTIVE		(1 << 2)	// error active mode
+#define NIOS_RX_PTR_MASK 	(0x003F0000)	// receive buffer pointer mask
+#define NIOS_RX_PTR_OFFS 	(16)		// receive buffer pointer offset
+#define NIOS_TX_PTR_MASK 	(0x00003F00)	// transmit buffer pointer mask
+#define NIOS_TX_PTR_OFFS 	(8)		// transmit buffer pointer offset
+
+/*
+ * Bit Definitions of Error Counter Reg
+ */
+#define NIOS_RX_ERR_CNT_MASK	(0x00ff0000)
+#define NIOS_TX_ERR_CNT_MASK	(0x000001ff)
+#define NIOS_RX_ERR_CNT_OFFS	16
+#define NIOS_TX_ERR_CNT_OFFS	0
+
+/*
+ * Bit Definitions of Filter Mask and Identifier Regs
+ */
+#define NIOS_MASK_VALID		(1 << 31)	// set valid for mask register
+#define NIOS_ID_VALID		(1 << 31)	// set valid for id register
+
+
+enum NIOS_CHIP_CLOCK {
+/* 	NIOS_CC_33 = 0, */
+	NIOS_CC_48 = 0,
+	NIOS_CC_MAX,
+};
+
+struct nioscan_private 
+{
+	struct net_device_stats	stats;
+	struct can_baudrate	br;
+	int			flags;
+	int			chip_clock;
+};
+
+static int do_set_baudrate(struct net_device *ndev, struct can_baudrate *br);
+
+static inline u32 nios_read_reg(unsigned long base, int reg)
+{
+	volatile unsigned int val;
+
+	val = *(volatile u32 *)(base + reg);
+
+	pr_debug("(%s) base 0x%08lx, reg 0x%x, val 0x%08x\n",
+		 __FUNCTION__, base, reg, val);
+
+	return val;
+}
+
+static inline void nios_write_reg(unsigned long base, int reg, u32 val)
+{
+	pr_debug("(%s) base 0x%08lx, reg 0x%x, val 0x%08x\n",
+		 __FUNCTION__, base, reg, val);
+
+	*(volatile u32 *)(base + reg) = val;
+}
+
+static inline void nios_write_filter(unsigned long base, int nr,
+				     u32 mask, u32 identifier)
+{
+	nios_write_reg(base, NIOS_FILTER_MASK       + (nr << 2), mask);
+	nios_write_reg(base, NIOS_FILTER_IDENTIFIER + (nr << 2), identifier);
+}
+
+
+static void nioscan_chip_reset(struct net_device *ndev)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+	int i;
+
+	/* set filter */
+	for (i = 0; i < 64; i++) {
+		nios_write_filter(ndev->base_addr, i, 0x80000000L, 0x80000000L);
+	}
+
+	/* mask interrupts and errors */
+	nios_write_reg(ndev->base_addr, NIOS_INTMASK, (nios_int_mask & ~NIOS_TX_EMPTY ) | NIOS_INTMASK_SET );
+	nios_write_reg(ndev->base_addr, NIOS_INTMASK, nios_err_mask | NIOS_ERRMASK_SET);
+
+	/*
+	 * _NOTE_: DO NOT combine these 2 write statements into 1!
+	 *         The RX & TX buffer pointer reset has to be taken back.
+	 *         (which does the 2nd write)
+	 */
+	/* pointer reset */
+	nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_RX_POINTER_RESET | NIOS_TX_POINTER_RESET);
+	nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_ERR_WARN | NIOS_ERR_BUSOFF);
+
+	/* status reset */
+	nios_write_reg(ndev->base_addr, NIOS_STATUS,
+		         NIOS_RX_FULL
+		       | NIOS_RX_OVFL
+		       | NIOS_RX_NEMPTY
+		       | NIOS_TX_FULL
+		       | NIOS_TX_OVFL
+		       | NIOS_TX_EMPTY);
+
+	/* normal mode */
+	tp->flags &= ~NIOS_ERR_BUSOFF;
+	nios_write_reg(ndev->base_addr, NIOS_TIMING, NIOS_TIME_NORMAL_MODE);
+
+	return;
+}
+
+
+static struct net_device_stats *nioscan_get_stats (struct net_device *ndev)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+	u32 reg_error_count;
+
+	reg_error_count = nios_read_reg(ndev->base_addr, NIOS_ERROR_COUNT);
+
+	/* FIXME: lock */
+
+	tp->stats.rx_errors = (reg_error_count & NIOS_RX_ERR_CNT_MASK) >> NIOS_RX_ERR_CNT_OFFS;
+	tp->stats.tx_errors = (reg_error_count & NIOS_TX_ERR_CNT_MASK) >> NIOS_TX_ERR_CNT_OFFS;
+
+	/* FIXME: unlock */
+
+	return &tp->stats;
+}
+
+
+static void nioscan_read_msg(struct net_device *ndev)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u32 reg_dlc, reg_id;
+
+	while (nios_read_reg(ndev->base_addr, NIOS_STATUS) & NIOS_RX_PTR_MASK) {
+		skb = alloc_skb(sizeof(struct can_frame), GFP_ATOMIC);
+		if (unlikely(skb == NULL)) {
+			if (net_ratelimit()) 
+				dev_warn(ND2D(ndev), "Memory squeeze, dropping packet.\n");
+			tp->stats.rx_dropped++;
+			continue;
+		}
+		skb->dev = ndev;
+
+		frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+		reg_id = nios_read_reg(ndev->base_addr, NIOS_ID);
+
+		/* process canid */
+		frame->can_id = reg_id;
+		if (reg_id & NIOS_EXTID) {
+			frame->can_id &= CAN_ID_EXT_MASK;
+			frame->can_id |= CAN_FLAG_EXTENDED;
+		} else {			
+			frame->can_id &= CAN_ID_STD_MASK;
+		}
+
+		/* process data length code & rtr */
+		reg_dlc = nios_read_reg(ndev->base_addr, NIOS_LENGTH);
+		frame->can_dlc = reg_dlc & 0xf;
+		if (reg_dlc & NIOS_RTR)
+			frame->can_id |= CAN_FLAG_RTR;
+
+		/* process payload */
+		frame->payload.dword[0] = nios_read_reg(ndev->base_addr, NIOS_DATA_0_3);
+		frame->payload.dword[1] = nios_read_reg(ndev->base_addr, NIOS_DATA_4_7);
+
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_RX_NEXT_VALUE);
+
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		
+		netif_rx(skb);
+
+		/* do stats and other stuff */
+		ndev->last_rx = jiffies;
+		tp->stats.rx_packets++;
+		tp->stats.rx_bytes += frame->can_dlc;
+	}
+
+	return;
+}
+
+static int nioscan_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	u32 reg_dlc, reg_id;
+
+	reg_dlc = frame->can_dlc;
+	if (frame->can_id & CAN_FLAG_RTR)
+		reg_dlc |= NIOS_RTR;
+	
+	reg_id = frame->can_id & CAN_ID_EXT_MASK;
+
+	if (frame->can_id & CAN_FLAG_EXTENDED)
+		reg_id |= NIOS_EXTID;
+	
+	nios_write_reg(ndev->base_addr, NIOS_DATA_0_3, frame->payload.dword[0]);
+	nios_write_reg(ndev->base_addr, NIOS_DATA_4_7, frame->payload.dword[1]);
+	nios_write_reg(ndev->base_addr, NIOS_ID, reg_id);
+	wmb();
+	nios_write_reg(ndev->base_addr, NIOS_LENGTH, reg_dlc);		/* must be last, starts xmit in HW */
+	ndev->trans_start = jiffies;
+
+	kfree_skb(skb);
+
+	/* do stats */
+	tp->stats.tx_packets++;
+	tp->stats.tx_bytes += frame->can_dlc;
+
+	if (nios_read_reg(ndev->base_addr, NIOS_STATUS) & NIOS_TX_BUFFER_FULL) {
+		/* enable TX-Buffer empty Interrupt */
+		nios_write_reg(ndev->base_addr, NIOS_INTMASK, nios_int_mask | NIOS_INTMASK_SET);
+		netif_stop_queue(ndev);
+	}
+
+	return 0;
+}
+
+
+static void nioscan_tx_timeout(struct net_device *ndev)
+{
+	printk ("%s\n", __FUNCTION__);
+}
+
+
+static const u32 baudrate2timing[NIOS_CC_MAX][CAN_BAUD_MAX] = {
+/* 	[NIOS_CC_33][CAN_BAUD_10K]  =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_20K]  =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_50K]  =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_100K] =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_125K] =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_250K] =   1 << NIOS_TIME_PRESCALE_OFFS | 29 << NIOS_TIME_TIMEA_OFFS | 11 << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_500K] =   1 << NIOS_TIME_PRESCALE_OFFS | 13 << NIOS_TIME_TIMEA_OFFS |  5 << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_800K] =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_33][CAN_BAUD_1M]   =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+
+/* 	[NIOS_CC_48][CAN_BAUD_10K]  =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_48][CAN_BAUD_20K]  =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_48][CAN_BAUD_50K]  =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_48][CAN_BAUD_100K] =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+	[NIOS_CC_48][CAN_BAUD_125K] =  14 << NIOS_TIME_PRESCALE_OFFS | 15 << NIOS_TIME_TIMEA_OFFS |  5 << NIOS_TIME_TIMEB_OFFS,
+	[NIOS_CC_48][CAN_BAUD_250K] =   6 << NIOS_TIME_PRESCALE_OFFS | 15 << NIOS_TIME_TIMEA_OFFS |  5 << NIOS_TIME_TIMEB_OFFS,
+	[NIOS_CC_48][CAN_BAUD_500K] =   2 << NIOS_TIME_PRESCALE_OFFS | 15 << NIOS_TIME_TIMEA_OFFS |  5 << NIOS_TIME_TIMEB_OFFS,
+/* 	[NIOS_CC_48][CAN_BAUD_800K] =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+/* 	[NIOS_CC_48][CAN_BAUD_1M]   =     << NIOS_TIME_PRESCALE_OFFS |    << NIOS_TIME_TIMEA_OFFS |    << NIOS_TIME_TIMEB_OFFS, */
+};
+
+
+static int do_set_baudrate(struct net_device *ndev, struct can_baudrate *br)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+	u32 reg_timing;
+	int err;
+
+	err = -EINVAL;
+	if (br->baudrate == CAN_BAUD_BTR) {
+		/*
+		 * btr[0] = prescale
+		 * btr[1] = timeA
+		 * btr[2] = timeB
+		 */
+		reg_timing = ((br->btr[0] & 0xff) << NIOS_TIME_PRESCALE_OFFS)
+			   | ((br->btr[1] & 0x1f) << NIOS_TIME_TIMEA_OFFS)
+			   | ((br->btr[2] & 0x1f) << NIOS_TIME_TIMEB_OFFS);
+
+		/* make a copy for later get_baudrate */
+		memcpy(&tp->br, br, sizeof(tp->br));
+	} else if (br->baudrate >= 0 && br->baudrate < CAN_BAUD_MAX) {
+		reg_timing = baudrate2timing[tp->chip_clock][br->baudrate];
+
+		/* puzzle together for later get_baudrate */
+		tp->br.baudrate = br->baudrate;
+		tp->br.btr[0] = (reg_timing & 0xff0000) >> NIOS_TIME_PRESCALE_OFFS;
+		tp->br.btr[1] = (reg_timing & 0x001f00) >> NIOS_TIME_TIMEA_OFFS;
+		tp->br.btr[2] = (reg_timing & 0x00001f) >> NIOS_TIME_TIMEB_OFFS;
+	} else {
+		goto exit;
+	}
+
+	err = 0;
+
+	reg_timing |= NIOS_TIME_SET_PRESCALE | NIOS_TIME_SET_TIMEA | NIOS_TIME_SET_TIMEB;
+	nios_write_reg(ndev->base_addr, NIOS_TIMING, reg_timing);
+
+ exit:
+	return err;
+}
+
+
+static int do_get_baudrate(struct net_device *ndev, struct can_baudrate *br)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+
+	memcpy(br, &tp->br, sizeof(*br));
+
+	return 0;
+}
+
+ 
+static int do_set_mode(struct net_device *ndev, enum CAN_MODE mode)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+
+	switch (mode) {
+	case CAN_MODE_START:
+		tp->flags &= ~NIOS_ERR_BUSOFF;
+		nios_write_reg(ndev->base_addr, NIOS_TIMING, NIOS_TIME_NORMAL_MODE);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+
+static int do_get_state(struct net_device *ndev, enum CAN_STATE *state)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+	u32 reg_status;
+
+	*state = -1;
+
+	reg_status = nios_read_reg(ndev->base_addr, NIOS_STATUS);
+	if (reg_status & NIOS_ERR_PASSIVE)
+		*state = CAN_STATE_BUS_PASSIVE;
+	else if (reg_status & NIOS_ERR_ACTIVE)
+		*state = CAN_STATE_ACTIVE;
+	else if (tp->flags & NIOS_ERR_BUSOFF)
+		*state = CAN_STATE_BUS_OFF;
+	return 0;
+}
+
+
+static int nioscan_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)
+{
+	struct can_baudrate	*baudrate = (struct can_baudrate *)&ifr->ifr_ifru;
+	union can_settings	*settings = (union can_settings *)&ifr->ifr_ifru;
+
+	dev_dbg(ND2D(ndev), "(%s) 0x%08x %p\n", __FUNCTION__, cmd);
+
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+		return do_set_baudrate(ndev, baudrate);
+	case SIOCGCANBAUDRATE:
+		return do_get_baudrate(ndev, baudrate);
+	case SIOCSCANMODE:
+		return do_set_mode(ndev, settings->mode);
+	case SIOCGCANSTATE:
+		return do_get_state(ndev, &settings->state);
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0; /* notreached */
+}
+
+
+static void do_weird_interrupt(struct net_device *ndev, u32 reg_status)
+{
+	struct nioscan_private *tp = netdev_priv(ndev);
+
+	dev_err(ND2D(ndev), "Abnormal interrupt, status 0x%08x\n", reg_status);
+
+	if (reg_status & NIOS_ERR_WARN) {
+		/* FIXME: do sth. useful */
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_ERR_WARN);
+		dev_err(ND2D(ndev), "Device is about to go into Error Passive Mode\n");
+	}
+
+	if (reg_status & NIOS_ERR_BUSOFF) {
+		tp->flags |= NIOS_ERR_BUSOFF;
+		netif_stop_queue(ndev);
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_ERR_WARN);
+		dev_err(ND2D(ndev), "Device is in Bus Off Mode\n");
+	}
+
+	if (reg_status & NIOS_RX_OVFL) {
+		/*
+		 * _NOTE_: DO NOT combine these 2 write statements into 1!
+		 *         The RX buffer pointer reset has to be taken back.
+		 *         (which does the 2nd write)
+		 */
+		dev_err(ND2D(ndev), "RX-Buffer Overflow - Clearing Buffer\n");
+		tp->stats.rx_dropped += (reg_status && NIOS_RX_PTR_MASK) >> NIOS_RX_PTR_OFFS;
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_RX_POINTER_RESET);
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_RX_OVFL);
+	}
+
+	/* This should not happen, the netif_queue should have been stopped before */
+	if (reg_status & NIOS_TX_OVFL) {
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_TX_OVFL);
+		netif_stop_queue(ndev);
+	}
+	    
+	return;
+}
+
+
+static irqreturn_t nioscan_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *ndev = (struct net_device *) dev_id;
+/* 	struct nioscan_private *tp = netdev_priv(ndev); */
+	u32 reg_status;
+	irqreturn_t handled = IRQ_NONE;
+
+	/* FIXME: lock */
+
+	reg_status = nios_read_reg(ndev->base_addr, NIOS_STATUS);
+
+	/* check for shared irq */
+	if (unlikely(reg_status & (nios_int_mask | nios_err_mask)) == 0)
+		goto exit;
+
+	handled = IRQ_HANDLED;
+
+	if (netif_running(ndev) && (reg_status & NIOS_RX_NEMPTY)) {
+		nioscan_read_msg(ndev);
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_RX_NEMPTY);
+	}
+
+	if (netif_running(ndev) && (reg_status & NIOS_TX_EMPTY)) {
+		/* ACK interrupt */
+		nios_write_reg(ndev->base_addr, NIOS_STATUS, NIOS_TX_EMPTY);
+
+		/* disable TX-Buffer empty interrupt */
+		nios_write_reg(ndev->base_addr, NIOS_INTMASK, (nios_int_mask & ~NIOS_TX_EMPTY ) | NIOS_INTMASK_SET );
+
+		netif_start_queue(ndev);
+	}
+
+	if (reg_status & (nios_int_mask_abnormal | nios_err_mask))
+		do_weird_interrupt(ndev, reg_status);
+
+ exit:
+	/*  FIXME: unlock */
+	return handled;
+}
+
+
+static int nioscan_open(struct net_device *ndev)
+{
+/* 	struct nioscan_private *tp = netdev_priv(ndev); */
+	int ret;
+       
+	/* Grab the IRQ */
+      	ret = request_irq(ndev->irq, &nioscan_interrupt, 0, ndev->name, ndev);
+      	if (ret) {
+		ret = -ENODEV;
+      		goto err_out;
+	}
+
+	set_irq_type(ndev->irq, IRQT_FALLING);
+
+	/* reset chip, setup chip, unmask IRQs */
+	nioscan_chip_reset(ndev);
+
+	netif_start_queue(ndev);
+
+	return 0;
+err_out:
+	return ret;
+}
+
+
+static int nioscan_stop(struct net_device *ndev)
+{
+/* 	struct nioscan_private *tp = netdev_priv(ndev); */
+
+	netif_stop_queue(ndev);
+
+	/* mask all IRQs */
+	nios_write_reg(ndev->base_addr, NIOS_INTMASK, 0x0 | NIOS_INTMASK_SET);
+
+	free_irq(ndev->irq, ndev);
+
+	return 0;
+}
+
+static int nioscan_probe(struct net_device *ndev, unsigned long ioaddr)
+{
+	int ret;
+
+	if (nios_read_reg(ndev->base_addr, NIOS_VERSION) != 0x0604291e) {
+		dev_err(ND2D(ndev), "no nios CAN chip found on address 0x%08lx\n", ioaddr);
+		return -ENODEV;
+	}
+
+	ndev->open            = nioscan_open;
+	ndev->stop            = nioscan_stop;
+	ndev->hard_start_xmit = nioscan_hard_start_xmit;
+	ndev->tx_timeout      = nioscan_tx_timeout;
+	ndev->do_ioctl        = nioscan_ioctl;
+	ndev->base_addr       = ioaddr;
+	ndev->get_stats	      = nioscan_get_stats;
+	ndev->tx_timeout      = nioscan_tx_timeout;
+	ndev->watchdog_timeo  = TX_TIMEOUT;
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(ND2D(ndev), "register_netdev failed\n");
+		return -1;
+	}
+	
+	return 0;
+}
+
+static int nioscan_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct nioscan_private *tp;
+	struct resource *res;
+	struct net_device *ndev;
+	unsigned long addr;
+	int irq, err;
+
+	err = -ENODEV;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || !irq) {
+		goto exit;
+	}
+
+	err = -ENOMEM;
+	ndev = alloc_candev(sizeof(struct nioscan_private));
+	if (!ndev) {
+		dev_err(dev, "could not allocate device\n");
+		goto exit;
+	}
+
+	tp = netdev_priv(ndev);
+
+	/*
+	 * Request the regions.
+	 */
+	err = -EBUSY;
+	if (!request_mem_region(res->start, res->end - res->start + 1, CARDNAME)) {
+		goto exit_free_netdev;
+	}
+	
+	SET_MODULE_OWNER(ndev);
+	SET_NETDEV_DEV(ndev, dev);
+
+	err = -ENOMEM;
+	addr = (unsigned long)ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!addr) {
+		goto exit_release;
+	}
+
+	ndev->base_addr = addr;
+	ndev->irq = irq;
+
+	dev_set_drvdata(dev, ndev);
+
+	err = nioscan_probe(ndev, addr);
+	if (err) {
+		dev_err(dev, "Device not found (%d).\n", err);
+		goto exit_unmap;
+	}
+
+	err = 0;
+
+ exit:
+	return err;
+
+ exit_unmap:
+	iounmap((unsigned long *)addr);
+ exit_release:
+	release_mem_region(res->start, res->end - res->start + 1);
+ exit_free_netdev:
+	dev_set_drvdata(dev, NULL);
+	free_netdev(ndev);
+	goto exit;
+}
+
+static int nioscan_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct resource *res;
+
+	dev_set_drvdata(dev, NULL);
+
+	unregister_netdev(ndev);
+
+	iounmap((void *)ndev->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	free_netdev(ndev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int nioscan_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	printk ("%s\n", __FUNCTION__);
+	return 0;
+}
+
+static int nioscan_drv_resume(struct device *dev, u32 level)
+{
+	printk ("%s\n", __FUNCTION__);
+	return 0;
+}
+#endif 	/* CONFIG_PM */
+
+static struct device_driver nioscan_driver = {
+	.name		= CARDNAME,
+	.bus		= &platform_bus_type,
+	.probe		= nioscan_drv_probe,
+	.remove		= nioscan_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= nioscan_drv_suspend,
+	.resume		= nioscan_drv_resume,
+#endif	/* CONFIG_PM */
+};
+
+static int __init nioscan_init(void)
+{
+	return driver_register(&nioscan_driver);
+}
+
+static void __exit nioscan_cleanup(void)
+{
+	driver_unregister(&nioscan_driver);
+}
+
+module_init(nioscan_init);
+module_exit(nioscan_cleanup);
+
+MODULE_LICENSE("GPL v2");
Index: drivers/can/Makefile
===================================================================
--- a/drivers/can/Makefile	(revision 0)
+++ b/drivers/can/Makefile	(revision 675)
@@ -0,0 +1,3 @@
+obj-$(CONFIG_NIOSCAN) += nioscan.o
+obj-$(CONFIG_IXXAT) += ixxatcan.o
+obj-$(CONFIG_SJA1000) += sja1000.o
Index: drivers/mmc/mmc_queue.c
===================================================================
--- a/drivers/mmc/mmc_queue.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmc_queue.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -60,6 +60,7 @@
 	struct mmc_queue *mq = d;
 	struct request_queue *q = mq->queue;
 	DECLARE_WAITQUEUE(wait, current);
+	int ret;
 
 	/*
 	 * Set iothread to ensure that we aren't put to sleep by
@@ -73,10 +74,184 @@
 
 	down(&mq->thread_sem);
 	add_wait_queue(&mq->thread_wq, &wait);
+	spin_lock_irq(q->queue_lock);
 	do {
 		struct request *req = NULL;
 
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (!blk_queue_plugged(q))
+			mq->req = req = elv_next_request(q);
+		spin_unlock(q->queue_lock);
+
+		if (!req) {
+			if (!mq->thread)
+				break;
+			schedule();
+			continue;
+		}
+		set_current_state(TASK_RUNNING);
+
+		ret = mq->issue_fn(mq, req);
+
 		spin_lock_irq(q->queue_lock);
+		end_request(req, ret);
+	} while (1);
+	remove_wait_queue(&mq->thread_wq, &wait);
+
+	complete_and_exit(&mq->thread_complete, 0);
+	return 0;
+}
+
+/*
+ * Generic MMC request handler.  This is called for any queue on a
+ * particular host.  When the host is not busy, we look for a request
+ * on any queue on this host, and attempt to issue it.  This may
+ * not be the queue we were asked to process.
+ */
+static void mmc_request(request_queue_t *q)
+{
+	struct mmc_queue *mq = q->queuedata;
+
+	if (!mq->req && !blk_queue_plugged(q))
+		wake_up(&mq->thread_wq);
+}
+
+/**
+ * mmc_init_queue - initialise a queue structure.
+ * @mq: mmc queue
+ * @card: mmc card to attach this queue
+ * @lock: queue lock
+ *
+ * Initialise a MMC card request queue.
+ */
+int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card, spinlock_t *lock)
+{
+	u64 limit = BLK_BOUNCE_HIGH;
+	int ret;
+
+	if (card->host->dev->dma_mask)
+		limit = *card->host->dev->dma_mask;
+
+	mq->card = card;
+	mq->queue = blk_init_queue(mmc_request, lock);
+	if (!mq->queue)
+		return -ENOMEM;
+
+	blk_queue_prep_rq(mq->queue, mmc_prep_request);
+	blk_queue_bounce_limit(mq->queue, limit);
+
+	mq->queue->queuedata = mq;
+	mq->req = NULL;
+
+	init_completion(&mq->thread_complete);
+	init_waitqueue_head(&mq->thread_wq);
+
+	ret = kernel_thread(mmc_queue_thread, mq, CLONE_KERNEL);
+	if (ret < 0) {
+		blk_cleanup_queue(mq->queue);
+	} else {
+		wait_for_completion(&mq->thread_complete);
+		init_completion(&mq->thread_complete);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(mmc_init_queue);
+
+void mmc_cleanup_queue(struct mmc_queue *mq)
+{
+	mq->thread = NULL;
+	wake_up(&mq->thread_wq);
+	wait_for_completion(&mq->thread_complete);
+	blk_cleanup_queue(mq->queue);
+
+	mq->card = NULL;
+}
+
+EXPORT_SYMBOL(mmc_cleanup_queue);
+/*
+ *  linux/drivers/mmc/mmc_queue.c
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/module.h>
+#include <linux/blkdev.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include "mmc_queue.h"
+
+/*
+ * Prepare a MMC request.  Essentially, this means passing the
+ * preparation off to the media driver.  The media driver will
+ * create a mmc_io_request in req->special.
+ */
+static int mmc_prep_request(struct request_queue *q, struct request *req)
+{
+	struct mmc_queue *mq = q->queuedata;
+	int ret = BLKPREP_KILL;
+
+	if (req->flags & REQ_SPECIAL) {
+		/*
+		 * Special commands already have the command
+		 * blocks already setup in req->special.
+		 */
+		BUG_ON(!req->special);
+
+		ret = BLKPREP_OK;
+	} else if (req->flags & (REQ_CMD | REQ_BLOCK_PC)) {
+		/*
+		 * Block I/O requests need translating according
+		 * to the protocol.
+		 */
+		ret = mq->prep_fn(mq, req);
+	} else {
+		/*
+		 * Everything else is invalid.
+		 */
+		blk_dump_rq_flags(req, "MMC bad request");
+	}
+
+	if (ret == BLKPREP_OK)
+		req->flags |= REQ_DONTPREP;
+
+	return ret;
+}
+
+static int mmc_queue_thread(void *d)
+{
+	struct mmc_queue *mq = d;
+	struct request_queue *q = mq->queue;
+	DECLARE_WAITQUEUE(wait, current);
+
+	/*
+	 * Set iothread to ensure that we aren't put to sleep by
+	 * the process freezing.  We handle suspension ourselves.
+	 */
+	current->flags |= PF_MEMALLOC|PF_NOFREEZE;
+
+	daemonize("mmcqd");
+
+	spin_lock_irq(&current->sighand->siglock);
+	sigfillset(&current->blocked);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	mq->thread = current;
+	complete(&mq->thread_complete);
+
+	add_wait_queue(&mq->thread_wq, &wait);
+	do {
+		struct request *req = NULL;
+
+		spin_lock_irq(q->queue_lock);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (!blk_queue_plugged(q))
 			mq->req = req = elv_next_request(q);
Index: drivers/mmc/mmc.h
===================================================================
--- a/drivers/mmc/mmc.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmc.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -14,3 +14,19 @@
 int mmc_register_card(struct mmc_card *card);
 void mmc_remove_card(struct mmc_card *card);
 #endif
+/*
+ *  linux/drivers/mmc/mmc.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _MMC_H
+#define _MMC_H
+/* core-internal functions */
+void mmc_init_card(struct mmc_card *card, struct mmc_host *host);
+int mmc_register_card(struct mmc_card *card);
+void mmc_remove_card(struct mmc_card *card);
+#endif
Index: drivers/mmc/pxamci.c
===================================================================
--- a/drivers/mmc/pxamci.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/pxamci.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -7,6 +7,596 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
+ *  This hardware is really sick.  No way to clear interrupts.  Have
+ *  to turn off the clock whenever we touch the device.  Yuck!
+ *
+ *	1 and 3 byte data transfers not supported
+ *	max block length up to 1023
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+
+#include "pxamci.h"
+
+#ifdef CONFIG_MMC_DEBUG
+#define DBG(x...)	printk(KERN_DEBUG x)
+#else
+#define DBG(x...)	do { } while (0)
+#endif
+
+struct pxamci_host {
+	struct mmc_host		*mmc;
+	spinlock_t		lock;
+	struct resource		*res;
+	void			*base;
+	int			irq;
+	int			dma;
+	unsigned int		clkrt;
+	unsigned int		cmdat;
+	unsigned int		imask;
+	unsigned int		power_mode;
+
+	struct mmc_request	*req;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+
+	dma_addr_t		sg_dma;
+	pxa_dma_desc		*sg_cpu;
+
+	dma_addr_t		dma_buf;
+	unsigned int		dma_size;
+	unsigned int		dma_dir;
+};
+
+/*
+ * The base MMC clock rate
+ */
+#define CLOCKRATE	20000000
+
+static inline unsigned int ns_to_clocks(unsigned int ns)
+{
+	return (ns * (CLOCKRATE / 1000000) + 999) / 1000;
+}
+
+static void pxamci_stop_clock(struct pxamci_host *host)
+{
+	if (readl(host->base + MMC_STAT) & STAT_CLK_EN) {
+		unsigned long flags;
+		unsigned int v;
+
+		writel(STOP_CLOCK, host->base + MMC_STRPCL);
+
+		/*
+		 * Wait for the "clock has stopped" interrupt.
+		 * We need to unmask the interrupt to receive
+		 * the notification.  Sigh.
+		 */
+		spin_lock_irqsave(&host->lock, flags);
+		writel(host->imask & ~CLK_IS_OFF, host->base + MMC_I_MASK);
+		do {
+			v = readl(host->base + MMC_I_REG);
+		} while (!(v & CLK_IS_OFF));
+		writel(host->imask, host->base + MMC_I_MASK);
+		spin_unlock_irqrestore(&host->lock, flags);
+	}
+}
+
+static void pxamci_enable_irq(struct pxamci_host *host, unsigned int mask)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->imask &= ~mask;
+	writel(host->imask, host->base + MMC_I_MASK);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void pxamci_disable_irq(struct pxamci_host *host, unsigned int mask)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->imask |= mask;
+	writel(host->imask, host->base + MMC_I_MASK);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void pxamci_setup_data(struct pxamci_host *host, struct mmc_data *data)
+{
+	unsigned int nob = data->blocks;
+	unsigned int timeout, size;
+	dma_addr_t dma;
+	u32 dcmd;
+	int i;
+
+	host->data = data;
+
+	if (data->flags & MMC_DATA_STREAM)
+		nob = 0xffff;
+
+	writel(nob, host->base + MMC_NOB);
+	writel(1 << data->blksz_bits, host->base + MMC_BLKLEN);
+
+	timeout = ns_to_clocks(data->timeout_ns) + data->timeout_clks;
+	writel((timeout + 255) / 256, host->base + MMC_RDTO);
+
+	if (data->flags & MMC_DATA_READ) {
+		host->dma_dir = DMA_FROM_DEVICE;
+		dcmd = DCMD_INCTRGADDR | DCMD_FLOWTRG;
+		DRCMRTXMMC = 0;
+		DRCMRRXMMC = host->dma | DRCMR_MAPVLD;
+	} else {
+		host->dma_dir = DMA_TO_DEVICE;
+		dcmd = DCMD_INCSRCADDR | DCMD_FLOWSRC;
+		DRCMRRXMMC = 0;
+		DRCMRTXMMC = host->dma | DRCMR_MAPVLD;
+	}
+
+	dcmd |= DCMD_BURST32 | DCMD_WIDTH1;
+
+	host->dma_size = data->blocks << data->blksz_bits;
+	host->dma_buf = dma_map_single(mmc_dev(host->mmc), data->rq->buffer,
+				       host->dma_size, host->dma_dir);
+
+	for (i = 0, size = host->dma_size, dma = host->dma_buf; size; i++) {
+		u32 len = size;
+
+		if (len > DCMD_LENGTH)
+			len = 0x1000;
+
+		if (data->flags & MMC_DATA_READ) {
+			host->sg_cpu[i].dsadr = host->res->start + MMC_RXFIFO;
+			host->sg_cpu[i].dtadr = dma;
+		} else {
+			host->sg_cpu[i].dsadr = dma;
+			host->sg_cpu[i].dtadr = host->res->start + MMC_TXFIFO;
+		}
+		host->sg_cpu[i].dcmd = dcmd | len;
+
+		dma += len;
+		size -= len;
+
+		if (size) {
+			host->sg_cpu[i].ddadr = host->sg_dma + (i + 1) *
+						 sizeof(pxa_dma_desc);
+		} else {
+			host->sg_cpu[i].ddadr = DDADR_STOP;
+		}
+	}
+	wmb();
+
+	DDADR(host->dma) = host->sg_dma;
+	DCSR(host->dma) = DCSR_RUN;
+}
+
+static void pxamci_start_cmd(struct pxamci_host *host, struct mmc_command *cmd, unsigned int cmdat)
+{
+	WARN_ON(host->cmd != NULL);
+	host->cmd = cmd;
+
+	if (cmd->flags & MMC_RSP_BUSY)
+		cmdat |= CMDAT_BUSY;
+
+	switch (cmd->flags & (MMC_RSP_MASK | MMC_RSP_CRC)) {
+	case MMC_RSP_SHORT | MMC_RSP_CRC:
+		cmdat |= CMDAT_RESP_SHORT;
+		break;
+	case MMC_RSP_SHORT:
+		cmdat |= CMDAT_RESP_R3;
+		break;
+	case MMC_RSP_LONG | MMC_RSP_CRC:
+		cmdat |= CMDAT_RESP_R2;
+		break;
+	default:
+		break;
+	}
+
+	writel(cmd->opcode, host->base + MMC_CMD);
+	writel(cmd->arg >> 16, host->base + MMC_ARGH);
+	writel(cmd->arg & 0xffff, host->base + MMC_ARGL);
+	writel(cmdat, host->base + MMC_CMDAT);
+	writel(host->clkrt, host->base + MMC_CLKRT);
+
+	writel(START_CLOCK, host->base + MMC_STRPCL);
+
+	pxamci_enable_irq(host, END_CMD_RES);
+}
+
+static void pxamci_finish_request(struct pxamci_host *host, struct mmc_request *req)
+{
+	DBG("PXAMCI: request done\n");
+	host->req = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+	mmc_request_done(host->mmc, req);
+}
+
+static int pxamci_cmd_done(struct pxamci_host *host, unsigned int stat)
+{
+	struct mmc_command *cmd = host->cmd;
+	int i;
+	u32 v;
+
+	if (!cmd)
+		return 0;
+
+	host->cmd = NULL;
+
+	/*
+	 * Did I mention this is Sick.  We always need to
+	 * discard the upper 8 bits of the first 16-bit word.
+	 */
+	v = readl(host->base + MMC_RES) & 0xffff;
+	for (i = 0; i < 4; i++) {
+		u32 w1 = readl(host->base + MMC_RES) & 0xffff;
+		u32 w2 = readl(host->base + MMC_RES) & 0xffff;
+		cmd->resp[i] = v << 24 | w1 << 8 | w2 >> 8;
+		v = w2;
+	}
+
+	if (stat & STAT_TIME_OUT_RESPONSE) {
+		cmd->error = MMC_ERR_TIMEOUT;
+	} else if (stat & STAT_RES_CRC_ERR && cmd->flags & MMC_RSP_CRC) {
+		cmd->error = MMC_ERR_BADCRC;
+	}
+
+	pxamci_disable_irq(host, END_CMD_RES);
+	if (host->data && cmd->error == MMC_ERR_NONE) {
+		pxamci_enable_irq(host, DATA_TRAN_DONE);
+	} else {
+		pxamci_finish_request(host, host->req);
+	}
+
+	return 1;
+}
+
+static int pxamci_data_done(struct pxamci_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+
+	if (!data)
+		return 0;
+
+	DCSR(host->dma) = 0;
+	dma_unmap_single(mmc_dev(host->mmc), host->dma_buf, host->dma_size,
+			 host->dma_dir);
+
+	if (stat & STAT_READ_TIME_OUT)
+		data->error = MMC_ERR_TIMEOUT;
+	else if (stat & (STAT_CRC_READ_ERROR|STAT_CRC_WRITE_ERROR))
+		data->error = MMC_ERR_BADCRC;
+
+	data->bytes_xfered = (data->blocks - readl(host->base + MMC_NOB))
+			       << data->blksz_bits;
+
+	pxamci_disable_irq(host, DATA_TRAN_DONE);
+
+	host->data = NULL;
+	if (host->req->stop && data->error == MMC_ERR_NONE) {
+		pxamci_stop_clock(host);
+		pxamci_start_cmd(host, host->req->stop, 0);
+	} else {
+		pxamci_finish_request(host, host->req);
+	}
+
+	return 1;
+}
+
+static irqreturn_t pxamci_irq(int irq, void *devid, struct pt_regs *regs)
+{
+	struct pxamci_host *host = devid;
+	unsigned int ireg;
+	int handled = 0;
+
+	ireg = readl(host->base + MMC_I_REG);
+
+	DBG("PXAMCI: irq %08x\n", ireg);
+
+	if (ireg) {
+		unsigned stat = readl(host->base + MMC_STAT);
+
+		DBG("PXAMCI: stat %08x\n", stat);
+
+		if (ireg & END_CMD_RES)
+			handled |= pxamci_cmd_done(host, stat);
+		if (ireg & DATA_TRAN_DONE)
+			handled |= pxamci_data_done(host, stat);
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+static void pxamci_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct pxamci_host *host = mmc_priv(mmc);
+	unsigned int cmdat;
+
+	WARN_ON(host->req != NULL);
+
+	host->req = req;
+
+	pxamci_stop_clock(host);
+
+	cmdat = host->cmdat;
+	host->cmdat &= ~CMDAT_INIT;
+
+	if (req->data) {
+		pxamci_setup_data(host, req->data);
+
+		cmdat &= ~CMDAT_BUSY;
+		cmdat |= CMDAT_DATAEN | CMDAT_DMAEN;
+		if (req->data->flags & MMC_DATA_WRITE)
+			cmdat |= CMDAT_WRITE;
+
+		if (req->data->flags & MMC_DATA_STREAM)
+			cmdat |= CMDAT_STREAM;
+	}
+
+	pxamci_start_cmd(host, req->cmd, cmdat);
+}
+
+static void pxamci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct pxamci_host *host = mmc_priv(mmc);
+
+	DBG("pxamci_set_ios: clock %u power %u vdd %u.%02u\n",
+	    ios->clock, ios->power_mode, ios->vdd / 100,
+	    ios->vdd % 100);
+
+	if (ios->clock) {
+		unsigned int clk = CLOCKRATE / ios->clock;
+		if (CLOCKRATE / clk > ios->clock)
+			clk <<= 1;
+		host->clkrt = fls(clk) - 1;
+
+		/*
+		 * we write clkrt on the next command
+		 */
+	} else if (readl(host->base + MMC_STAT) & STAT_CLK_EN) {
+		/*
+		 * Ensure that the clock is off.
+		 */
+		writel(STOP_CLOCK, host->base + MMC_STRPCL);
+	}
+
+	if (host->power_mode != ios->power_mode) {
+		host->power_mode = ios->power_mode;
+
+		/*
+		 * power control?  none on the lubbock.
+		 */
+
+		if (ios->power_mode == MMC_POWER_ON)
+			host->cmdat |= CMDAT_INIT;
+	}
+
+	DBG("pxamci_set_ios: clkrt = %x cmdat = %x\n",
+	    host->clkrt, host->cmdat);
+}
+
+static struct mmc_host_ops pxamci_ops = {
+	.request	= pxamci_request,
+	.set_ios	= pxamci_set_ios,
+};
+
+static struct resource *platform_device_resource(struct platform_device *dev, unsigned int mask, int nr)
+{
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++)
+		if (dev->resource[i].flags == mask && nr-- == 0)
+			return &dev->resource[i];
+	return NULL;
+}
+
+static int platform_device_irq(struct platform_device *dev, int nr)
+{
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++)
+		if (dev->resource[i].flags == IORESOURCE_IRQ && nr-- == 0)
+			return dev->resource[i].start;
+	return NO_IRQ;
+}
+
+static void pxamci_dma_irq(int dma, void *devid, struct pt_regs *regs)
+{
+	printk(KERN_ERR "DMA%d: IRQ???\n", dma);
+	DCSR(dma) = DCSR_STARTINTR|DCSR_ENDINTR|DCSR_BUSERR;
+}
+
+static int pxamci_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mmc_host *mmc;
+	struct pxamci_host *host = NULL;
+	struct resource *r;
+	int ret, irq;
+
+	r = platform_device_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_device_irq(pdev, 0);
+	if (!r || irq == NO_IRQ)
+		return -ENXIO;
+
+	r = request_mem_region(r->start, SZ_4K, "PXAMCI");
+	if (!r)
+		return -EBUSY;
+
+	mmc = mmc_alloc_host(sizeof(struct pxamci_host), dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mmc->ops = &pxamci_ops;
+	mmc->f_min = 312500;
+	mmc->f_max = 20000000;
+	mmc->ocr_avail = MMC_VDD_32_33;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->dma = -1;
+
+	host->sg_cpu = dma_alloc_coherent(dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
+	if (!host->sg_cpu) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	spin_lock_init(&host->lock);
+	host->res = r;
+	host->irq = irq;
+	host->imask = TXFIFO_WR_REQ|RXFIFO_RD_REQ|CLK_IS_OFF|STOP_CMD|
+		      END_CMD_RES|PRG_DONE|DATA_TRAN_DONE;
+
+	host->base = ioremap(r->start, SZ_4K);
+	if (!host->base) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/*
+	 * Ensure that the host controller is shut down, and setup
+	 * with our defaults.
+	 */
+	pxamci_stop_clock(host);
+	writel(0, host->base + MMC_SPI);
+	writel(64, host->base + MMC_RESTO);
+
+#ifdef CONFIG_PREEMPT
+//#error Not Preempt-safe
+#endif
+	pxa_gpio_mode(GPIO6_MMCCLK_MD);
+	pxa_gpio_mode(GPIO8_MMCCS0_MD);
+	CKEN |= CKEN12_MMC;
+
+	host->dma = pxa_request_dma("PXAMCI", DMA_PRIO_LOW, pxamci_dma_irq, host);
+	if (host->dma < 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = request_irq(host->irq, pxamci_irq, 0, "PXAMCI", host);
+	if (ret)
+		goto out;
+
+	dev_set_drvdata(dev, host);
+
+	mmc_add_host(mmc);
+
+	return 0;
+
+ out:
+	if (host) {
+		if (host->dma >= 0)
+			pxa_free_dma(host->dma);
+		if (host->base)
+			iounmap(host->base);
+		if (host->sg_cpu)
+			dma_free_coherent(dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
+	}
+	if (mmc)
+		mmc_free_host(mmc);
+	release_resource(r);
+	return ret;
+}
+
+static int pxamci_remove(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	if (mmc) {
+		struct pxamci_host *host = mmc_priv(mmc);
+
+		mmc_remove_host(mmc);
+
+		pxamci_stop_clock(host);
+		writel(TXFIFO_WR_REQ|RXFIFO_RD_REQ|CLK_IS_OFF|STOP_CMD|
+		       END_CMD_RES|PRG_DONE|DATA_TRAN_DONE,
+		       host->base + MMC_I_MASK);
+
+		free_irq(host->irq, host);
+		pxa_free_dma(host->dma);
+		iounmap(host->base);
+		dma_free_coherent(dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
+
+		release_resource(host->res);
+
+		mmc_free_host(mmc);
+	}
+	return 0;
+}
+
+static int pxamci_suspend(struct device *dev, u32 state, u32 level)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	int ret = 0;
+
+//	if (mmc && level == SUSPEND_DISABLE)
+//		ret = mmc_suspend_host(mmc, state);
+
+	return ret;
+}
+
+static int pxamci_resume(struct device *dev, u32 level)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	int ret = 0;
+
+//	if (mmc && level == RESUME_ENABLE)
+//		ret = mmc_resume_host(mmc);
+
+	return ret;
+}
+
+static struct device_driver pxamci_driver = {
+	.name		= "pxamci",
+	.bus		= &platform_bus_type,
+	.probe		= pxamci_probe,
+	.remove		= pxamci_remove,
+	.suspend	= pxamci_suspend,
+	.resume		= pxamci_resume,
+};
+
+static int __init pxamci_init(void)
+{
+	return driver_register(&pxamci_driver);
+}
+
+static void __exit pxamci_exit(void)
+{
+	driver_unregister(&pxamci_driver);
+}
+
+module_init(pxamci_init);
+module_exit(pxamci_exit);
+
+MODULE_DESCRIPTION("PXA Multimedia Card Interface Driver");
+MODULE_LICENSE("GPL");
+/*
+ *  linux/drivers/mmc/pxa.c - PXA MMCI driver
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
  *  This hardware is really sick:
  *   - No way to clear interrupts.
  *   - Have to turn off the clock whenever we touch the device.
Index: drivers/mmc/mmc_sysfs.c
===================================================================
--- a/drivers/mmc/mmc_sysfs.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmc_sysfs.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -239,3 +239,234 @@
 
 module_init(mmc_init);
 module_exit(mmc_exit);
+/*
+ *  linux/drivers/mmc/mmc_sysfs.c
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  MMC sysfs/driver model support.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+
+#include "mmc.h"
+
+#define dev_to_mmc_card(d)	container_of(d, struct mmc_card, dev)
+#define to_mmc_driver(d)	container_of(d, struct mmc_driver, drv)
+
+static void mmc_release_card(struct device *dev)
+{
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	kfree(card);
+}
+
+/*
+ * This currently matches any MMC driver to any MMC card - drivers
+ * themselves make the decision whether to drive this card in their
+ * probe method.
+ */
+static int mmc_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+static int
+mmc_bus_hotplug(struct device *dev, char **envp, int num_envp, char *buf,
+		int buf_size)
+{
+	struct mmc_card *card = dev_to_mmc_card(dev);
+	char ccc[13];
+	int i = 0;
+
+#define add_env(fmt,val)						\
+	({								\
+		int len, ret = -ENOMEM;					\
+		if (i < num_envp) {					\
+			envp[i++] = buf;				\
+			len = snprintf(buf, buf_size, fmt, val) + 1;	\
+			buf_size -= len;				\
+			buf += len;					\
+			if (buf_size >= 0)				\
+				ret = 0;				\
+		}							\
+		ret;							\
+	})
+
+	for (i = 0; i < 12; i++)
+		ccc[i] = card->csd.cmdclass & (1 << i) ? '1' : '0';
+	ccc[12] = '\0';
+
+	i = 0;
+	add_env("MMC_CCC=%s", ccc);
+	add_env("MMC_MANFID=%03x", card->cid.manfid);
+	add_env("MMC_SLOT_NAME=%s", card->dev.bus_id);
+
+	return 0;
+}
+
+static int mmc_bus_suspend(struct device *dev, u32 state)
+{
+	struct mmc_driver *drv = to_mmc_driver(dev->driver);
+	struct mmc_card *card = dev_to_mmc_card(dev);
+	int ret = 0;
+
+	if (dev->driver && drv->suspend)
+		ret = drv->suspend(card, state);
+	return ret;
+}
+
+static int mmc_bus_resume(struct device *dev)
+{
+	struct mmc_driver *drv = to_mmc_driver(dev->driver);
+	struct mmc_card *card = dev_to_mmc_card(dev);
+	int ret = 0;
+
+	if (dev->driver && drv->resume)
+		ret = drv->resume(card);
+	return ret;
+}
+
+static struct bus_type mmc_bus_type = {
+	.name		= "mmc",
+	.match		= mmc_bus_match,
+	.hotplug	= mmc_bus_hotplug,
+	.suspend	= mmc_bus_suspend,
+	.resume		= mmc_bus_resume,
+};
+
+
+static int mmc_drv_probe(struct device *dev)
+{
+	struct mmc_driver *drv = to_mmc_driver(dev->driver);
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	return drv->probe(card);
+}
+
+static int mmc_drv_remove(struct device *dev)
+{
+	struct mmc_driver *drv = to_mmc_driver(dev->driver);
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	drv->remove(card);
+
+	return 0;
+}
+
+
+/**
+ *	mmc_register_driver - register a media driver
+ *	@drv: MMC media driver
+ */
+int mmc_register_driver(struct mmc_driver *drv)
+{
+	drv->drv.bus = &mmc_bus_type;
+	drv->drv.probe = mmc_drv_probe;
+	drv->drv.remove = mmc_drv_remove;
+	return driver_register(&drv->drv);
+}
+
+EXPORT_SYMBOL(mmc_register_driver);
+
+/**
+ *	mmc_unregister_driver - unregister a media driver
+ *	@drv: MMC media driver
+ */
+void mmc_unregister_driver(struct mmc_driver *drv)
+{
+	drv->drv.bus = &mmc_bus_type;
+	driver_unregister(&drv->drv);
+}
+
+EXPORT_SYMBOL(mmc_unregister_driver);
+
+
+#define MMC_ATTR(name, fmt, args...)					\
+static ssize_t mmc_dev_show_##name (struct device *dev, char *buf)	\
+{									\
+	struct mmc_card *card = dev_to_mmc_card(dev);			\
+	return sprintf(buf, fmt, args);					\
+}									\
+static DEVICE_ATTR(name, S_IRUGO, mmc_dev_show_##name, NULL)
+
+MMC_ATTR(date, "%02d/%04d\n", card->cid.month, 1997 + card->cid.year);
+MMC_ATTR(fwrev, "0x%x\n", card->cid.fwrev);
+MMC_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
+MMC_ATTR(manfid, "0x%03x\n", card->cid.manfid);
+MMC_ATTR(serial, "0x%06x\n", card->cid.serial);
+MMC_ATTR(name, "%s\n", card->cid.prod_name);
+
+static struct device_attribute *mmc_dev_attributes[] = {
+	&dev_attr_date,
+	&dev_attr_fwrev,
+	&dev_attr_hwrev,
+	&dev_attr_manfid,
+	&dev_attr_serial,
+	&dev_attr_name,
+};
+
+/*
+ * Internal function.  Initialise a MMC card structure.
+ */
+void mmc_init_card(struct mmc_card *card, struct mmc_host *host)
+{
+	memset(card, 0, sizeof(struct mmc_card));
+	card->host = host;
+	device_initialize(&card->dev);
+	card->dev.parent = card->host->dev;
+	card->dev.bus = &mmc_bus_type;
+	card->dev.release = mmc_release_card;
+}
+
+/*
+ * Internal function.  Register a new MMC card with the driver model.
+ */
+int mmc_register_card(struct mmc_card *card)
+{
+	int ret, i;
+
+	snprintf(card->dev.bus_id, sizeof(card->dev.bus_id),
+		 "%s:%04x", card->host->host_name, card->rca);
+
+	ret = device_add(&card->dev);
+	if (ret == 0)
+		for (i = 0; i < ARRAY_SIZE(mmc_dev_attributes); i++)
+			device_create_file(&card->dev, mmc_dev_attributes[i]);
+
+	return ret;
+}
+
+/*
+ * Internal function.  Unregister a new MMC card with the
+ * driver model, and (eventually) free it.
+ */
+void mmc_remove_card(struct mmc_card *card)
+{
+	if (mmc_card_present(card))
+		device_del(&card->dev);
+
+	put_device(&card->dev);
+}
+
+
+static int __init mmc_init(void)
+{
+	return bus_register(&mmc_bus_type);
+}
+
+static void __exit mmc_exit(void)
+{
+	bus_unregister(&mmc_bus_type);
+}
+
+module_init(mmc_init);
+module_exit(mmc_exit);
Index: drivers/mmc/mmc_queue.h
===================================================================
--- a/drivers/mmc/mmc_queue.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmc_queue.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -31,3 +31,32 @@
 extern void mmc_queue_resume(struct mmc_queue *);
 
 #endif
+#ifndef MMC_QUEUE_H
+#define MMC_QUEUE_H
+
+struct request;
+struct task_struct;
+
+struct mmc_queue {
+	struct mmc_card		*card;
+	struct completion	thread_complete;
+	wait_queue_head_t	thread_wq;
+	struct task_struct	*thread;
+	struct request		*req;
+	int			(*prep_fn)(struct mmc_queue *, struct request *);
+	int			(*issue_fn)(struct mmc_queue *, struct request *);
+	void			*data;
+	struct request_queue	*queue;
+};
+
+struct mmc_io_request {
+	struct request		*rq;
+	int			num;
+	struct mmc_command	selcmd;		/* mmc_queue private */
+	struct mmc_command	cmd[4];		/* max 4 commands */
+};
+
+extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *);
+extern void mmc_cleanup_queue(struct mmc_queue *);
+
+#endif
Index: drivers/mmc/mmci.c
===================================================================
--- a/drivers/mmc/mmci.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmci.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -15,6 +15,529 @@
 #include <linux/device.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware/amba.h>
+#include <asm/mach/mmc.h>
+
+#include "mmci.h"
+
+#define DRIVER_NAME "mmci-pl18x"
+
+#ifdef CONFIG_MMC_DEBUG
+#define DBG(x...)	pr_debug(x)
+#else
+#define DBG(x...)	do { } while (0)
+#endif
+
+static unsigned int fmax = 515633;
+
+static void
+mmci_request_end(struct mmci_host *host, struct mmc_request *req)
+{
+	writel(0, host->base + MMCICOMMAND);
+	host->req = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+	host->buffer = NULL;
+
+	if (req->data)
+		req->data->bytes_xfered = host->data_xfered;
+
+	/*
+	 * Need to drop the host lock here; mmc_request_done may call
+	 * back into the driver...
+	 */
+	spin_unlock(&host->lock);
+	mmc_request_done(host->mmc, req);
+	spin_lock(&host->lock);
+}
+
+static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
+{
+	unsigned int datactrl;
+
+	DBG("%s: data: blksz %04x blks %04x flags %08x\n",
+	    host->mmc->host_name, 1 << data->blksz_bits, data->blocks,
+	    data->flags);
+
+	datactrl = MCI_DPSM_ENABLE | data->blksz_bits << 4;
+
+	if (data->flags & MMC_DATA_READ)
+		datactrl |= MCI_DPSM_DIRECTION;
+
+	host->data = data;
+	host->buffer = data->rq->buffer;
+	host->size = data->blocks << data->blksz_bits;
+	host->data_xfered = 0;
+
+	writel(0x800000, host->base + MMCIDATATIMER);
+	writel(host->size, host->base + MMCIDATALENGTH);
+	writel(datactrl, host->base + MMCIDATACTRL);
+}
+
+static void
+mmci_start_command(struct mmci_host *host, struct mmc_command *cmd, u32 c)
+{
+	DBG("%s: cmd: op %02x arg %08x flags %08x\n",
+	    host->mmc->host_name, cmd->opcode, cmd->arg, cmd->flags);
+
+	if (readl(host->base + MMCICOMMAND) & MCI_CPSM_ENABLE) {
+		writel(0, host->base + MMCICOMMAND);
+		udelay(1);
+	}
+
+	c |= cmd->opcode | MCI_CPSM_ENABLE;
+	switch (cmd->flags & MMC_RSP_MASK) {
+	case MMC_RSP_NONE:
+	default:
+		break;
+	case MMC_RSP_LONG:
+		c |= MCI_CPSM_LONGRSP;
+	case MMC_RSP_SHORT:
+		c |= MCI_CPSM_RESPONSE;
+		break;
+	}
+	if (/*interrupt*/0)
+		c |= MCI_CPSM_INTERRUPT;
+
+	host->cmd = cmd;
+
+	writel(cmd->arg, host->base + MMCIARGUMENT);
+	writel(c, host->base + MMCICOMMAND);
+}
+
+static void
+mmci_data_irq(struct mmci_host *host, struct mmc_data *data,
+	      unsigned int status)
+{
+	if (status & MCI_DATABLOCKEND) {
+		host->data_xfered += 1 << data->blksz_bits;
+	}
+	if (status & (MCI_DATACRCFAIL|MCI_DATATIMEOUT|MCI_TXUNDERRUN|MCI_RXOVERRUN)) {
+		if (status & MCI_DATACRCFAIL)
+			data->error = MMC_ERR_BADCRC;
+		else if (status & MCI_DATATIMEOUT)
+			data->error = MMC_ERR_TIMEOUT;
+		else if (status & (MCI_TXUNDERRUN|MCI_RXOVERRUN))
+			data->error = MMC_ERR_FIFO;
+		status |= MCI_DATAEND;
+	}
+	if (status & MCI_DATAEND) {
+		host->data = NULL;
+		if (!data->stop) {
+			mmci_request_end(host, data->req);
+		} else /*if (readl(host->base + MMCIDATACNT) > 6)*/ {
+			mmci_start_command(host, data->stop, 0);
+		}
+	}
+}
+
+static void
+mmci_cmd_irq(struct mmci_host *host, struct mmc_command *cmd,
+	     unsigned int status)
+{
+	host->cmd = NULL;
+
+	cmd->resp[0] = readl(host->base + MMCIRESPONSE0);
+	cmd->resp[1] = readl(host->base + MMCIRESPONSE1);
+	cmd->resp[2] = readl(host->base + MMCIRESPONSE2);
+	cmd->resp[3] = readl(host->base + MMCIRESPONSE3);
+
+	if (status & MCI_CMDTIMEOUT) {
+		cmd->error = MMC_ERR_TIMEOUT;
+	} else if (status & MCI_CMDCRCFAIL && cmd->flags & MMC_RSP_CRC) {
+		cmd->error = MMC_ERR_BADCRC;
+	}
+
+	if (!cmd->data || cmd->error != MMC_ERR_NONE) {
+		mmci_request_end(host, cmd->req);
+	} else if (!(cmd->data->flags & MMC_DATA_READ)) {
+		mmci_start_data(host, cmd->data);
+	}
+}
+
+static irqreturn_t mmci_pio_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct mmci_host *host = dev_id;
+	u32 status;
+	int ret = 0;
+
+	do {
+		status = readl(host->base + MMCISTATUS);
+
+		if (!(status & (MCI_RXDATAAVLBL|MCI_RXFIFOHALFFULL|
+				MCI_TXFIFOEMPTY|MCI_TXFIFOHALFEMPTY)))
+			break;
+
+		DBG("%s: irq1 %08x\n", host->mmc->host_name, status);
+
+		if (status & (MCI_RXDATAAVLBL|MCI_RXFIFOHALFFULL)) {
+			int count = host->size - (readl(host->base + MMCIFIFOCNT) << 2);
+			if (count < 0)
+				count = 0;
+			if (count && host->buffer) {
+				readsl(host->base + MMCIFIFO, host->buffer, count >> 2);
+				host->buffer += count;
+				host->size -= count;
+				if (host->size == 0)
+					host->buffer = NULL;
+			} else {
+				static int first = 1;
+				if (first) {
+					first = 0;
+					printk(KERN_ERR "MMCI: sinking excessive data\n");
+				}
+				readl(host->base + MMCIFIFO);
+			}
+		}
+		if (status & (MCI_TXFIFOEMPTY|MCI_TXFIFOHALFEMPTY)) {
+			int count = host->size;
+			if (count > MCI_FIFOHALFSIZE)
+				count = MCI_FIFOHALFSIZE;
+			if (count && host->buffer) {
+				writesl(host->base + MMCIFIFO, host->buffer, count >> 2);
+				host->buffer += count;
+				host->size -= count;
+				if (host->size == 0)
+					host->buffer = NULL;
+			} else {
+				static int first = 1;
+				if (first) {
+					first = 0;
+					printk(KERN_ERR "MMCI: ran out of source data\n");
+				}
+			}
+		}
+		ret = 1;
+	} while (status);
+
+	return IRQ_RETVAL(ret);
+}
+
+static irqreturn_t mmci_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct mmci_host *host = dev_id;
+	u32 status;
+	int ret = 0;
+
+	spin_lock(&host->lock);
+
+	do {
+		struct mmc_command *cmd;
+		struct mmc_data *data;
+
+		status = readl(host->base + MMCISTATUS);
+		writel(status, host->base + MMCICLEAR);
+
+		if (!(status & MCI_IRQMASK))
+			break;
+
+		DBG("%s: irq0 %08x\n", host->mmc->host_name, status);
+
+		data = host->data;
+		if (status & (MCI_DATACRCFAIL|MCI_DATATIMEOUT|MCI_TXUNDERRUN|
+			      MCI_RXOVERRUN|MCI_DATAEND|MCI_DATABLOCKEND))
+			mmci_data_irq(host, data, status);
+
+		cmd = host->cmd;
+		if (status & (MCI_CMDCRCFAIL|MCI_CMDTIMEOUT|MCI_CMDSENT|MCI_CMDRESPEND) && cmd)
+			mmci_cmd_irq(host, cmd, status);
+
+		ret = 1;
+	} while (status);
+
+	spin_unlock(&host->lock);
+
+	return IRQ_RETVAL(ret);
+}
+
+static void mmci_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct mmci_host *host = mmc_priv(mmc);
+
+	WARN_ON(host->req != NULL);
+
+	spin_lock_irq(&host->lock);
+
+	host->req = req;
+
+	if (req->data && req->data->flags & MMC_DATA_READ)
+		mmci_start_data(host, req->data);
+
+	mmci_start_command(host, req->cmd, 0);
+
+	spin_unlock_irq(&host->lock);
+}
+
+static void mmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mmci_host *host = mmc_priv(mmc);
+	u32 clk = 0, pwr = 0;
+
+	DBG("%s: set_ios: clock %dHz busmode %d powermode %d Vdd %d.%02d\n",
+	    mmc->host_name, ios->clock, ios->bus_mode, ios->power_mode,
+	    ios->vdd / 100, ios->vdd % 100);
+
+	if (ios->clock) {
+		clk = host->mclk / (2 * ios->clock) - 1;
+		if (clk > 256)
+			clk = 255;
+		clk |= MCI_CLK_ENABLE;
+	}
+
+	if (host->plat->translate_vdd)
+		pwr |= host->plat->translate_vdd(mmc_dev(mmc), ios->vdd);
+
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		break;
+	case MMC_POWER_UP:
+		pwr |= MCI_PWR_UP;
+		break;
+	case MMC_POWER_ON:
+		pwr |= MCI_PWR_ON;
+		break;
+	}
+
+	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)
+		pwr |= MCI_ROD;
+
+	writel(clk, host->base + MMCICLOCK);
+
+	if (host->pwr != pwr) {
+		host->pwr = pwr;
+		writel(pwr, host->base + MMCIPOWER);
+	}
+}
+
+static struct mmc_host_ops mmci_ops = {
+	.request	= mmci_request,
+	.set_ios	= mmci_set_ios,
+};
+
+static void mmci_check_status(unsigned long data)
+{
+	struct mmci_host *host = (struct mmci_host *)data;
+	unsigned int status;
+
+	status = host->plat->status(mmc_dev(host->mmc));
+	if (status ^ host->oldstat)
+		mmc_detect_change(host->mmc);
+
+	host->oldstat = status;
+	mod_timer(&host->timer, jiffies + HZ);
+}
+
+static int mmci_probe(struct amba_device *dev, void *id)
+{
+	struct mmc_platform_data *plat = dev->dev.platform_data;
+	struct mmci_host *host = NULL;
+	struct mmc_host *mmc;
+	int ret;
+
+	/* must have platform data */
+	if (!plat)
+		return -EINVAL;
+
+	ret = amba_request_regions(dev, DRIVER_NAME);
+	if (ret)
+		return ret;
+
+	mmc = mmc_alloc_host(sizeof(struct mmci_host), &dev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mmc->ops = &mmci_ops;
+	mmc->f_min = (plat->mclk + 511) / 512;
+	mmc->f_max = max(plat->mclk / 2, fmax);
+	mmc->ocr_avail = plat->ocr_mask;
+
+	host = mmc_priv(mmc);
+	host->plat = plat;
+	host->mclk = plat->mclk;
+	host->mmc = mmc;
+	host->base = ioremap(dev->res.start, SZ_4K);
+	if (!host->base) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	spin_lock_init(&host->lock);
+
+	writel(0, host->base + MMCIMASK0);
+	writel(0, host->base + MMCIMASK1);
+	writel(0xfff, host->base + MMCICLEAR);
+
+	ret = request_irq(dev->irq[0], mmci_irq, SA_SHIRQ, DRIVER_NAME " (cmd)", host);
+	if (ret)
+		goto out;
+
+	ret = request_irq(dev->irq[1], mmci_pio_irq, SA_SHIRQ, DRIVER_NAME " (pio)", host);
+	if (ret) {
+		free_irq(dev->irq[0], host);
+		goto out;
+	}
+
+	writel(MCI_IRQENABLE, host->base + MMCIMASK0);
+	writel(MCI_TXFIFOHALFEMPTYMASK|MCI_RXFIFOHALFFULLMASK, host->base + MMCIMASK1);
+
+	amba_set_drvdata(dev, mmc);
+
+	mmc_add_host(mmc);
+
+	printk(KERN_INFO "%s: MMCI rev %x cfg %02x at 0x%08lx irq %d,%d\n",
+		mmc->host_name, amba_rev(dev), amba_config(dev),
+		dev->res.start, dev->irq[0], dev->irq[1]);
+
+	init_timer(&host->timer);
+	host->timer.data = (unsigned long)host;
+	host->timer.function = mmci_check_status;
+	host->timer.expires = jiffies + HZ;
+	add_timer(&host->timer);
+
+	return 0;
+
+ out:
+	if (host && host->base)
+		iounmap(host->base);
+	if (mmc)
+		mmc_free_host(mmc);
+	amba_release_regions(dev);
+	return ret;
+}
+
+static int mmci_remove(struct amba_device *dev)
+{
+	struct mmc_host *mmc = amba_get_drvdata(dev);
+
+	amba_set_drvdata(dev, NULL);
+
+	if (mmc) {
+		struct mmci_host *host = mmc_priv(mmc);
+
+		del_timer_sync(&host->timer);
+
+		mmc_remove_host(mmc);
+
+		writel(0, host->base + MMCIMASK0);
+		writel(0, host->base + MMCIMASK1);
+
+		writel(0, host->base + MMCICOMMAND);
+		writel(0, host->base + MMCIDATACTRL);
+
+		free_irq(dev->irq[0], host);
+		free_irq(dev->irq[1], host);
+
+		iounmap(host->base);
+
+		mmc_free_host(mmc);
+
+		amba_release_regions(dev);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mmci_suspend(struct amba_device *dev, u32 state)
+{
+	struct mmc_host *mmc = amba_get_drvdata(dev);
+	int ret = 0;
+
+	if (mmc) {
+		struct mmci_host *host = mmc_priv(mmc);
+
+		ret = mmc_suspend_host(mmc, state);
+		if (ret == 0)
+			writel(0, host->base + MMCIMASK0);
+	}
+
+	return ret;
+}
+
+static int mmci_resume(struct amba_device *dev)
+{
+	struct mmc_host *mmc = amba_get_drvdata(dev);
+	int ret = 0;
+
+	if (mmc) {
+		struct mmci_host *host = mmc_priv(mmc);
+
+		writel(MCI_IRQENABLE, host->base + MMCIMASK0);
+
+		ret = mmc_resume_host(mmc);
+	}
+
+	return ret;
+}
+#else
+#define mmci_suspend	NULL
+#define mmci_resume	NULL
+#endif
+
+static struct amba_id mmci_ids[] = {
+	{
+		.id	= 0x00041180,
+		.mask	= 0x000fffff,
+	},
+	{
+		.id	= 0x00041181,
+		.mask	= 0x000fffff,
+	},
+	{ 0, 0 },
+};
+
+static struct amba_driver mmci_driver = {
+	.drv		= {
+		.name	= DRIVER_NAME,
+	},
+	.probe		= mmci_probe,
+	.remove		= mmci_remove,
+	.suspend	= mmci_suspend,
+	.resume		= mmci_resume,
+	.id_table	= mmci_ids,
+};
+
+static int __init mmci_init(void)
+{
+	return amba_driver_register(&mmci_driver);
+}
+
+static void __exit mmci_exit(void)
+{
+	amba_driver_unregister(&mmci_driver);
+}
+
+module_init(mmci_init);
+module_exit(mmci_exit);
+module_param(fmax, uint, 0444);
+
+MODULE_DESCRIPTION("ARM PrimeCell PL180/181 Multimedia Card Interface driver");
+MODULE_LICENSE("GPL");
+/*
+ *  linux/drivers/mmc/mmci.c - ARM PrimeCell MMCI PL180/1 driver
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/highmem.h>
 #include <linux/mmc/host.h>
Index: drivers/mmc/pxamci.h
===================================================================
--- a/drivers/mmc/pxamci.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/pxamci.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -122,3 +122,101 @@
 
 #define CLOCKRATE	CLOCKRATE_MAX
 
+/* RSC: fixme: ported from 2.6.9-rc2-pxa5 */
+
+#undef MMC_STRPCL
+#undef MMC_STAT
+#undef MMC_CLKRT
+#undef MMC_SPI
+#undef MMC_CMDAT
+#undef MMC_RESTO
+#undef MMC_RDTO
+#undef MMC_BLKLEN
+#undef MMC_NOB
+#undef MMC_PRTBUF
+#undef MMC_I_MASK
+#undef END_CMD_RES
+#undef PRG_DONE
+#undef DATA_TRAN_DONE
+#undef MMC_I_REG
+#undef MMC_CMD
+#undef MMC_ARGH
+#undef MMC_ARGL
+#undef MMC_RES
+#undef MMC_RXFIFO
+#undef MMC_TXFIFO
+
+#define MMC_STRPCL	0x0000
+#define STOP_CLOCK		(1 << 0)
+#define START_CLOCK		(2 << 0)
+
+#define MMC_STAT	0x0004
+#define STAT_END_CMD_RES		(1 << 13)
+#define STAT_PRG_DONE			(1 << 12)
+#define STAT_DATA_TRAN_DONE		(1 << 11)
+#define STAT_CLK_EN			(1 << 8)
+#define STAT_RECV_FIFO_FULL		(1 << 7)
+#define STAT_XMIT_FIFO_EMPTY		(1 << 6)
+#define STAT_RES_CRC_ERR		(1 << 5)
+#define STAT_SPI_READ_ERROR_TOKEN	(1 << 4)
+#define STAT_CRC_READ_ERROR		(1 << 3)
+#define STAT_CRC_WRITE_ERROR		(1 << 2)
+#define STAT_TIME_OUT_RESPONSE		(1 << 1)
+#define STAT_READ_TIME_OUT		(1 << 0)
+
+#define MMC_CLKRT	0x0008		/* 3 bit */
+
+#define MMC_SPI		0x000c
+#define SPI_CS_ADDRESS		(1 << 3)
+#define SPI_CS_EN		(1 << 2)
+#define CRC_ON			(1 << 1)
+#define SPI_EN			(1 << 0)
+
+#define MMC_CMDAT	0x0010
+#define CMDAT_DMAEN		(1 << 7)
+#define CMDAT_INIT		(1 << 6)
+#define CMDAT_BUSY		(1 << 5)
+#define CMDAT_STREAM		(1 << 4)	/* 1 = stream */
+#define CMDAT_WRITE		(1 << 3)	/* 1 = write */
+#define CMDAT_DATAEN		(1 << 2)
+#define CMDAT_RESP_NONE		(0 << 0)
+#define CMDAT_RESP_SHORT	(1 << 0)
+#define CMDAT_RESP_R2		(2 << 0)
+#define CMDAT_RESP_R3		(3 << 0)
+
+#define MMC_RESTO	0x0014	/* 7 bit */
+
+#define MMC_RDTO	0x0018	/* 16 bit */
+
+#define MMC_BLKLEN	0x001c	/* 10 bit */
+
+#define MMC_NOB		0x0020	/* 16 bit */
+
+#define MMC_PRTBUF	0x0024
+#define BUF_PART_FULL		(1 << 0)
+
+#define MMC_I_MASK	0x0028
+#define TXFIFO_WR_REQ		(1 << 6)
+#define RXFIFO_RD_REQ		(1 << 5)
+#define CLK_IS_OFF		(1 << 4)
+#define STOP_CMD		(1 << 3)
+#define END_CMD_RES		(1 << 2)
+#define PRG_DONE		(1 << 1)
+#define DATA_TRAN_DONE		(1 << 0)
+
+#define MMC_I_REG	0x002c
+/* same as MMC_I_MASK */
+
+#define MMC_CMD		0x0030
+
+#define MMC_ARGH	0x0034	/* 16 bit */
+
+#define MMC_ARGL	0x0038	/* 16 bit */
+
+#define MMC_RES		0x003c	/* 16 bit */
+
+#define MMC_RXFIFO	0x0040	/* 8 bit */
+
+#define MMC_TXFIFO	0x0044	/* 8 bit */
+
+/* end of port from 2.6.9-rc2-pxa5 */
Index: drivers/mmc/mmc_block.c
===================================================================
--- a/drivers/mmc/mmc_block.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmc_block.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -43,6 +43,7 @@
 #define MMC_SHIFT	3
 
 static int major;
+static int maxsectors = 8;
 
 /*
  * There is one mmc_blk_data per slot.
@@ -54,6 +55,7 @@
 
 	unsigned int	usage;
 	unsigned int	block_bits;
+	unsigned int	suspended;
 };
 
 static DECLARE_MUTEX(open_lock);
@@ -123,6 +125,502 @@
 		geo.sectors	= 16;
 		geo.start	= get_start_sect(bdev);
 
+		return copy_to_user((void *)arg, &geo, sizeof(geo))
+			? -EFAULT : 0;
+	}
+
+	return -ENOTTY;
+}
+
+static struct block_device_operations mmc_bdops = {
+	.open			= mmc_blk_open,
+	.release		= mmc_blk_release,
+	.ioctl			= mmc_blk_ioctl,
+	.owner			= THIS_MODULE,
+};
+
+struct mmc_blk_request {
+	struct mmc_request	req;
+	struct mmc_command	cmd;
+	struct mmc_command	stop;
+	struct mmc_data		data;
+};
+
+static int mmc_blk_prep_rq(struct mmc_queue *mq, struct request *req)
+{
+	struct mmc_blk_data *md = mq->data;
+
+	/*
+	 * If we have no device, we haven't finished initialising.
+	 */
+	if (!md || !mq->card) {
+		printk(KERN_ERR "%s: killing request - no device/host\n",
+		       req->rq_disk->disk_name);
+		goto kill;
+	}
+
+	if (md->suspended) {
+		blk_plug_device(md->queue.queue);
+		goto defer;
+	}
+
+	/*
+	 * Check for excessive requests.
+	 */
+	if (req->sector + req->nr_sectors > get_capacity(req->rq_disk)) {
+		printk(KERN_ERR "%s: bad request size\n",
+		       req->rq_disk->disk_name);
+		goto kill;
+	}
+
+	return BLKPREP_OK;
+
+ defer:
+	return BLKPREP_DEFER;
+ kill:
+	return BLKPREP_KILL;
+}
+
+static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
+{
+	struct mmc_blk_data *md = mq->data;
+	struct mmc_card *card = md->queue.card;
+	int err, sz = 0;
+
+	err = mmc_card_claim_host(card);
+	if (err)
+		goto cmd_err;
+
+	do {
+		struct mmc_blk_request rq;
+		struct mmc_command cmd;
+
+		memset(&rq, 0, sizeof(struct mmc_blk_request));
+		rq.req.cmd = &rq.cmd;
+		rq.req.data = &rq.data;
+
+		rq.cmd.arg = req->sector << 9;
+		rq.cmd.flags = MMC_RSP_SHORT | MMC_RSP_CRC;
+		rq.data.rq = req;
+		rq.data.timeout_ns = card->csd.tacc_ns * 10;
+		rq.data.timeout_clks = card->csd.tacc_clks * 10;
+		rq.data.blksz_bits = md->block_bits;
+		rq.data.blocks = req->current_nr_sectors >> (md->block_bits - 9);
+		rq.stop.opcode = MMC_STOP_TRANSMISSION;
+		rq.stop.arg = 0;
+		rq.stop.flags = MMC_RSP_SHORT | MMC_RSP_CRC | MMC_RSP_BUSY;
+
+		if (rq_data_dir(req) == READ) {
+			rq.cmd.opcode = rq.data.blocks > 1 ? MMC_READ_MULTIPLE_BLOCK : MMC_READ_SINGLE_BLOCK;
+			rq.data.flags |= MMC_DATA_READ;
+		} else {
+			rq.cmd.opcode = MMC_WRITE_BLOCK;
+			rq.cmd.flags |= MMC_RSP_BUSY;
+			rq.data.flags |= MMC_DATA_WRITE;
+			rq.data.blocks = 1;
+		}
+		rq.req.stop = rq.data.blocks > 1 ? &rq.stop : NULL;
+
+		mmc_wait_for_req(card->host, &rq.req);
+		if (rq.cmd.error) {
+			err = rq.cmd.error;
+			printk(KERN_ERR "%s: error %d sending read/write command\n",
+			       req->rq_disk->disk_name, err);
+			goto cmd_err;
+		}
+
+		if (rq_data_dir(req) == READ) {
+			sz = rq.data.bytes_xfered;
+		} else {
+			sz = 0;
+		}
+
+		if (rq.data.error) {
+			err = rq.data.error;
+			printk(KERN_ERR "%s: error %d transferring data\n",
+			       req->rq_disk->disk_name, err);
+			goto cmd_err;
+		}
+
+		if (rq.stop.error) {
+			err = rq.stop.error;
+			printk(KERN_ERR "%s: error %d sending stop command\n",
+			       req->rq_disk->disk_name, err);
+			goto cmd_err;
+		}
+
+		do {
+			cmd.opcode = MMC_SEND_STATUS;
+			cmd.arg = card->rca << 16;
+			cmd.flags = MMC_RSP_SHORT | MMC_RSP_CRC;
+			err = mmc_wait_for_cmd(card->host, &cmd, 5);
+			if (err) {
+				printk(KERN_ERR "%s: error %d requesting status\n",
+				       req->rq_disk->disk_name, err);
+				goto cmd_err;
+			}
+		} while (!(cmd.resp[0] & R1_READY_FOR_DATA));
+
+#if 0
+		if (cmd.resp[0] & ~0x00000900)
+			printk(KERN_ERR "%s: status = %08x\n",
+			       req->rq_disk->disk_name, cmd.resp[0]);
+		err = mmc_decode_status(cmd.resp);
+		if (err)
+			goto cmd_err;
+#endif
+
+		sz = rq.data.bytes_xfered;
+	} while (end_that_request_chunk(req, 1, sz));
+
+	mmc_card_release_host(card);
+
+	return 1;
+
+ cmd_err:
+	mmc_card_release_host(card);
+
+	end_that_request_chunk(req, 1, sz);
+	req->errors = err;
+
+	return 0;
+}
+
+#define MMC_NUM_MINORS	(256 >> MMC_SHIFT)
+
+static unsigned long dev_use[MMC_NUM_MINORS/(8*sizeof(unsigned long))];
+
+static struct mmc_blk_data *mmc_blk_alloc(struct mmc_card *card)
+{
+	struct mmc_blk_data *md;
+	int devidx, ret;
+
+	devidx = find_first_zero_bit(dev_use, MMC_NUM_MINORS);
+	if (devidx >= MMC_NUM_MINORS)
+		return ERR_PTR(-ENOSPC);
+	__set_bit(devidx, dev_use);
+
+	md = kmalloc(sizeof(struct mmc_blk_data), GFP_KERNEL);
+	if (md) {
+		memset(md, 0, sizeof(struct mmc_blk_data));
+
+		md->disk = alloc_disk(1 << MMC_SHIFT);
+		if (md->disk == NULL) {
+			kfree(md);
+			md = ERR_PTR(-ENOMEM);
+			goto out;
+		}
+
+		spin_lock_init(&md->lock);
+		md->usage = 1;
+
+		ret = mmc_init_queue(&md->queue, card, &md->lock);
+		if (ret) {
+			put_disk(md->disk);
+			kfree(md);
+			md = ERR_PTR(ret);
+			goto out;
+		}
+		md->queue.prep_fn = mmc_blk_prep_rq;
+		md->queue.issue_fn = mmc_blk_issue_rq;
+		md->queue.data = md;
+
+		md->disk->major	= mmc_major;
+		md->disk->first_minor = devidx << MMC_SHIFT;
+		md->disk->fops = &mmc_bdops;
+		md->disk->private_data = md;
+		md->disk->queue = md->queue.queue;
+		md->disk->driverfs_dev = &card->dev;
+
+		sprintf(md->disk->disk_name, "mmcblk%d", devidx);
+		sprintf(md->disk->devfs_name, "mmc/blk%d", devidx);
+
+		md->block_bits = md->queue.card->csd.read_blkbits;
+
+		blk_queue_max_sectors(md->queue.queue, maxsectors);
+		blk_queue_hardsect_size(md->queue.queue, 1 << md->block_bits);
+		set_capacity(md->disk, md->queue.card->csd.capacity);
+	}
+ out:
+	return md;
+}
+
+static int
+mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card)
+{
+	struct mmc_command cmd;
+	int err;
+
+	mmc_card_claim_host(card);
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = 1 << card->csd.read_blkbits;
+	cmd.flags = MMC_RSP_SHORT | MMC_RSP_CRC;
+	err = mmc_wait_for_cmd(card->host, &cmd, 5);
+	mmc_card_release_host(card);
+
+	if (err) {
+		printk(KERN_ERR "%s: unable to set block size to %d: %d\n",
+			md->disk->disk_name, cmd.arg, err);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mmc_blk_probe(struct mmc_card *card)
+{
+	struct mmc_blk_data *md;
+	int err;
+
+	if (card->csd.cmdclass & ~0x1ff)
+		return -ENODEV;
+
+	if (card->csd.read_blkbits < 9) {
+		printk(KERN_WARNING "%s: read blocksize too small (%u)\n",
+			mmc_card_id(card), 1 << card->csd.read_blkbits);
+		return -ENODEV;
+	}
+
+	md = mmc_blk_alloc(card);
+	if (IS_ERR(md))
+		return PTR_ERR(md);
+
+	err = mmc_blk_set_blksize(md, card);
+	if (err)
+		goto out;
+
+	printk(KERN_INFO "%s: %s %s %dKiB\n",
+		md->disk->disk_name, mmc_card_id(card), mmc_card_name(card),
+		(card->csd.capacity << card->csd.read_blkbits) / 1024);
+
+	mmc_set_drvdata(card, md);
+	add_disk(md->disk);
+	return 0;
+
+ out:
+	mmc_blk_put(md);
+
+	return err;
+}
+
+static void mmc_blk_remove(struct mmc_card *card)
+{
+	struct mmc_blk_data *md = mmc_get_drvdata(card);
+
+	if (md) {
+		int devidx;
+
+		del_gendisk(md->disk);
+
+		/*
+		 * I think this is needed.
+		 */
+		md->disk->queue = NULL;
+
+		devidx = md->disk->first_minor >> MMC_SHIFT;
+		__clear_bit(devidx, dev_use);
+
+		mmc_blk_put(md);
+	}
+	mmc_set_drvdata(card, NULL);
+}
+
+#ifdef CONFIG_PM
+static int mmc_blk_suspend(struct mmc_card *card, u32 state)
+{
+	struct mmc_blk_data *md = mmc_get_drvdata(card);
+
+	if (md) {
+		blk_stop_queue(md->queue.queue);
+	}
+	return 0;
+}
+
+static int mmc_blk_resume(struct mmc_card *card)
+{
+	struct mmc_blk_data *md = mmc_get_drvdata(card);
+
+	if (md) {
+		mmc_blk_set_blksize(md, md->queue.card);
+		blk_start_queue(md->queue.queue);
+	}
+	return 0;
+}
+#else
+#define	mmc_blk_suspend	NULL
+#define mmc_blk_resume	NULL
+#endif
+
+static struct mmc_driver mmc_driver = {
+	.drv		= {
+		.name	= "mmcblk",
+	},
+	.probe		= mmc_blk_probe,
+	.remove		= mmc_blk_remove,
+	.suspend	= mmc_blk_suspend,
+	.resume		= mmc_blk_resume,
+};
+
+static int __init mmc_blk_init(void)
+{
+	int res = -ENOMEM;
+
+	res = register_blkdev(mmc_major, "mmc");
+	if (res < 0) {
+		printk(KERN_WARNING "Unable to get major %d for MMC media: %d\n",
+		       mmc_major, res);
+		goto out;
+	}
+	if (mmc_major == 0)
+		mmc_major = res;
+
+	devfs_mk_dir("mmc");
+	return mmc_register_driver(&mmc_driver);
+
+ out:
+	return res;
+}
+
+static void __exit mmc_blk_exit(void)
+{
+	mmc_unregister_driver(&mmc_driver);
+	devfs_remove("mmc");
+	unregister_blkdev(mmc_major, "mmc");
+}
+
+module_init(mmc_blk_init);
+module_exit(mmc_blk_exit);
+module_param(maxsectors, int, 0444);
+
+MODULE_PARM_DESC(maxsectors, "Maximum number of sectors for a single request");
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Multimedia Card (MMC) block device driver");
+/*
+ * Block driver for media (i.e., flash cards)
+ *
+ * Copyright 2002 Hewlett-Packard Company
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * HEWLETT-PACKARD COMPANY MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ * Many thanks to Alessandro Rubini and Jonathan Corbet!
+ *
+ * Author:  Andrew Christian
+ *          28 May 2002
+ */
+#include <linux/moduleparam.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/hdreg.h>
+#include <linux/kdev_t.h>
+#include <linux/blkdev.h>
+#include <linux/devfs_fs_kernel.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/protocol.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include "mmc_queue.h"
+
+/*
+ * max 8 partitions per card
+ */
+#define MMC_SHIFT	3
+
+static int mmc_major;
+
+/*
+ * There is one mmc_blk_data per slot.
+ */
+struct mmc_blk_data {
+	spinlock_t	lock;
+	struct gendisk	*disk;
+	struct mmc_queue queue;
+
+	unsigned int	usage;
+	unsigned int	block_bits;
+};
+
+static DECLARE_MUTEX(open_lock);
+
+static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
+{
+	struct mmc_blk_data *md;
+
+	down(&open_lock);
+	md = disk->private_data;
+	if (md && md->usage == 0)
+		md = NULL;
+	if (md)
+		md->usage++;
+	up(&open_lock);
+
+	return md;
+}
+
+static void mmc_blk_put(struct mmc_blk_data *md)
+{
+	down(&open_lock);
+	md->usage--;
+	if (md->usage == 0) {
+		put_disk(md->disk);
+		mmc_cleanup_queue(&md->queue);
+		kfree(md);
+	}
+	up(&open_lock);
+}
+
+static int mmc_blk_open(struct inode *inode, struct file *filp)
+{
+	struct mmc_blk_data *md;
+	int ret = -ENXIO;
+
+	md = mmc_blk_get(inode->i_bdev->bd_disk);
+	if (md) {
+		if (md->usage == 2)
+			check_disk_change(inode->i_bdev);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int mmc_blk_release(struct inode *inode, struct file *filp)
+{
+	struct mmc_blk_data *md = inode->i_bdev->bd_disk->private_data;
+
+	mmc_blk_put(md);
+	return 0;
+}
+
+static int
+mmc_blk_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct block_device *bdev = inode->i_bdev;
+
+	if (cmd == HDIO_GETGEO) {
+		struct hd_geometry geo;
+
+		memset(&geo, 0, sizeof(struct hd_geometry));
+
+		geo.cylinders	= get_capacity(bdev->bd_disk) / (4 * 16);
+		geo.heads	= 4;
+		geo.sectors	= 16;
+		geo.start	= get_start_sect(bdev);
+
 		return copy_to_user((void __user *)arg, &geo, sizeof(geo))
 			? -EFAULT : 0;
 	}
Index: drivers/mmc/mmci.h
===================================================================
--- a/drivers/mmc/mmci.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmci.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -16,6 +16,155 @@
 
 #define MMCICLOCK		0x004
 #define MCI_CLK_ENABLE		(1 << 8)
+#define MCI_PWRSAVE		(1 << 9)
+#define MCI_BYPASS		(1 << 10)
+
+#define MMCIARGUMENT		0x008
+#define MMCICOMMAND		0x00c
+#define MCI_CPSM_RESPONSE	(1 << 6)
+#define MCI_CPSM_LONGRSP	(1 << 7)
+#define MCI_CPSM_INTERRUPT	(1 << 8)
+#define MCI_CPSM_PENDING	(1 << 9)
+#define MCI_CPSM_ENABLE		(1 << 10)
+
+#define MMCIRESPCMD		0x010
+#define MMCIRESPONSE0		0x014
+#define MMCIRESPONSE1		0x018
+#define MMCIRESPONSE2		0x01c
+#define MMCIRESPONSE3		0x020
+#define MMCIDATATIMER		0x024
+#define MMCIDATALENGTH		0x028
+#define MMCIDATACTRL		0x02c
+#define MCI_DPSM_ENABLE		(1 << 0)
+#define MCI_DPSM_DIRECTION	(1 << 1)
+#define MCI_DPSM_MODE		(1 << 2)
+#define MCI_DPSM_DMAENABLE	(1 << 3)
+
+#define MMCIDATACNT		0x030
+#define MMCISTATUS		0x034
+#define MCI_CMDCRCFAIL		(1 << 0)
+#define MCI_DATACRCFAIL		(1 << 1)
+#define MCI_CMDTIMEOUT		(1 << 2)
+#define MCI_DATATIMEOUT		(1 << 3)
+#define MCI_TXUNDERRUN		(1 << 4)
+#define MCI_RXOVERRUN		(1 << 5)
+#define MCI_CMDRESPEND		(1 << 6)
+#define MCI_CMDSENT		(1 << 7)
+#define MCI_DATAEND		(1 << 8)
+#define MCI_DATABLOCKEND	(1 << 10)
+#define MCI_CMDACTIVE		(1 << 11)
+#define MCI_TXACTIVE		(1 << 12)
+#define MCI_RXACTIVE		(1 << 13)
+#define MCI_TXFIFOHALFEMPTY	(1 << 14)
+#define MCI_RXFIFOHALFFULL	(1 << 15)
+#define MCI_TXFIFOFULL		(1 << 16)
+#define MCI_RXFIFOFULL		(1 << 17)
+#define MCI_TXFIFOEMPTY		(1 << 18)
+#define MCI_RXFIFOEMPTY		(1 << 19)
+#define MCI_TXDATAAVLBL		(1 << 20)
+#define MCI_RXDATAAVLBL		(1 << 21)
+
+#define MMCICLEAR		0x038
+#define MCI_CMDCRCFAILCLR	(1 << 0)
+#define MCI_DATACRCFAILCLR	(1 << 1)
+#define MCI_CMDTIMEOUTCLR	(1 << 2)
+#define MCI_DATATIMEOUTCLR	(1 << 3)
+#define MCI_TXUNDERRUNCLR	(1 << 4)
+#define MCI_RXOVERRUNCLR	(1 << 5)
+#define MCI_CMDRESPENDCLR	(1 << 6)
+#define MCI_CMDSENTCLR		(1 << 7)
+#define MCI_DATAENDCLR		(1 << 8)
+#define MCI_DATABLOCKENDCLR	(1 << 10)
+
+#define MMCIMASK0		0x03c
+#define MCI_CMDCRCFAILMASK	(1 << 0)
+#define MCI_DATACRCFAILMASK	(1 << 1)
+#define MCI_CMDTIMEOUTMASK	(1 << 2)
+#define MCI_DATATIMEOUTMASK	(1 << 3)
+#define MCI_TXUNDERRUNMASK	(1 << 4)
+#define MCI_RXOVERRUNMASK	(1 << 5)
+#define MCI_CMDRESPENDMASK	(1 << 6)
+#define MCI_CMDSENTMASK		(1 << 7)
+#define MCI_DATAENDMASK		(1 << 8)
+#define MCI_DATABLOCKENDMASK	(1 << 10)
+#define MCI_CMDACTIVEMASK	(1 << 11)
+#define MCI_TXACTIVEMASK	(1 << 12)
+#define MCI_RXACTIVEMASK	(1 << 13)
+#define MCI_TXFIFOHALFEMPTYMASK	(1 << 14)
+#define MCI_RXFIFOHALFFULLMASK	(1 << 15)
+#define MCI_TXFIFOFULLMASK	(1 << 16)
+#define MCI_RXFIFOFULLMASK	(1 << 17)
+#define MCI_TXFIFOEMPTYMASK	(1 << 18)
+#define MCI_RXFIFOEMPTYMASK	(1 << 19)
+#define MCI_TXDATAAVLBLMASK	(1 << 20)
+#define MCI_RXDATAAVLBLMASK	(1 << 21)
+
+#define MMCIMASK1		0x040
+#define MMCIFIFOCNT		0x048
+#define MMCIFIFO		0x080 /* to 0x0bc */
+
+#define MCI_IRQMASK	\
+	(MCI_CMDCRCFAIL|MCI_DATACRCFAIL|MCI_CMDTIMEOUT|MCI_DATATIMEOUT|	\
+	MCI_TXUNDERRUN|MCI_RXOVERRUN|MCI_CMDRESPEND|MCI_CMDSENT|	\
+	MCI_DATAEND|MCI_DATABLOCKEND)
+
+#define MCI_IRQENABLE	\
+	(MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|	\
+	MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|	\
+	MCI_CMDRESPENDMASK|MCI_CMDSENTMASK|MCI_DATAENDMASK|		\
+	MCI_DATABLOCKENDMASK)
+
+#define MCI_FIFOSIZE	16
+	
+#define MCI_FIFOHALFSIZE (MCI_FIFOSIZE / 2)
+
+struct mmci_host {
+	void			*base;
+	struct mmc_request	*req;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+	struct mmc_host		*mmc;
+
+	unsigned int		data_xfered;
+
+	spinlock_t		lock;
+
+	unsigned int		mclk;
+	u32			pwr;
+	struct mmc_platform_data *plat;
+
+	struct timer_list	timer;
+	unsigned int		oldstat;
+
+	/* pio stuff */
+	void			*buffer;
+	unsigned int		size;
+
+	/* dma stuff */
+//	struct scatterlist	*sg_list;
+//	int			sg_len;
+//	int			sg_dir;
+};
+
+#define to_mmci_host(mmc)	container_of(mmc, struct mmci_host, mmc)
+/*
+ *  linux/drivers/mmc/mmci.h - ARM PrimeCell MMCI PL180/1 driver
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define MMCIPOWER		0x000
+#define MCI_PWR_OFF		0x00
+#define MCI_PWR_UP		0x02
+#define MCI_PWR_ON		0x03
+#define MCI_OD			(1 << 6)
+#define MCI_ROD			(1 << 7)
+
+#define MMCICLOCK		0x004
+#define MCI_CLK_ENABLE		(1 << 8)
 #define MCI_CLK_PWRSAVE		(1 << 9)
 #define MCI_CLK_BYPASS		(1 << 10)
 
Index: drivers/mmc/Makefile
===================================================================
--- a/drivers/mmc/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -20,3 +20,24 @@
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 
 mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
+#
+# Makefile for the kernel mmc device drivers.
+#
+
+#
+# Core
+#
+obj-$(CONFIG_MMC)		+= mmc_core.o
+
+#
+# Media drivers
+#
+obj-$(CONFIG_MMC_BLOCK)		+= mmc_block.o
+
+#
+# Host drivers
+#
+obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
+obj-$(CONFIG_MMC_PXA)		+= pxamci.o
+
+mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
Index: drivers/mmc/mmc.c
===================================================================
--- a/drivers/mmc/mmc.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/mmc/mmc.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -1,6 +1,829 @@
 /*
  *  linux/drivers/mmc/mmc.c
  *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+
+#include "mmc.h"
+
+#ifdef CONFIG_MMC_DEBUG
+#define DBG(x...)	printk(KERN_DEBUG x)
+#else
+#define DBG(x...)	do { } while (0)
+#endif
+
+#define CMD_RETRIES	3
+
+/*
+ * OCR Bit positions to 10s of Vdd mV.
+ */
+static const unsigned short mmc_ocr_bit_to_vdd[] = {
+	150,	155,	160,	165,	170,	180,	190,	200,
+	210,	220,	230,	240,	250,	260,	270,	280,
+	290,	300,	310,	320,	330,	340,	350,	360
+};
+
+static const unsigned int tran_exp[] = {
+	10000,		100000,		1000000,	10000000,
+	0,		0,		0,		0
+};
+
+static const unsigned char tran_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+static const unsigned int tacc_exp[] = {
+	1,	10,	100,	1000,	10000,	100000,	1000000, 10000000,
+};
+
+static const unsigned int tacc_mant[] = {
+	0,	10,	12,	13,	15,	20,	25,	30,
+	35,	40,	45,	50,	55,	60,	70,	80,
+};
+
+
+/**
+ *	mmc_request_done - finish processing an MMC command
+ *	@host: MMC host which completed command
+ *	@cmd: MMC command which completed
+ *	@err: MMC error code
+ *
+ *	MMC drivers should call this function when they have completed
+ *	their processing of a command.  This should be called before the
+ *	data part of the command has completed.
+ */
+void mmc_request_done(struct mmc_host *host, struct mmc_request *req)
+{
+	struct mmc_command *cmd = req->cmd;
+	int err = req->cmd->error;
+	DBG("MMC: req done (%02x): %d: %08x %08x %08x %08x\n", cmd->opcode,
+	    err, cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+
+	if (err && cmd->retries) {
+		cmd->retries--;
+		cmd->error = 0;
+		host->ops->request(host, req);
+	} else if (req->done) {
+		req->done(req);
+	}
+}
+
+EXPORT_SYMBOL(mmc_request_done);
+
+/**
+ *	mmc_start_request - start a command on a host
+ *	@host: MMC host to start command on
+ *	@cmd: MMC command to start
+ *
+ *	Queue a command on the specified host.  We expect the
+ *	caller to be holding the host lock with interrupts disabled.
+ */
+void
+mmc_start_request(struct mmc_host *host, struct mmc_request *req)
+{
+	DBG("MMC: starting cmd %02x arg %08x flags %08x\n",
+	    req->cmd->opcode, req->cmd->arg, req->cmd->flags);
+
+	WARN_ON(host->card_busy == NULL);
+
+	req->cmd->error = 0;
+	req->cmd->req = req;
+	if (req->data) {
+		req->cmd->data = req->data;
+		req->data->error = 0;
+		req->data->req = req;
+		if (req->stop) {
+			req->data->stop = req->stop;
+			req->stop->error = 0;
+			req->stop->req = req;
+		}
+	}
+	host->ops->request(host, req);
+}
+
+EXPORT_SYMBOL(mmc_start_request);
+
+static void mmc_wait_done(struct mmc_request *req)
+{
+	complete(req->done_data);
+}
+
+int mmc_wait_for_req(struct mmc_host *host, struct mmc_request *req)
+{
+	DECLARE_COMPLETION(complete);
+
+	req->done_data = &complete;
+	req->done = mmc_wait_done;
+
+	mmc_start_request(host, req);
+
+	wait_for_completion(&complete);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_wait_for_req);
+
+/**
+ *	mmc_wait_for_cmd - start a command and wait for completion
+ *	@host: MMC host to start command
+ *	@cmd: MMC command to start
+ *	@retries: maximum number of retries
+ *
+ *	Start a new MMC command for a host, and wait for the command
+ *	to complete.  Return any error that occurred while the command
+ *	was executing.  Do not attempt to parse the response.
+ */
+int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
+{
+	struct mmc_request req;
+
+	BUG_ON(host->card_busy == NULL);
+
+	memset(&req, 0, sizeof(struct mmc_request));
+
+	memset(cmd->resp, 0, sizeof(cmd->resp));
+	cmd->retries = retries;
+
+	req.cmd = cmd;
+	cmd->data = NULL;
+
+	mmc_wait_for_req(host, &req);
+
+	return cmd->error;
+}
+
+EXPORT_SYMBOL(mmc_wait_for_cmd);
+
+
+
+/**
+ *	__mmc_claim_host - exclusively claim a host
+ *	@host: mmc host to claim
+ *	@card: mmc card to claim host for
+ *
+ *	Claim a host for a set of operations.  If a valid card
+ *	is passed and this wasn't the last card selected, select
+ *	the card before returning.
+ *
+ *	Note: you should use mmc_card_claim_host or mmc_claim_host.
+ */
+int __mmc_claim_host(struct mmc_host *host, struct mmc_card *card)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long flags;
+	int err = 0;
+
+	add_wait_queue(&host->wq, &wait);
+	spin_lock_irqsave(&host->lock, flags);
+	while (1) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		if (host->card_busy == NULL)
+			break;
+		spin_unlock_irqrestore(&host->lock, flags);
+		schedule();
+		spin_lock_irqsave(&host->lock, flags);
+	}
+	set_current_state(TASK_RUNNING);
+	host->card_busy = card;
+	spin_unlock_irqrestore(&host->lock, flags);
+	remove_wait_queue(&host->wq, &wait);
+
+	if (card != (void *)-1 && host->card_selected != card) {
+		struct mmc_command cmd;
+
+		host->card_selected = card;
+
+		cmd.opcode = MMC_SELECT_CARD;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_SHORT | MMC_RSP_CRC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL(__mmc_claim_host);
+
+/**
+ *	mmc_release_host - release a host
+ *	@host: mmc host to release
+ *
+ *	Release a MMC host, allowing others to claim the host
+ *	for their operations.
+ */
+void mmc_release_host(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	BUG_ON(host->card_busy == NULL);
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->card_busy = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	wake_up(&host->wq);
+}
+
+EXPORT_SYMBOL(mmc_release_host);
+
+/*
+ * Ensure that no card is selected.
+ */
+static void mmc_deselect_cards(struct mmc_host *host)
+{
+	struct mmc_command cmd;
+
+	if (host->card_selected) {
+		host->card_selected = NULL;
+
+		cmd.opcode = MMC_SELECT_CARD;
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_NONE;
+
+		mmc_wait_for_cmd(host, &cmd, 0);
+	}
+}
+
+
+static inline void mmc_delay(unsigned int ms)
+{
+	if (ms < HZ / 1000) {
+		yield();
+		mdelay(ms);
+	} else {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(ms * HZ / 1000);
+	}
+}
+
+/*
+ * Mask off any voltages we don't support and select
+ * the lowest voltage
+ */
+static u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
+{
+	int bit;
+
+	ocr &= host->ocr_avail;
+
+	bit = ffs(ocr);
+	if (bit) {
+		bit -= 1;
+
+		ocr = 3 << bit;
+
+		host->ios.vdd = bit;
+		host->ops->set_ios(host, &host->ios);
+	} else {
+		ocr = 0;
+	}
+
+	return ocr;
+}
+
+static void mmc_decode_cid(struct mmc_cid *cid, u32 *resp)
+{
+	memset(cid, 0, sizeof(struct mmc_cid));
+
+	cid->manfid	  = resp[0] >> 8;
+	cid->prod_name[0] = resp[0];
+	cid->prod_name[1] = resp[1] >> 24;
+	cid->prod_name[2] = resp[1] >> 16;
+	cid->prod_name[3] = resp[1] >> 8;
+	cid->prod_name[4] = resp[1];
+	cid->prod_name[5] = resp[2] >> 24;
+	cid->prod_name[6] = resp[2] >> 16;
+	cid->prod_name[7] = '\0';
+	cid->hwrev	  = (resp[2] >> 12) & 15;
+	cid->fwrev	  = (resp[2] >> 8) & 15;
+	cid->serial	  = (resp[2] & 255) << 16 | (resp[3] >> 16);
+	cid->month	  = (resp[3] >> 12) & 15;
+	cid->year	  = (resp[3] >> 8) & 15;
+}
+
+static void mmc_decode_csd(struct mmc_csd *csd, u32 *resp)
+{
+	unsigned int e, m;
+
+	csd->mmc_prot	 = (resp[0] >> 26) & 15;
+	m = (resp[0] >> 19) & 15;
+	e = (resp[0] >> 16) & 7;
+	csd->tacc_ns	 = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
+	csd->tacc_clks	 = ((resp[0] >> 8) & 255) * 100;
+
+	m = (resp[0] >> 3) & 15;
+	e = resp[0] & 7;
+	csd->max_dtr	  = tran_exp[e] * tran_mant[m];
+	csd->cmdclass	  = (resp[1] >> 20) & 0xfff;
+
+	e = (resp[2] >> 15) & 7;
+	m = (resp[1] << 2 | resp[2] >> 30) & 0x3fff;
+	csd->capacity	  = (1 + m) << (e + 2);
+
+	csd->read_blkbits = (resp[1] >> 16) & 15;
+}
+
+/*
+ * Locate a MMC card on this MMC host given a CID.
+ */
+static struct mmc_card *
+mmc_find_card(struct mmc_host *host, struct mmc_cid *cid)
+{
+	struct mmc_card *card;
+
+	list_for_each_entry(card, &host->cards, node) {
+		if (memcmp(&card->cid, cid, sizeof(struct mmc_cid)) == 0)
+			return card;
+	}
+	return NULL;
+}
+
+/*
+ * Allocate a new MMC card, and assign a unique RCA.
+ */
+static struct mmc_card *
+mmc_alloc_card(struct mmc_host *host, struct mmc_cid *cid, unsigned int *frca)
+{
+	struct mmc_card *card, *c;
+	unsigned int rca = *frca;
+
+	card = kmalloc(sizeof(struct mmc_card), GFP_KERNEL);
+	if (!card)
+		return ERR_PTR(-ENOMEM);
+
+	mmc_init_card(card, host);
+	memcpy(&card->cid, cid, sizeof(struct mmc_cid));
+
+ again:
+	list_for_each_entry(c, &host->cards, node)
+		if (c->rca == rca) {
+			rca++;
+			goto again;
+		}
+
+	card->rca = rca;
+
+	*frca = rca;
+
+	return card;
+}
+
+/*
+ * Apply power to the MMC stack.
+ */
+static void mmc_power_up(struct mmc_host *host)
+{
+	struct mmc_command cmd;
+	int bit = fls(host->ocr_avail) - 1;
+
+	host->ios.vdd = bit;
+	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	host->ios.power_mode = MMC_POWER_UP;
+	host->ops->set_ios(host, &host->ios);
+
+	mmc_delay(1);
+
+	host->ios.clock = host->f_min;
+	host->ios.power_mode = MMC_POWER_ON;
+	host->ops->set_ios(host, &host->ios);
+
+	mmc_delay(2);
+
+	cmd.opcode = MMC_GO_IDLE_STATE;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_NONE;
+
+	mmc_wait_for_cmd(host, &cmd, 0);
+}
+
+static void mmc_power_off(struct mmc_host *host)
+{
+	host->ios.clock = 0;
+	host->ios.vdd = 0;
+	host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	host->ios.power_mode = MMC_POWER_OFF;
+	host->ops->set_ios(host, &host->ios);
+}
+
+static int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
+{
+	struct mmc_command cmd;
+	int i, err = 0;
+
+	cmd.opcode = MMC_SEND_OP_COND;
+	cmd.arg = ocr;
+	cmd.flags = MMC_RSP_SHORT;
+
+	for (i = 100; i; i--) {
+		err = mmc_wait_for_cmd(host, &cmd, 0);
+		if (err != MMC_ERR_NONE)
+			break;
+
+		if (cmd.resp[0] & MMC_CARD_BUSY || ocr == 0)
+			break;
+
+		err = MMC_ERR_TIMEOUT;
+	}
+
+	if (rocr)
+		*rocr = cmd.resp[0];
+
+	return err;
+}
+
+/*
+ * Discover cards by requesting their CID.  If this command
+ * times out, it is not an error; there are no further cards
+ * to be discovered.  Add new cards to the list.
+ *
+ * Create a mmc_card entry for each discovered card, assigning
+ * it an RCA, and save the CID.
+ */
+static void mmc_discover_cards(struct mmc_host *host)
+{
+	struct mmc_card *card;
+	unsigned int first_rca = 1, err;
+
+	while (1) {
+		struct mmc_command cmd;
+		struct mmc_cid cid;
+
+		cmd.opcode = MMC_ALL_SEND_CID;
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_LONG | MMC_RSP_CRC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err == MMC_ERR_TIMEOUT) {
+			err = MMC_ERR_NONE;
+			break;
+		}
+		if (err != MMC_ERR_NONE) {
+			printk(KERN_ERR "%s: error requesting CID: %d\n",
+				host->host_name, err);
+			break;
+		}
+
+		mmc_decode_cid(&cid, cmd.resp);
+
+		card = mmc_find_card(host, &cid);
+		if (!card) {
+			card = mmc_alloc_card(host, &cid, &first_rca);
+			if (IS_ERR(card)) {
+				err = PTR_ERR(card);
+				break;
+			}
+			list_add(&card->node, &host->cards);
+		}
+
+		card->state &= ~MMC_STATE_DEAD;
+
+		cmd.opcode = MMC_SET_RELATIVE_ADDR;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_SHORT | MMC_RSP_CRC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE)
+			card->state |= MMC_STATE_DEAD;
+	}
+}
+
+static void mmc_read_csds(struct mmc_host *host)
+{
+	struct mmc_card *card;
+
+	list_for_each_entry(card, &host->cards, node) {
+		struct mmc_command cmd;
+		int err;
+
+		if (card->state & (MMC_STATE_DEAD|MMC_STATE_PRESENT))
+			continue;
+
+		cmd.opcode = MMC_SEND_CSD;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_LONG | MMC_RSP_CRC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err != MMC_ERR_NONE) {
+			card->state |= MMC_STATE_DEAD;
+			continue;
+		}
+
+		mmc_decode_csd(&card->csd, cmd.resp);
+	}
+}
+
+static unsigned int mmc_calculate_clock(struct mmc_host *host)
+{
+	struct mmc_card *card;
+	unsigned int max_dtr = host->f_max;
+
+	list_for_each_entry(card, &host->cards, node)
+		if (!mmc_card_dead(card) && max_dtr > card->csd.max_dtr)
+			max_dtr = card->csd.max_dtr;
+
+	DBG("MMC: selected %d.%03dMHz transfer rate\n",
+	    max_dtr / 1000000, (max_dtr / 1000) % 1000);
+
+	return max_dtr;
+}
+
+/*
+ * Check whether cards we already know about are still present.
+ * We do this by requesting status, and checking whether a card
+ * responds.
+ *
+ * A request for status does not cause a state change in data
+ * transfer mode.
+ */
+static void mmc_check_cards(struct mmc_host *host)
+{
+	struct list_head *l, *n;
+
+	mmc_deselect_cards(host);
+
+	list_for_each_safe(l, n, &host->cards) {
+		struct mmc_card *card = mmc_list_to_card(l);
+		struct mmc_command cmd;
+		int err;
+
+		cmd.opcode = MMC_SEND_STATUS;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_SHORT | MMC_RSP_CRC;
+
+		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+		if (err == MMC_ERR_NONE)
+			continue;
+
+		card->state |= MMC_STATE_DEAD;
+	}
+}
+
+static void mmc_setup(struct mmc_host *host)
+{
+	if (host->ios.power_mode != MMC_POWER_ON) {
+		int err;
+		u32 ocr;
+
+		mmc_power_up(host);
+
+		err = mmc_send_op_cond(host, 0, &ocr);
+		if (err != MMC_ERR_NONE)
+			return;
+
+		host->ocr = mmc_select_voltage(host, ocr);
+	} else {
+		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+		host->ios.clock = host->f_min;
+		host->ops->set_ios(host, &host->ios);
+
+		/*
+		 * We should remember the OCR mask from the existing
+		 * cards, and detect the new cards OCR mask, combine
+		 * the two and re-select the VDD.  However, if we do
+		 * change VDD, we should do an idle, and then do a
+		 * full re-initialisation.  We would need to notify
+		 * drivers so that they can re-setup the cards as
+		 * well, while keeping their queues at bay.
+		 *
+		 * For the moment, we take the easy way out - if the
+		 * new cards don't like our currently selected VDD,
+		 * they drop off the bus.
+		 */
+	}
+
+	if (host->ocr == 0)
+		return;
+
+	/*
+	 * Send the selected OCR multiple times... until the cards
+	 * all get the idea that they should be ready for CMD2.
+	 * (My SanDisk card seems to need this.)
+	 */
+	mmc_send_op_cond(host, host->ocr, NULL);
+
+	mmc_discover_cards(host);
+
+	/*
+	 * Ok, now switch to push-pull mode.
+	 */
+	host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	host->ops->set_ios(host, &host->ios);
+
+	mmc_read_csds(host);
+}
+
+
+/**
+ *	mmc_detect_change - process change of state on a MMC socket
+ *	@host: host which changed state.
+ *
+ *	All we know is that card(s) have been inserted or removed
+ *	from the socket(s).  We don't know which socket or cards.
+ */
+void mmc_detect_change(struct mmc_host *host)
+{
+	schedule_work(&host->detect);
+}
+
+EXPORT_SYMBOL(mmc_detect_change);
+
+
+static void mmc_rescan(void *data)
+{
+	struct mmc_host *host = data;
+	struct list_head *l, *n;
+
+	mmc_claim_host(host);
+
+	if (host->ios.power_mode == MMC_POWER_ON)
+		mmc_check_cards(host);
+
+	mmc_setup(host);
+
+	if (!list_empty(&host->cards)) {
+		/*
+		 * (Re-)calculate the fastest clock rate which the
+		 * attached cards and the host support.
+		 */
+		host->ios.clock = mmc_calculate_clock(host);
+		host->ops->set_ios(host, &host->ios);
+	}
+
+	mmc_release_host(host);
+
+	list_for_each_safe(l, n, &host->cards) {
+		struct mmc_card *card = mmc_list_to_card(l);
+
+		/*
+		 * If this is a new and good card, register it.
+		 */
+		if (!mmc_card_present(card) && !mmc_card_dead(card)) {
+			if (mmc_register_card(card))
+				card->state |= MMC_STATE_DEAD;
+			else
+				card->state |= MMC_STATE_PRESENT;
+		}
+
+		/*
+		 * If this card is dead, destroy it.
+		 */
+		if (mmc_card_dead(card)) {
+			list_del(&card->node);
+			mmc_remove_card(card);
+		}
+	}
+
+	/*
+	 * If we discover that there are no cards on the
+	 * bus, turn off the clock and power down.
+	 */
+	if (list_empty(&host->cards))
+		mmc_power_off(host);
+}
+
+
+/**
+ *	mmc_alloc_host - initialise the per-host structure.
+ *	@extra: sizeof private data structure
+ *	@dev: pointer to host device model structure
+ *
+ *	Initialise the per-host structure.
+ */
+struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
+{
+	struct mmc_host *host;
+
+	host = kmalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
+	if (host) {
+		memset(host, 0, sizeof(struct mmc_host) + extra);
+
+		host->priv = host + 1;
+
+		spin_lock_init(&host->lock);
+		init_waitqueue_head(&host->wq);
+		INIT_LIST_HEAD(&host->cards);
+		INIT_WORK(&host->detect, mmc_rescan, host);
+
+		host->dev = dev;
+	}
+
+	return host;
+}
+
+EXPORT_SYMBOL(mmc_alloc_host);
+
+/**
+ *	mmc_add_host - initialise host hardware
+ *	@host: mmc host
+ */
+int mmc_add_host(struct mmc_host *host)
+{
+	static unsigned int host_num;
+
+	snprintf(host->host_name, sizeof(host->host_name),
+		 "mmc%d", host_num++);
+
+	mmc_power_off(host);
+	mmc_detect_change(host);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_add_host);
+
+/**
+ *	mmc_remove_host - remove host hardware
+ *	@host: mmc host
+ *
+ *	Unregister and remove all cards associated with this host,
+ *	and power down the MMC bus.
+ */
+void mmc_remove_host(struct mmc_host *host)
+{
+	struct list_head *l, *n;
+
+	list_for_each_safe(l, n, &host->cards) {
+		struct mmc_card *card = mmc_list_to_card(l);
+
+		mmc_remove_card(card);
+	}
+
+	mmc_power_off(host);
+}
+
+EXPORT_SYMBOL(mmc_remove_host);
+
+/**
+ *	mmc_free_host - free the host structure
+ *	@host: mmc host
+ *
+ *	Free the host once all references to it have been dropped.
+ */
+void mmc_free_host(struct mmc_host *host)
+{
+	flush_scheduled_work();
+	kfree(host);
+}
+
+EXPORT_SYMBOL(mmc_free_host);
+
+#ifdef CONFIG_PM
+
+/**
+ *	mmc_suspend_host - suspend a host
+ *	@host: mmc host
+ *	@state: suspend mode (PM_SUSPEND_xxx)
+ */
+int mmc_suspend_host(struct mmc_host *host, u32 state)
+{
+	mmc_claim_host(host);
+	mmc_deselect_cards(host);
+	mmc_power_off(host);
+	mmc_release_host(host);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_suspend_host);
+
+/**
+ *	mmc_resume_host - resume a previously suspended host
+ *	@host: mmc host
+ */
+int mmc_resume_host(struct mmc_host *host)
+{
+	mmc_detect_change(host);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_resume_host);
+
+#endif
+
+MODULE_LICENSE("GPL");
+/*
+ *  linux/drivers/mmc/mmc.c
+ *
  *  Copyright (C) 2003-2004 Russell King, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
Index: drivers/Makefile
===================================================================
--- a/drivers/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -63,3 +63,6 @@
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-y				+= firmware/
 obj-$(CONFIG_CRYPTO)		+= crypto/
+obj-$(CONFIG_FPBUS)		+= fpbus/
+obj-$(CONFIG_MMC)		+= mmc/
+obj-$(CONFIG_CAN)		+= can/
Index: drivers/net/smc91x_old.c
===================================================================
--- a/drivers/net/smc91x_old.c	(revision 0)
+++ b/drivers/net/smc91x_old.c	(revision 675)
@@ -0,0 +1,2322 @@
+/*
+ * smc91x.c
+ * This is a driver for SMSC's 91C9x/91C1xx single-chip Ethernet devices.
+ *
+ * Copyright (C) 1996 by Erik Stahlman
+ * Copyright (C) 2001 Standard Microsystems Corporation
+ *	Developed by Simple Network Magic Corporation
+ * Copyright (C) 2003 Monta Vista Software, Inc.
+ *	Unified SMC91x driver by Nicolas Pitre
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Arguments:
+ * 	io	= for the base address
+ *	irq	= for the IRQ
+ *	nowait	= 0 for normal wait states, 1 eliminates additional wait states
+ *
+ * original author:
+ * 	Erik Stahlman <erik@vt.edu>
+ *
+ * hardware multicast code:
+ *    Peter Cammaert <pc@denkart.be>
+ *
+ * contributors:
+ * 	Daris A Nevil <dnevil@snmc.com>
+ *      Nicolas Pitre <nico@cam.org>
+ *	Russell King <rmk@arm.linux.org.uk>
+ *
+ * History:
+ *   08/20/00  Arnaldo Melo       fix kfree(skb) in smc_hardware_send_packet
+ *   12/15/00  Christian Jullien  fix "Warning: kfree_skb on hard IRQ"
+ *   03/16/01  Daris A Nevil      modified smc9194.c for use with LAN91C111
+ *   08/22/01  Scott Anderson     merge changes from smc9194 to smc91111
+ *   08/21/01  Pramod B Bhardwaj  added support for RevB of LAN91C111
+ *   12/20/01  Jeff Sutherland    initial port to Xscale PXA with DMA support
+ *   04/07/03  Nicolas Pitre      unified SMC91x driver, killed irq races,
+ *                                more bus abstraction, big cleanup, etc.
+ *   29/09/03  Russell King       - add driver model support
+ *                                - ethtool support
+ *                                - convert to use generic MII interface
+ *                                - add link up/down notification
+ *                                - don't try to handle full negotiation in
+ *                                  smc_phy_configure
+ *                                - clean up (and fix stack overrun) in PHY
+ *                                  MII read/write functions
+ *   09/15/04  Hayato Fujiwara    - Add m32r support.
+ *                                - Modify for SMP kernel; Change spin-locked
+ *                                  regions.
+ */
+static const char version[] =
+	"smc91x.c: v1.0, mar 07 2003 by Nicolas Pitre <nico@cam.org>\n";
+
+/* Debugging level */
+#ifndef SMC_DEBUG
+#define SMC_DEBUG		0
+#endif
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/crc32.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#if CONFIG_SMC91X_HAL
+#include "smc91x_hal.h"
+#else
+#include "smc91x_old.h"
+#endif
+
+#ifdef CONFIG_ISA
+/*
+ * the LAN91C111 can be at any of the following port addresses.  To change,
+ * for a slightly different card, you can add it to the array.  Keep in
+ * mind that the array must end in zero.
+ */
+static unsigned int smc_portlist[] __initdata = {
+	0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
+	0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0
+};
+
+#ifndef SMC_IOADDR
+# define SMC_IOADDR		-1
+#endif
+static unsigned long io = SMC_IOADDR;
+module_param(io, ulong, 0400);
+MODULE_PARM_DESC(io, "I/O base address");
+
+#ifndef SMC_IRQ
+# define SMC_IRQ		-1
+#endif
+static int irq = SMC_IRQ;
+module_param(irq, int, 0400);
+MODULE_PARM_DESC(irq, "IRQ number");
+
+#endif  /* CONFIG_ISA */
+
+static int nowait = -1;
+module_param(nowait, int, 0400);
+MODULE_PARM_DESC(nowait, "set to 1 for no wait state");
+
+/*
+ * Transmit timeout, default 5 seconds.
+ */
+static int watchdog = 5000;
+module_param(watchdog, int, 0400);
+MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
+
+MODULE_LICENSE("GPL");
+
+/*
+ * The internal workings of the driver.  If you are changing anything
+ * here with the SMC stuff, you should have the datasheet and know
+ * what you are doing.
+ */
+#define CARDNAME "smc91x"
+
+/*
+ * Use power-down feature of the chip
+ */
+#define POWER_DOWN		1
+
+/*
+ * Wait time for memory to be free.  This probably shouldn't be
+ * tuned that much, as waiting for this means nothing else happens
+ * in the system
+ */
+#define MEMORY_WAIT_TIME	16
+
+/*
+ * This selects whether TX packets are sent one by one to the SMC91x internal
+ * memory and throttled until transmission completes.  This may prevent
+ * RX overruns a litle by keeping much of the memory free for RX packets
+ * but to the expense of reduced TX throughput and increased IRQ overhead.
+ * Note this is not a cure for a too slow data bus or too high IRQ latency.
+ */
+#define THROTTLE_TX_PKTS	0
+
+/*
+ * The MII clock high/low times.  2x this number gives the MII clock period
+ * in microseconds. (was 50, but this gives 6.4ms for each MII transaction!)
+ */
+#define MII_DELAY		1
+
+#if SMC_DEBUG > 0
+#define DBG(n, args...)					\
+	do {						\
+		if (SMC_DEBUG >= (n))			\
+			printk(KERN_DEBUG args);	\
+	} while (0)
+
+#define PRINTK(args...)   printk(args)
+#else
+#define DBG(n, args...)   do { } while(0)
+#define PRINTK(args...)   printk(KERN_DEBUG args)
+#endif
+
+#if SMC_DEBUG > 3
+static void PRINT_PKT(u_char *buf, int length)
+{
+	int i;
+	int remainder;
+	int lines;
+
+	lines = length / 16;
+	remainder = length % 16;
+
+	for (i = 0; i < lines ; i ++) {
+		int cur;
+		for (cur = 0; cur < 8; cur++) {
+			u_char a, b;
+			a = *buf++;
+			b = *buf++;
+			printk("%02x%02x ", a, b);
+		}
+		printk("\n");
+	}
+	for (i = 0; i < remainder/2 ; i++) {
+		u_char a, b;
+		a = *buf++;
+		b = *buf++;
+		printk("%02x%02x ", a, b);
+	}
+	printk("\n");
+}
+#else
+#define PRINT_PKT(x...)  do { } while(0)
+#endif
+
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) do {						\
+	unsigned char mask;						\
+	mask = SMC_GET_INT_MASK();					\
+	mask |= (x);							\
+	SMC_SET_INT_MASK(mask);						\
+} while (0)
+
+/* this disables an interrupt from the interrupt mask register */
+#define SMC_DISABLE_INT(x) do {						\
+	unsigned char mask;						\
+	mask = SMC_GET_INT_MASK();					\
+	mask &= ~(x);							\
+	SMC_SET_INT_MASK(mask);						\
+} while (0)
+
+/*
+ * Wait while MMU is busy.  This is usually in the order of a few nanosecs
+ * if at all, but let's avoid deadlocking the system if the hardware
+ * decides to go south.
+ */
+#define SMC_WAIT_MMU_BUSY() do {					\
+	if (unlikely(SMC_GET_MMU_CMD() & MC_BUSY)) {			\
+		unsigned long timeout = jiffies + 2;			\
+		while (SMC_GET_MMU_CMD() & MC_BUSY) {			\
+			if (time_after(jiffies, timeout)) {		\
+				printk("%s: timeout %s line %d\n",	\
+					dev->name, __FILE__, __LINE__);	\
+				break;					\
+			}						\
+			cpu_relax();					\
+		}							\
+	}								\
+} while (0)
+
+
+/*
+ * this does a soft reset on the device
+ */
+static void smc_reset(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int ctl, cfg;
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	/*
+	 * This resets the registers mostly to defaults, but doesn't
+	 * affect EEPROM.  That seems unnecessary
+	 */
+	SMC_SELECT_BANK(0);
+	SMC_SET_RCR(RCR_SOFTRST);
+
+	/*
+	 * Setup the Configuration Register
+	 * This is necessary because the CONFIG_REG is not affected
+	 * by a soft reset
+	 */
+	SMC_SELECT_BANK(1);
+
+	cfg = CONFIG_DEFAULT;
+
+	/*
+	 * Setup for fast accesses if requested.  If the card/system
+	 * can't handle it then there will be no recovery except for
+	 * a hard reset or power cycle
+	 */
+	if (lp->hal.nowait)
+		cfg |= CONFIG_NO_WAIT;
+
+	/*
+	 * Release from possible power-down state
+	 * Configuration register is not affected by Soft Reset
+	 */
+	cfg |= CONFIG_EPH_POWER_EN;
+
+	SMC_SET_CONFIG(cfg);
+
+	/* this should pause enough for the chip to be happy */
+	/*
+	 * elaborate?  What does the chip _need_? --jgarzik
+	 *
+	 * This seems to be undocumented, but something the original
+	 * driver(s) have always done.  Suspect undocumented timing
+	 * info/determined empirically. --rmk
+	 */
+	udelay(1);
+
+	/* Disable transmit and receive functionality */
+	SMC_SELECT_BANK(0);
+	SMC_SET_RCR(RCR_CLEAR);
+	SMC_SET_TCR(TCR_CLEAR);
+
+	SMC_SELECT_BANK(1);
+	ctl = SMC_GET_CTL() | CTL_LE_ENABLE;
+
+	/*
+	 * Set the control register to automatically release successfully
+	 * transmitted packets, to make the best use out of our limited
+	 * memory
+	 */
+#if ! THROTTLE_TX_PKTS
+	ctl |= CTL_AUTO_RELEASE;
+#else
+	ctl &= ~CTL_AUTO_RELEASE;
+#endif
+	SMC_SET_CTL(ctl);
+
+	/* Disable all interrupts */
+	SMC_SELECT_BANK(2);
+	SMC_SET_INT_MASK(0);
+
+	/* Reset the MMU */
+	SMC_SET_MMU_CMD(MC_RESET);
+	SMC_WAIT_MMU_BUSY();
+}
+
+/*
+ * Enable Interrupts, Receive, and Transmit
+ */
+static void smc_enable(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	int mask;
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	/* see the header file for options in TCR/RCR DEFAULT */
+	SMC_SELECT_BANK(0);
+	SMC_SET_TCR(lp->tcr_cur_mode);
+	SMC_SET_RCR(lp->rcr_cur_mode);
+
+	/* now, enable interrupts */
+	mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
+	if (lp->version >= (CHIP_91100 << 4))
+		mask |= IM_MDINT;
+	SMC_SELECT_BANK(2);
+	SMC_SET_INT_MASK(mask);
+}
+
+/*
+ * this puts the device in an inactive state
+ */
+static void smc_shutdown(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	
+	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
+
+	/* no more interrupts for me */
+	SMC_SELECT_BANK(2);
+	SMC_SET_INT_MASK(0);
+
+	/* and tell the card to stay away from that nasty outside world */
+	SMC_SELECT_BANK(0);
+	SMC_SET_RCR(RCR_CLEAR);
+	SMC_SET_TCR(TCR_CLEAR);
+
+#ifdef POWER_DOWN
+	/* finally, shut the chip down */
+	SMC_SELECT_BANK(1);
+	SMC_SET_CONFIG(SMC_GET_CONFIG() & ~CONFIG_EPH_POWER_EN);
+#endif
+}
+
+
+/*
+ * This are the procedures to handle the receipt of a packet.
+ */
+#if !CONFIG_SMC91X_NAPI
+static inline void  smc_rcv(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int packet_number, status, packet_len;
+
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+
+	packet_number = SMC_GET_RXFIFO();
+	if (unlikely(packet_number & RXFIFO_REMPTY)) {
+		PRINTK("%s: smc_rcv with nothing on FIFO.\n", dev->name);
+		return;
+	}
+
+	/* read from start of packet */
+	SMC_SET_PTR(PTR_READ | PTR_RCV | PTR_AUTOINC);
+
+	/* First two words are status and packet length */
+	SMC_GET_PKT_HDR(status, packet_len);
+	packet_len &= 0x07ff;  /* mask off top bits */
+	DBG(2, "%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",
+		dev->name, packet_number, status,
+		packet_len, packet_len);
+
+	if (unlikely(status & RS_ERRORS)) {
+		lp->stats.rx_errors++;
+		if (status & RS_ALGNERR)
+			lp->stats.rx_frame_errors++;
+		if (status & (RS_TOOSHORT | RS_TOOLONG))
+			lp->stats.rx_length_errors++;
+		if (status & RS_BADCRC)
+			lp->stats.rx_crc_errors++;
+	} else {
+		struct sk_buff *skb;
+		unsigned char *data;
+		unsigned int data_len;
+
+		/* set multicast stats */
+		if (status & RS_MULTICAST)
+			lp->stats.multicast++;
+
+		/*
+		 * Actual payload is packet_len - 4 (or 3 if odd byte).
+		 * We want skb_reserve(2) and the final ctrl word
+		 * (2 bytes, possibly containing the payload odd byte).
+		 * Ence packet_len - 4 + 2 + 2.
+		 */
+		skb = dev_alloc_skb(packet_len);
+		if (unlikely(skb == NULL)) {
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+				dev->name);
+			lp->stats.rx_dropped++;
+			goto done;
+		}
+
+		/* Align IP header to 32 bits */
+		skb_reserve(skb, 2);
+
+		/* BUG: the LAN91C111 rev A never sets this bit. Force it. */
+		if (lp->version == 0x90)
+			status |= RS_ODDFRAME;
+
+		/*
+		 * If odd length: packet_len - 3,
+		 * otherwise packet_len - 4.
+		 */
+		data_len = packet_len - ((status & RS_ODDFRAME) ? 3 : 4);
+		data = skb_put(skb, data_len);
+		SMC_PULL_DATA(data, packet_len - 2);
+
+		PRINT_PKT(data, packet_len - 2);
+
+		dev->last_rx = jiffies;
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb, dev);
+		netif_rx(skb);
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += data_len;
+	}
+
+done:
+	SMC_WAIT_MMU_BUSY();
+	SMC_SET_MMU_CMD(MC_RELEASE);
+}
+#else
+static int smc_poll(struct net_device *dev, int *budget)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	int rx_work_limit = dev->quota;
+	unsigned int packet_number, status, irqstat, packet_len, received = 0;
+	struct sk_buff *skb;
+	unsigned char *data;
+	unsigned int data_len;
+		
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+	
+	SMC_SELECT_BANK(2);
+	
+	irqstat = SMC_GET_INT();
+	while (irqstat & IM_RCV_INT) 
+	{
+		packet_number = SMC_GET_RXFIFO();
+		/* read from start of packet */
+		SMC_SET_PTR(PTR_READ | PTR_RCV | PTR_AUTOINC);
+		
+		/* First two words are status and packet length */
+		SMC_GET_PKT_HDR(status, packet_len);
+		packet_len &= 0x07ff;  /* mask off top bits */
+		DBG(2, "%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",
+		    dev->name, packet_number, status,
+		    packet_len, packet_len);
+		
+		if (unlikely(status & RS_ERRORS)) {
+			lp->stats.rx_errors++;
+			if (status & RS_ALGNERR)
+			    lp->stats.rx_frame_errors++;
+			if (status & (RS_TOOSHORT | RS_TOOLONG))
+			    lp->stats.rx_length_errors++;
+			if (status & RS_BADCRC)
+			    lp->stats.rx_crc_errors++;
+			
+			return 1;
+		}
+		
+		if (--rx_work_limit < 0) 
+		    goto not_done;
+		
+		/* set multicast stats */
+		if (status & RS_MULTICAST)
+		    lp->stats.multicast++;
+		
+		/*
+		 * Actual payload is packet_len - 4 (or 3 if odd byte).
+		 * We want skb_reserve(2) and the final ctrl word
+		 * (2 bytes, possibly containing the payload odd byte).
+		 * Ence packet_len - 4 + 2 + 2.
+		 */
+		skb = dev_alloc_skb(packet_len);
+		if (unlikely(skb == NULL)) {
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+			       dev->name);
+			lp->stats.rx_dropped++;
+			goto oom;
+		}
+		
+		/* Align IP header to 32 bits */
+		skb_reserve(skb, 2);
+		
+		/* BUG: the LAN91C111 rev A never sets this bit. Force it. */
+		if (lp->version == 0x90)
+		    status |= RS_ODDFRAME;
+		
+		/*
+		 * If odd length: packet_len - 3,
+		 * otherwise packet_len - 4.
+		 */
+		data_len = packet_len - ((status & RS_ODDFRAME) ? 3 : 4);
+		data = skb_put(skb, data_len);
+		SMC_PULL_DATA(data, packet_len - 2);
+		
+		PRINT_PKT(data, packet_len - 2);
+		
+		dev->last_rx = jiffies;
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb, dev);
+		
+		netif_receive_skb (skb);
+		
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += data_len;
+		
+		SMC_WAIT_MMU_BUSY();
+		SMC_SET_MMU_CMD(MC_RELEASE);
+		
+		irqstat = SMC_GET_INT();
+	}
+	
+	dev->quota -= received;
+	*budget -= received;
+	
+	netif_rx_complete(dev);
+	SMC_ENABLE_INT(IM_RCV_INT);
+	
+	return 0;   /* done */
+not_done:
+	
+	dev->quota -= received;
+	*budget -= received;
+	return 1;  /* not_done */
+oom:
+	netif_rx_schedule(dev);
+	return 0;
+}
+#endif
+/*
+ * This is called to actually send a packet to the chip.
+ * Returns non-zero when successful.
+ */
+static void smc_hardware_send_packet(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	struct sk_buff *skb = lp->saved_skb;
+	unsigned int packet_no, len;
+	unsigned char *buf;
+
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+	
+	if (!skb) return;
+	
+	packet_no = SMC_GET_AR();
+	if (unlikely(packet_no & AR_FAILED)) {
+		printk("%s: Memory allocation failed.\n", dev->name);
+		lp->saved_skb = NULL;
+		lp->stats.tx_errors++;
+		lp->stats.tx_fifo_errors++;
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	/* point to the beginning of the packet */
+	SMC_SET_PN(packet_no);
+	SMC_SET_PTR(PTR_AUTOINC);
+
+	buf = skb->data;
+	len = skb->len;
+	DBG(2, "%s: TX PNR 0x%x LENGTH 0x%04x (%d) BUF 0x%p\n",
+		dev->name, packet_no, len, len, buf);
+	PRINT_PKT(buf, len);
+
+	/*
+	 * Send the packet length (+6 for status words, length, and ctl.
+	 * The card will pad to 64 bytes with zeroes if packet is too small.
+	 */
+	SMC_PUT_PKT_HDR(0, len + 6);
+
+	/* send the actual data */
+	SMC_PUSH_DATA(buf, len & ~1);
+
+	/* Send final ctl word with the last byte if there is one */
+	SMC_outw(((len & 1) ? (0x2000 | buf[len-1]) : 0), ioaddr, DATA_REG);
+
+	/* and let the chipset deal with it */
+	SMC_SET_MMU_CMD(MC_ENQUEUE);
+	SMC_ACK_INT(IM_TX_EMPTY_INT);
+
+	dev->trans_start = jiffies;
+	dev_kfree_skb_any(skb);
+	lp->saved_skb = NULL;
+	lp->stats.tx_packets++;
+	lp->stats.tx_bytes += len;
+}
+
+/*
+ * Since I am not sure if I will have enough room in the chip's ram
+ * to store the packet, I call this routine which either sends it
+ * now, or set the card to generates an interrupt when ready
+ * for the packet.
+ */
+static int smc_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int numPages, poll_count, status, saved_bank;
+	unsigned long flags;
+
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	BUG_ON(lp->saved_skb != NULL);
+	lp->saved_skb = skb;
+
+	/*
+	 * The MMU wants the number of pages to be the number of 256 bytes
+	 * 'pages', minus 1 (since a packet can't ever have 0 pages :))
+	 *
+	 * The 91C111 ignores the size bits, but earlier models don't.
+	 *
+	 * Pkt size for allocating is data length +6 (for additional status
+	 * words, length and ctl)
+	 *
+	 * If odd size then last byte is included in ctl word.
+	 */
+	numPages = ((skb->len & ~1) + (6 - 1)) >> 8;
+	if (unlikely(numPages > 7)) {
+		printk("%s: Far too big packet error.\n", dev->name);
+		lp->saved_skb = NULL;
+		lp->stats.tx_errors++;
+		lp->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		spin_unlock_irqrestore(&lp->lock, flags);
+		return 0;
+	}
+
+	/* now, try to allocate the memory */
+	saved_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK(2);
+	SMC_SET_MMU_CMD(MC_ALLOC | numPages);
+
+	/*
+	 * Poll the chip for a short amount of time in case the
+	 * allocation succeeds quickly.
+	 */
+	poll_count = MEMORY_WAIT_TIME;
+	do {
+		status = SMC_GET_INT();
+		if (status & IM_ALLOC_INT) {
+			SMC_ACK_INT(IM_ALLOC_INT);
+  			break;
+		}
+   	} while (--poll_count);
+
+   	if (!poll_count) {
+		/* oh well, wait until the chip finds memory later */
+		netif_stop_queue(dev);
+		DBG(2, "%s: TX memory allocation deferred.\n", dev->name);
+		SMC_ENABLE_INT(IM_ALLOC_INT);
+   	} else {
+		/*
+		 * Allocation succeeded: push packet to the chip's own memory
+		 * immediately.
+		 *
+		 * If THROTTLE_TX_PKTS is selected that means we don't want
+		 * more than a single TX packet taking up space in the chip's
+		 * internal memory at all time, in which case we stop the
+		 * queue right here until we're notified of TX completion.
+		 *
+		 * Otherwise we're quite happy to feed more TX packets right
+		 * away for better TX throughput, in which case the queue is
+		 * left active.
+		 */  
+#if THROTTLE_TX_PKTS
+		netif_stop_queue(dev);
+#endif
+		smc_hardware_send_packet(dev);
+		SMC_ENABLE_INT(IM_TX_INT | IM_TX_EMPTY_INT);
+	}
+
+	SMC_SELECT_BANK(saved_bank);
+	spin_unlock_irqrestore(&lp->lock, flags);
+	return 0;
+}
+
+/*
+ * This handles a TX interrupt, which is only called when:
+ * - a TX error occurred, or
+ * - CTL_AUTO_RELEASE is not set and TX of a packet completed.
+ */
+static void smc_tx(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int saved_packet, packet_no, tx_status, pkt_len;
+
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+
+	/* If the TX FIFO is empty then nothing to do */
+	packet_no = SMC_GET_TXFIFO();
+	if (unlikely(packet_no & TXFIFO_TEMPTY)) {
+		PRINTK("%s: smc_tx with nothing on FIFO.\n", dev->name);
+		return;
+	}
+
+	/* select packet to read from */
+	saved_packet = SMC_GET_PN();
+	SMC_SET_PN(packet_no);
+
+	/* read the first word (status word) from this packet */
+	SMC_SET_PTR(PTR_AUTOINC | PTR_READ);
+	SMC_GET_PKT_HDR(tx_status, pkt_len);
+	DBG(2, "%s: TX STATUS 0x%04x PNR 0x%02x\n",
+		dev->name, tx_status, packet_no);
+
+	if (!(tx_status & TS_SUCCESS))
+		lp->stats.tx_errors++;
+	if (tx_status & TS_LOSTCAR)
+		lp->stats.tx_carrier_errors++;
+
+	if (tx_status & TS_LATCOL) {
+		PRINTK("%s: late collision occurred on last xmit\n", dev->name);
+		lp->stats.tx_window_errors++;
+		if (!(lp->stats.tx_window_errors & 63) && net_ratelimit()) {
+			printk(KERN_INFO "%s: unexpectedly large numbers of "
+			       "late collisions. Please check duplex "
+			       "setting.\n", dev->name);
+		}
+	}
+
+	/* kill the packet */
+	SMC_WAIT_MMU_BUSY();
+	SMC_SET_MMU_CMD(MC_FREEPKT);
+
+	/* Don't restore Packet Number Reg until busy bit is cleared */
+	SMC_WAIT_MMU_BUSY();
+	SMC_SET_PN(saved_packet);
+
+	/* re-enable transmit */
+	SMC_SELECT_BANK(0);
+	SMC_SET_TCR(lp->tcr_cur_mode);
+	SMC_SELECT_BANK(2);
+}
+
+
+/*---PHY CONTROL AND CONFIGURATION-----------------------------------------*/
+
+static void smc_mii_out(struct net_device *dev, unsigned int val, int bits)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int mii_reg, mask;
+
+	mii_reg = SMC_GET_MII() & ~(MII_MCLK | MII_MDOE | MII_MDO);
+	mii_reg |= MII_MDOE;
+
+	for (mask = 1 << (bits - 1); mask; mask >>= 1) {
+		if (val & mask)
+			mii_reg |= MII_MDO;
+		else
+			mii_reg &= ~MII_MDO;
+
+		SMC_SET_MII(mii_reg);
+		udelay(MII_DELAY);
+		SMC_SET_MII(mii_reg | MII_MCLK);
+		udelay(MII_DELAY);
+	}
+}
+
+static unsigned int smc_mii_in(struct net_device *dev, int bits)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int mii_reg, mask, val;
+
+	mii_reg = SMC_GET_MII() & ~(MII_MCLK | MII_MDOE | MII_MDO);
+	SMC_SET_MII(mii_reg);
+
+	for (mask = 1 << (bits - 1), val = 0; mask; mask >>= 1) {
+		if (SMC_GET_MII() & MII_MDI)
+			val |= mask;
+
+		SMC_SET_MII(mii_reg);
+		udelay(MII_DELAY);
+		SMC_SET_MII(mii_reg | MII_MCLK);
+		udelay(MII_DELAY);
+	}
+
+	return val;
+}
+
+/*
+ * Reads a register from the MII Management serial interface
+ */
+static int smc_phy_read(struct net_device *dev, int phyaddr, int phyreg)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int phydata, old_bank;
+
+	/* Save the current bank, and select bank 3 */
+	old_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK(3);
+
+	/* Idle - 32 ones */
+	smc_mii_out(dev, 0xffffffff, 32);
+
+	/* Start code (01) + read (10) + phyaddr + phyreg */
+	smc_mii_out(dev, 6 << 10 | phyaddr << 5 | phyreg, 14);
+
+	/* Turnaround (2bits) + phydata */
+	phydata = smc_mii_in(dev, 18);
+
+	/* Return to idle state */
+	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
+
+	/* And select original bank */
+	SMC_SELECT_BANK(old_bank);
+
+	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
+		__FUNCTION__, phyaddr, phyreg, phydata);
+
+	return phydata;
+}
+
+/*
+ * Writes a register to the MII Management serial interface
+ */
+static void smc_phy_write(struct net_device *dev, int phyaddr, int phyreg,
+			  int phydata)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int old_bank;
+
+	/* Save the current bank, and select bank 3 */
+	old_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK(3);
+
+	/* Idle - 32 ones */
+	smc_mii_out(dev, 0xffffffff, 32);
+
+	/* Start code (01) + write (01) + phyaddr + phyreg + turnaround + phydata */
+	smc_mii_out(dev, 5 << 28 | phyaddr << 23 | phyreg << 18 | 2 << 16 | phydata, 32);
+
+	/* Return to idle state */
+	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
+
+	/* And select original bank */
+	SMC_SELECT_BANK(old_bank);
+
+	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
+		__FUNCTION__, phyaddr, phyreg, phydata);
+}
+
+/*
+ * Finds and reports the PHY address
+ */
+static void smc_detect_phy(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	int phyaddr;
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	lp->phy_type = 0;
+
+	/*
+	 * Scan all 32 PHY addresses if necessary, starting at
+	 * PHY#1 to PHY#31, and then PHY#0 last.
+	 */
+	for (phyaddr = 1; phyaddr < 33; ++phyaddr) {
+		unsigned int id1, id2;
+
+		/* Read the PHY identifiers */
+		id1 = smc_phy_read(dev, phyaddr & 31, MII_PHYSID1);
+		id2 = smc_phy_read(dev, phyaddr & 31, MII_PHYSID2);
+
+		DBG(3, "%s: phy_id1=0x%x, phy_id2=0x%x\n",
+			dev->name, id1, id2);
+
+		/* Make sure it is a valid identifier */
+		if (id1 != 0x0000 && id1 != 0xffff && id1 != 0x8000 &&
+		    id2 != 0x0000 && id2 != 0xffff && id2 != 0x8000) {
+			/* Save the PHY's address */
+			lp->mii.phy_id = phyaddr & 31;
+			lp->phy_type = id1 << 16 | id2;
+			break;
+		}
+	}
+}
+
+/*
+ * Sets the PHY to a configuration as determined by the user
+ */
+static int smc_phy_fixed(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	int phyaddr = lp->mii.phy_id;
+	int bmcr, cfg1;
+
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+
+	/* Enter Link Disable state */
+	cfg1 = smc_phy_read(dev, phyaddr, PHY_CFG1_REG);
+	cfg1 |= PHY_CFG1_LNKDIS;
+	smc_phy_write(dev, phyaddr, PHY_CFG1_REG, cfg1);
+
+	/*
+	 * Set our fixed capabilities
+	 * Disable auto-negotiation
+	 */
+	bmcr = 0;
+
+	if (lp->ctl_rfduplx)
+		bmcr |= BMCR_FULLDPLX;
+
+	if (lp->ctl_rspeed == 100)
+		bmcr |= BMCR_SPEED100;
+
+	/* Write our capabilities to the phy control register */
+	smc_phy_write(dev, phyaddr, MII_BMCR, bmcr);
+
+	/* Re-Configure the Receive/Phy Control register */
+	SMC_SET_RPC(lp->rpc_cur_mode);
+
+	return 1;
+}
+
+/*
+ * smc_phy_reset - reset the phy
+ * @dev: net device
+ * @phy: phy address
+ *
+ * Issue a software reset for the specified PHY and
+ * wait up to 100ms for the reset to complete.  We should
+ * not access the PHY for 50ms after issuing the reset.
+ *
+ * The time to wait appears to be dependent on the PHY.
+ *
+ * Must be called with lp->lock locked.
+ */
+static int smc_phy_reset(struct net_device *dev, int phy)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int bmcr;
+	int timeout;
+
+	smc_phy_write(dev, phy, MII_BMCR, BMCR_RESET);
+
+	for (timeout = 2; timeout; timeout--) {
+		spin_unlock_irq(&lp->lock);
+		msleep(50);
+		spin_lock_irq(&lp->lock);
+
+		bmcr = smc_phy_read(dev, phy, MII_BMCR);
+		if (!(bmcr & BMCR_RESET))
+			break;
+	}
+
+	return bmcr & BMCR_RESET;
+}
+
+/*
+ * smc_phy_powerdown - powerdown phy
+ * @dev: net device
+ * @phy: phy address
+ *
+ * Power down the specified PHY
+ */
+static void smc_phy_powerdown(struct net_device *dev, int phy)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int bmcr;
+
+	spin_lock_irq(&lp->lock);
+	bmcr = smc_phy_read(dev, phy, MII_BMCR);
+	smc_phy_write(dev, phy, MII_BMCR, bmcr | BMCR_PDOWN);
+	spin_unlock_irq(&lp->lock);
+}
+
+/*
+ * smc_phy_check_media - check the media status and adjust TCR
+ * @dev: net device
+ * @init: set true for initialisation
+ *
+ * Select duplex mode depending on negotiation state.  This
+ * also updates our carrier state.
+ */
+static void smc_phy_check_media(struct net_device *dev, int init)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+
+	if (mii_check_media(&lp->mii, netif_msg_link(lp), init)) {
+		unsigned int old_bank;
+
+		/* duplex state has changed */
+		if (lp->mii.full_duplex) {
+			lp->tcr_cur_mode |= TCR_SWFDUP;
+		} else {
+			lp->tcr_cur_mode &= ~TCR_SWFDUP;
+		}
+
+		old_bank = SMC_CURRENT_BANK();
+		SMC_SELECT_BANK(0);
+		SMC_SET_TCR(lp->tcr_cur_mode);
+		SMC_SELECT_BANK(old_bank);
+	}
+}
+
+/*
+ * Configures the specified PHY through the MII management interface
+ * using Autonegotiation.
+ * Calls smc_phy_fixed() if the user has requested a certain config.
+ * If RPC ANEG bit is set, the media selection is dependent purely on
+ * the selection by the MII (either in the MII BMCR reg or the result
+ * of autonegotiation.)  If the RPC ANEG bit is cleared, the selection
+ * is controlled by the RPC SPEED and RPC DPLX bits.
+ */
+static void smc_phy_configure(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	int phyaddr = lp->mii.phy_id;
+	int my_phy_caps; /* My PHY capabilities */
+	int my_ad_caps; /* My Advertised capabilities */
+	int status;
+
+	DBG(3, "%s:smc_program_phy()\n", dev->name);
+
+	spin_lock_irq(&lp->lock);
+
+	/*
+	 * We should not be called if phy_type is zero.
+	 */
+	if (lp->phy_type == 0)
+		goto smc_phy_configure_exit;
+
+	if (smc_phy_reset(dev, phyaddr)) {
+		printk("%s: PHY reset timed out\n", dev->name);
+		goto smc_phy_configure_exit;
+	}
+
+	/*
+	 * Enable PHY Interrupts (for register 18)
+	 * Interrupts listed here are disabled
+	 */
+	smc_phy_write(dev, phyaddr, PHY_MASK_REG,
+		PHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |
+		PHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |
+		PHY_INT_SPDDET | PHY_INT_DPLXDET);
+
+	/* Configure the Receive/Phy Control register */
+	SMC_SELECT_BANK(0);
+	SMC_SET_RPC(lp->rpc_cur_mode);
+
+	/* If the user requested no auto neg, then go set his request */
+	if (lp->mii.force_media) {
+		smc_phy_fixed(dev);
+		goto smc_phy_configure_exit;
+	}
+
+	/* Copy our capabilities from MII_BMSR to MII_ADVERTISE */
+	my_phy_caps = smc_phy_read(dev, phyaddr, MII_BMSR);
+
+	if (!(my_phy_caps & BMSR_ANEGCAPABLE)) {
+		printk(KERN_INFO "Auto negotiation NOT supported\n");
+		smc_phy_fixed(dev);
+		goto smc_phy_configure_exit;
+	}
+
+	my_ad_caps = ADVERTISE_CSMA; /* I am CSMA capable */
+
+	if (my_phy_caps & BMSR_100BASE4)
+		my_ad_caps |= ADVERTISE_100BASE4;
+	if (my_phy_caps & BMSR_100FULL)
+		my_ad_caps |= ADVERTISE_100FULL;
+	if (my_phy_caps & BMSR_100HALF)
+		my_ad_caps |= ADVERTISE_100HALF;
+	if (my_phy_caps & BMSR_10FULL)
+		my_ad_caps |= ADVERTISE_10FULL;
+	if (my_phy_caps & BMSR_10HALF)
+		my_ad_caps |= ADVERTISE_10HALF;
+
+	/* Disable capabilities not selected by our user */
+	if (lp->ctl_rspeed != 100)
+		my_ad_caps &= ~(ADVERTISE_100BASE4|ADVERTISE_100FULL|ADVERTISE_100HALF);
+
+	if (!lp->ctl_rfduplx)
+		my_ad_caps &= ~(ADVERTISE_100FULL|ADVERTISE_10FULL);
+
+	/* Update our Auto-Neg Advertisement Register */
+	smc_phy_write(dev, phyaddr, MII_ADVERTISE, my_ad_caps);
+	lp->mii.advertising = my_ad_caps;
+
+	/*
+	 * Read the register back.  Without this, it appears that when
+	 * auto-negotiation is restarted, sometimes it isn't ready and
+	 * the link does not come up.
+	 */
+	status = smc_phy_read(dev, phyaddr, MII_ADVERTISE);
+
+	DBG(2, "%s: phy caps=%x\n", dev->name, my_phy_caps);
+	DBG(2, "%s: phy advertised caps=%x\n", dev->name, my_ad_caps);
+
+	/* Restart auto-negotiation process in order to advertise my caps */
+	smc_phy_write(dev, phyaddr, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+
+	smc_phy_check_media(dev, 1);
+
+smc_phy_configure_exit:
+	spin_unlock_irq(&lp->lock);
+}
+
+/*
+ * smc_phy_interrupt
+ *
+ * Purpose:  Handle interrupts relating to PHY register 18. This is
+ *  called from the "hard" interrupt handler under our private spinlock.
+ */
+static void smc_phy_interrupt(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	int phyaddr = lp->mii.phy_id;
+	int phy18;
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	if (lp->phy_type == 0)
+		return;
+
+	for(;;) {
+		smc_phy_check_media(dev, 0);
+
+		/* Read PHY Register 18, Status Output */
+		phy18 = smc_phy_read(dev, phyaddr, PHY_INT_REG);
+		if ((phy18 & PHY_INT_INT) == 0)
+			break;
+	}
+}
+
+/*--- END PHY CONTROL AND CONFIGURATION-------------------------------------*/
+
+static void smc_10bt_check_media(struct net_device *dev, int init)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	unsigned int old_carrier, new_carrier, old_bank;
+
+	old_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK(0);
+	old_carrier = netif_carrier_ok(dev) ? 1 : 0;
+	new_carrier = SMC_inw(ioaddr, EPH_STATUS_REG) & ES_LINK_OK ? 1 : 0;
+
+	if (init || (old_carrier != new_carrier)) {
+		if (!new_carrier) {
+			netif_carrier_off(dev);
+		} else {
+			netif_carrier_on(dev);
+		}
+		if (netif_msg_link(lp))
+			printk(KERN_INFO "%s: link %s\n", dev->name,
+			       new_carrier ? "up" : "down");
+	}
+	SMC_SELECT_BANK(old_bank);
+}
+
+static void smc_eph_interrupt(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned int old_bank, ctl;
+
+	smc_10bt_check_media(dev, 0);
+
+	old_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK(1);
+
+	ctl = SMC_GET_CTL();
+	SMC_SET_CTL(ctl & ~CTL_LE_ENABLE);
+	SMC_SET_CTL(ctl);
+
+	SMC_SELECT_BANK(old_bank);
+}
+
+/*
+ * This is the main routine of the driver, to handle the device when
+ * it needs some attention.
+ */
+static irqreturn_t smc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	int status, mask, card_stats;
+	int saved_bank, saved_pointer;
+
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+
+	spin_lock(&lp->lock);
+
+	saved_bank = SMC_CURRENT_BANK();
+	SMC_SELECT_BANK(2);
+	saved_pointer = SMC_GET_PTR();
+	mask = SMC_GET_INT_MASK();
+	SMC_SET_INT_MASK(0);
+	
+	status = SMC_GET_INT();
+	DBG(2, "%s: IRQ 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",
+	    dev->name, status, mask,
+	    ({ int meminfo; SMC_SELECT_BANK(0);
+		    meminfo = SMC_GET_MIR();
+		    SMC_SELECT_BANK(2); meminfo; }),
+	    SMC_GET_FIFO());
+	
+	status &= mask;
+	
+	do {
+		if (status & IM_RCV_INT) {
+			DBG(3, "%s: RX irq\n", dev->name);
+#if CONFIG_SMC91X_NAPI
+			if (netif_rx_schedule_prep(dev))
+			{
+				/* disable interrupts caused 
+				 * by arriving packets */
+				mask &= ~IM_RCV_INT;
+				/* tell system we have work to be done. */
+				__netif_rx_schedule(dev);
+			}
+			else
+			{
+				printk(KERN_WARNING 
+				       "%s: driver bug! interrupt while in poll\n", 
+				       __FUNCTION__);
+				mask &= ~IM_RCV_INT;
+			}
+#else				
+			smc_rcv(dev);
+#endif
+		} 
+		
+		if (status & IM_TX_INT) {
+			DBG(3, "%s: TX int\n", dev->name);
+			smc_tx(dev);
+			SMC_ACK_INT(IM_TX_INT);
+#if THROTTLE_TX_PKTS
+			netif_wake_queue(dev);
+#endif
+		}
+		
+		if (status & IM_ALLOC_INT) {
+			DBG(3, "%s: Allocation irq\n", dev->name);
+			smc_hardware_send_packet(dev);
+			mask |= (IM_TX_INT | IM_TX_EMPTY_INT);
+			mask &= ~IM_ALLOC_INT;
+#if ! THROTTLE_TX_PKTS
+			netif_wake_queue(dev);
+#endif
+		}
+		
+		if (status & IM_TX_EMPTY_INT) {
+			DBG(3, "%s: TX empty\n", dev->name);
+			mask &= ~IM_TX_EMPTY_INT;
+
+			/* update stats */
+			SMC_SELECT_BANK(0);
+			card_stats = SMC_GET_COUNTER();
+			SMC_SELECT_BANK(2);
+
+			/* single collisions */
+			lp->stats.collisions += card_stats & 0xF;
+			card_stats >>= 4;
+
+			/* multiple collisions */
+			lp->stats.collisions += card_stats & 0xF;
+		}
+		
+		if (status & IM_RX_OVRN_INT) {
+			DBG(1, "%s: RX overrun\n", dev->name);
+			SMC_ACK_INT(IM_RX_OVRN_INT);
+			lp->stats.rx_errors++;
+			lp->stats.rx_fifo_errors++;
+		}
+		
+		if (status & IM_EPH_INT) {
+			smc_eph_interrupt(dev);
+		} 
+		
+		if (status & IM_MDINT) {
+			SMC_ACK_INT(IM_MDINT);
+			smc_phy_interrupt(dev);
+		} 
+		
+		if (status & IM_ERCV_INT) {
+			SMC_ACK_INT(IM_ERCV_INT);
+			PRINTK("%s: UNSUPPORTED: ERCV INTERRUPT \n", dev->name);
+		}
+		
+		status = SMC_GET_INT();
+		DBG(2, "%s: IRQ 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",
+		    dev->name, status, mask,
+		    ({ int meminfo; SMC_SELECT_BANK(0);
+			    meminfo = SMC_GET_MIR();
+			    SMC_SELECT_BANK(2); meminfo; }),
+		    SMC_GET_FIFO());
+		
+		status &= mask;
+		
+	} while (status);
+
+	/* restore register states */
+	SMC_SET_INT_MASK(mask);
+	SMC_SET_PTR(saved_pointer);
+	SMC_SELECT_BANK(saved_bank);
+
+	DBG(3, "%s: Interrupt done (%d loops)\n", dev->name, 8-timeout);
+
+	spin_unlock(&lp->lock);
+	/*
+	 * We return IRQ_HANDLED unconditionally here even if there was
+	 * nothing to do.  There is a possibility that a packet might
+	 * get enqueued into the chip right after TX_EMPTY_INT is raised
+	 * but just before the CPU acknowledges the IRQ.
+	 * Better take an unneeded IRQ in some occasions than complexifying
+	 * the code for all cases.
+	 */
+	return IRQ_HANDLED;
+}
+
+/* Our watchdog timed out. Called by the networking layer */
+static void smc_timeout(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&lp->lock, flags);
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	smc_reset(dev);
+	smc_enable(dev);
+
+#if 0
+	/*
+	 * Reconfiguring the PHY doesn't seem like a bad idea here, but
+	 * it introduced a problem.  Now that this is a timeout routine,
+	 * we are getting called from within an interrupt context.
+	 * smc_phy_configure() calls msleep() which calls
+	 * schedule_timeout() which calls schedule().  When schedule()
+	 * is called from an interrupt context, it prints out
+	 * "Scheduling in interrupt" and then calls BUG().  This is
+	 * obviously not desirable.  This was worked around by removing
+	 * the call to smc_phy_configure() here because it didn't seem
+	 * absolutely necessary.  Ultimately, if msleep() is
+	 * supposed to be usable from an interrupt context (which it
+	 * looks like it thinks it should handle), it should be fixed.
+	 */
+	if (lp->phy_type != 0)
+		smc_phy_configure(dev);
+#endif
+
+	/* clear anything saved */
+	if (lp->saved_skb != NULL) {
+		dev_kfree_skb (lp->saved_skb);
+		lp->saved_skb = NULL;
+		lp->stats.tx_errors++;
+		lp->stats.tx_aborted_errors++;
+	}
+	/* We can accept TX packets again */
+	dev->trans_start = jiffies;
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	netif_wake_queue(dev);
+}
+
+/*
+ *    This sets the internal hardware table to filter out unwanted multicast
+ *    packets before they take up memory.
+ *
+ *    The SMC chip uses a hash table where the high 6 bits of the CRC of
+ *    address are the offset into the table.  If that bit is 1, then the
+ *    multicast packet is accepted.  Otherwise, it's dropped silently.
+ *
+ *    To use the 6 bits as an offset into the table, the high 3 bits are the
+ *    number of the 8 bit register, while the low 3 bits are the bit within
+ *    that register.
+ *
+ *    This routine is based very heavily on the one provided by Peter Cammaert.
+ */
+static void
+smc_setmulticast(struct net_device *dev, int count, struct dev_mc_list *addrs)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	int i;
+	unsigned char multicast_table[8];
+	struct dev_mc_list *cur_addr;
+
+	/* table for flipping the order of 3 bits */
+	static unsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };
+
+	/* start with a table of all zeros: reject all */
+	memset(multicast_table, 0, sizeof(multicast_table));
+
+	cur_addr = addrs;
+	for (i = 0; i < count; i++, cur_addr = cur_addr->next) {
+		int position;
+
+		/* do we have a pointer here? */
+		if (!cur_addr)
+			break;
+		/* make sure this is a multicast address - shouldn't this
+		   be a given if we have it here ? */
+		if (!(*cur_addr->dmi_addr & 1))
+			continue;
+
+		/* only use the low order bits */
+		position = crc32_le(~0, cur_addr->dmi_addr, 6) & 0x3f;
+
+		/* do some messy swapping to put the bit in the right spot */
+		multicast_table[invert3[position&7]] |=
+					(1<<invert3[(position>>3)&7]);
+
+	}
+	/* now, the table can be loaded into the chipset */
+	SMC_SELECT_BANK(3);
+	SMC_SET_MCAST(multicast_table);
+}
+
+/*
+ * This routine will, depending on the values passed to it,
+ * either make it accept multicast packets, go into
+ * promiscuous mode (for TCPDUMP and cousins) or accept
+ * a select set of multicast packets
+ */
+static void smc_set_multicast_list(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	SMC_SELECT_BANK(0);
+	if (dev->flags & IFF_PROMISC) {
+		DBG(2, "%s: RCR_PRMS\n", dev->name);
+		lp->rcr_cur_mode |= RCR_PRMS;
+		SMC_SET_RCR(lp->rcr_cur_mode);
+	}
+
+/* BUG?  I never disable promiscuous mode if multicasting was turned on.
+   Now, I turn off promiscuous mode, but I don't do anything to multicasting
+   when promiscuous mode is turned on.
+*/
+
+	/*
+	 * Here, I am setting this to accept all multicast packets.
+	 * I don't need to zero the multicast table, because the flag is
+	 * checked before the table is
+	 */
+	else if (dev->flags & IFF_ALLMULTI || dev->mc_count > 16) {
+		lp->rcr_cur_mode |= RCR_ALMUL;
+		SMC_SET_RCR(lp->rcr_cur_mode);
+		DBG(2, "%s: RCR_ALMUL\n", dev->name);
+	}
+
+	/*
+	 * We just get all multicast packets even if we only want them
+	 * from one source.  This will be changed at some future point.
+	 */
+	else if (dev->mc_count)  {
+		/* support hardware multicasting */
+
+		/* be sure I get rid of flags I might have set */
+		lp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);
+		SMC_SET_RCR(lp->rcr_cur_mode);
+		/*
+		 * NOTE: this has to set the bank, so make sure it is the
+		 * last thing called.  The bank is set to zero at the top
+		 */
+		smc_setmulticast(dev, dev->mc_count, dev->mc_list);
+	} else  {
+		DBG(2, "%s: ~(RCR_PRMS|RCR_ALMUL)\n", dev->name);
+		lp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);
+		SMC_SET_RCR(lp->rcr_cur_mode);
+
+		/*
+		 * since I'm disabling all multicast entirely, I need to
+		 * clear the multicast list
+		 */
+		SMC_SELECT_BANK(3);
+		SMC_CLEAR_MCAST();
+	}
+}
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc..
+ */
+static int
+smc_open(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	/*
+	 * Check that the address is valid.  If its not, refuse
+	 * to bring the device up.  The user must specify an
+	 * address using ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx
+	 */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		DBG(2, "smc_open: no valid ethernet hw addr\n");
+		return -EINVAL;
+	}
+
+	/* clear out all the junk that was put here before... */
+	lp->saved_skb = NULL;
+
+	/* Setup the default Register Modes */
+	lp->tcr_cur_mode = TCR_DEFAULT;
+	lp->rcr_cur_mode = RCR_DEFAULT;
+	lp->rpc_cur_mode = RPC_DEFAULT;
+
+	/*
+	 * If we are not using a MII interface, we need to
+	 * monitor our own carrier signal to detect faults.
+	 */
+	if (lp->phy_type == 0)
+		lp->tcr_cur_mode |= TCR_MON_CSN;
+
+	/* reset the hardware */
+	smc_reset(dev);
+	smc_enable(dev);
+
+	SMC_SELECT_BANK(1);
+	SMC_SET_MAC_ADDR(dev->dev_addr);
+
+	/* Configure the PHY */
+	if (lp->phy_type != 0)
+		smc_phy_configure(dev);
+	else {
+		spin_lock_irq(&lp->lock);
+		smc_10bt_check_media(dev, 1);
+		spin_unlock_irq(&lp->lock);
+	}
+
+	/*
+	 * make sure to initialize the link state with netif_carrier_off()
+	 * somewhere, too --jgarzik
+	 *
+	 * smc_phy_configure() and smc_10bt_check_media() does that. --rmk
+	 */
+	netif_start_queue(dev);
+	return 0;
+}
+
+/*
+ * smc_close
+ *
+ * this makes the board clean up everything that it can
+ * and not talk to the outside world.   Caused by
+ * an 'ifconfig ethX down'
+ */
+static int smc_close(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	netif_stop_queue(dev);
+	netif_carrier_off(dev);
+
+	/* clear everything */
+	smc_shutdown(dev);
+
+	if (lp->phy_type != 0)
+		smc_phy_powerdown(dev, lp->mii.phy_id);
+
+	return 0;
+}
+
+/*
+ * Get the current statistics.
+ * This may be called with the card open or closed.
+ */
+static struct net_device_stats *smc_query_statistics(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+
+	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+
+	return &lp->stats;
+}
+
+/*
+ * Ethtool support
+ */
+static int
+smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	int ret;
+
+	cmd->maxtxpkt = 1;
+	cmd->maxrxpkt = 1;
+
+	if (lp->phy_type != 0) {
+		spin_lock_irq(&lp->lock);
+		ret = mii_ethtool_gset(&lp->mii, cmd);
+		spin_unlock_irq(&lp->lock);
+	} else {
+		cmd->supported = SUPPORTED_10baseT_Half |
+				 SUPPORTED_10baseT_Full |
+				 SUPPORTED_TP | SUPPORTED_AUI;
+
+		if (lp->ctl_rspeed == 10)
+			cmd->speed = SPEED_10;
+		else if (lp->ctl_rspeed == 100)
+			cmd->speed = SPEED_100;
+
+		cmd->autoneg = AUTONEG_DISABLE;
+		cmd->transceiver = XCVR_INTERNAL;
+		cmd->port = 0;
+		cmd->duplex = lp->tcr_cur_mode & TCR_SWFDUP ? DUPLEX_FULL : DUPLEX_HALF;
+
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int
+smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	int ret;
+
+	if (lp->phy_type != 0) {
+		spin_lock_irq(&lp->lock);
+		ret = mii_ethtool_sset(&lp->mii, cmd);
+		spin_unlock_irq(&lp->lock);
+	} else {
+		if (cmd->autoneg != AUTONEG_DISABLE ||
+		    cmd->speed != SPEED_10 ||
+		    (cmd->duplex != DUPLEX_HALF && cmd->duplex != DUPLEX_FULL) ||
+		    (cmd->port != PORT_TP && cmd->port != PORT_AUI))
+			return -EINVAL;
+
+//		lp->port = cmd->port;
+		lp->ctl_rfduplx = cmd->duplex == DUPLEX_FULL;
+
+//		if (netif_running(dev))
+//			smc_set_port(dev);
+
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static void
+smc_ethtool_getdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	strncpy(info->driver, CARDNAME, sizeof(info->driver));
+	strncpy(info->version, version, sizeof(info->version));
+	strncpy(info->bus_info, dev->class_dev.dev->bus_id, sizeof(info->bus_info));
+}
+
+static int smc_ethtool_nwayreset(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	int ret = -EINVAL;
+
+	if (lp->phy_type != 0) {
+		spin_lock_irq(&lp->lock);
+		ret = mii_nway_restart(&lp->mii);
+		spin_unlock_irq(&lp->lock);
+	}
+
+	return ret;
+}
+
+static u32 smc_ethtool_getmsglevel(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	return lp->msg_enable;
+}
+
+static void smc_ethtool_setmsglevel(struct net_device *dev, u32 level)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	lp->msg_enable = level;
+}
+
+static struct ethtool_ops smc_ethtool_ops = {
+	.get_settings	= smc_ethtool_getsettings,
+	.set_settings	= smc_ethtool_setsettings,
+	.get_drvinfo	= smc_ethtool_getdrvinfo,
+
+	.get_msglevel	= smc_ethtool_getmsglevel,
+	.set_msglevel	= smc_ethtool_setmsglevel,
+	.nway_reset	= smc_ethtool_nwayreset,
+	.get_link	= ethtool_op_get_link,
+//	.get_eeprom	= smc_ethtool_geteeprom,
+//	.set_eeprom	= smc_ethtool_seteeprom,
+};
+
+/*
+ * smc_findirq
+ *
+ * This routine has a simple purpose -- make the SMC chip generate an
+ * interrupt, so an auto-detect routine can detect it, and find the IRQ,
+ */
+/*
+ * does this still work?
+ *
+ * I just deleted auto_irq.c, since it was never built...
+ *   --jgarzik
+ */
+static int __init smc_findirq(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	int timeout = 20;
+	unsigned long cookie;
+
+	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
+
+	cookie = probe_irq_on();
+
+	/*
+	 * What I try to do here is trigger an ALLOC_INT. This is done
+	 * by allocating a small chunk of memory, which will give an interrupt
+	 * when done.
+	 */
+	/* enable ALLOCation interrupts ONLY */
+	SMC_SELECT_BANK(2);
+	SMC_SET_INT_MASK(IM_ALLOC_INT);
+
+	/*
+ 	 * Allocate 512 bytes of memory.  Note that the chip was just
+	 * reset so all the memory is available
+	 */
+	SMC_SET_MMU_CMD(MC_ALLOC | 1);
+
+	/*
+	 * Wait until positive that the interrupt has been generated
+	 */
+	do {
+		int int_status;
+		udelay(10);
+		int_status = SMC_GET_INT();
+		if (int_status & IM_ALLOC_INT)
+			break;		/* got the interrupt */
+	} while (--timeout);
+
+	/*
+	 * there is really nothing that I can do here if timeout fails,
+	 * as autoirq_report will return a 0 anyway, which is what I
+	 * want in this case.   Plus, the clean up is needed in both
+	 * cases.
+	 */
+
+	/* and disable all interrupts again */
+	SMC_SET_INT_MASK(0);
+
+	/* and return what I found */
+	return probe_irq_off(cookie);
+}
+
+/*
+ * Function: smc_probe(unsigned long ioaddr)
+ *
+ * Purpose:
+ *	Tests to see if a given ioaddr points to an SMC91x chip.
+ *	Returns a 0 on success
+ *
+ * Algorithm:
+ *	(1) see if the high byte of BANK_SELECT is 0x33
+ * 	(2) compare the ioaddr with the base register's address
+ *	(3) see if I recognize the chip ID in the appropriate register
+ *
+ * Here I do typical initialization tasks.
+ *
+ * o  Initialize the structure if needed
+ * o  print out my vanity message if not done so already
+ * o  print out what type of hardware is detected
+ * o  print out the ethernet address
+ * o  find the IRQ
+ * o  set up my private data
+ * o  configure the dev structure with my subroutines
+ * o  actually GRAB the irq.
+ * o  GRAB the region
+ */
+static int __init smc_probe(struct net_device *dev, unsigned long ioaddr)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	static int version_printed = 0;
+	int i, retval;
+	unsigned int val, revision_register;
+	const char *version_string;
+
+	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
+
+	/* First, see if the high byte is 0x33 */
+	val = SMC_CURRENT_BANK();
+	DBG(2, "%s: bank signature probe returned 0x%04x\n", CARDNAME, val);
+	if ((val & 0xFF00) != 0x3300) {
+		if ((val & 0xFF) == 0x33) {
+			printk(KERN_WARNING
+				"%s: Detected possible byte-swapped interface"
+				" at IOADDR 0x%lx\n", CARDNAME, ioaddr);
+		}
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/*
+	 * The above MIGHT indicate a device, but I need to write to
+	 * further test this.
+	 */
+	SMC_SELECT_BANK(0);
+	val = SMC_CURRENT_BANK();
+	if ((val & 0xFF00) != 0x3300) {
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/*
+	 * well, we've already written once, so hopefully another
+	 * time won't hurt.  This time, I need to switch the bank
+	 * register to bank 1, so I can access the base address
+	 * register
+	 */
+	SMC_SELECT_BANK(1);
+	val = SMC_GET_BASE();
+	val = ((val & 0x1F00) >> 3) << SMC_IO_SHIFT;
+	if ((ioaddr & ((PAGE_SIZE-1)<<SMC_IO_SHIFT)) != val) {
+		printk("%s: IOADDR %lx doesn't match configuration (%x).\n",
+			CARDNAME, ioaddr, val);
+	}
+
+	/*
+	 * check if the revision register is something that I
+	 * recognize.  These might need to be added to later,
+	 * as future revisions could be added.
+	 */
+	SMC_SELECT_BANK(3);
+	revision_register = SMC_GET_REV();
+	DBG(2, "%s: revision = 0x%04x\n", CARDNAME, revision_register);
+	version_string = chip_ids[ (revision_register >> 4) & 0xF];
+	if (!version_string || (revision_register & 0xff00) != 0x3300) {
+		/* I don't recognize this chip, so... */
+		printk("%s: IO 0x%lx: Unrecognized revision register 0x%04x"
+			", Contact author.\n", CARDNAME,
+			ioaddr, revision_register);
+
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/* At this point I'll assume that the chip is an SMC91x. */
+	if (version_printed++ == 0)
+		printk("%s", version);
+
+	/* fill in some of the fields */
+	dev->base_addr = ioaddr;
+	lp->version = revision_register & 0xff;
+
+	/* Get the MAC address */
+	SMC_SELECT_BANK(1);
+	SMC_GET_MAC_ADDR(dev->dev_addr);
+
+	/* now, reset the chip, and put it into a known state */
+	smc_reset(dev);
+
+	/*
+	 * If dev->irq is 0, then the device has to be banged on to see
+	 * what the IRQ is.
+ 	 *
+	 * This banging doesn't always detect the IRQ, for unknown reasons.
+	 * a workaround is to reset the chip and try again.
+	 *
+	 * Interestingly, the DOS packet driver *SETS* the IRQ on the card to
+	 * be what is requested on the command line.   I don't do that, mostly
+	 * because the card that I have uses a non-standard method of accessing
+	 * the IRQs, and because this _should_ work in most configurations.
+	 *
+	 * Specifying an IRQ is done with the assumption that the user knows
+	 * what (s)he is doing.  No checking is done!!!!
+	 */
+	if (dev->irq < 1) {
+		int trials;
+
+		trials = 3;
+		while (trials--) {
+			dev->irq = smc_findirq(dev);
+			if (dev->irq)
+				break;
+			/* kick the card and try again */
+			smc_reset(dev);
+		}
+	}
+	if (dev->irq == 0) {
+		printk("%s: Couldn't autodetect your IRQ. Use irq=xx.\n",
+			dev->name);
+		retval = -ENODEV;
+		goto err_out;
+	}
+	dev->irq = irq_canonicalize(dev->irq);
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	ether_setup(dev);
+
+	dev->open = smc_open;
+	dev->stop = smc_close;
+	dev->hard_start_xmit = smc_hard_start_xmit;
+	dev->tx_timeout = smc_timeout;
+	dev->watchdog_timeo = msecs_to_jiffies(watchdog);
+	dev->get_stats = smc_query_statistics;
+	dev->set_multicast_list = smc_set_multicast_list;
+	dev->ethtool_ops = &smc_ethtool_ops;
+
+#if CONFIG_SMC91X_NAPI
+	/* NAPI */
+	dev->poll = smc_poll;
+	dev->weight = 16;
+#endif
+	
+	spin_lock_init(&lp->lock);
+	lp->mii.phy_id_mask = 0x1f;
+	lp->mii.reg_num_mask = 0x1f;
+	lp->mii.force_media = 0;
+	lp->mii.full_duplex = 0;
+	lp->mii.dev = dev;
+	lp->mii.mdio_read = smc_phy_read;
+	lp->mii.mdio_write = smc_phy_write;
+
+	/*
+	 * Locate the phy, if any.
+	 */
+	if (lp->version >= (CHIP_91100 << 4))
+		smc_detect_phy(dev);
+
+	/* Set default parameters */
+	lp->msg_enable = NETIF_MSG_LINK;
+	lp->ctl_rfduplx = 0;
+	lp->ctl_rspeed = 10;
+
+	if (lp->version >= (CHIP_91100 << 4)) {
+		lp->ctl_rfduplx = 1;
+		lp->ctl_rspeed = 100;
+	}
+
+	/* Grab the IRQ */
+      	retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+      	if (retval)
+      		goto err_out;
+
+#if !defined(__m32r__)
+	set_irq_type(dev->irq, IRQT_RISING);
+#endif
+#ifdef SMC_USE_PXA_DMA
+	{
+		int dma = pxa_request_dma(dev->name, DMA_PRIO_LOW,
+					  smc_pxa_dma_irq, NULL);
+		if (dma >= 0)
+			dev->dma = dma;
+	}
+#endif
+
+	retval = register_netdev(dev);
+	if (retval == 0) {
+		/* now, print out the card info, in a short format.. */
+		printk("%s: %s (rev %d) at %#lx IRQ %d",
+			dev->name, version_string, revision_register & 0x0f,
+			dev->base_addr, dev->irq);
+
+		if (dev->dma != (unsigned char)-1)
+			printk(" DMA %d", dev->dma);
+
+		printk("%s%s\n", lp->hal.nowait ? " [nowait]" : "",
+			THROTTLE_TX_PKTS ? " [throttle_tx]" : "");
+
+		if (!is_valid_ether_addr(dev->dev_addr)) {
+			printk("%s: Invalid ethernet MAC address.  Please "
+			       "set using ifconfig\n", dev->name);
+		} else {
+			/* Print the Ethernet address */
+			printk("%s: Ethernet addr: ", dev->name);
+			for (i = 0; i < 5; i++)
+				printk("%2.2x:", dev->dev_addr[i]);
+			printk("%2.2x\n", dev->dev_addr[5]);
+		}
+
+		if (lp->phy_type == 0) {
+			PRINTK("%s: No PHY found\n", dev->name);
+		} else if ((lp->phy_type & 0xfffffff0) == 0x0016f840) {
+			PRINTK("%s: PHY LAN83C183 (LAN91C111 Internal)\n", dev->name);
+		} else if ((lp->phy_type & 0xfffffff0) == 0x02821c50) {
+			PRINTK("%s: PHY LAN83C180\n", dev->name);
+		}
+	}
+
+err_out:
+#ifdef SMC_USE_PXA_DMA
+	if (retval && dev->dma != (unsigned char)-1)
+		pxa_free_dma(dev->dma);
+#endif
+	return retval;
+}
+
+static int smc_enable_device(struct net_device *dev)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long flags;
+	unsigned char ecor, ecsr;
+	void *addr;
+
+	/*
+	 * Map the attribute space.  This is overkill, but clean.
+	 */
+	addr = ioremap(lp->attrib_phys, ATTRIB_SIZE);
+	if (!addr)
+		return -ENOMEM;
+
+	/*
+	 * Reset the device.  We must disable IRQs around this
+	 * since a reset causes the IRQ line become active.
+	 */
+	local_irq_save(flags);
+	ecor = readb(addr + (ECOR << SMC_IO_SHIFT)) & ~ECOR_RESET;
+	writeb(ecor | ECOR_RESET, addr + (ECOR << SMC_IO_SHIFT));
+	readb(addr + (ECOR << SMC_IO_SHIFT));
+
+	/*
+	 * Wait 100us for the chip to reset.
+	 */
+	udelay(100);
+
+	/*
+	 * The device will ignore all writes to the enable bit while
+	 * reset is asserted, even if the reset bit is cleared in the
+	 * same write.  Must clear reset first, then enable the device.
+	 */
+	writeb(ecor, addr + (ECOR << SMC_IO_SHIFT));
+	writeb(ecor | ECOR_ENABLE, addr + (ECOR << SMC_IO_SHIFT));
+
+	/*
+	 * Set the appropriate byte/word mode.
+	 */
+	ecsr = readb(addr + (ECSR << SMC_IO_SHIFT)) & ~ECSR_IOIS8;
+#ifndef SMC_CAN_USE_16BIT
+	ecsr |= ECSR_IOIS8;
+#endif
+	writeb(ecsr, addr + (ECSR << SMC_IO_SHIFT));
+	local_irq_restore(flags);
+
+	iounmap(addr);
+
+	/*
+	 * Wait for the chip to wake up.  We could poll the control
+	 * register in the main register space, but that isn't mapped
+	 * yet.  We know this is going to take 750us.
+	 */
+	msleep(1);
+
+	return 0;
+}
+
+/*
+ * smc_init(void)
+ *   Input parameters:
+ *	dev->base_addr == 0, try to find all possible locations
+ *	dev->base_addr > 0x1ff, this is the address to check
+ *	dev->base_addr == <anything else>, return failure code
+ *
+ *   Output:
+ *	0 --> there is a device
+ *	anything else, error
+ */
+static int smc_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev;
+	struct smc_local *lp;
+	struct resource *res, *ext = NULL;
+	unsigned int *addr;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ndev = alloc_etherdev(sizeof(struct smc_local));
+	if (!ndev) {
+		printk("%s: could not allocate device.\n", CARDNAME);
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	lp  = netdev_priv(ndev);
+	smc_set_hal (lp);
+
+	/*
+	 * Request the regions.
+	 */
+	if (!request_mem_region(res->start, SMC_IO_EXTENT, "smc91x")) 
+	{
+		ret = -EBUSY;
+		goto out;
+	}
+	
+	SET_MODULE_OWNER(ndev);
+	SET_NETDEV_DEV(ndev, dev);
+
+	ndev->dma = (unsigned char)-1;
+	ndev->irq = platform_get_irq(pdev, 0);
+
+	ext = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (ext) {
+		if (!request_mem_region(ext->start, ATTRIB_SIZE, ndev->name)) {
+			ret = -EBUSY;
+			goto release_1;
+		}
+		lp->attrib_phys = ext->start;
+#if defined(CONFIG_SA1100_ASSABET)
+		NCR_0 |= NCR_ENET_OSC_EN;
+#endif
+
+		ret = smc_enable_device(ndev);
+		if (ret)
+			goto release_both;
+	}
+
+	addr = ioremap(res->start, SMC_IO_EXTENT);
+	if (!addr) {
+		ret = -ENOMEM;
+		goto release_both;
+	}
+
+	dev_set_drvdata(dev, ndev);
+	ret = smc_probe(ndev, (unsigned long)addr);
+	if (ret != 0) {
+		dev_set_drvdata(dev, NULL);
+		iounmap(addr);
+ release_both:
+		if (ext)
+			release_mem_region(ext->start, ATTRIB_SIZE);
+		free_netdev(ndev);
+ release_1:
+		release_mem_region(res->start, SMC_IO_EXTENT);
+ out:
+		printk("%s: not found (%d).\n", CARDNAME, ret);
+	}
+#ifdef SMC_USE_PXA_DMA
+	else {
+		struct smc_local *lp = netdev_priv(ndev);
+		lp->physaddr = res->start;
+	}
+#endif
+
+	return ret;
+}
+
+static int smc_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct smc_local *lp = netdev_priv(ndev);
+	struct resource *res;
+
+	dev_set_drvdata(dev, NULL);
+
+	unregister_netdev(ndev);
+
+	free_irq(ndev->irq, ndev);
+
+#ifdef SMC_USE_PXA_DMA
+	if (ndev->dma != (unsigned char)-1)
+		pxa_free_dma(ndev->dma);
+#endif
+	iounmap((void *)ndev->base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, ATTRIB_SIZE);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, SMC_IO_EXTENT);
+
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static int smc_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	if (ndev && level == SUSPEND_DISABLE) {
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
+			smc_shutdown(ndev);
+		}
+	}
+	return 0;
+}
+
+static int smc_drv_resume(struct device *dev, u32 level)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = dev_get_drvdata(dev);
+	
+	if (ndev && level == RESUME_ENABLE) {
+		struct smc_local *lp = netdev_priv(ndev);
+		unsigned long ioaddr = ndev->base_addr;
+
+		if (pdev->num_resources == 3) {
+			lp->attrib_phys = pdev->resource[2].start;
+			smc_enable_device(ndev);
+		}
+		
+		if (netif_running(ndev)) {
+			smc_reset(ndev);
+			smc_enable(ndev);
+			SMC_SELECT_BANK(1);
+			SMC_SET_MAC_ADDR(ndev->dev_addr);
+			if (lp->phy_type != 0)
+				smc_phy_configure(ndev);
+			netif_device_attach(ndev);
+		}
+	}
+	return 0;
+}
+
+static struct device_driver smc_driver = {
+	.name		= CARDNAME,
+	.bus		= &platform_bus_type,
+	.probe		= smc_drv_probe,
+	.remove		= smc_drv_remove,
+	.suspend	= smc_drv_suspend,
+	.resume		= smc_drv_resume,
+};
+
+static int __init smc_init(void)
+{
+#ifdef MODULE
+#ifdef CONFIG_ISA
+	if (io == -1)
+		printk(KERN_WARNING 
+			"%s: You shouldn't use auto-probing with insmod!\n",
+			CARDNAME);
+#endif
+#endif
+
+	return driver_register(&smc_driver);
+}
+
+static void __exit smc_cleanup(void)
+{
+	driver_unregister(&smc_driver);
+}
+
+module_init(smc_init);
+module_exit(smc_cleanup);
Index: drivers/net/smc91x_old.h
===================================================================
--- a/drivers/net/smc91x_old.h	(revision 0)
+++ b/drivers/net/smc91x_old.h	(revision 675)
@@ -0,0 +1,937 @@
+/*------------------------------------------------------------------------
+ . smc91x.h - macros for SMSC's 91C9x/91C1xx single-chip Ethernet device.
+ .
+ . Copyright (C) 1996 by Erik Stahlman
+ . Copyright (C) 2001 Standard Microsystems Corporation
+ .	Developed by Simple Network Magic Corporation
+ . Copyright (C) 2003 Monta Vista Software, Inc.
+ .	Unified SMC91x driver by Nicolas Pitre
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ . Authors
+ .	Erik Stahlman		<erik@vt.edu>
+ .	Daris A Nevil		<dnevil@snmc.com>
+ .	Nicolas Pitre 		<nico@cam.org>
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC91X_H_
+#define _SMC91X_H_
+
+struct smc_hal {
+	u32	shift;
+	u32	nowait:1;
+	u32	width:2;
+};
+
+/* store this information for the driver.. */
+struct smc_local 
+{
+	/*
+	 * If I have to wait until memory is available to send a
+	 * packet, I will store the skbuff here, until I get the
+	 * desired memory.  Then, I'll send it out and free it.
+	 */
+	struct sk_buff *saved_skb;
+	
+	/*
+	 *          * these are things that the kernel wants me to keep, so users
+	 *          * can find out semi-useless statistics of how well the card is
+	 *          * performing
+	 *          */
+	struct net_device_stats stats;
+	
+	/* version/revision of the SMC91x chip */
+	int     version;
+	
+	/* Contains the current active transmission mode */
+	int     tcr_cur_mode;
+	
+	/* Contains the current active receive mode */
+	int     rcr_cur_mode;
+	
+	/* Contains the current active receive/phy mode */
+	int     rpc_cur_mode;
+	int     ctl_rfduplx;
+	int     ctl_rspeed;
+	
+	u32     msg_enable;
+	u32     phy_type;
+	struct mii_if_info mii;
+	spinlock_t lock;
+	
+	struct smc_hal hal;
+	u_long attrib_phys;
+//#ifdef SMC_USE_PXA_DMA
+	/* DMA needs the physical address of the chip */
+	u_long physaddr;
+//#endif
+};
+
+
+/* 
+ * dummy for new HAL 
+ */
+void smc_set_hal (struct smc_local *lp)
+{
+	return;
+}
+
+/*
+ * Define your architecture specific bus configuration parameters here.
+ */
+
+#if	defined(CONFIG_SA1100_GRAPHICSCLIENT) || \
+	defined(CONFIG_SA1100_PFS168) || \
+	defined(CONFIG_SA1100_FLEXANET) || \
+	defined(CONFIG_SA1100_GRAPHICSMASTER) || \
+	defined(CONFIG_ARCH_LUBBOCK)
+
+/* We can only do 16-bit reads and writes in the static memory space. */
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_NOWAIT		1
+
+/* The first two address lines aren't connected... */
+#define SMC_IO_SHIFT		2
+
+#define SMC_inw(a, r)		readw((a) + (r))
+#define SMC_outw(v, a, r)	writew(v, (a) + (r))
+#define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
+#define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
+
+#elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6)
+
+/* We can only do 16-bit reads and writes in the static memory space. */
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_NOWAIT		1
+
+#define SMC_IO_SHIFT		0
+
+#define SMC_inw(a, r)		in_be16((volatile u16 *)((a) + (r)))
+#define SMC_outw(v, a, r)	out_be16((volatile u16 *)((a) + (r)), v)
+#define SMC_insw(a, r, p, l) 						\
+	do {								\
+		unsigned long __port = (a) + (r);			\
+		u16 *__p = (u16 *)(p);					\
+		int __l = (l);						\
+		insw(__port, __p, __l);					\
+		while (__l > 0) {					\
+			*__p = swab16(*__p);				\
+			__p++;						\
+			__l--;						\
+		}							\
+	} while (0)
+#define SMC_outsw(a, r, p, l) 						\
+	do {								\
+		unsigned long __port = (a) + (r);			\
+		u16 *__p = (u16 *)(p);					\
+		int __l = (l);						\
+		while (__l > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			outw( /* swab16 */ (*__p++), __port);		\
+			__l--;						\
+		}							\
+	} while (0)
+#define set_irq_type(irq, type)
+
+#elif defined(CONFIG_SA1100_ASSABET)
+
+#include <asm/arch/neponset.h>
+
+/* We can only do 8-bit reads and writes in the static memory space. */
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	0
+#define SMC_CAN_USE_32BIT	0
+#define SMC_NOWAIT		1
+
+/* The first two address lines aren't connected... */
+#define SMC_IO_SHIFT		2
+
+#define SMC_inb(a, r)		readb((a) + (r))
+#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
+#define SMC_insb(a, r, p, l)	readsb((a) + (r), p, (l))
+#define SMC_outsb(a, r, p, l)	writesb((a) + (r), p, (l))
+
+#elif	defined(CONFIG_ARCH_INNOKOM) || \
+	defined(CONFIG_MACH_MAINSTONE) || \
+	defined(CONFIG_ARCH_PXA_IDP) || \
+	defined(CONFIG_ARCH_RAMSES) || \
+	defined(CONFIG_ARCH_PXA_PNP2110_V2)
+
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	1
+#define SMC_IO_SHIFT		0
+#define SMC_NOWAIT		0
+#define SMC_USE_PXA_DMA		1
+
+#define SMC_inb(a, r)		readb((a) + (r))
+#define SMC_inw(a, r)		readw((a) + (r))
+#define SMC_inl(a, r)		readl((a) + (r))
+#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
+#define SMC_outl(v, a, r)	writel(v, (a) + (r))
+#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
+
+/* We actually can't write halfwords properly if not word aligned */
+static inline void
+SMC_outw(u16 val, unsigned long ioaddr, int reg)
+{
+	if (reg & 2) {
+		unsigned int v = val << 16;
+		v |= readl(ioaddr + (reg & ~2)) & 0xffff;
+		writel(v, ioaddr + (reg & ~2));
+	} else {
+		writew(val, ioaddr + reg);
+	}
+}
+
+#ifndef SMC_USE_PXA_DMA
+#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
+#else
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+
+#define SMC_insl(a, r, p, l) \
+	    smc_pxa_dma_insl(a, lp->physaddr, r, dev->dma, p, l)
+static inline void
+    smc_pxa_dma_insl(u_long ioaddr, u_long physaddr, int reg, int dma,
+		     u_char *buf, int len)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (dma == (unsigned char)-1) 
+	{
+		readsw(ioaddr + reg, buf, len);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)buf & 6) 
+	{
+		*((u16 *)buf)++ = SMC_inw(ioaddr, reg);
+		len--;
+	}
+	
+	len *= 4;
+	dmabuf = dma_map_single(NULL, buf, len, DMA_FROM_DEVICE);
+	DCSR(dma) = DCSR_NODESC;
+	DTADR(dma) = dmabuf;
+	DSADR(dma) = physaddr + reg;
+	DCMD(dma) = (DCMD_INCTRGADDR | DCMD_BURST32 |
+		     DCMD_WIDTH4 | (DCMD_LENGTH & len));
+	DCSR(dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(dma) & DCSR_STOPSTATE));
+	DCSR(dma) = 0;
+	dma_unmap_single(NULL, dmabuf, len, DMA_FROM_DEVICE);
+}
+#endif
+
+#elif defined(CONFIG_ARCH_PXA_PNP2110_V1)
+#define SMC_CAN_USE_8BIT        0
+#define SMC_CAN_USE_16BIT       1
+#define SMC_CAN_USE_32BIT       0
+#define SMC_IO_SHIFT            0
+#define SMC_NOWAIT              1
+#define SMC_USE_PXA_DMA		1
+
+#define SMC_inw(a, r)		readw((a) + (r))
+#define SMC_outw(v, a, r)	writew(v, (a) + (r))
+#define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
+
+#ifndef SMC_USE_PXA_DMA
+#define SMC_insw(a, r, p, l)	insw((a) + (r), p, l)
+#else
+# include <linux/dma-mapping.h>
+#include <asm/dma.h>
+
+#define SMC_insw(a, r, p, l) \
+	    smc_pxa_dma_insw(a, lp->physaddr, r, dev->dma, p, l)
+static inline void
+    smc_pxa_dma_insw(u_long ioaddr, u_long physaddr, int reg, int dma,
+		     u_char *buf, int len)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (dma == (unsigned char)-1) 
+	{
+		readsw(ioaddr + reg, buf, len);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)buf & 6) 
+	{
+		*((u16 *)buf)++ = SMC_inw(ioaddr, reg);
+		len--;
+	}
+	
+	len *= 2;
+	dmabuf = dma_map_single(NULL, buf, len, DMA_FROM_DEVICE);
+	DCSR(dma) = DCSR_NODESC;
+	DTADR(dma) = dmabuf;
+	DSADR(dma) = physaddr + reg;
+	DCMD(dma) = (DCMD_INCTRGADDR | DCMD_BURST32 |
+		     DCMD_WIDTH2 | (DCMD_LENGTH & len));
+	DCSR(dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(dma) & DCSR_STOPSTATE));
+	DCSR(dma) = 0;
+	dma_unmap_single(NULL, dmabuf, len, DMA_FROM_DEVICE);
+}
+#endif
+
+#elif	defined(CONFIG_ISA)
+
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+
+#define SMC_inb(a, r)		inb((a) + (r))
+#define SMC_inw(a, r)		inw((a) + (r))
+#define SMC_outb(v, a, r)	outb(v, (a) + (r))
+#define SMC_outw(v, a, r)	outw(v, (a) + (r))
+#define SMC_insw(a, r, p, l)	insw((a) + (r), p, l)
+#define SMC_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#else
+
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	1
+#define SMC_NOWAIT		1
+
+#define SMC_inb(a, r)		readb((a) + (r))
+#define SMC_inw(a, r)		readw((a) + (r))
+#define SMC_inl(a, r)		readl((a) + (r))
+#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
+#define SMC_outw(v, a, r)	writew(v, (a) + (r))
+#define SMC_outl(v, a, r)	writel(v, (a) + (r))
+#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
+#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
+
+#define RPC_LSA_DEFAULT		RPC_LED_100_10
+#define RPC_LSB_DEFAULT		RPC_LED_TX_RX
+
+#endif
+
+/* Because of bank switching, the LAN91x uses only 16 I/O ports */
+#ifndef SMC_IO_SHIFT
+#define SMC_IO_SHIFT	0
+#endif
+#define SMC_IO_EXTENT	(16 << SMC_IO_SHIFT)
+
+
+/*
+ . Bank Select Register:
+ .
+ .		yyyy yyyy 0000 00xx
+ .		xx 		= bank number
+ .		yyyy yyyy	= 0x33, for identification purposes.
+*/
+#define BANK_SELECT		(14 << SMC_IO_SHIFT)
+
+
+// Transmit Control Register
+/* BANK 0  */
+#define TCR_REG 	SMC_REG(0x0000, 0)
+#define TCR_ENABLE	0x0001	// When 1 we can transmit
+#define TCR_LOOP	0x0002	// Controls output pin LBK
+#define TCR_FORCOL	0x0004	// When 1 will force a collision
+#define TCR_PAD_EN	0x0080	// When 1 will pad tx frames < 64 bytes w/0
+#define TCR_NOCRC	0x0100	// When 1 will not append CRC to tx frames
+#define TCR_MON_CSN	0x0400	// When 1 tx monitors carrier
+#define TCR_FDUPLX    	0x0800  // When 1 enables full duplex operation
+#define TCR_STP_SQET	0x1000	// When 1 stops tx if Signal Quality Error
+#define TCR_EPH_LOOP	0x2000	// When 1 enables EPH block loopback
+#define TCR_SWFDUP	0x8000	// When 1 enables Switched Full Duplex mode
+
+#define TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+#define TCR_DEFAULT	(TCR_ENABLE | TCR_PAD_EN)
+
+
+// EPH Status Register
+/* BANK 0  */
+#define EPH_STATUS_REG	SMC_REG(0x0002, 0)
+#define ES_TX_SUC	0x0001	// Last TX was successful
+#define ES_SNGL_COL	0x0002	// Single collision detected for last tx
+#define ES_MUL_COL	0x0004	// Multiple collisions detected for last tx
+#define ES_LTX_MULT	0x0008	// Last tx was a multicast
+#define ES_16COL	0x0010	// 16 Collisions Reached
+#define ES_SQET		0x0020	// Signal Quality Error Test
+#define ES_LTXBRD	0x0040	// Last tx was a broadcast
+#define ES_TXDEFR	0x0080	// Transmit Deferred
+#define ES_LATCOL	0x0200	// Late collision detected on last tx
+#define ES_LOSTCARR	0x0400	// Lost Carrier Sense
+#define ES_EXC_DEF	0x0800	// Excessive Deferral
+#define ES_CTR_ROL	0x1000	// Counter Roll Over indication
+#define ES_LINK_OK	0x4000	// Driven by inverted value of nLNK pin
+#define ES_TXUNRN	0x8000	// Tx Underrun
+
+
+// Receive Control Register
+/* BANK 0  */
+#define RCR_REG		SMC_REG(0x0004, 0)
+#define RCR_RX_ABORT	0x0001	// Set if a rx frame was aborted
+#define RCR_PRMS	0x0002	// Enable promiscuous mode
+#define RCR_ALMUL	0x0004	// When set accepts all multicast frames
+#define RCR_RXEN	0x0100	// IFF this is set, we can receive packets
+#define RCR_STRIP_CRC	0x0200	// When set strips CRC from rx packets
+#define RCR_ABORT_ENB	0x0200	// When set will abort rx on collision
+#define RCR_FILT_CAR	0x0400	// When set filters leading 12 bit s of carrier
+#define RCR_SOFTRST	0x8000 	// resets the chip
+
+/* the normal settings for the RCR register : */
+#define RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	// set it to a base state
+
+
+// Counter Register
+/* BANK 0  */
+#define COUNTER_REG	SMC_REG(0x0006, 0)
+
+
+// Memory Information Register
+/* BANK 0  */
+#define MIR_REG		SMC_REG(0x0008, 0)
+
+
+// Receive/Phy Control Register
+/* BANK 0  */
+#define RPC_REG		SMC_REG(0x000A, 0)
+#define RPC_SPEED	0x2000	// When 1 PHY is in 100Mbps mode.
+#define RPC_DPLX	0x1000	// When 1 PHY is in Full-Duplex Mode
+#define RPC_ANEG	0x0800	// When 1 PHY is in Auto-Negotiate Mode
+#define RPC_LSXA_SHFT	5	// Bits to shift LS2A,LS1A,LS0A to lsb
+#define RPC_LSXB_SHFT	2	// Bits to get LS2B,LS1B,LS0B to lsb
+#define RPC_LED_100_10	(0x00)	// LED = 100Mbps OR's with 10Mbps link detect
+#define RPC_LED_RES	(0x01)	// LED = Reserved
+#define RPC_LED_10	(0x02)	// LED = 10Mbps link detect
+#define RPC_LED_FD	(0x03)	// LED = Full Duplex Mode
+#define RPC_LED_TX_RX	(0x04)	// LED = TX or RX packet occurred
+#define RPC_LED_100	(0x05)	// LED = 100Mbps link dectect
+#define RPC_LED_TX	(0x06)	// LED = TX packet occurred
+#define RPC_LED_RX	(0x07)	// LED = RX packet occurred
+
+#ifndef RPC_LSA_DEFAULT
+#define RPC_LSA_DEFAULT	RPC_LED_100
+#endif
+#ifndef RPC_LSB_DEFAULT
+#define RPC_LSB_DEFAULT RPC_LED_FD
+#endif
+
+#define RPC_DEFAULT (RPC_ANEG | (RPC_LSA_DEFAULT << RPC_LSXA_SHFT) | (RPC_LSB_DEFAULT << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+
+
+/* Bank 0 0x0C is reserved */
+
+// Bank Select Register
+/* All Banks */
+#define BSR_REG		0x000E
+
+
+// Configuration Reg
+/* BANK 1 */
+#define CONFIG_REG	SMC_REG(0x0000,	1)
+#define CONFIG_EXT_PHY	0x0200	// 1=external MII, 0=internal Phy
+#define CONFIG_GPCNTRL	0x0400	// Inverse value drives pin nCNTRL
+#define CONFIG_NO_WAIT	0x1000	// When 1 no extra wait states on ISA bus
+#define CONFIG_EPH_POWER_EN 0x8000 // When 0 EPH is placed into low power mode.
+
+// Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+// Base Address Register
+/* BANK 1 */
+#define BASE_REG	SMC_REG(0x0002, 1)
+
+
+// Individual Address Registers
+/* BANK 1 */
+#define ADDR0_REG	SMC_REG(0x0004, 1)
+#define ADDR1_REG	SMC_REG(0x0006, 1)
+#define ADDR2_REG	SMC_REG(0x0008, 1)
+
+
+// General Purpose Register
+/* BANK 1 */
+#define GP_REG		SMC_REG(0x000A, 1)
+
+
+// Control Register
+/* BANK 1 */
+#define CTL_REG		SMC_REG(0x000C, 1)
+#define CTL_RCV_BAD	0x4000 // When 1 bad CRC packets are received
+#define CTL_AUTO_RELEASE 0x0800 // When 1 tx pages are released automatically
+#define CTL_LE_ENABLE	0x0080 // When 1 enables Link Error interrupt
+#define CTL_CR_ENABLE	0x0040 // When 1 enables Counter Rollover interrupt
+#define CTL_TE_ENABLE	0x0020 // When 1 enables Transmit Error interrupt
+#define CTL_EEPROM_SELECT 0x0004 // Controls EEPROM reload & store
+#define CTL_RELOAD	0x0002 // When set reads EEPROM into registers
+#define CTL_STORE	0x0001 // When set stores registers into EEPROM
+
+
+// MMU Command Register
+/* BANK 2 */
+#define MMU_CMD_REG	SMC_REG(0x0000, 2)
+#define MC_BUSY		1	// When 1 the last release has not completed
+#define MC_NOP		(0<<5)	// No Op
+#define MC_ALLOC	(1<<5) 	// OR with number of 256 byte packets
+#define MC_RESET	(2<<5)	// Reset MMU to initial state
+#define MC_REMOVE	(3<<5) 	// Remove the current rx packet
+#define MC_RELEASE  	(4<<5) 	// Remove and release the current rx packet
+#define MC_FREEPKT  	(5<<5) 	// Release packet in PNR register
+#define MC_ENQUEUE	(6<<5)	// Enqueue the packet for transmit
+#define MC_RSTTXFIFO	(7<<5)	// Reset the TX FIFOs
+
+
+// Packet Number Register
+/* BANK 2 */
+#define PN_REG		SMC_REG(0x0002, 2)
+
+
+// Allocation Result Register
+/* BANK 2 */
+#define AR_REG		SMC_REG(0x0003, 2)
+#define AR_FAILED	0x80	// Alocation Failed
+
+
+// TX FIFO Ports Register
+/* BANK 2 */
+#define TXFIFO_REG	SMC_REG(0x0004, 2)
+#define TXFIFO_TEMPTY	0x80	// TX FIFO Empty
+
+// RX FIFO Ports Register
+/* BANK 2 */
+#define RXFIFO_REG	SMC_REG(0x0005, 2)
+#define RXFIFO_REMPTY	0x80	// RX FIFO Empty
+
+#define FIFO_REG	SMC_REG(0x0004, 2)
+
+// Pointer Register
+/* BANK 2 */
+#define PTR_REG		SMC_REG(0x0006, 2)
+#define PTR_RCV		0x8000 // 1=Receive area, 0=Transmit area
+#define PTR_AUTOINC 	0x4000 // Auto increment the pointer on each access
+#define PTR_READ	0x2000 // When 1 the operation is a read
+
+
+// Data Register
+/* BANK 2 */
+#define DATA_REG	SMC_REG(0x0008, 2)
+
+
+// Interrupt Status/Acknowledge Register
+/* BANK 2 */
+#define INT_REG		SMC_REG(0x000C, 2)
+
+
+// Interrupt Mask Register
+/* BANK 2 */
+#define IM_REG		SMC_REG(0x000D, 2)
+#define IM_MDINT	0x80 // PHY MI Register 18 Interrupt
+#define IM_ERCV_INT	0x40 // Early Receive Interrupt
+#define IM_EPH_INT	0x20 // Set by Ethernet Protocol Handler section
+#define IM_RX_OVRN_INT	0x10 // Set by Receiver Overruns
+#define IM_ALLOC_INT	0x08 // Set when allocation request is completed
+#define IM_TX_EMPTY_INT	0x04 // Set if the TX FIFO goes empty
+#define IM_TX_INT	0x02 // Transmit Interrupt
+#define IM_RCV_INT	0x01 // Receive Interrupt
+
+
+// Multicast Table Registers
+/* BANK 3 */
+#define MCAST_REG1	SMC_REG(0x0000, 3)
+#define MCAST_REG2	SMC_REG(0x0002, 3)
+#define MCAST_REG3	SMC_REG(0x0004, 3)
+#define MCAST_REG4	SMC_REG(0x0006, 3)
+
+
+// Management Interface Register (MII)
+/* BANK 3 */
+#define MII_REG		SMC_REG(0x0008, 3)
+#define MII_MSK_CRS100	0x4000 // Disables CRS100 detection during tx half dup
+#define MII_MDOE	0x0008 // MII Output Enable
+#define MII_MCLK	0x0004 // MII Clock, pin MDCLK
+#define MII_MDI		0x0002 // MII Input, pin MDI
+#define MII_MDO		0x0001 // MII Output, pin MDO
+
+
+// Revision Register
+/* BANK 3 */
+/* ( hi: chip id   low: rev # ) */
+#define REV_REG		SMC_REG(0x000A, 3)
+
+
+// Early RCV Register
+/* BANK 3 */
+/* this is NOT on SMC9192 */
+#define ERCV_REG	SMC_REG(0x000C, 3)
+#define ERCV_RCV_DISCRD	0x0080 // When 1 discards a packet being received
+#define ERCV_THRESHOLD	0x001F // ERCV Threshold Mask
+
+
+// External Register
+/* BANK 7 */
+#define EXT_REG		SMC_REG(0x0000, 7)
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+static const char * chip_ids[ 16 ] =  {
+	NULL, NULL, NULL,
+	/* 3 */ "SMC91C90/91C92",
+	/* 4 */ "SMC91C94",
+	/* 5 */ "SMC91C95",
+	/* 6 */ "SMC91C96",
+	/* 7 */ "SMC91C100",
+	/* 8 */ "SMC91C100FD",
+	/* 9 */ "SMC91C11xFD",
+	NULL, NULL, NULL,
+	NULL, NULL, NULL};
+
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+/*
+ * PHY IDs
+ *  LAN83C183 == LAN91C111 Internal PHY
+ */
+#define PHY_LAN83C183	0x0016f840
+#define PHY_LAN83C180	0x02821c50
+
+/*
+ * PHY Register Addresses (LAN91C111 Internal PHY)
+ *
+ * Generic PHY registers can be found in <linux/mii.h>
+ *
+ * These phy registers are specific to our on-board phy.
+ */
+
+// PHY Configuration Register 1
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	// 1=Rx Link Detect Function disabled
+#define PHY_CFG1_XMTDIS		0x4000	// 1=TP Transmitter Disabled
+#define PHY_CFG1_XMTPDN		0x2000	// 1=TP Transmitter Powered Down
+#define PHY_CFG1_BYPSCR		0x0400	// 1=Bypass scrambler/descrambler
+#define PHY_CFG1_UNSCDS		0x0200	// 1=Unscramble Idle Reception Disable
+#define PHY_CFG1_EQLZR		0x0100	// 1=Rx Equalizer Disabled
+#define PHY_CFG1_CABLE		0x0080	// 1=STP(150ohm), 0=UTP(100ohm)
+#define PHY_CFG1_RLVL0		0x0040	// 1=Rx Squelch level reduced by 4.5db
+#define PHY_CFG1_TLVL_SHIFT	2	// Transmit Output Level Adjust
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	// Transmitter Rise/Fall time
+
+
+// PHY Configuration Register 2
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	// 1=Auto Polarity Correction disabled
+#define PHY_CFG2_JABDIS		0x0010	// 1=Jabber disabled
+#define PHY_CFG2_MREG		0x0008	// 1=Multiple register access (MII mgt)
+#define PHY_CFG2_INTMDIO	0x0004	// 1=Interrupt signaled with MDIO pulseo
+
+// PHY Status Output (and Interrupt status) Register
+#define PHY_INT_REG		0x12	// Status Output (Interrupt Status)
+#define PHY_INT_INT		0x8000	// 1=bits have changed since last read
+#define PHY_INT_LNKFAIL		0x4000	// 1=Link Not detected
+#define PHY_INT_LOSSSYNC	0x2000	// 1=Descrambler has lost sync
+#define PHY_INT_CWRD		0x1000	// 1=Invalid 4B5B code detected on rx
+#define PHY_INT_SSD		0x0800	// 1=No Start Of Stream detected on rx
+#define PHY_INT_ESD		0x0400	// 1=No End Of Stream detected on rx
+#define PHY_INT_RPOL		0x0200	// 1=Reverse Polarity detected
+#define PHY_INT_JAB		0x0100	// 1=Jabber detected
+#define PHY_INT_SPDDET		0x0080	// 1=100Base-TX mode, 0=10Base-T mode
+#define PHY_INT_DPLXDET		0x0040	// 1=Device in Full Duplex
+
+// PHY Interrupt/Status Mask Register
+#define PHY_MASK_REG		0x13	// Interrupt Mask
+// Uses the same bit definitions as PHY_INT_REG
+
+
+/*
+ * SMC91C96 ethernet config and status registers.
+ * These are in the "attribute" space.
+ */
+#define ECOR			0x8000
+#define ECOR_RESET		0x80
+#define ECOR_LEVEL_IRQ		0x40
+#define ECOR_WR_ATTRIB		0x04
+#define ECOR_ENABLE		0x01
+
+#define ECSR			0x8002
+#define ECSR_IOIS8		0x20
+#define ECSR_PWRDWN		0x04
+#define ECSR_INT		0x02
+
+#define ATTRIB_SIZE		((64*1024) << SMC_IO_SHIFT)
+
+
+/*
+ * Macros to abstract register access according to the data bus
+ * capabilities.  Please use those and not the in/out primitives.
+ * Note: the following macros do *not* select the bank -- this must
+ * be done separately as needed in the main code.  The SMC_REG() macro
+ * only uses the bank argument for debugging purposes (when enabled).
+ */
+
+#if SMC_DEBUG > 0
+#define SMC_REG(reg, bank)						\
+	({								\
+		int __b = SMC_CURRENT_BANK();				\
+		if (unlikely((__b & ~0xf0) != (0x3300 | bank))) {	\
+			printk( "%s: bank reg screwed (0x%04x)\n",	\
+				CARDNAME, __b );			\
+			BUG();						\
+		}							\
+		reg<<SMC_IO_SHIFT;					\
+	})
+#else
+#define SMC_REG(reg, bank)	(reg<<SMC_IO_SHIFT)
+#endif
+
+#if SMC_CAN_USE_8BIT
+#define SMC_GET_PN()		SMC_inb( ioaddr, PN_REG )
+#define SMC_SET_PN(x)		SMC_outb( x, ioaddr, PN_REG )
+#define SMC_GET_AR()		SMC_inb( ioaddr, AR_REG )
+#define SMC_GET_TXFIFO()	SMC_inb( ioaddr, TXFIFO_REG )
+#define SMC_GET_RXFIFO()	SMC_inb( ioaddr, RXFIFO_REG )
+#define SMC_GET_INT()		SMC_inb( ioaddr, INT_REG )
+#define SMC_ACK_INT(x)		SMC_outb( x, ioaddr, INT_REG )
+#define SMC_GET_INT_MASK()	SMC_inb( ioaddr, IM_REG )
+#define SMC_SET_INT_MASK(x)	SMC_outb( x, ioaddr, IM_REG )
+#else
+#define SMC_GET_PN()		(SMC_inw( ioaddr, PN_REG ) & 0xFF)
+#define SMC_SET_PN(x)		SMC_outw( x, ioaddr, PN_REG )
+#define SMC_GET_AR()		(SMC_inw( ioaddr, PN_REG ) >> 8)
+#define SMC_GET_TXFIFO()	(SMC_inw( ioaddr, TXFIFO_REG ) & 0xFF)
+#define SMC_GET_RXFIFO()	(SMC_inw( ioaddr, TXFIFO_REG ) >> 8)
+#define SMC_GET_INT()		(SMC_inw( ioaddr, INT_REG ) & 0xFF)
+#define SMC_ACK_INT(x)							\
+	do {								\
+		unsigned long __flags;					\
+		int __mask;						\
+		local_irq_save(__flags);				\
+		__mask = SMC_inw( ioaddr, INT_REG ) & ~0xff;		\
+		SMC_outw( __mask | (x), ioaddr, INT_REG );		\
+		local_irq_restore(__flags);				\
+	} while (0)
+#define SMC_GET_INT_MASK()	(SMC_inw( ioaddr, INT_REG ) >> 8)
+#define SMC_SET_INT_MASK(x)	SMC_outw( (x) << 8, ioaddr, INT_REG )
+#endif
+
+#define SMC_CURRENT_BANK()	SMC_inw( ioaddr, BANK_SELECT )
+#define SMC_SELECT_BANK(x)	SMC_outw( x, ioaddr, BANK_SELECT )
+#define SMC_GET_BASE()		SMC_inw( ioaddr, BASE_REG )
+#define SMC_SET_BASE(x)		SMC_outw( x, ioaddr, BASE_REG )
+#define SMC_GET_CONFIG()	SMC_inw( ioaddr, CONFIG_REG )
+#define SMC_SET_CONFIG(x)	SMC_outw( x, ioaddr, CONFIG_REG )
+#define SMC_GET_COUNTER()	SMC_inw( ioaddr, COUNTER_REG )
+#define SMC_GET_CTL()		SMC_inw( ioaddr, CTL_REG )
+#define SMC_SET_CTL(x)		SMC_outw( x, ioaddr, CTL_REG )
+#define SMC_GET_MII()		SMC_inw( ioaddr, MII_REG )
+#define SMC_SET_MII(x)		SMC_outw( x, ioaddr, MII_REG )
+#define SMC_GET_MIR()		SMC_inw( ioaddr, MIR_REG )
+#define SMC_SET_MIR(x)		SMC_outw( x, ioaddr, MIR_REG )
+#define SMC_GET_MMU_CMD()	SMC_inw( ioaddr, MMU_CMD_REG )
+#define SMC_SET_MMU_CMD(x)	SMC_outw( x, ioaddr, MMU_CMD_REG )
+#define SMC_GET_FIFO()		SMC_inw( ioaddr, FIFO_REG )
+#define SMC_GET_PTR()		SMC_inw( ioaddr, PTR_REG )
+#define SMC_SET_PTR(x)		SMC_outw( x, ioaddr, PTR_REG )
+#define SMC_GET_RCR()		SMC_inw( ioaddr, RCR_REG )
+#define SMC_SET_RCR(x)		SMC_outw( x, ioaddr, RCR_REG )
+#define SMC_GET_REV()		SMC_inw( ioaddr, REV_REG )
+#define SMC_GET_RPC()		SMC_inw( ioaddr, RPC_REG )
+#define SMC_SET_RPC(x)		SMC_outw( x, ioaddr, RPC_REG )
+#define SMC_GET_TCR()		SMC_inw( ioaddr, TCR_REG )
+#define SMC_SET_TCR(x)		SMC_outw( x, ioaddr, TCR_REG )
+
+#ifndef SMC_GET_MAC_ADDR
+#define SMC_GET_MAC_ADDR(addr)						\
+	do {								\
+		unsigned int __v;					\
+		__v = SMC_inw( ioaddr, ADDR0_REG );			\
+		addr[0] = __v; addr[1] = __v >> 8;			\
+		__v = SMC_inw( ioaddr, ADDR1_REG );			\
+		addr[2] = __v; addr[3] = __v >> 8;			\
+		__v = SMC_inw( ioaddr, ADDR2_REG );			\
+		addr[4] = __v; addr[5] = __v >> 8;			\
+	} while (0)
+#endif
+
+#define SMC_SET_MAC_ADDR(addr)						\
+	do {								\
+		SMC_outw( addr[0]|(addr[1] << 8), ioaddr, ADDR0_REG );	\
+		SMC_outw( addr[2]|(addr[3] << 8), ioaddr, ADDR1_REG );	\
+		SMC_outw( addr[4]|(addr[5] << 8), ioaddr, ADDR2_REG );	\
+	} while (0)
+
+#define SMC_CLEAR_MCAST()						\
+	do {								\
+		SMC_outw( 0, ioaddr, MCAST_REG1 );			\
+		SMC_outw( 0, ioaddr, MCAST_REG2 );			\
+		SMC_outw( 0, ioaddr, MCAST_REG3 );			\
+		SMC_outw( 0, ioaddr, MCAST_REG4 );			\
+	} while (0)
+#define SMC_SET_MCAST(x)						\
+	do {								\
+		unsigned char *mt = (x);				\
+		SMC_outw( mt[0] | (mt[1] << 8), ioaddr, MCAST_REG1 );	\
+		SMC_outw( mt[2] | (mt[3] << 8), ioaddr, MCAST_REG2 );	\
+		SMC_outw( mt[4] | (mt[5] << 8), ioaddr, MCAST_REG3 );	\
+		SMC_outw( mt[6] | (mt[7] << 8), ioaddr, MCAST_REG4 );	\
+	} while (0)
+
+#if SMC_CAN_USE_32BIT
+/*
+ * Some setups just can't write 8 or 16 bits reliably when not aligned
+ * to a 32 bit boundary.  I tell you that exists!
+ * We re-do the ones here that can be easily worked around if they can have
+ * their low parts written to 0 without adverse effects.
+ */
+#undef SMC_SELECT_BANK
+#define SMC_SELECT_BANK(x)	SMC_outl( (x)<<16, ioaddr, 12<<SMC_IO_SHIFT )
+#undef SMC_SET_RPC
+#define SMC_SET_RPC(x)		SMC_outl( (x)<<16, ioaddr, SMC_REG(8, 0) )
+#undef SMC_SET_PN
+#define SMC_SET_PN(x)		SMC_outl( (x)<<16, ioaddr, SMC_REG(0, 2) )
+#undef SMC_SET_PTR
+#define SMC_SET_PTR(x)		SMC_outl( (x)<<16, ioaddr, SMC_REG(4, 2) )
+#endif
+
+#if SMC_CAN_USE_32BIT
+#define SMC_PUT_PKT_HDR(status, length)					\
+	SMC_outl( (status) | (length) << 16, ioaddr, DATA_REG )
+#define SMC_GET_PKT_HDR(status, length)					\
+	do {								\
+		unsigned int __val = SMC_inl( ioaddr, DATA_REG );	\
+		(status) = __val & 0xffff;				\
+		(length) = __val >> 16;					\
+	} while (0)
+#else
+#define SMC_PUT_PKT_HDR(status, length)					\
+	do {								\
+		SMC_outw( status, ioaddr, DATA_REG );			\
+		SMC_outw( length, ioaddr, DATA_REG );			\
+	} while (0)
+#define SMC_GET_PKT_HDR(status, length)					\
+	do {								\
+		(status) = SMC_inw( ioaddr, DATA_REG );			\
+		(length) = SMC_inw( ioaddr, DATA_REG );			\
+	} while (0)
+#endif
+
+#if SMC_CAN_USE_32BIT
+#define SMC_PUSH_DATA(p, l)						\
+	do {								\
+		char *__ptr = (p);					\
+		int __len = (l);					\
+		if (__len >= 2 && (unsigned long)__ptr & 2) {		\
+			__len -= 2;					\
+			SMC_outw( *(u16 *)__ptr, ioaddr, DATA_REG );	\
+			__ptr += 2;					\
+		}							\
+		SMC_outsl( ioaddr, DATA_REG, __ptr, __len >> 2);	\
+		if (__len & 2) {					\
+			__ptr += (__len & ~3);				\
+			SMC_outw( *((u16 *)__ptr), ioaddr, DATA_REG );	\
+		}							\
+	} while (0)
+#define SMC_PULL_DATA(p, l)						\
+	do {								\
+		char *__ptr = (p);					\
+		int __len = (l);					\
+		if ((unsigned long)__ptr & 2) {				\
+			/*						\
+			 * We want 32bit alignment here.		\
+			 * Since some buses perform a full 32bit	\
+			 * fetch even for 16bit data we can't use	\
+			 * SMC_inw() here.  Back both source (on chip	\
+			 * and destination) pointers of 2 bytes.	\
+			 */						\
+			__ptr -= 2;					\
+			__len += 2;					\
+			SMC_SET_PTR( 2|PTR_READ|PTR_RCV|PTR_AUTOINC );	\
+		}							\
+		__len += 2;						\
+		SMC_insl( ioaddr, DATA_REG, __ptr, __len >> 2);		\
+	} while (0)
+#elif SMC_CAN_USE_16BIT
+#define SMC_PUSH_DATA(p, l)	SMC_outsw( ioaddr, DATA_REG, p, (l) >> 1 )
+#define SMC_PULL_DATA(p, l)	SMC_insw ( ioaddr, DATA_REG, p, (l) >> 1 )
+#elif SMC_CAN_USE_8BIT
+#define SMC_PUSH_DATA(p, l)	SMC_outsb( ioaddr, DATA_REG, p, l )
+#define SMC_PULL_DATA(p, l)	SMC_insb ( ioaddr, DATA_REG, p, l )
+#endif
+
+#if ! SMC_CAN_USE_16BIT
+#define SMC_outw(x, ioaddr, reg)					\
+	do {								\
+		unsigned int __val16 = (x);				\
+		SMC_outb( __val16, ioaddr, reg );			\
+		SMC_outb( __val16 >> 8, ioaddr, reg + (1 << SMC_IO_SHIFT));\
+	} while (0)
+#define SMC_inw(ioaddr, reg)						\
+	({								\
+		unsigned int __val16;					\
+		__val16 =  SMC_inb( ioaddr, reg );			\
+		__val16 |= SMC_inb( ioaddr, reg + (1 << SMC_IO_SHIFT)) << 8; \
+		__val16;						\
+	})
+#endif
+
+#if SMC_USE_PXA_DMA
+static void
+    smc_pxa_dma_irq(int dma, void *_lp, struct pt_regs *regs)
+{
+	DCSR(dma) = 0;
+}
+#endif
+
+#endif  /* _SMC91X_H_ */
Index: drivers/net/mii-dev.c
===================================================================
--- a/drivers/net/mii-dev.c	(revision 0)
+++ b/drivers/net/mii-dev.c	(revision 675)
@@ -0,0 +1,343 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/if_arp.h>
+#include <asm/io.h>
+#include <asm/arch/pxa-regs.h>
+
+#define NGE_MII_READ (2<<26)
+#define NGE_MII_WRITE (1<<26)
+#define NGE_MII_DATA_MASK 0xFFFF
+#define NGE_MII_PHYS_SHIFT 21
+#define NGE_MII_PHYS_MASK (0x1F << NGE_MII_PHYS_SHIFT)
+#define NGE_MII_REG_SHIFT 16
+#define NGE_MII_REG_MASK (0x1F << NGE_MII_REG_SHIFT)
+
+
+struct miidev_info;
+
+struct miidev_platform_info {
+	unsigned int numphys;
+	int (*mdio_read)(struct miidev_info *inf, int phy_id, int location);
+	void (*mdio_write)(struct miidev_info *inf, int phy_id, int location, int value);
+};
+
+struct miidev_info {
+	unsigned int physid;
+	unsigned long base;
+	struct miidev_platform_info *platform_info;
+	int (*mdio_read)(struct miidev_info *inf, int phy_id, int location);
+	void (*mdio_write)(struct miidev_info *inf, int phy_id, int location, int value);
+	struct net_device *ndev;
+	struct mii_if_info mii;
+};
+
+static int mdio_read (struct net_device *ndev, int phy_id, int location)
+{
+	struct miidev_info *inf = (struct miidev_info *)ndev->priv;
+	return inf->mdio_read(inf, phy_id, location);
+}
+
+static void mdio_write (struct net_device *ndev, int phy_id, int location,
+			int value)
+{
+	struct miidev_info *inf = (struct miidev_info *)ndev->priv;
+	inf->mdio_write(inf, phy_id, location, value);
+}
+
+static int miidev_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	return -1;
+}
+
+static int miidev_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)
+{
+	struct miidev_info *inf = (struct miidev_info *)ndev->priv;
+	int rc;
+
+	rc = generic_mii_ioctl(&inf->mii, if_mii(ifr), cmd, NULL);
+
+	return rc;
+}
+
+static int miidev_open(struct net_device *ndev)
+{
+	return -ENODEV;
+}
+
+static int miidev_stop(struct net_device *ndev)
+{
+	return 0;
+}
+
+static void miidev_setup(struct net_device *dev) {
+	dev->open            = miidev_open;
+	dev->stop            = miidev_stop;
+	dev->do_ioctl        = miidev_ioctl;
+	dev->hard_start_xmit = miidev_hard_start_xmit;
+	dev->type		= ARPHRD_VOID;
+	dev->mtu		= 0;		/* can_mtu */
+	dev->tx_queue_len	= 0;
+	
+	/* New-style flags. */
+	dev->flags		= IFF_NOARP;
+}
+
+static int miidev_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct miidev_platform_info 	*platform_inf;
+	struct miidev_info *inf = NULL;
+	struct resource *res;
+	struct net_device *ndev;
+	unsigned long addr;
+	int err;
+
+	platform_inf = dev->platform_data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if( !res )
+		return -ENODEV;
+
+	/*
+	 * Request the regions.
+	 */
+	err = -EBUSY;
+	if (!request_mem_region(res->start, res->end - res->start + 1, "miidev")) {
+		return -ENOMEM;
+	}
+
+	addr = (unsigned long)ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!addr) {
+		goto exit_release;
+	}
+
+	ndev = alloc_netdev(sizeof(struct miidev_info), "sw%d", miidev_setup);
+
+	if (!ndev) {
+		dev_err(dev, "could not allocate device\n");
+		goto exit;
+	}
+
+	inf = ndev->priv;
+	inf->base = addr;
+	inf->ndev = ndev;
+
+	inf->mdio_read = platform_inf->mdio_read;
+	inf->mdio_write = platform_inf->mdio_write;
+	inf->mii.dev = ndev;
+	inf->mii.mdio_read = mdio_read;
+	inf->mii.mdio_write = mdio_write;
+	inf->mii.phy_id = 0;
+	inf->mii.phy_id_mask = 0x1f;
+	inf->mii.reg_num_mask = 0x1f;
+
+	dev_set_drvdata(dev, inf);
+
+	ndev->base_addr = addr;
+	ndev->priv = inf;
+
+	err = register_netdev(ndev);
+	if (err) {
+		printk("register_netdev failed\n");
+		return -1;
+	}
+
+	return 0;
+
+exit_release:
+	release_mem_region(res->start, res->end - res->start + 1);
+exit:
+	return -ENODEV;
+}
+
+static int miidev_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct miidev_info 	*inf;
+	struct resource *res;
+	int i=0;
+
+	inf = dev_get_drvdata(dev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	dev_set_drvdata(dev, NULL);
+
+	iounmap((void *)inf->base);
+
+	struct net_device *ndev = inf->ndev;
+	printk("releasing dev %d\n",i++);
+
+	unregister_netdev(ndev);
+	free_netdev(ndev);
+
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int miidev_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	printk ("%s\n", __FUNCTION__);
+	return 0;
+}
+
+static int miidev_drv_resume(struct device *dev, u32 level)
+{
+	printk ("%s\n", __FUNCTION__);
+	return 0;
+}
+#endif 	/* CONFIG_PM */
+
+static int nge_mdio_read(struct miidev_info *inf, int phy_id, int location)
+{
+	unsigned long val;
+
+	val = NGE_MII_READ |
+	      ((phy_id << NGE_MII_PHYS_SHIFT) & NGE_MII_PHYS_MASK) |
+	      ((location << NGE_MII_REG_SHIFT) & NGE_MII_REG_MASK);
+
+	*(volatile unsigned long*)inf->base = val;
+	udelay(100);
+
+	val = (*(volatile unsigned long*)inf->base);
+
+//	printk("%s: phy_id: 0x%08x location: 0x%08x value: 0x%08x\n",__FUNCTION__,phy_id,
+//								location, val);
+
+	return val & NGE_MII_DATA_MASK;
+}
+
+static void nge_mdio_write(struct miidev_info *inf, int phy_id, int location, int value)
+{
+	unsigned long val;
+
+//	printk("%s: phy_id: 0x%08x location: 0x%08x value: 0x%08x\n",__FUNCTION__,phy_id,
+//								location, value);
+
+	val = NGE_MII_WRITE |
+	      ((phy_id << NGE_MII_PHYS_SHIFT) & NGE_MII_PHYS_MASK) |
+	      ((location << NGE_MII_REG_SHIFT) & NGE_MII_REG_MASK) |
+	      (value & NGE_MII_DATA_MASK);
+
+	*(volatile unsigned long*)inf->base = val;
+}
+
+
+static struct device_driver miidev_driver = {
+	.name		= "miidev",
+	.bus		= &platform_bus_type,
+	.probe		= miidev_drv_probe,
+	.remove		= miidev_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= miidev_drv_suspend,
+	.resume		= miidev_drv_resume,
+#endif	/* CONFIG_PM */
+};
+
+static struct resource  nge_miidev_resources_1[] = {
+        [0] = {
+                .start  = PXA_CS4_PHYS + 0x1800,
+                .end    = PXA_CS4_PHYS + 0x1803,
+                .flags  = IORESOURCE_MEM,
+        },
+};
+
+static struct resource  nge_miidev_resources_2[] = {
+        [0] = {
+                .start  = PXA_CS4_PHYS + 0x1804,
+                .end    = PXA_CS4_PHYS + 0x1807,
+                .flags  = IORESOURCE_MEM,
+        },
+};
+
+static struct resource  nge_miidev_resources_3[] = {
+        [0] = {
+                .start  = PXA_CS4_PHYS + 0x1808,
+                .end    = PXA_CS4_PHYS + 0x180b,
+                .flags  = IORESOURCE_MEM,
+        },
+};
+
+struct miidev_platform_info nge_miidev_platform_info = {
+	.mdio_read = nge_mdio_read,
+	.mdio_write = nge_mdio_write,
+};
+
+static void miidev_release(struct device *dev)
+{
+}
+
+static struct platform_device nge_miidev_device_1 = {
+        .name           = "miidev",
+        .id             = 0,
+        .dev            = {
+                .platform_data  = &nge_miidev_platform_info,
+		.release = miidev_release,
+        },
+        .num_resources  = ARRAY_SIZE(nge_miidev_resources_1),
+        .resource       = nge_miidev_resources_1,
+};
+
+static struct platform_device nge_miidev_device_2 = {
+        .name           = "miidev",
+        .id             = 1,
+        .dev            = {
+                .platform_data  = &nge_miidev_platform_info,
+		.release = miidev_release,
+        },
+        .num_resources  = ARRAY_SIZE(nge_miidev_resources_2),
+        .resource       = nge_miidev_resources_2,
+};
+
+static struct platform_device nge_miidev_device_3 = {
+        .name           = "miidev",
+        .id             = 2,
+        .dev            = {
+                .platform_data  = &nge_miidev_platform_info,
+		.release = miidev_release,
+        },
+        .num_resources  = ARRAY_SIZE(nge_miidev_resources_3),
+        .resource       = nge_miidev_resources_3,
+};
+
+static int __init miidev_init_module (void)
+{
+	int err;
+
+	printk ("miidev initializing\n");
+
+	err = platform_device_register(&nge_miidev_device_1);
+	err = platform_device_register(&nge_miidev_device_2);
+	err = platform_device_register(&nge_miidev_device_3);
+	if(err < 0) {
+		printk("register platform device failed\n");
+		return err;
+	}
+
+	return driver_register(&miidev_driver);
+}
+
+
+static void __exit miidev_cleanup_module (void)
+{
+	driver_unregister(&miidev_driver);
+	platform_device_unregister(&nge_miidev_device_1);
+	platform_device_unregister(&nge_miidev_device_2);
+	platform_device_unregister(&nge_miidev_device_3);
+}
+
+module_init(miidev_init_module);
+module_exit(miidev_cleanup_module);
+
+MODULE_AUTHOR("Sascha Hauer, Pengutronix");
+MODULE_LICENSE("GPL");
Index: drivers/net/Kconfig
===================================================================
--- a/drivers/net/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/net/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -197,6 +197,10 @@
 	  or internal device.  It is safe to say Y or M here even if your
 	  ethernet card lack MII.
 
+config MII_DEV
+	tristate "support for mii-only devices"
+	depends on MII
+
 source "drivers/net/arm/Kconfig"
 
 config MACE
@@ -816,7 +820,7 @@
 	  will be called smc-ultra32.
 
 config SMC91X
-	tristate "SMC 91C9x/91C1xxx support"
+	tristate "SMC 91C9x/91C1xxx support (new 2.6.10-rc3 driver)"
 	select CRC32
 	select MII
 	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R)
@@ -833,22 +837,22 @@
 	  module, say M here and read <file:Documentation/modules.txt> as well
 	  as <file:Documentation/networking/net-modules.txt>.
 
-config SMC9194
-	tristate "SMC 9194 support"
-	depends on NET_VENDOR_SMC && (ISA || MAC && BROKEN)
-	select CRC32
-	---help---
-	  This is support for the SMC9xxx based Ethernet cards. Choose this
-	  option if you have a DELL laptop with the docking station, or
-	  another SMC9192/9194 based chipset.  Say Y if you want it compiled
-	  into the kernel, and read the file
-	  <file:Documentation/networking/smc9.txt> and the Ethernet-HOWTO,
-	  available from <http://www.tldp.org/docs.html#howto>.
+config SMC91X_OLD
+	bool "use old SMC 91C9x/91C1xxx driver"
+	depends on SMC91X
 
-	  To compile this driver as a module, choose M here and read
-	  <file:Documentation/networking/net-modules.txt>. The module
-	  will be called smc9194.
+config SMC91X_NAPI
+	bool "SMC 91C9x/91C1xxx NAPI support"
+	depends on SMC91X
+	help
+	  NAPI support for SMC's 91x series of Ethernet chipsets.
 
+config SMC91X_HAL
+	bool "SMC 91C9x/91C1xxx new HAL"
+	depends on SMC91X
+	help
+	  HAL support for SMC's 91x series of Ethernet chipsets.
+
 config NET_VENDOR_RACAL
 	bool "Racal-Interlan (Micom) NI cards"
 	depends on NET_ETHERNET && ISA
@@ -1368,6 +1372,18 @@
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called cs89x.
 
+config CIRRUS
+	tristate "CS89x0 support (ARM driver)"
+	depends on ARM
+	---help---
+	  Support for CS89x0 chipsets based Ethernet cards. If you have a
+	  network (Ethernet) card of this type, say Y and read the
+	  Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto> as well as
+	  <file:Documentation/networking/cs89x0.txt>.
+
+	  This is the ARM driver from 2.4.
+
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && TOSHIBA_JMR3927
Index: drivers/net/smc91x_hal.h
===================================================================
--- a/drivers/net/smc91x_hal.h	(revision 0)
+++ b/drivers/net/smc91x_hal.h	(revision 675)
@@ -0,0 +1,990 @@
+/*------------------------------------------------------------------------
+ . smc91x.h - macros for SMSC's 91C9x/91C1xx single-chip Ethernet device.
+ .
+ . Copyright (C) 1996 by Erik Stahlman
+ . Copyright (C) 2001 Standard Microsystems Corporation
+ .	Developed by Simple Network Magic Corporation
+ . Copyright (C) 2003 Monta Vista Software, Inc.
+ .	Unified SMC91x driver by Nicolas Pitre
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ . Authors
+ .	Erik Stahlman		<erik@vt.edu>
+ .	Daris A Nevil		<dnevil@snmc.com>
+ .	Nicolas Pitre 		<nico@cam.org>
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC91X_H_
+#define _SMC91X_H_
+
+struct smc_hal {
+	u32	shift;
+	u32	nowait:1;
+	u32	width:2;
+	u8 (*readb)(unsigned long);
+	u16 (*readw)(unsigned long);
+	u32 (*readl)(unsigned long);
+	void (*writeb) (u8, unsigned long);
+	void (*writew) (u16, unsigned long);
+	void (*writel) (u32, unsigned long);
+	void (*reads) (unsigned int, void *, int);
+	void (*writes) (unsigned int, void *, int);
+};
+
+/* store this information for the driver.. */
+struct smc_local 
+{
+	/* for old NAPI driver */
+#ifdef CONFIG_SMC91X_HAL
+	struct sk_buff *saved_skb;
+#endif
+	/*
+	 * If I have to wait until memory is available to send a
+	 * packet, I will store the skbuff here, until I get the
+	 * desired memory.  Then, I'll send it out and free it.
+	 */
+	struct sk_buff *pending_tx_skb;
+	struct tasklet_struct tx_task;
+	
+	/*
+	 * these are things that the kernel wants me to keep, so users
+	 * can find out semi-useless statistics of how well the card is
+	 * performing
+	 */
+	struct net_device_stats stats;
+	
+	/* version/revision of the SMC91x chip */
+	int     version;
+	
+	/* Contains the current active transmission mode */
+	int     tcr_cur_mode;
+	
+	/* Contains the current active receive mode */
+	int     rcr_cur_mode;
+	
+	/* Contains the current active receive/phy mode */
+	int     rpc_cur_mode;
+	int     ctl_rfduplx;
+	int     ctl_rspeed;
+	
+	u32     msg_enable;
+	u32     phy_type;
+	struct mii_if_info mii;
+	
+	/* work queue */
+	struct work_struct phy_configure;
+	int     work_pending;
+	
+	spinlock_t lock;
+	
+	struct smc_hal hal;
+	
+	u_long attrib_phys;
+	
+	/* DMA needs the physical address of the chip */
+	u_long physaddr;
+};
+	
+static inline u8 smc_readb (unsigned long a){return readb (a);}
+static inline u16 smc_readw (unsigned long a){return readw (a);}
+static inline u32 smc_readl (unsigned long a){return readl (a);}
+static inline void smc_writeb (u8 v, unsigned long a) {writeb (v, a);}
+static inline void smc_writew (u16 v, unsigned long a) {writew (v, a);}
+static inline void smc_writel (u32 v, unsigned long a) {writel (v, a);}
+static inline void smc_readsb (unsigned int a, void *b, int l) {readsb ((void __iomem*)a, b, l);}
+static inline void smc_readsw (unsigned int a, void *b, int l) {readsw ((void __iomem*)a, b, l);}
+static inline void smc_readsl (unsigned int a, void *b, int l) {readsl ((void __iomem*)a, b, l);}
+static inline void smc_writesb (unsigned int a, void *b, int l) {writesb ((void __iomem*)a, b, l);}
+static inline void smc_writesw (unsigned int a, void *b, int l) {writesw ((void __iomem*)a, b, l);}
+static inline void smc_writesl (unsigned int a, void *b, int l) {writesl ((void __iomem*)a, b, l);}
+
+#define SMC_IO_SHIFT		lp->hal.shift
+#define SMC_NOWAIT		lp->hal.nowait
+
+static inline u8 SMC_rb (struct smc_local *lp, unsigned long a)
+{
+	return (*(lp->hal.readb)) (a);
+}
+static inline u16 SMC_rw (struct smc_local *lp, unsigned long a)
+{
+	return (*(lp->hal.readw)) (a);
+}
+static inline u32 SMC_rl (struct smc_local *lp, unsigned long a)
+{
+	return (*(lp->hal.readl)) (a);
+}
+
+static inline void SMC_wb (struct smc_local *lp, u8 v, unsigned long a)
+{
+	return (*(lp->hal.writeb)) (v, a);
+}
+static inline void SMC_ww (struct smc_local *lp, u16 v, unsigned long a)
+{
+	return (*(lp->hal.writew)) (v, a);
+}
+static inline void SMC_wl (struct smc_local *lp, u32 v, unsigned long a)
+{
+	return (*(lp->hal.writel)) (v, a);
+}
+
+#define SMC_inb(a, r)           (SMC_rb (lp, (a) + (r)))
+#define SMC_inw(a, r)           (SMC_rw (lp, (a) + (r)))
+#define SMC_inl(a, r)           (SMC_rl (lp, (a) + (r)))
+#define SMC_outb(v, a, r)       (SMC_wb (lp, v, (a) + (r)))
+#define SMC_outw(v, a, r)       (SMC_ww (lp, v, (a) + (r)))
+#define SMC_outl(v, a, r)       (SMC_wl (lp, v, (a) + (r)))
+
+/*
+ * Define your architecture specific bus configuration parameters here.
+ */
+
+#if	defined(CONFIG_SA1100_GRAPHICSCLIENT) || \
+	defined(CONFIG_SA1100_PFS168) || \
+	defined(CONFIG_SA1100_FLEXANET) || \
+	defined(CONFIG_SA1100_GRAPHICSMASTER) || \
+	defined(CONFIG_ARCH_LUBBOCK)
+
+void smc_set_hal (struct smc_local *lp)
+{
+	/* We can only do 16-bit reads and writes in the static memory space. */
+	/* The first two address lines aren't connected... */
+	lp->hal.shift = 2;
+	lp->hal.nowait = 1;
+	lp->hal.width = 1;
+	lp->hal.readw = smc_readw;
+	lp->hal.writew = smc_writew;
+	lp->hal.reads = smc_readsw;
+	lp->hal.writes = smc_writesw;
+}
+
+#elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6)
+# error FIXME: make function
+# define SMC_insw_redwood(a, r, p, l) 					\
+	do {								\
+		unsigned long __port = (a) + (r);			\
+		u16 *__p = (u16 *)(p);					\
+		int __l = (l);						\
+		insw(__port, __p, __l);					\
+		while (__l > 0) {					\
+			*__p = swab16(*__p);				\
+			__p++;						\
+			__l--;						\
+		}							\
+	} while (0)
+#define SMC_outsw_redwood(a, r, p, l) 					\
+	do {								\
+		unsigned long __port = (a) + (r);			\
+		u16 *__p = (u16 *)(p);					\
+		int __l = (l);						\
+		while (__l > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			outw( /* swab16 */ (*__p++), __port);		\
+			__l--;						\
+		}							\
+	} while (0)
+
+void smc_set_hal (struct smc_local *lp)
+{
+	/* We can only do 16-bit reads and writes in the static memory space. */
+	lp->hal.shift = 0;
+	lp->hal.nowait = 1;
+	lp->hal.width = 1;
+	lp->hal.read.w = in_be16;
+	lp->hal.write.w = out_be16;
+	lp->hal.reads = smc_insw_redwood;
+	lp->hal.writes = smc_outsw_redwood;
+}
+
+#define set_irq_type(irq, type)
+
+#elif defined(CONFIG_SA1100_ASSABET)
+
+#include <asm/arch/neponset.h>
+
+void smc_set_hal (struct smc_local *lp)
+{
+	/* We can only do 8-bit reads and writes in the static memory space. */
+	/* The first two address lines aren't connected... */
+	lp->hal.shift = 2;
+	lp->hal.nowait = 1;
+	lp->hal.width = 0;
+	lp->hal.readb = smc_readb;
+	lp->hal.writeb = smc_writeb;
+	lp->hal.reads = smc_readsb;
+	lp->hal.writes = smc_writesb;
+}
+
+#elif	defined(CONFIG_ARCH_INNOKOM) || \
+	defined(CONFIG_MACH_MAINSTONE) || \
+	defined(CONFIG_ARCH_PXA_IDP) || \
+	defined(CONFIG_ARCH_RAMSES) || \
+	defined(CONFIG_ARCH_PXA_PNP2110_V2)
+
+/* We actually can't write halfwords properly if not word aligned */
+static inline void
+smc_pxa_writew(u16 val, unsigned long ioaddr)
+{
+	if (ioaddr & 2) {
+		unsigned int v = val << 16;
+		v |= readl(ioaddr & ~2) & 0xffff;
+		writel(v, ioaddr & ~2);
+	} else {
+		writew(val, ioaddr);
+	}
+}
+
+void smc_set_hal (struct smc_local *lp)
+{
+	lp->hal.shift = 0;
+	lp->hal.nowait = 0;
+	lp->hal.width = 2;
+	lp->hal.readw = smc_readw;
+	lp->hal.writew = smc_pxa_writew;
+	lp->hal.readl = smc_readl;
+	lp->hal.writel = smc_writel;
+	lp->hal.reads = smc_readsl;
+	lp->hal.writes = smc_writesl;
+}
+
+//FIXME: enable DMA
+//#define SMC_USE_PXA_DMA		1
+
+#ifdef SMC_USE_PXA_DMA
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+
+#define SMC_insl(a, r, p, l) \
+	    smc_pxa_dma_insl(a, lp->physaddr, r, dev->dma, p, l)
+static inline void
+    smc_pxa_dma_insl(u_long ioaddr, u_long physaddr, int reg, int dma,
+		     u_char *buf, int len)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (dma == (unsigned char)-1) 
+	{
+		readsw(ioaddr + reg, buf, len);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)buf & 6) 
+	{
+		*((u16 *)buf)++ = SMC_inw(ioaddr, reg);
+		len--;
+	}
+	
+	len *= 4;
+	dmabuf = dma_map_single(NULL, buf, len, DMA_FROM_DEVICE);
+	DCSR(dma) = DCSR_NODESC;
+	DTADR(dma) = dmabuf;
+	DSADR(dma) = physaddr + reg;
+	DCMD(dma) = (DCMD_INCTRGADDR | DCMD_BURST32 |
+		     DCMD_WIDTH4 | (DCMD_LENGTH & len));
+	DCSR(dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(dma) & DCSR_STOPSTATE));
+	DCSR(dma) = 0;
+	dma_unmap_single(NULL, dmabuf, len, DMA_FROM_DEVICE);
+}
+#endif
+
+#elif defined(CONFIG_ARCH_PXA_PNP2110_V1)
+//#define SMC_USE_PXA_DMA		1
+
+#ifdef SMC_USE_PXA_DMA
+
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+
+static inline void
+    smc_pxa_dma_insw(u_long ioaddr, u_char *buf, int len)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (dev->dma == (unsigned char)-1) 
+	{
+		readsw(ioaddr, buf, len);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)buf & 6) 
+	{
+		*((u16 *)buf)++ = SMC_inw(ioaddr, reg);
+		len--;
+	}
+	
+	len *= 2;
+	dmabuf = dma_map_single(NULL, buf, len, DMA_FROM_DEVICE);
+	DCSR(dev->dma) = DCSR_NODESC;
+	DTADR(dev->dma) = dmabuf;
+	DSADR(dev->dma) = lp->physaddr + ioaddr - dev->base_addr;
+	DCMD(dev->dma) = (DCMD_INCTRGADDR | DCMD_BURST32 |
+		     DCMD_WIDTH2 | (DCMD_LENGTH & len));
+	DCSR(dev->dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(dev->dma) & DCSR_STOPSTATE));
+	DCSR(dev->dma) = 0;
+	dma_unmap_single(NULL, dmabuf, len, DMA_FROM_DEVICE);
+}
+#endif
+
+void smc_set_hal (struct smc_local *lp)
+{
+	lp->hal.shift = 0;
+	lp->hal.nowait = 1;
+	lp->hal.width = 1;
+	lp->hal.readw = smc_readw;
+	lp->hal.writew = smc_writew;
+#ifndef SMC_USE_PXA_DMA
+	lp->hal.reads = smc_readsw;
+#else
+	lp->hal.reads = smc_pxa_dma_insw;
+#endif	
+	lp->hal.writes = smc_writesw;
+}
+
+#elif	defined(CONFIG_ISA)
+
+void smc_set_hal (struct smc_local *lp)
+{
+	lp->hal.shift = 0;
+	lp->hal.nowait = 1;
+	lp->hal.width = 1;
+	lp->hal.readb = smc_readw;
+	lp->hal.writeb = smc_writeb;
+	lp->hal.readw = smc_readw;
+	lp->hal.writew = smc_writew;
+	lp->hal.reads = smc_readsw;
+	lp->hal.writes = smc_writesw;
+}
+
+#else
+
+void smc_set_hal (struct smc_local *lp)
+{
+	lp->hal.shift = 0;
+	lp->hal.nowait = 1;
+	lp->hal.width = 2;
+	lp->hal.readb = smc_readw;
+	lp->hal.writeb = smc_writeb;
+	lp->hal.readw = smc_readw;
+	lp->hal.writew = smc_writew;
+	lp->hal.reads = smc_readsw;
+	lp->hal.writes = smc_writesw;
+}
+
+#define RPC_LSA_DEFAULT		RPC_LED_100_10
+#define RPC_LSB_DEFAULT		RPC_LED_TX_RX
+
+#endif
+
+/* Because of bank switching, the LAN91x uses only 16 I/O ports */
+#define SMC_IO_EXTENT	(16 << SMC_IO_SHIFT)
+
+/*
+ . Bank Select Register:
+ .
+ .		yyyy yyyy 0000 00xx
+ .		xx 		= bank number
+ .		yyyy yyyy	= 0x33, for identification purposes.
+*/
+#define BANK_SELECT		(14 << SMC_IO_SHIFT)
+
+
+// Transmit Control Register
+/* BANK 0  */
+#define TCR_REG 	SMC_REG(0x0000, 0)
+#define TCR_ENABLE	0x0001	// When 1 we can transmit
+#define TCR_LOOP	0x0002	// Controls output pin LBK
+#define TCR_FORCOL	0x0004	// When 1 will force a collision
+#define TCR_PAD_EN	0x0080	// When 1 will pad tx frames < 64 bytes w/0
+#define TCR_NOCRC	0x0100	// When 1 will not append CRC to tx frames
+#define TCR_MON_CSN	0x0400	// When 1 tx monitors carrier
+#define TCR_FDUPLX    	0x0800  // When 1 enables full duplex operation
+#define TCR_STP_SQET	0x1000	// When 1 stops tx if Signal Quality Error
+#define TCR_EPH_LOOP	0x2000	// When 1 enables EPH block loopback
+#define TCR_SWFDUP	0x8000	// When 1 enables Switched Full Duplex mode
+
+#define TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+#define TCR_DEFAULT	(TCR_ENABLE | TCR_PAD_EN)
+
+
+// EPH Status Register
+/* BANK 0  */
+#define EPH_STATUS_REG	SMC_REG(0x0002, 0)
+#define ES_TX_SUC	0x0001	// Last TX was successful
+#define ES_SNGL_COL	0x0002	// Single collision detected for last tx
+#define ES_MUL_COL	0x0004	// Multiple collisions detected for last tx
+#define ES_LTX_MULT	0x0008	// Last tx was a multicast
+#define ES_16COL	0x0010	// 16 Collisions Reached
+#define ES_SQET		0x0020	// Signal Quality Error Test
+#define ES_LTXBRD	0x0040	// Last tx was a broadcast
+#define ES_TXDEFR	0x0080	// Transmit Deferred
+#define ES_LATCOL	0x0200	// Late collision detected on last tx
+#define ES_LOSTCARR	0x0400	// Lost Carrier Sense
+#define ES_EXC_DEF	0x0800	// Excessive Deferral
+#define ES_CTR_ROL	0x1000	// Counter Roll Over indication
+#define ES_LINK_OK	0x4000	// Driven by inverted value of nLNK pin
+#define ES_TXUNRN	0x8000	// Tx Underrun
+
+
+// Receive Control Register
+/* BANK 0  */
+#define RCR_REG		SMC_REG(0x0004, 0)
+#define RCR_RX_ABORT	0x0001	// Set if a rx frame was aborted
+#define RCR_PRMS	0x0002	// Enable promiscuous mode
+#define RCR_ALMUL	0x0004	// When set accepts all multicast frames
+#define RCR_RXEN	0x0100	// IFF this is set, we can receive packets
+#define RCR_STRIP_CRC	0x0200	// When set strips CRC from rx packets
+#define RCR_ABORT_ENB	0x0200	// When set will abort rx on collision
+#define RCR_FILT_CAR	0x0400	// When set filters leading 12 bit s of carrier
+#define RCR_SOFTRST	0x8000 	// resets the chip
+
+/* the normal settings for the RCR register : */
+#define RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	// set it to a base state
+
+
+// Counter Register
+/* BANK 0  */
+#define COUNTER_REG	SMC_REG(0x0006, 0)
+
+
+// Memory Information Register
+/* BANK 0  */
+#define MIR_REG		SMC_REG(0x0008, 0)
+
+
+// Receive/Phy Control Register
+/* BANK 0  */
+#define RPC_REG		SMC_REG(0x000A, 0)
+#define RPC_SPEED	0x2000	// When 1 PHY is in 100Mbps mode.
+#define RPC_DPLX	0x1000	// When 1 PHY is in Full-Duplex Mode
+#define RPC_ANEG	0x0800	// When 1 PHY is in Auto-Negotiate Mode
+#define RPC_LSXA_SHFT	5	// Bits to shift LS2A,LS1A,LS0A to lsb
+#define RPC_LSXB_SHFT	2	// Bits to get LS2B,LS1B,LS0B to lsb
+#define RPC_LED_100_10	(0x00)	// LED = 100Mbps OR's with 10Mbps link detect
+#define RPC_LED_RES	(0x01)	// LED = Reserved
+#define RPC_LED_10	(0x02)	// LED = 10Mbps link detect
+#define RPC_LED_FD	(0x03)	// LED = Full Duplex Mode
+#define RPC_LED_TX_RX	(0x04)	// LED = TX or RX packet occurred
+#define RPC_LED_100	(0x05)	// LED = 100Mbps link dectect
+#define RPC_LED_TX	(0x06)	// LED = TX packet occurred
+#define RPC_LED_RX	(0x07)	// LED = RX packet occurred
+
+#ifndef RPC_LSA_DEFAULT
+#define RPC_LSA_DEFAULT	RPC_LED_100
+#endif
+#ifndef RPC_LSB_DEFAULT
+#define RPC_LSB_DEFAULT RPC_LED_FD
+#endif
+
+#define RPC_DEFAULT (RPC_ANEG | (RPC_LSA_DEFAULT << RPC_LSXA_SHFT) | (RPC_LSB_DEFAULT << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+
+
+/* Bank 0 0x0C is reserved */
+
+// Bank Select Register
+/* All Banks */
+#define BSR_REG		0x000E
+
+
+// Configuration Reg
+/* BANK 1 */
+#define CONFIG_REG	SMC_REG(0x0000,	1)
+#define CONFIG_EXT_PHY	0x0200	// 1=external MII, 0=internal Phy
+#define CONFIG_GPCNTRL	0x0400	// Inverse value drives pin nCNTRL
+#define CONFIG_NO_WAIT	0x1000	// When 1 no extra wait states on ISA bus
+#define CONFIG_EPH_POWER_EN 0x8000 // When 0 EPH is placed into low power mode.
+
+// Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+// Base Address Register
+/* BANK 1 */
+#define BASE_REG	SMC_REG(0x0002, 1)
+
+
+// Individual Address Registers
+/* BANK 1 */
+#define ADDR0_REG	SMC_REG(0x0004, 1)
+#define ADDR1_REG	SMC_REG(0x0006, 1)
+#define ADDR2_REG	SMC_REG(0x0008, 1)
+
+
+// General Purpose Register
+/* BANK 1 */
+#define GP_REG		SMC_REG(0x000A, 1)
+
+
+// Control Register
+/* BANK 1 */
+#define CTL_REG		SMC_REG(0x000C, 1)
+#define CTL_RCV_BAD	0x4000 // When 1 bad CRC packets are received
+#define CTL_AUTO_RELEASE 0x0800 // When 1 tx pages are released automatically
+#define CTL_LE_ENABLE	0x0080 // When 1 enables Link Error interrupt
+#define CTL_CR_ENABLE	0x0040 // When 1 enables Counter Rollover interrupt
+#define CTL_TE_ENABLE	0x0020 // When 1 enables Transmit Error interrupt
+#define CTL_EEPROM_SELECT 0x0004 // Controls EEPROM reload & store
+#define CTL_RELOAD	0x0002 // When set reads EEPROM into registers
+#define CTL_STORE	0x0001 // When set stores registers into EEPROM
+
+
+// MMU Command Register
+/* BANK 2 */
+#define MMU_CMD_REG	SMC_REG(0x0000, 2)
+#define MC_BUSY		1	// When 1 the last release has not completed
+#define MC_NOP		(0<<5)	// No Op
+#define MC_ALLOC	(1<<5) 	// OR with number of 256 byte packets
+#define MC_RESET	(2<<5)	// Reset MMU to initial state
+#define MC_REMOVE	(3<<5) 	// Remove the current rx packet
+#define MC_RELEASE  	(4<<5) 	// Remove and release the current rx packet
+#define MC_FREEPKT  	(5<<5) 	// Release packet in PNR register
+#define MC_ENQUEUE	(6<<5)	// Enqueue the packet for transmit
+#define MC_RSTTXFIFO	(7<<5)	// Reset the TX FIFOs
+
+
+// Packet Number Register
+/* BANK 2 */
+#define PN_REG		SMC_REG(0x0002, 2)
+
+
+// Allocation Result Register
+/* BANK 2 */
+#define AR_REG		SMC_REG(0x0003, 2)
+#define AR_FAILED	0x80	// Alocation Failed
+
+
+// TX FIFO Ports Register
+/* BANK 2 */
+#define TXFIFO_REG	SMC_REG(0x0004, 2)
+#define TXFIFO_TEMPTY	0x80	// TX FIFO Empty
+
+// RX FIFO Ports Register
+/* BANK 2 */
+#define RXFIFO_REG	SMC_REG(0x0005, 2)
+#define RXFIFO_REMPTY	0x80	// RX FIFO Empty
+
+#define FIFO_REG	SMC_REG(0x0004, 2)
+
+// Pointer Register
+/* BANK 2 */
+#define PTR_REG		SMC_REG(0x0006, 2)
+#define PTR_RCV		0x8000 // 1=Receive area, 0=Transmit area
+#define PTR_AUTOINC 	0x4000 // Auto increment the pointer on each access
+#define PTR_READ	0x2000 // When 1 the operation is a read
+
+
+// Data Register
+/* BANK 2 */
+#define DATA_REG	SMC_REG(0x0008, 2)
+
+
+// Interrupt Status/Acknowledge Register
+/* BANK 2 */
+#define INT_REG		SMC_REG(0x000C, 2)
+
+
+// Interrupt Mask Register
+/* BANK 2 */
+#define IM_REG		SMC_REG(0x000D, 2)
+#define IM_MDINT	0x80 // PHY MI Register 18 Interrupt
+#define IM_ERCV_INT	0x40 // Early Receive Interrupt
+#define IM_EPH_INT	0x20 // Set by Ethernet Protocol Handler section
+#define IM_RX_OVRN_INT	0x10 // Set by Receiver Overruns
+#define IM_ALLOC_INT	0x08 // Set when allocation request is completed
+#define IM_TX_EMPTY_INT	0x04 // Set if the TX FIFO goes empty
+#define IM_TX_INT	0x02 // Transmit Interrupt
+#define IM_RCV_INT	0x01 // Receive Interrupt
+
+
+// Multicast Table Registers
+/* BANK 3 */
+#define MCAST_REG1	SMC_REG(0x0000, 3)
+#define MCAST_REG2	SMC_REG(0x0002, 3)
+#define MCAST_REG3	SMC_REG(0x0004, 3)
+#define MCAST_REG4	SMC_REG(0x0006, 3)
+
+
+// Management Interface Register (MII)
+/* BANK 3 */
+#define MII_REG		SMC_REG(0x0008, 3)
+#define MII_MSK_CRS100	0x4000 // Disables CRS100 detection during tx half dup
+#define MII_MDOE	0x0008 // MII Output Enable
+#define MII_MCLK	0x0004 // MII Clock, pin MDCLK
+#define MII_MDI		0x0002 // MII Input, pin MDI
+#define MII_MDO		0x0001 // MII Output, pin MDO
+
+
+// Revision Register
+/* BANK 3 */
+/* ( hi: chip id   low: rev # ) */
+#define REV_REG		SMC_REG(0x000A, 3)
+
+
+// Early RCV Register
+/* BANK 3 */
+/* this is NOT on SMC9192 */
+#define ERCV_REG	SMC_REG(0x000C, 3)
+#define ERCV_RCV_DISCRD	0x0080 // When 1 discards a packet being received
+#define ERCV_THRESHOLD	0x001F // ERCV Threshold Mask
+
+
+// External Register
+/* BANK 7 */
+#define EXT_REG		SMC_REG(0x0000, 7)
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+static const char * chip_ids[ 16 ] =  {
+	NULL, NULL, NULL,
+	/* 3 */ "SMC91C90/91C92",
+	/* 4 */ "SMC91C94",
+	/* 5 */ "SMC91C95",
+	/* 6 */ "SMC91C96",
+	/* 7 */ "SMC91C100",
+	/* 8 */ "SMC91C100FD",
+	/* 9 */ "SMC91C11xFD",
+	NULL, NULL, NULL,
+	NULL, NULL, NULL};
+
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+/*
+ * PHY IDs
+ *  LAN83C183 == LAN91C111 Internal PHY
+ */
+#define PHY_LAN83C183	0x0016f840
+#define PHY_LAN83C180	0x02821c50
+
+/*
+ * PHY Register Addresses (LAN91C111 Internal PHY)
+ *
+ * Generic PHY registers can be found in <linux/mii.h>
+ *
+ * These phy registers are specific to our on-board phy.
+ */
+
+// PHY Configuration Register 1
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	// 1=Rx Link Detect Function disabled
+#define PHY_CFG1_XMTDIS		0x4000	// 1=TP Transmitter Disabled
+#define PHY_CFG1_XMTPDN		0x2000	// 1=TP Transmitter Powered Down
+#define PHY_CFG1_BYPSCR		0x0400	// 1=Bypass scrambler/descrambler
+#define PHY_CFG1_UNSCDS		0x0200	// 1=Unscramble Idle Reception Disable
+#define PHY_CFG1_EQLZR		0x0100	// 1=Rx Equalizer Disabled
+#define PHY_CFG1_CABLE		0x0080	// 1=STP(150ohm), 0=UTP(100ohm)
+#define PHY_CFG1_RLVL0		0x0040	// 1=Rx Squelch level reduced by 4.5db
+#define PHY_CFG1_TLVL_SHIFT	2	// Transmit Output Level Adjust
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	// Transmitter Rise/Fall time
+
+
+// PHY Configuration Register 2
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	// 1=Auto Polarity Correction disabled
+#define PHY_CFG2_JABDIS		0x0010	// 1=Jabber disabled
+#define PHY_CFG2_MREG		0x0008	// 1=Multiple register access (MII mgt)
+#define PHY_CFG2_INTMDIO	0x0004	// 1=Interrupt signaled with MDIO pulseo
+
+// PHY Status Output (and Interrupt status) Register
+#define PHY_INT_REG		0x12	// Status Output (Interrupt Status)
+#define PHY_INT_INT		0x8000	// 1=bits have changed since last read
+#define PHY_INT_LNKFAIL		0x4000	// 1=Link Not detected
+#define PHY_INT_LOSSSYNC	0x2000	// 1=Descrambler has lost sync
+#define PHY_INT_CWRD		0x1000	// 1=Invalid 4B5B code detected on rx
+#define PHY_INT_SSD		0x0800	// 1=No Start Of Stream detected on rx
+#define PHY_INT_ESD		0x0400	// 1=No End Of Stream detected on rx
+#define PHY_INT_RPOL		0x0200	// 1=Reverse Polarity detected
+#define PHY_INT_JAB		0x0100	// 1=Jabber detected
+#define PHY_INT_SPDDET		0x0080	// 1=100Base-TX mode, 0=10Base-T mode
+#define PHY_INT_DPLXDET		0x0040	// 1=Device in Full Duplex
+
+// PHY Interrupt/Status Mask Register
+#define PHY_MASK_REG		0x13	// Interrupt Mask
+// Uses the same bit definitions as PHY_INT_REG
+
+
+/*
+ * SMC91C96 ethernet config and status registers.
+ * These are in the "attribute" space.
+ */
+#define ECOR			0x8000
+#define ECOR_RESET		0x80
+#define ECOR_LEVEL_IRQ		0x40
+#define ECOR_WR_ATTRIB		0x04
+#define ECOR_ENABLE		0x01
+
+#define ECSR			0x8002
+#define ECSR_IOIS8		0x20
+#define ECSR_PWRDWN		0x04
+#define ECSR_INT		0x02
+
+#define ATTRIB_SIZE		((64*1024) << SMC_IO_SHIFT)
+
+
+/*
+ * Macros to abstract register access according to the data bus
+ * capabilities.  Please use those and not the in/out primitives.
+ * Note: the following macros do *not* select the bank -- this must
+ * be done separately as needed in the main code.  The SMC_REG() macro
+ * only uses the bank argument for debugging purposes (when enabled).
+ */
+
+#if SMC_DEBUG > 0
+#define SMC_REG(reg, bank)						\
+	({								\
+		int __b = SMC_CURRENT_BANK();				\
+		if (unlikely((__b & ~0xf0) != (0x3300 | bank))) {	\
+			printk( "%s: bank reg screwed (0x%04x)\n",	\
+				CARDNAME, __b );			\
+			BUG();						\
+		}							\
+		reg<<SMC_IO_SHIFT;					\
+	})
+#else
+#define SMC_REG(reg, bank)	(reg<<SMC_IO_SHIFT)
+#endif
+
+#define SMC_GET_PN()		\
+(lp->hal.width) ? SMC_inw(ioaddr, PN_REG) & 0xFF : SMC_inb(ioaddr, PN_REG)
+
+#define SMC_GET_AR()		\
+(lp->hal.width) ? SMC_inw(ioaddr, PN_REG) >> 8 : SMC_inb(ioaddr, AR_REG)
+
+#define SMC_GET_TXFIFO()	\
+(lp->hal.width) ? SMC_inw(ioaddr, TXFIFO_REG) & 0xFF : SMC_inb(ioaddr, TXFIFO_REG)
+
+#define SMC_GET_RXFIFO()	\
+(lp->hal.width) ? SMC_inw(ioaddr, TXFIFO_REG) >> 8 : SMC_inb(ioaddr, RXFIFO_REG)
+
+#define SMC_GET_INT()		\
+(lp->hal.width) ? SMC_inw(ioaddr, INT_REG) & 0xFF : SMC_inb(ioaddr, INT_REG)
+
+#define SMC_GET_INT_MASK()	\
+(lp->hal.width) ? SMC_inw(ioaddr, INT_REG) >> 8 : SMC_inb(ioaddr, IM_REG)
+
+#define SMC_SET_PN(x)							\
+if (lp->hal.width == 1) SMC_outw(x, ioaddr, PN_REG);			\
+else if (lp->hal.width == 2) SMC_outl( (x)<<16, ioaddr, SMC_REG(0, 2)); \
+else SMC_outb(x, ioaddr, PN_REG)
+
+#define SMC_ACK_INT(x)							\
+	if (lp->hal.width)						\
+	do {								\
+		unsigned long __flags;					\
+		int __mask;						\
+		local_irq_save(__flags);				\
+		__mask = SMC_inw( ioaddr, INT_REG ) & ~0xff;		\
+		SMC_outw( __mask | (x), ioaddr, INT_REG );		\
+		local_irq_restore(__flags);				\
+	} while (0);							\
+	else SMC_outb(x, ioaddr, INT_REG)
+
+#define SMC_SET_INT_MASK(x)						\
+if (lp->hal.width) SMC_outw((x) << 8, ioaddr, INT_REG);		\
+else SMC_outb(x, ioaddr, IM_REG)
+
+#define SMC_SELECT_BANK(x)						\
+	if (lp->hal.width == 2) SMC_outl((x)<<16, ioaddr, 12<<SMC_IO_SHIFT); \
+	else SMC_outw(x, ioaddr, BANK_SELECT)    
+
+#define SMC_SET_RPC(x)							\
+	if (lp->hal.width == 2) SMC_outl((x)<<16, ioaddr, SMC_REG(8, 0)); \
+	else SMC_outw(x, ioaddr, RPC_REG )
+
+#define SMC_SET_PTR(x)							\
+	if (lp->hal.width == 2) SMC_outl((x)<<16, ioaddr, SMC_REG(4, 2)); \
+	else SMC_outw(x, ioaddr, PTR_REG)
+
+#define SMC_CURRENT_BANK()	SMC_inw( ioaddr, BANK_SELECT )
+#define SMC_GET_BASE()		SMC_inw( ioaddr, BASE_REG )
+#define SMC_SET_BASE(x)		SMC_outw( x, ioaddr, BASE_REG )
+#define SMC_GET_CONFIG()	SMC_inw( ioaddr, CONFIG_REG )
+#define SMC_SET_CONFIG(x)	SMC_outw( x, ioaddr, CONFIG_REG )
+#define SMC_GET_COUNTER()	SMC_inw( ioaddr, COUNTER_REG )
+#define SMC_GET_CTL()		SMC_inw( ioaddr, CTL_REG )
+#define SMC_SET_CTL(x)		SMC_outw( x, ioaddr, CTL_REG )
+#define SMC_GET_MII()		SMC_inw( ioaddr, MII_REG )
+#define SMC_SET_MII(x)		SMC_outw( x, ioaddr, MII_REG )
+#define SMC_GET_MIR()		SMC_inw( ioaddr, MIR_REG )
+#define SMC_SET_MIR(x)		SMC_outw( x, ioaddr, MIR_REG )
+#define SMC_GET_MMU_CMD()	SMC_inw( ioaddr, MMU_CMD_REG )
+#define SMC_SET_MMU_CMD(x)	SMC_outw( x, ioaddr, MMU_CMD_REG )
+#define SMC_GET_FIFO()		SMC_inw( ioaddr, FIFO_REG )
+#define SMC_GET_PTR()		SMC_inw( ioaddr, PTR_REG )
+#define SMC_GET_RCR()		SMC_inw( ioaddr, RCR_REG )
+#define SMC_SET_RCR(x)		SMC_outw( x, ioaddr, RCR_REG )
+#define SMC_GET_REV()		SMC_inw( ioaddr, REV_REG )
+#define SMC_GET_RPC()		SMC_inw( ioaddr, RPC_REG )
+#define SMC_GET_TCR()		SMC_inw( ioaddr, TCR_REG )
+#define SMC_SET_TCR(x)		SMC_outw( x, ioaddr, TCR_REG )
+
+#ifndef SMC_GET_MAC_ADDR
+#define SMC_GET_MAC_ADDR(addr)						\
+	do {								\
+		unsigned int __v;					\
+		__v = SMC_inw( ioaddr, ADDR0_REG );			\
+		addr[0] = __v; addr[1] = __v >> 8;			\
+		__v = SMC_inw( ioaddr, ADDR1_REG );			\
+		addr[2] = __v; addr[3] = __v >> 8;			\
+		__v = SMC_inw( ioaddr, ADDR2_REG );			\
+		addr[4] = __v; addr[5] = __v >> 8;			\
+	} while (0)
+#endif
+
+#define SMC_SET_MAC_ADDR(addr)						\
+	do {								\
+		SMC_outw( addr[0]|(addr[1] << 8), ioaddr, ADDR0_REG );	\
+		SMC_outw( addr[2]|(addr[3] << 8), ioaddr, ADDR1_REG );	\
+		SMC_outw( addr[4]|(addr[5] << 8), ioaddr, ADDR2_REG );	\
+	} while (0)
+
+#define SMC_CLEAR_MCAST()						\
+	do {								\
+		SMC_outw( 0, ioaddr, MCAST_REG1 );			\
+		SMC_outw( 0, ioaddr, MCAST_REG2 );			\
+		SMC_outw( 0, ioaddr, MCAST_REG3 );			\
+		SMC_outw( 0, ioaddr, MCAST_REG4 );			\
+	} while (0)
+#define SMC_SET_MCAST(x)						\
+	do {								\
+		unsigned char *mt = (x);				\
+		SMC_outw( mt[0] | (mt[1] << 8), ioaddr, MCAST_REG1 );	\
+		SMC_outw( mt[2] | (mt[3] << 8), ioaddr, MCAST_REG2 );	\
+		SMC_outw( mt[4] | (mt[5] << 8), ioaddr, MCAST_REG3 );	\
+		SMC_outw( mt[6] | (mt[7] << 8), ioaddr, MCAST_REG4 );	\
+	} while (0)
+
+#define SMC_PUT_PKT_HDR(status, length)					\
+	if (lp->hal.width == 2)					\
+	SMC_outl( (status) | (length) << 16, ioaddr, DATA_REG );	\
+	else								\
+	do {								\
+		SMC_outw( status, ioaddr, DATA_REG );			\
+		SMC_outw( length, ioaddr, DATA_REG );			\
+	} while (0)
+
+#define SMC_GET_PKT_HDR(status, length)					\
+	if (lp->hal.width == 2)					\
+	do {								\
+		unsigned int __val = SMC_inl( ioaddr, DATA_REG );	\
+		(status) = __val & 0xffff;				\
+		(length) = __val >> 16;					\
+	} while (0);							\
+	else								\
+	do {								\
+		(status) = SMC_inw( ioaddr, DATA_REG );			\
+		(length) = SMC_inw( ioaddr, DATA_REG );			\
+	} while (0)
+
+#define SMC_ins(a, r, p, l)    (*(lp->hal.reads))((a) + (r), p, l)
+#define SMC_outs(a, r, p, l)   (*(lp->hal.writes))((a) + (r), p, l)
+
+#define SMC_PUSH_DATA(p, l)						\
+	if (lp->hal.width == 2)					\
+	do {								\
+		char *__ptr = (p);					\
+		int __len = (l);					\
+		if (__len >= 2 && (unsigned long)__ptr & 2) {		\
+			__len -= 2;					\
+			SMC_outw( *(u16 *)__ptr, ioaddr, DATA_REG );	\
+			__ptr += 2;					\
+		}							\
+		SMC_outs( ioaddr, DATA_REG, __ptr, __len >> 2);	\
+		if (__len & 2) {					\
+			__ptr += (__len & ~3);				\
+			SMC_outw( *((u16 *)__ptr), ioaddr, DATA_REG );	\
+		}							\
+	} while (0);							\
+	else if (lp->hal.width == 1)					\
+	    SMC_outs( ioaddr, DATA_REG, p, (l) >> 1 );			\
+	else								\
+	    SMC_outs( ioaddr, DATA_REG, p, l )
+
+#define SMC_PULL_DATA(p, l)						\
+	if (lp->hal.width == 2)					\
+	do {								\
+		char *__ptr = (p);					\
+		int __len = (l);					\
+		if ((unsigned long)__ptr & 2) {				\
+			/*						\
+			 * We want 32bit alignment here.		\
+			 * Since some buses perform a full 32bit	\
+			 * fetch even for 16bit data we can't use	\
+			 * SMC_inw() here.  Back both source (on chip	\
+			 * and destination) pointers of 2 bytes.	\
+			 */						\
+			__ptr -= 2;					\
+			__len += 2;					\
+			SMC_SET_PTR( 2|PTR_READ|PTR_RCV|PTR_AUTOINC );	\
+		}							\
+		__len += 2;						\
+		SMC_ins( ioaddr, DATA_REG, __ptr, __len >> 2);		\
+	} while (0);							\
+	else if (lp->hal.width == 1)					\
+	    SMC_ins( ioaddr, DATA_REG, p, (l) >> 1 );			\
+	else								\
+	    SMC_ins( ioaddr, DATA_REG, p, l )
+
+#if SMC_USE_PXA_DMA
+static void
+    smc_pxa_dma_irq(int dma, void *_lp, struct pt_regs *regs)
+{
+	DCSR(dma) = 0;
+}
+#endif
+
+#if !defined (SMC_INTERRUPT_PREAMBLE)
+# define SMC_INTERRUPT_PREAMBLE
+#endif
+
+#endif  /* _SMC91X_H_ */
Index: drivers/net/Makefile
===================================================================
--- a/drivers/net/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/net/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -63,6 +63,7 @@
 #
 
 obj-$(CONFIG_MII) += mii.o
+obj-$(CONFIG_MII_DEV) += mii-dev.o
 
 obj-$(CONFIG_SUNDANCE) += sundance.o
 obj-$(CONFIG_HAMACHI) += hamachi.o
@@ -171,6 +172,7 @@
 obj-$(CONFIG_HYDRA) += hydra.o 8390.o
 obj-$(CONFIG_ARIADNE) += ariadne.o
 obj-$(CONFIG_CS89x0) += cs89x0.o
+obj-$(CONFIG_CIRRUS) += cirrus.o
 obj-$(CONFIG_MACSONIC) += macsonic.o
 obj-$(CONFIG_MACMACE) += macmace.o
 obj-$(CONFIG_MAC89x0) += mac89x0.o
@@ -180,7 +182,12 @@
 obj-$(CONFIG_AMD8111_ETH) += amd8111e.o
 obj-$(CONFIG_IBMVETH) += ibmveth.o
 obj-$(CONFIG_S2IO) += s2io.o
+ifeq ($(CONFIG_SMC91X_OLD),y)
+obj-$(CONFIG_SMC91X) += smc91x_old.o
+else
 obj-$(CONFIG_SMC91X) += smc91x.o
+endif
+
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 
 obj-$(CONFIG_ARM) += arm/
Index: drivers/net/cirrus.c
===================================================================
--- a/drivers/net/cirrus.c	(revision 0)
+++ b/drivers/net/cirrus.c	(revision 675)
@@ -0,0 +1,704 @@
+
+/*
+ * linux/drivers/net/cirrus.c
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * At the moment the driver does not support memory mode operation.
+ * It is trivial to implement this, but not worth the effort.
+ */
+
+/*
+ * TODO:
+ *
+ *   1. If !ready in send_start(), queue buffer and send it in interrupt handler
+ *      when we receive a BufEvent with Rdy4Tx, send it again. dangerous!
+ *   2. how do we prevent interrupt handler destroying integrity of get_stats()?
+ *   3. Change reset code to check status.
+ *   4. Implement set_mac_address and remove fake mac address
+ *   5. Link status detection stuff
+ *   6. Write utility to write EEPROM, do self testing, etc.
+ *   7. Implement DMA routines (I need a board w/ DMA support for that)
+ *   8. Power management
+ *   9. Add support for multiple ethernet chips
+ *  10. Add support for other cs89xx chips (need hardware for that)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "cirrus.h"
+
+/* #define DEBUG */
+/* #define FULL_DUPLEX */
+
+#if 0
+//#elif CONFIG_ARCH_CSB226
+#	define CIRRUS_DEFAULT_IO 0xF8000300
+#	define CIRRUS_DEFAULT_IRQ IRQ_GPIO(14) 
+	/* PTX: uggly hack... */
+#	define CS8900_OFF 0x04
+#	define CS8900_PPTR	*(volatile u32 *)(CIRRUS_DEFAULT_IO+0x05*CS8900_OFF)
+#	define CS8900_PDATA	*(volatile u32 *)(CIRRUS_DEFAULT_IO+0x06*CS8900_OFF)
+//#else
+#	define CIRRUS_DEFAULT_IO	0
+#	define CIRRUS_DEFAULT_IRQ	0
+#endif
+
+typedef struct {
+	struct net_device_stats stats;
+	u16 txlen;
+} cirrus_t;
+
+typedef struct {
+	u16 io_base;		/* I/O Base Address			*/
+	u16 irq;			/* Interrupt Number			*/
+	u16 dma;			/* DMA Channel Numbers		*/
+	u32 mem_base;		/* Memory Base Address		*/
+	u32 rom_base;		/* Boot PROM Base Address	*/
+	u32 rom_mask;		/* Boot PROM Address Mask	*/
+	u8 mac[6];			/* Individual Address		*/
+} cirrus_eeprom_t;
+
+/*
+ * I/O routines
+ */
+
+static inline u16 cirrus_read (struct net_device *dev,u16 reg)
+{
+	CIRRUS_outw (reg, dev->base_addr, PP_Address);
+	return (CIRRUS_inw (dev->base_addr, PP_Data));
+}
+
+static inline void cirrus_write (struct net_device *dev,u16 reg,u16 value)
+{
+	CIRRUS_outw (reg, dev->base_addr, PP_Address);
+	CIRRUS_outw (value, dev->base_addr, PP_Data);
+}
+
+static inline void cirrus_set (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) | value);
+}
+
+static inline void cirrus_clear (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) & ~value);
+}
+
+static inline void cirrus_frame_read (struct net_device *dev,struct sk_buff *skb,u16 length)
+{
+	CIRRUS_insw (dev->base_addr, 0, skb_put (skb,length), (length + 1) / 2);
+}
+
+static inline void cirrus_frame_write (struct net_device *dev,struct sk_buff *skb)
+{
+	CIRRUS_outsw (dev->base_addr, 0, skb->data, (skb->len + 1) / 2);
+}
+
+/*
+ * Debugging functions
+ */
+
+#ifdef DEBUG
+static inline int printable (int c)
+{
+	return ((c >= 32 && c <= 126) ||
+			(c >= 174 && c <= 223) ||
+			(c >= 242 && c <= 243) ||
+			(c >= 252 && c <= 253));
+}
+
+static void dump16 (struct net_device *dev,const u8 *s,size_t len)
+{
+	int i;
+	char str[128];
+
+	if (!len) return;
+
+	*str = '\0';
+
+	for (i = 0; i < len; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		sprintf (str,"%s%.2x ",str,s[i]);
+	}
+
+	for ( ; i < 16; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		strcat (str,"   ");
+	}
+
+	strcat (str," ");
+	for (i = 0; i < len; i++) sprintf (str,"%s%c",str,printable (s[i]) ? s[i] : '.');
+
+	printk (KERN_DEBUG "%s:     %s\n",dev->name,str);
+}
+
+static void hexdump (struct net_device *dev,const void *ptr,size_t size)
+{
+	const u8 *s = (u8 *) ptr;
+	int i;
+	for (i = 0; i < size / 16; i++, s += 16) dump16 (dev,s,16);
+	dump16 (dev,s,size % 16);
+}
+
+static void dump_packet (struct net_device *dev,struct sk_buff *skb,const char *type)
+{
+	printk (KERN_INFO "%s: %s %d byte frame %.2x:%.2x:%.2x:%.2x:%.2x:%.2x to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x type %.4x\n",
+			dev->name,
+			type,
+			skb->len,
+			skb->data[0],skb->data[1],skb->data[2],skb->data[3],skb->data[4],skb->data[5],
+			skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11],
+			(skb->data[12] << 8) | skb->data[13]);
+	if (skb->len < 0x100) hexdump (dev,skb->data,skb->len);
+}
+#endif	/* #ifdef DEBUG */
+
+/*
+ * Driver functions
+ */
+
+static void cirrus_receive (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	struct sk_buff *skb;
+	u16 status,length;
+
+	status = cirrus_read (dev,PP_RxStatus);
+	length = cirrus_read (dev,PP_RxLength);
+
+	if (!(status & RxOK)) {
+		priv->stats.rx_errors++;
+		if ((status & (Runt | Extradata))) priv->stats.rx_length_errors++;
+		if ((status & CRCerror)) priv->stats.rx_crc_errors++;
+		return;
+	}
+
+	if ((skb = dev_alloc_skb (length + 4)) == NULL) {
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb->dev = dev;
+	skb_reserve (skb,2);
+
+	cirrus_frame_read (dev,skb,length);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"recv");
+#endif	/* #ifdef DEBUG */
+
+	skb->protocol = eth_type_trans (skb,dev);
+
+	netif_rx (skb);
+	dev->last_rx = jiffies;
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += length;
+}
+
+static int cirrus_send_start (struct sk_buff *skb,struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	u16 status;
+
+	netif_stop_queue (dev);
+
+	cirrus_write (dev,PP_TxCMD,TxStart (After5));
+	cirrus_write (dev,PP_TxLength,skb->len);
+
+	status = cirrus_read (dev,PP_BusST);
+
+	if ((status & TxBidErr)) {
+		printk (KERN_WARNING "%s: Invalid frame size %d!\n",dev->name,skb->len);
+		priv->stats.tx_errors++;
+		priv->stats.tx_aborted_errors++;
+		priv->txlen = 0;
+		return (1);
+	}
+
+	if (!(status & Rdy4TxNOW)) {
+		printk (KERN_WARNING "%s: Transmit buffer not free!\n",dev->name);
+		priv->stats.tx_errors++;
+		priv->txlen = 0;
+		/* FIXME: store skb and send it in interrupt handler */
+		return (1);
+	}
+
+	cirrus_frame_write (dev,skb);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"send");
+#endif	/* #ifdef DEBUG */
+
+	dev->trans_start = jiffies;
+
+	dev_kfree_skb (skb);
+
+	priv->txlen = skb->len;
+
+	return (0);
+}
+
+static irqreturn_t cirrus_interrupt (int irq,void *id,struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) id;
+	cirrus_t *priv;
+	u16 status;
+
+	int handled = 0;
+
+	if (dev->priv == NULL) {
+		printk (KERN_WARNING "%s: irq %d for unknown device.\n",dev->name,irq);
+		handled = 1;
+		return IRQ_RETVAL(handled);
+	}
+
+	priv = (cirrus_t *) dev->priv;
+
+	while ((status = cirrus_read (dev,PP_ISQ))) {
+		switch (RegNum (status)) {
+		case RxEvent:
+			cirrus_receive (dev);
+			handled = 1;
+			break;
+
+		case TxEvent:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			if (!(RegContent (status) & TxOK)) {
+				priv->stats.tx_errors++;
+				if ((RegContent (status) & Out_of_window)) priv->stats.tx_window_errors++;
+				if ((RegContent (status) & Jabber)) priv->stats.tx_aborted_errors++;
+				break;
+			} else if (priv->txlen) {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += priv->txlen;
+			}
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			handled = 1;
+			break;
+
+		case BufEvent:
+			if ((RegContent (status) & RxMiss)) {
+				u16 missed = MissCount (cirrus_read (dev,PP_RxMISS));
+				priv->stats.rx_errors += missed;
+				priv->stats.rx_missed_errors += missed;
+			}
+			if ((RegContent (status) & TxUnderrun)) {
+				priv->stats.tx_errors++;
+				priv->stats.tx_fifo_errors++;
+			}
+			/* FIXME: if Rdy4Tx, transmit last sent packet (if any) */
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			handled = 1;
+			break;
+
+		case TxCOL:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			handled = 1;
+			break;
+
+		case RxMISS:
+			status = MissCount (cirrus_read (dev,PP_RxMISS));
+			priv->stats.rx_errors += status;
+			priv->stats.rx_missed_errors += status;
+			handled = 1;
+			break;
+		}
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+static void cirrus_transmit_timeout (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	priv->stats.tx_errors++;
+	priv->stats.tx_heartbeat_errors++;
+	priv->txlen = 0;
+	netif_wake_queue (dev);
+}
+
+static int cirrus_start (struct net_device *dev)
+{
+	int result;
+
+	/* valid ethernet address? */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		printk(KERN_ERR "%s: invalid ethernet MAC address\n",dev->name);
+		return (-EINVAL);
+	}
+
+	/* install interrupt handler */
+	printk("%s: requesting interrupt %i\n", __FUNCTION__, dev->irq);
+	if ((result = request_irq (dev->irq,&cirrus_interrupt,0,dev->name,dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name,dev->irq);
+		return (result);
+	}
+	
+#if defined(CONFIG_ARCH_CSB226)
+	set_irq_type(dev->irq, IRQT_RISING);
+#endif
+
+	/* enable the ethernet controller */
+	cirrus_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cirrus_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cirrus_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cirrus_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cirrus_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cirrus_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cirrus_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+
+	/* start the queue */
+	netif_start_queue (dev);
+
+	MOD_INC_USE_COUNT;
+
+	return (0);
+}
+
+static int cirrus_stop (struct net_device *dev)
+{
+	/* disable ethernet controller */
+	cirrus_write (dev,PP_BusCTL,0);
+	cirrus_write (dev,PP_TestCTL,0);
+	cirrus_write (dev,PP_SelfCTL,0);
+	cirrus_write (dev,PP_LineCTL,0);
+	cirrus_write (dev,PP_BufCFG,0);
+	cirrus_write (dev,PP_TxCFG,0);
+	cirrus_write (dev,PP_RxCTL,0);
+	cirrus_write (dev,PP_RxCFG,0);
+
+	/* uninstall interrupt handler */
+	free_irq (dev->irq,dev);
+
+	/* stop the queue */
+	netif_stop_queue (dev);
+
+	MOD_DEC_USE_COUNT;
+
+	return (0);
+}
+
+static int cirrus_set_mac_address (struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+	int i;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return 0;
+}
+
+static struct net_device_stats *cirrus_get_stats (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	return (&priv->stats);
+}
+
+static void cirrus_set_receive_mode (struct net_device *dev)
+{
+	if ((dev->flags & IFF_PROMISC))
+		cirrus_set (dev,PP_RxCTL,PromiscuousA);
+	else
+		cirrus_clear (dev,PP_RxCTL,PromiscuousA);
+
+	if ((dev->flags & IFF_ALLMULTI) && dev->mc_list)
+		cirrus_set (dev,PP_RxCTL,MulticastA);
+	else
+		cirrus_clear (dev,PP_RxCTL,MulticastA);
+}
+
+static int cirrus_eeprom_wait (struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < 200; i++) {
+		if (!(cirrus_read (dev,PP_SelfST) & SIBUSY))
+			return (0);
+		udelay (1);
+	}
+
+	return (-1);
+}
+
+static int cirrus_eeprom_read (struct net_device *dev,u16 *value,u16 offset)
+{
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	cirrus_write (dev,PP_EEPROMCommand,offset | EEReadRegister);
+
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	*value = cirrus_read (dev,PP_EEPROMData);
+
+	return (0);
+}
+
+static int cirrus_eeprom (struct net_device *dev,cirrus_eeprom_t *eeprom)
+{
+	u16 offset,buf[16],*word;
+	u8 checksum = 0,*byte;
+
+	if (cirrus_eeprom_read (dev,buf,0) < 0) {
+		read_timed_out:
+		printk (KERN_DEBUG "%s: EEPROM read timed out\n",dev->name);
+		return (-ETIMEDOUT);
+	}
+
+	if ((buf[0] >> 8) != 0xa1) {
+		printk (KERN_DEBUG "%s: No EEPROM present\n",dev->name);
+		return (-ENODEV);
+	}
+
+	if ((buf[0] & 0xff) < sizeof (buf)) {
+		eeprom_too_small:
+		printk (KERN_DEBUG "%s: EEPROM too small\n",dev->name);
+		return (-ENODEV);
+	}
+
+	for (offset = 1; offset < (buf[0] & 0xff); offset++) {
+		if (cirrus_eeprom_read (dev,buf + offset,offset) < 0)
+			goto read_timed_out;
+
+		if (buf[offset] == 0xffff)
+			goto eeprom_too_small;
+	}
+
+	if (buf[1] != 0x2020) {
+		printk (KERN_DEBUG "%s: Group Header #1 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[5] != 0x502c) {
+		printk (KERN_DEBUG "%s: Group Header #2 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[12] != 0x2158) {
+		printk (KERN_DEBUG "%s: Group Header #3 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	eeprom->io_base = buf[2];
+	eeprom->irq = buf[3];
+	eeprom->dma = buf[4];
+	eeprom->mem_base = (buf[7] << 16) | buf[6];
+	eeprom->rom_base = (buf[9] << 16) | buf[8];
+	eeprom->rom_mask = (buf[11] << 16) | buf[10];
+
+	word = (u16 *) eeprom->mac;
+	for (offset = 0; offset < 3; offset++) word[offset] = buf[13 + offset];
+
+	byte = (u8 *) buf;
+	for (offset = 0; offset < sizeof (buf); offset++) checksum += byte[offset];
+
+	if (cirrus_eeprom_read (dev,&offset,0x10) < 0)
+		goto read_timed_out;
+
+	if ((offset >> 8) != (u8) (0x100 - checksum)) {
+		printk (KERN_DEBUG "%s: Checksum mismatch (expected 0x%.2x, got 0x%.2x instead\n",
+				dev->name,
+				(u8) (0x100 - checksum),
+				offset >> 8);
+		return (-EIO);
+	}
+
+	return (0);
+}
+
+/*
+ * Architecture dependant code
+ */
+
+#ifdef CONFIG_SA1100_FRODO
+static void frodo_reset (struct net_device *dev)
+{
+	int i;
+	volatile u16 value;
+
+	/* reset ethernet controller */
+	FRODO_CPLD_ETHERNET |= FRODO_ETH_RESET;
+	mdelay (50);
+	FRODO_CPLD_ETHERNET &= ~FRODO_ETH_RESET;
+	mdelay (50);
+
+	/* we tied SBHE to CHIPSEL, so each memory access ensure the chip is in 16-bit mode */
+	for (i = 0; i < 3; i++) value = cirrus_read (dev,0);
+
+	/* FIXME: poll status bit */
+}
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+/*
+ * Driver initialization routines
+ */
+
+static int io = 0;
+static int irq = 0;
+
+int __init cirrus_probe (struct net_device *dev)
+{
+	static cirrus_t priv;
+	int i,result;
+	u16 value;
+	cirrus_eeprom_t eeprom;
+
+	printk ("Cirrus Logic CS8900A driver for Linux (V0.02)\n");
+
+	memset (&priv,0,sizeof (cirrus_t));
+
+	ether_setup (dev);
+
+	dev->open               = cirrus_start;
+	dev->stop               = cirrus_stop;
+	dev->hard_start_xmit    = cirrus_send_start;
+	dev->get_stats          = cirrus_get_stats;
+	dev->set_multicast_list = cirrus_set_receive_mode;
+	dev->set_mac_address	= cirrus_set_mac_address;
+	dev->tx_timeout         = cirrus_transmit_timeout;
+	dev->watchdog_timeo     = HZ;
+
+	/* hack!! */ // 00:05:5D:DD:81:18
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x00;
+	dev->dev_addr[2] = 0x02;
+	dev->dev_addr[3] = 0x50;
+	dev->dev_addr[4] = 0x10;
+	dev->dev_addr[5] = 0x08;
+
+	dev->if_port   = IF_PORT_10BASET;
+	dev->priv      = (void *) &priv;
+
+	SET_MODULE_OWNER (dev);
+
+	dev->base_addr = CIRRUS_IOADDR;
+	dev->irq = CIRRUS_IRQ;
+
+	/* module parameters override everything */
+	if (io > 0) dev->base_addr = io;
+	if (irq > 0) dev->irq = irq;
+
+	if (!dev->base_addr) {
+		printk (KERN_ERR
+				"%s: No default I/O base address defined. Use io=... or\n"
+				"%s: define CIRRUS_DEFAULT_IO for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!dev->irq) {
+		printk (KERN_ERR
+				"%s: No default IRQ number defined. Use irq=... or\n"
+				"%s: define CIRRUS_DEFAULT_IRQ for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!request_region (dev->base_addr,16,dev->name)) {
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr);
+		return -EBUSY;
+	}
+
+#ifdef CONFIG_SA1100_FRODO
+	frodo_reset (dev);
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+	/* if an EEPROM is present, use it's MAC address */
+	if (!cirrus_eeprom (dev,&eeprom))
+		for (i = 0; i < 6; i++)
+			dev->dev_addr[i] = eeprom.mac[i];
+
+	/* verify EISA registration number for Cirrus Logic */
+	if ((value = cirrus_read (dev,PP_ProductID)) != EISA_REG_CODE) {
+		printk (KERN_ERR "%s: incorrect signature 0x%.4x\n",dev->name,value);
+		return (-ENXIO);
+	}
+
+	/* verify chip version */
+	value = cirrus_read (dev,PP_ProductID + 2);
+	if (VERSION (value) != CS8900A) {
+		printk (KERN_ERR "%s: unknown chip version 0x%.8x\n",dev->name,VERSION (value));
+		return (-ENXIO);
+	}
+	printk (KERN_INFO "%s: CS8900A rev %c detected\n",dev->name,'B' + REVISION (value) - REV_B);
+
+	/* setup interrupt number */
+	cirrus_write (dev,PP_IntNum,0);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return (0);
+}
+
+EXPORT_NO_SYMBOLS;
+
+static struct net_device dev;
+
+static int __init cirrus_init (void)
+{
+	memset (&dev,0,sizeof (struct net_device));
+	dev.init = cirrus_probe;
+	return (register_netdev (&dev));
+}
+
+static void __exit cirrus_cleanup (void)
+{
+	release_region (dev.base_addr,16);
+	unregister_netdev (&dev);
+}
+
+MODULE_AUTHOR ("Abraham van der Merwe <abraham@2d3d.co.za>");
+MODULE_DESCRIPTION ("Cirrus Logic CS8900A driver for Linux (V0.02)");
+MODULE_LICENSE ("GPL");
+MODULE_PARM_DESC (io,"I/O Base Address");
+MODULE_PARM (io,"i");
+MODULE_PARM_DESC (irq,"IRQ Number");
+MODULE_PARM (irq,"i");
+
+module_init (cirrus_init);
+module_exit (cirrus_cleanup);
+
Index: drivers/net/cirrus.h
===================================================================
--- a/drivers/net/cirrus.h	(revision 0)
+++ b/drivers/net/cirrus.h	(revision 675)
@@ -0,0 +1,309 @@
+#ifndef CIRRUS_H
+#define CIRRUS_H
+
+/*
+ * linux/drivers/net/cirrus.h
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * Ports
+ */
+
+#define PP_Address		0x0a	/* PacketPage Pointer Port (Section 4.10.10) */
+#define PP_Data			0x0c	/* PacketPage Data Port (Section 4.10.10) */
+
+/*
+ * Registers
+ */
+
+#define PP_ProductID		0x0000	/* Section 4.3.1   Product Identification Code */
+#define PP_MemBase			0x002c	/* Section 4.9.2   Memory Base Address Register */
+#define PP_IntNum			0x0022	/* Section 3.2.3   Interrupt Number */
+#define PP_EEPROMCommand	0x0040	/* Section 4.3.11  EEPROM Command */
+#define PP_EEPROMData		0x0042	/* Section 4.3.12  EEPROM Data */
+#define PP_RxCFG			0x0102	/* Section 4.4.6   Receiver Configuration */
+#define PP_RxCTL			0x0104	/* Section 4.4.8   Receiver Control */
+#define PP_TxCFG			0x0106	/* Section 4.4.9   Transmit Configuration */
+#define PP_BufCFG			0x010a	/* Section 4.4.12  Buffer Configuration */
+#define PP_LineCTL			0x0112	/* Section 4.4.16  Line Control */
+#define PP_SelfCTL			0x0114	/* Section 4.4.18  Self Control */
+#define PP_BusCTL			0x0116	/* Section 4.4.20  Bus Control */
+#define PP_TestCTL			0x0118	/* Section 4.4.22  Test Control */
+#define PP_ISQ				0x0120	/* Section 4.4.5   Interrupt Status Queue */
+#define PP_TxEvent			0x0128	/* Section 4.4.10  Transmitter Event */
+#define PP_BufEvent			0x012c	/* Section 4.4.13  Buffer Event */
+#define PP_RxMISS			0x0130	/* Section 4.4.14  Receiver Miss Counter */
+#define PP_TxCOL			0x0132	/* Section 4.4.15  Transmit Collision Counter */
+#define PP_SelfST			0x0136	/* Section 4.4.19  Self Status */
+#define PP_BusST			0x0138	/* Section 4.4.21  Bus Status */
+#define PP_TxCMD			0x0144	/* Section 4.4.11  Transmit Command */
+#define PP_TxLength			0x0146	/* Section 4.5.2   Transmit Length */
+#define PP_IA				0x0158	/* Section 4.6.2   Individual Address (IEEE Address) */
+#define PP_RxStatus			0x0400	/* Section 4.7.1   Receive Status */
+#define PP_RxLength			0x0402	/* Section 4.7.1   Receive Length (in bytes) */
+#define PP_RxFrame			0x0404	/* Section 4.7.2   Receive Frame Location */
+#define PP_TxFrame			0x0a00	/* Section 4.7.2   Transmit Frame Location */
+
+/*
+ * Values
+ */
+
+/* PP_IntNum */
+#define INTRQ0			0x0000
+#define INTRQ1			0x0001
+#define INTRQ2			0x0002
+#define INTRQ3			0x0003
+
+/* PP_ProductID */
+#define EISA_REG_CODE	0x630e
+#define REVISION(x)		(((x) & 0x1f00) >> 8)
+#define VERSION(x)		((x) & ~0x1f00)
+
+#define CS8900A			0x0000
+#define REV_B			7
+#define REV_C			8
+#define REV_D			9
+
+/* PP_RxCFG */
+#define Skip_1			0x0040
+#define StreamE			0x0080
+#define RxOKiE			0x0100
+#define RxDMAonly		0x0200
+#define AutoRxDMAE		0x0400
+#define BufferCRC		0x0800
+#define CRCerroriE		0x1000
+#define RuntiE			0x2000
+#define ExtradataiE		0x4000
+
+/* PP_RxCTL */
+#define IAHashA			0x0040
+#define PromiscuousA	0x0080
+#define RxOKA			0x0100
+#define MulticastA		0x0200
+#define IndividualA		0x0400
+#define BroadcastA		0x0800
+#define CRCerrorA		0x1000
+#define RuntA			0x2000
+#define ExtradataA		0x4000
+
+/* PP_TxCFG */
+#define Loss_of_CRSiE	0x0040
+#define SQErroriE		0x0080
+#define TxOKiE			0x0100
+#define Out_of_windowiE	0x0200
+#define JabberiE		0x0400
+#define AnycolliE		0x0800
+#define T16colliE		0x8000
+
+/* PP_BufCFG */
+#define SWint_X			0x0040
+#define RxDMAiE			0x0080
+#define Rdy4TxiE		0x0100
+#define TxUnderruniE	0x0200
+#define RxMissiE		0x0400
+#define Rx128iE			0x0800
+#define TxColOvfiE		0x1000
+#define MissOvfloiE		0x2000
+#define RxDestiE		0x8000
+
+/* PP_LineCTL */
+#define SerRxON			0x0040
+#define SerTxON			0x0080
+#define AUIonly			0x0100
+#define AutoAUI_10BT	0x0200
+#define ModBackoffE		0x0800
+#define PolarityDis		0x1000
+#define L2_partDefDis	0x2000
+#define LoRxSquelch		0x4000
+
+/* PP_SelfCTL */
+#define RESET			0x0040
+#define SWSuspend		0x0100
+#define HWSleepE		0x0200
+#define HWStandbyE		0x0400
+#define HC0E			0x1000
+#define HC1E			0x2000
+#define HCB0			0x4000
+#define HCB1			0x8000
+
+/* PP_BusCTL */
+#define ResetRxDMA		0x0040
+#define DMAextend		0x0100
+#define UseSA			0x0200
+#define MemoryE			0x0400
+#define DMABurst		0x0800
+#define IOCHRDYE		0x1000
+#define RxDMAsize		0x2000
+#define EnableRQ		0x8000
+
+/* PP_TestCTL */
+#define DisableLT		0x0080
+#define ENDECloop		0x0200
+#define AUIloop			0x0400
+#define DisableBackoff	0x0800
+#define FDX				0x4000
+
+/* PP_ISQ */
+#define RegNum(x) ((x) & 0x3f)
+#define RegContent(x) ((x) & ~0x3d)
+
+#define RxEvent			0x0004
+#define TxEvent			0x0008
+#define BufEvent		0x000c
+#define RxMISS			0x0010
+#define TxCOL			0x0012
+
+/* PP_RxStatus */
+#define IAHash			0x0040
+#define Dribblebits		0x0080
+#define RxOK			0x0100
+#define Hashed			0x0200
+#define IndividualAdr	0x0400
+#define Broadcast		0x0800
+#define CRCerror		0x1000
+#define Runt			0x2000
+#define Extradata		0x4000
+
+#define HashTableIndex(x) ((x) >> 0xa)
+
+/* PP_TxCMD */
+#define After5			0
+#define After381		1
+#define After1021		2
+#define AfterAll		3
+#define TxStart(x) ((x) << 6)
+
+#define Force			0x0100
+#define Onecoll			0x0200
+#define InhibitCRC		0x1000
+#define TxPadDis		0x2000
+
+/* PP_BusST */
+#define TxBidErr		0x0080
+#define Rdy4TxNOW		0x0100
+
+/* PP_TxEvent */
+#define Loss_of_CRS		0x0040
+#define SQEerror		0x0080
+#define TxOK			0x0100
+#define Out_of_window	0x0200
+#define Jabber			0x0400
+#define T16coll			0x8000
+
+#define TX_collisions(x) (((x) >> 0xb) & ~0x8000)
+
+/* PP_BufEvent */
+#define SWint			0x0040
+#define RxDMAFrame		0x0080
+#define Rdy4Tx			0x0100
+#define TxUnderrun		0x0200
+#define RxMiss			0x0400
+#define Rx128			0x0800
+#define RxDest			0x8000
+
+/* PP_RxMISS */
+#define MissCount(x) ((x) >> 6)
+
+/* PP_TxCOL */
+#define ColCount(x) ((x) >> 6)
+
+/* PP_SelfST */
+#define T3VActive		0x0040
+#define INITD			0x0080
+#define SIBUSY			0x0100
+#define EEPROMpresent	0x0200
+#define EEPROMOK		0x0400
+#define ELpresent		0x0800
+#define EEsize			0x1000
+
+/* PP_EEPROMCommand */
+#define EEWriteRegister	0x0100
+#define EEReadRegister	0x0200
+#define EEEraseRegister	0x0300
+#define ELSEL			0x0400
+
+
+/* -------------------- Set Hardware Capabilities for CSB226 -------------- */
+
+#if defined(CONFIG_ARCH_CSB226)
+
+#define CIRRUS_inw(a, r)		readw((a) + (r*0x02))
+#define CIRRUS_outw(v, a, r)		writew(v, (a) + (r*0x02))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r*0x02), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r*0x02), p, l)
+
+#define CIRRUS_IOADDR			(CSB226_ETH_VIRT + 0x300)
+#define CIRRUS_IRQ			CSB226_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for frodo --------------- */
+
+#elif defined(CONFIG_SA1100_FRODO)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(FRODO_ETH_IO + 0x300)
+#define CIRRUS_IRQ			FRODO_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for cerf ---------------- */
+
+#elif defined(CONFIG_SA1100_CERF)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(CERF_ETH_IO + 0x300)
+#define CIRRUS_IRQ			CERF_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for CDB89712 ------------ */
+
+#elif defined(CONFIG_ARCH_CDB89712)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(ETHER_BASE + 0x300)
+#define CIRRUS_IRQ			IRQ_EINT3
+
+/* -------------------- ISA ----------------------------------------------- */
+
+#elif defined(CONFIG_ISA)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			0
+#define CIRRUS_IRQ			0
+
+#else
+#error "FIXME..."
+#endif
+
+#endif	/* #ifndef CIRRUS_H */
+
Index: drivers/net/smc91x.c
===================================================================
--- a/drivers/net/smc91x.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/net/smc91x.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -90,7 +90,11 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
+#if CONFIG_SMC91X_HAL
+#include "smc91x_hal.h"
+#else
 #include "smc91x.h"
+#endif
 
 #ifdef CONFIG_ISA
 /*
@@ -119,13 +123,6 @@
 
 #endif  /* CONFIG_ISA */
 
-#ifndef SMC_NOWAIT
-# define SMC_NOWAIT		0
-#endif
-static int nowait = SMC_NOWAIT;
-module_param(nowait, int, 0400);
-MODULE_PARM_DESC(nowait, "set to 1 for no wait state");
-
 /*
  * Transmit timeout, default 5 seconds.
  */
@@ -169,53 +166,6 @@
  */
 #define MII_DELAY		1
 
-/* store this information for the driver.. */
-struct smc_local {
-	/*
-	 * If I have to wait until memory is available to send a
-	 * packet, I will store the skbuff here, until I get the
-	 * desired memory.  Then, I'll send it out and free it.
-	 */
-	struct sk_buff *pending_tx_skb;
-	struct tasklet_struct tx_task;
-
- 	/*
-	 * these are things that the kernel wants me to keep, so users
-	 * can find out semi-useless statistics of how well the card is
-	 * performing
-	 */
-	struct net_device_stats stats;
-
-	/* version/revision of the SMC91x chip */
-	int	version;
-
-	/* Contains the current active transmission mode */
-	int	tcr_cur_mode;
-
-	/* Contains the current active receive mode */
-	int	rcr_cur_mode;
-
-	/* Contains the current active receive/phy mode */
-	int	rpc_cur_mode;
-	int	ctl_rfduplx;
-	int	ctl_rspeed;
-
-	u32	msg_enable;
-	u32	phy_type;
-	struct mii_if_info mii;
-
-	/* work queue */
-	struct work_struct phy_configure;
-	int	work_pending;
-
-	spinlock_t lock;
-
-#ifdef SMC_USE_PXA_DMA
-	/* DMA needs the physical address of the chip */
-	u_long physaddr;
-#endif
-};
-
 #if SMC_DEBUG > 0
 #define DBG(n, args...)					\
 	do {						\
@@ -340,7 +290,7 @@
 	 * can't handle it then there will be no recovery except for
 	 * a hard reset or power cycle
 	 */
-	if (nowait)
+	if (lp->hal.nowait)
 		cfg |= CONFIG_NO_WAIT;
 
 	/*
@@ -456,10 +406,11 @@
 #endif
 }
 
+#if !CONFIG_SMC91X_NAPI
 /*
  * This is the procedure to handle the receipt of a packet.
  */
-static inline void  smc_rcv(struct net_device *dev)
+static inline void smc_rcv(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
@@ -549,7 +500,128 @@
 		lp->stats.rx_bytes += data_len;
 	}
 }
+#else
+static int smc_poll(struct net_device *dev, int *budget)
+{
+	struct smc_local *lp = netdev_priv(dev);
+	unsigned long ioaddr = dev->base_addr;
+	int rx_work_limit = dev->quota;
+	unsigned int packet_number, status, packet_len;
+	unsigned int irqstat, received = 0;
+	struct sk_buff *skb;
+	unsigned char *data;
+	unsigned int data_len;
+	
+	DBG(3, "%s: %s\n", dev->name, __FUNCTION__);
+	SMC_SELECT_BANK(2);
+	
+	irqstat = SMC_GET_INT();
+	while (irqstat & IM_RCV_INT) 
+	{
+		packet_number = SMC_GET_RXFIFO();
+		
+		/* read from start of packet */
+		SMC_SET_PTR(PTR_READ | PTR_RCV | PTR_AUTOINC);
+		
+		/* First two words are status and packet length */
+		SMC_GET_PKT_HDR(status, packet_len);
+		packet_len &= 0x07ff;  /* mask off top bits */
+		DBG(2, "%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",
+		    dev->name, packet_number, status,
+		    packet_len, packet_len);
+		
+		if (unlikely(status & RS_ERRORS)) {
+			SMC_WAIT_MMU_BUSY();
+			SMC_SET_MMU_CMD(MC_RELEASE);
+			lp->stats.rx_errors++;
+			if (status & RS_ALGNERR)
+			    lp->stats.rx_frame_errors++;
+			if (status & (RS_TOOSHORT | RS_TOOLONG))
+			    lp->stats.rx_length_errors++;
+			if (status & RS_BADCRC)
+			    lp->stats.rx_crc_errors++;
+			
+			return 1;
+		}
+		
+		if (--rx_work_limit < 0) 
+		{
+			dev->quota -= received;
+			*budget -= received;
+			
+			return 1;  /* not_done */
+		}
+				
+		/* set multicast stats */
+		if (status & RS_MULTICAST)
+		    lp->stats.multicast++;
 
+		/*
+		 * Actual payload is packet_len - 6 (or 5 if odd byte).
+		 * We want skb_reserve(2) and the final ctrl word
+		 * (2 bytes, possibly containing the payload odd byte).
+		 * Furthermore, we add 2 bytes to allow rounding up to
+		 * multiple of 4 bytes on 32 bit buses.
+		 * Ence packet_len - 6 + 2 + 2 + 2.
+		 */
+		skb = dev_alloc_skb(packet_len);
+		if (unlikely(skb == NULL)) {
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+				dev->name);
+			SMC_WAIT_MMU_BUSY();
+			SMC_SET_MMU_CMD(MC_RELEASE);
+			lp->stats.rx_dropped++;
+			
+			netif_rx_schedule(dev);
+			return 0;
+		}
+
+		/* Align IP header to 32 bits */
+		skb_reserve(skb, 2);
+
+		/* BUG: the LAN91C111 rev A never sets this bit. Force it. */
+		if (lp->version == 0x90)
+			status |= RS_ODDFRAME;
+
+		/*
+		 * If odd length: packet_len - 5,
+		 * otherwise packet_len - 6.
+		 * With the trailing ctrl byte it's packet_len - 4.
+		 */
+		data_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);
+		data = skb_put(skb, data_len);
+		SMC_PULL_DATA(data, packet_len - 4);
+
+		SMC_WAIT_MMU_BUSY();
+		SMC_SET_MMU_CMD(MC_RELEASE);
+
+		PRINT_PKT(data, packet_len - 4);
+
+		dev->last_rx = jiffies;
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb, dev);
+		
+		netif_receive_skb (skb);
+		
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += data_len;
+		
+		SMC_WAIT_MMU_BUSY();
+		SMC_SET_MMU_CMD(MC_RELEASE);
+		
+		irqstat = SMC_GET_INT();
+	}
+	
+	dev->quota -= received;
+	*budget -= received;
+	
+	netif_rx_complete(dev);
+	SMC_ENABLE_INT(IM_RCV_INT);
+	
+	return 0;   /* done */
+}
+#endif /* NAPI */
+
 #ifdef CONFIG_SMP
 /*
  * On SMP we have the following problem:
@@ -809,6 +881,7 @@
 
 static void smc_mii_out(struct net_device *dev, unsigned int val, int bits)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
 	unsigned int mii_reg, mask;
 
@@ -830,6 +903,7 @@
 
 static unsigned int smc_mii_in(struct net_device *dev, int bits)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
 	unsigned int mii_reg, mask, val;
 
@@ -854,6 +928,7 @@
  */
 static int smc_phy_read(struct net_device *dev, int phyaddr, int phyreg)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
 	unsigned int phydata;
 
@@ -884,6 +959,7 @@
 static void smc_phy_write(struct net_device *dev, int phyaddr, int phyreg,
 			  int phydata)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
 
 	SMC_SELECT_BANK(3);
@@ -1216,6 +1292,7 @@
 
 static void smc_eph_interrupt(struct net_device *dev)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr;
 	unsigned int ctl;
 
@@ -1272,7 +1349,25 @@
 
 		if (status & IM_RCV_INT) {
 			DBG(3, "%s: RX irq\n", dev->name);
+#if CONFIG_SMC91X_NAPI
+			if (netif_rx_schedule_prep(dev))
+			{
+				/* disable interrupts caused 
+				 * by arriving packets */
+				mask &= ~IM_RCV_INT;
+				/* tell system we have work to be done. */
+				__netif_rx_schedule(dev);
+			}
+			else
+			{
+				printk(KERN_WARNING 
+				       "%s: driver bug! interrupt while in poll\n", 
+				       __FUNCTION__);
+				mask &= ~IM_RCV_INT;
+			}
+#else
 			smc_rcv(dev);
+#endif
 		} else if (status & IM_TX_INT) {
 			DBG(3, "%s: TX int\n", dev->name);
 			smc_tx(dev);
@@ -1723,8 +1818,9 @@
  * I just deleted auto_irq.c, since it was never built...
  *   --jgarzik
  */
-static int __init smc_findirq(unsigned long ioaddr)
+static int __init smc_findirq(struct net_device *dev, unsigned long ioaddr)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	int timeout = 20;
 	unsigned long cookie;
 
@@ -1899,7 +1995,7 @@
 
 		trials = 3;
 		while (trials--) {
-			dev->irq = smc_findirq(ioaddr);
+			dev->irq = smc_findirq(dev, ioaddr);
 			if (dev->irq)
 				break;
 			/* kick the card and try again */
@@ -1929,6 +2025,12 @@
 	dev->poll_controller = smc_poll_controller;
 #endif
 
+#if CONFIG_SMC91X_NAPI
+	/* NAPI */
+	dev->poll = smc_poll;
+	dev->weight = 16;
+#endif
+	
 	tasklet_init(&lp->tx_task, smc_hardware_send_pkt, (unsigned long)dev);
 	INIT_WORK(&lp->phy_configure, smc_phy_configure, dev);
 	lp->mii.phy_id_mask = 0x1f;
@@ -1981,7 +2083,7 @@
 		if (dev->dma != (unsigned char)-1)
 			printk(" DMA %d", dev->dma);
 
-		printk("%s%s\n", nowait ? " [nowait]" : "",
+		printk("%s%s\n", lp->hal.nowait ? " [nowait]" : "",
 			THROTTLE_TX_PKTS ? " [throttle_tx]" : "");
 
 		if (!is_valid_ether_addr(dev->dev_addr)) {
@@ -2012,8 +2114,9 @@
 	return retval;
 }
 
-static int smc_enable_device(unsigned long attrib_phys)
+static int smc_enable_device(struct net_device *dev, unsigned long attrib_phys)
 {
+	struct smc_local *lp = netdev_priv(dev);
 	unsigned long flags;
 	unsigned char ecor, ecsr;
 	void *addr;
@@ -2084,6 +2187,7 @@
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct net_device *ndev;
+	struct smc_local *lp;
 	struct resource *res, *ext = NULL;
 	unsigned int *addr;
 	int ret;
@@ -2094,6 +2198,19 @@
 		goto out;
 	}
 
+	ndev = alloc_etherdev(sizeof(struct smc_local));
+	if (!ndev) {
+		printk("%s: could not allocate device.\n", CARDNAME);
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	lp  = netdev_priv(ndev);
+
+#if CONFIG_SMC91X_HAL
+	smc_set_hal (lp);
+#endif
+	
 	/*
 	 * Request the regions.
 	 */
@@ -2101,13 +2218,7 @@
 		ret = -EBUSY;
 		goto out;
 	}
-
-	ndev = alloc_etherdev(sizeof(struct smc_local));
-	if (!ndev) {
-		printk("%s: could not allocate device.\n", CARDNAME);
-		ret = -ENOMEM;
-		goto release_1;
-	}
+	
 	SET_MODULE_OWNER(ndev);
 	SET_NETDEV_DEV(ndev, dev);
 
@@ -2125,7 +2236,7 @@
 		NCR_0 |= NCR_ENET_OSC_EN;
 #endif
 
-		ret = smc_enable_device(ext->start);
+		ret = smc_enable_device(ndev, ext->start);
 		if (ret)
 			goto release_both;
 	}
@@ -2164,6 +2275,7 @@
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct net_device *ndev = dev_get_drvdata(dev);
+	struct smc_local *lp = netdev_priv(ndev);
 	struct resource *res;
 
 	dev_set_drvdata(dev, NULL);
@@ -2210,7 +2322,7 @@
 		struct smc_local *lp = netdev_priv(ndev);
 
 		if (pdev->num_resources == 3)
-			smc_enable_device(pdev->resource[2].start);
+			smc_enable_device(ndev, pdev->resource[2].start);
 		if (netif_running(ndev)) {
 			smc_reset(ndev);
 			smc_enable(ndev);
Index: drivers/net/smc91x.h
===================================================================
--- a/drivers/net/smc91x.h	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/net/smc91x.h	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -34,7 +34,67 @@
 #ifndef _SMC91X_H_
 #define _SMC91X_H_
 
+#include <asm/io.h>
 
+/* store this information for the driver.. */
+struct smc_hal 
+{
+	u32     shift;
+	u32     nowait:1;
+	u32     width:2;
+};
+
+/* store this information for the driver.. */
+struct smc_local {
+	/*
+	 * If I have to wait until memory is available to send a
+	 * packet, I will store the skbuff here, until I get the
+	 * desired memory.  Then, I'll send it out and free it.
+	 */
+	struct sk_buff *pending_tx_skb;
+	struct tasklet_struct tx_task;
+
+	/*
+	 * these are things that the kernel wants me to keep, so users
+	 * can find out semi-useless statistics of how well the card is
+	 * performing
+	 */
+	struct net_device_stats stats;
+
+	/* version/revision of the SMC91x chip */
+	int version;
+
+	/* Contains the current active transmission mode */
+	int tcr_cur_mode;
+
+	/* Contains the current active receive mode */
+	int rcr_cur_mode;
+
+	/* Contains the current active receive/phy mode */
+	int rpc_cur_mode;
+	int ctl_rfduplx;
+	int ctl_rspeed;
+
+	u32 msg_enable;
+	u32 phy_type;
+	struct mii_if_info mii;
+
+	/* work queue */
+	struct work_struct phy_configure;
+	int work_pending;
+
+	spinlock_t lock;
+
+	/* hardware abstraction layer */
+	struct smc_hal hal;
+
+	/* ??? */
+	u_long attrib_phys;
+
+	/* DMA needs the physical address of the chip */
+	u_long physaddr;
+};
+
 /*
  * Define your architecture specific bus configuration parameters here.
  */
@@ -132,7 +192,8 @@
 #elif	defined(CONFIG_ARCH_INNOKOM) || \
 	defined(CONFIG_MACH_MAINSTONE) || \
 	defined(CONFIG_ARCH_PXA_IDP) || \
-	defined(CONFIG_ARCH_RAMSES)
+	defined(CONFIG_ARCH_RAMSES) || \
+	defined(CONFIG_ARCH_PXA_PNP2110_V2)
 
 #define SMC_CAN_USE_8BIT	1
 #define SMC_CAN_USE_16BIT	1
@@ -146,8 +207,8 @@
 #define SMC_inl(a, r)		readl((a) + (r))
 #define SMC_outb(v, a, r)	writeb(v, (a) + (r))
 #define SMC_outl(v, a, r)	writel(v, (a) + (r))
-#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
-#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
+#define SMC_insl(a, r, p, l)	readsl((void __iomem *)((a) + (r)), p, l)
+#define SMC_outsl(a, r, p, l)	writesl((void __iomem *)((a) + (r)), p, l)
 
 /* We actually can't write halfwords properly if not word aligned */
 static inline void
@@ -285,7 +346,7 @@
 
 	/* fallback if no DMA available */
 	if (dma == (unsigned char)-1) {
-		readsl(ioaddr + reg, buf, len);
+		readsl((void __iomem *)(ioaddr + reg), buf, len);
 		return;
 	}
 
@@ -915,7 +976,7 @@
 			SMC_SET_PTR( 2|PTR_READ|PTR_RCV|PTR_AUTOINC );	\
 		}							\
 		__len += 2;						\
-		SMC_insl( ioaddr, DATA_REG, __ptr, __len >> 2);		\
+		SMC_insl(ioaddr, DATA_REG, __ptr, __len >> 2);		\
 	} while (0)
 #elif SMC_CAN_USE_16BIT
 #define SMC_PUSH_DATA(p, l)	SMC_outsw( ioaddr, DATA_REG, p, (l) >> 1 )
Index: drivers/net/cs89x0.c
===================================================================
--- a/drivers/net/cs89x0.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/net/cs89x0.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -173,6 +173,17 @@
 #include <asm/irq.h>
 static unsigned int netcard_portlist[] __initdata = {IXDP2X01_CS8900_VIRT_BASE, 0};
 static unsigned int cs8900_irq_map[] = {IRQ_IXDP2X01_CS8900, 0, 0, 0};
+#elif defined(CONFIG_ARCH_CSB226)
+static unsigned int netcard_portlist[] __initdata = { CSB226_ETH_VIRT+0x0300+1, 0};
+static unsigned int cs8900_irq_map[] = {37,0,0,0};
+#undef inw
+#define inw(a,r)		readw((a) + (r*0x02))
+#undef outw
+#define outw(v, a, r)		writew(v, (a) + (r*0x02))
+#undef insw
+#define insw(a, r, p, l)	insw((a) + (r*0x02), p, l)
+#undef outsw
+#define outsw(a, r, p, l)	outsw((a) + (r*0x02), p, l)
 #else
 static unsigned int netcard_portlist[] __initdata =
    { 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
@@ -466,7 +477,7 @@
 				goto out2;
 			}
 	}
-printk("PP_addr=0x%x\n", inw(ioaddr + ADD_PORT));
+	printk("PP_addr=0x%x\n", inw(ioaddr + ADD_PORT));
 
 	ioaddr &= ~3;
 	outw(PP_ChipID, ioaddr + ADD_PORT);
Index: drivers/net/cs89x0-old.c
===================================================================
--- a/drivers/net/cs89x0-old.c	(revision 0)
+++ b/drivers/net/cs89x0-old.c	(revision 675)
@@ -0,0 +1,1831 @@
+/* cs89x0.c: A Crystal Semiconductor (Now Cirrus Logic) CS89[02]0
+ *  driver for linux.
+ */
+
+/*
+	Written 1996 by Russell Nelson, with reference to skeleton.c
+	written 1993-1994 by Donald Becker.
+
+	This software may be used and distributed according to the terms
+	of the GNU General Public License, incorporated herein by reference.
+
+        The author may be reached at nelson@crynwr.com, Crynwr
+        Software, 521 Pleasant Valley Rd., Potsdam, NY 13676
+
+  Changelog:
+
+  Mike Cruse        : mcruse@cti-ltd.com
+                    : Changes for Linux 2.0 compatibility. 
+                    : Added dev_id parameter in net_interrupt(),
+                    : request_irq() and free_irq(). Just NULL for now.
+
+  Mike Cruse        : Added MOD_INC_USE_COUNT and MOD_DEC_USE_COUNT macros
+                    : in net_open() and net_close() so kerneld would know
+                    : that the module is in use and wouldn't eject the 
+                    : driver prematurely.
+
+  Mike Cruse        : Rewrote init_module() and cleanup_module using 8390.c
+                    : as an example. Disabled autoprobing in init_module(),
+                    : not a good thing to do to other devices while Linux
+                    : is running from all accounts.
+
+  Russ Nelson       : Jul 13 1998.  Added RxOnly DMA support.
+
+  Melody Lee        : Aug 10 1999.  Changes for Linux 2.2.5 compatibility. 
+                    : email: ethernet@crystal.cirrus.com
+
+  Alan Cox          : Removed 1.2 support, added 2.1 extra counters.
+
+  Andrew Morton     : andrewm@uow.edu.au
+                    : Kernel 2.3.48
+                    : Handle kmalloc() failures
+                    : Other resource allocation fixes
+                    : Add SMP locks
+                    : Integrate Russ Nelson's ALLOW_DMA functionality back in.
+                    : If ALLOW_DMA is true, make DMA runtime selectable
+                    : Folded in changes from Cirrus (Melody Lee
+                    : <klee@crystal.cirrus.com>)
+                    : Don't call netif_wake_queue() in net_send_packet()
+                    : Fixed an out-of-mem bug in dma_rx()
+                    : Updated Documentation/cs89x0.txt
+
+  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.3.99-pre1
+                    : Use skb_reserve to longword align IP header (two places)
+                    : Remove a delay loop from dma_rx()
+                    : Replace '100' with HZ
+                    : Clean up a couple of skb API abuses
+                    : Added 'cs89x0_dma=N' kernel boot option
+                    : Correctly initialise lp->lock in non-module compile
+
+  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.3.99-pre4-1
+                    : MOD_INC/DEC race fix (see
+                    : http://www.uwsg.indiana.edu/hypermail/linux/kernel/0003.3/1532.html)
+
+  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.4.0-test7-pre2
+                    : Enhanced EEPROM support to cover more devices,
+                    :   abstracted IRQ mapping to support CONFIG_ARCH_CLPS7500 arch
+                    :   (Jason Gunthorpe <jgg@ualberta.ca>)
+
+  Andrew Morton     : Kernel 2.4.0-test11-pre4
+                    : Use dev->name in request_*() (Andrey Panin)
+                    : Fix an error-path memleak in init_module()
+                    : Preserve return value from request_irq()
+                    : Fix type of `media' module parm (Keith Owens)
+                    : Use SET_MODULE_OWNER()
+                    : Tidied up strange request_irq() abuse in net_open().
+
+  Andrew Morton     : Kernel 2.4.3-pre1
+                    : Request correct number of pages for DMA (Hugh Dickens)
+                    : Select PP_ChipID _after_ unregister_netdev in cleanup_module()
+                    :  because unregister_netdev() calls get_stats.
+                    : Make `version[]' __initdata
+                    : Uninlined the read/write reg/word functions.
+
+  Oskar Schirmer    : oskar@scara.com
+                    : HiCO.SH4 (superh) support added (irq#1, cs89x0_media=)
+
+*/
+
+/* Always include 'config.h' first in case the user wants to turn on
+   or override something. */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+/*
+ * Set this to zero to disable DMA code
+ *
+ * Note that even if DMA is turned off we still support the 'dma' and  'use_dma'
+ * module options so we don't break any startup scripts.
+ */
+#define ALLOW_DMA	1
+
+/*
+ * Set this to zero to remove all the debug statements via
+ * dead code elimination
+ */
+#define DEBUGGING	1
+
+/*
+  Sources:
+
+	Crynwr packet driver epktisa.
+
+	Crystal Semiconductor data sheets.
+
+*/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#if ALLOW_DMA
+#include <asm/dma.h>
+#endif
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "cs89x0.h"
+
+static char version[] __initdata =
+"cs89x0.c: v2.4.3-pre1 Russell Nelson <nelson@crynwr.com>, Andrew Morton <andrewm@uow.edu.au>\n";
+
+/* First, a few definitions that the brave might change.
+   A zero-terminated list of I/O addresses to be probed. Some special flags..
+      Addr & 1 = Read back the address port, look for signature and reset
+                 the page window before probing 
+      Addr & 3 = Reset the page window and probe 
+   The CLPS eval board has the Cirrus chip at 0x80090300, in ARM IO space,
+   but it is possible that a Cirrus board could be plugged into the ISA
+   slots. */
+/* The cs8900 has 4 IRQ pins, software selectable. cs8900_irq_map maps 
+   them to system IRQ numbers. This mapping is card specific and is set to
+   the configuration of the Cirrus Eval board for this chip. */
+#ifdef CONFIG_ARCH_CLPS7500
+static unsigned int netcard_portlist[] __initdata =
+   { 0x80090303, 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
+static unsigned int cs8900_irq_map[] = {12,0,0,0};
+#elif defined(CONFIG_SH_HICOSH4)
+static unsigned int netcard_portlist[] __initdata =
+   { 0x0300, 0};
+static unsigned int cs8900_irq_map[] = {1,0,0,0};
+#else
+static unsigned int netcard_portlist[] __initdata =
+   { 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
+static unsigned int cs8900_irq_map[] = {10,11,12,5};
+#endif
+
+#if DEBUGGING
+static unsigned int net_debug = DEBUGGING;
+#else
+#define net_debug 0	/* gcc will remove all the debug code for us */
+#endif
+
+/* The number of low I/O ports used by the ethercard. */
+#define NETCARD_IO_EXTENT	16
+
+/* we allow the user to override various values normally set in the EEPROM */
+#define FORCE_RJ45	0x0001    /* pick one of these three */
+#define FORCE_AUI	0x0002
+#define FORCE_BNC	0x0004
+
+#define FORCE_AUTO	0x0010    /* pick one of these three */
+#define FORCE_HALF	0x0020
+#define FORCE_FULL	0x0030
+
+/* Information that need to be kept for each board. */
+struct net_local {
+	struct net_device_stats stats;
+	int chip_type;		/* one of: CS8900, CS8920, CS8920M */
+	char chip_revision;	/* revision letter of the chip ('A'...) */
+	int send_cmd;		/* the proper send command: TX_NOW, TX_AFTER_381, or TX_AFTER_ALL */
+	int auto_neg_cnf;	/* auto-negotiation word from EEPROM */
+	int adapter_cnf;	/* adapter configuration from EEPROM */
+	int isa_config;		/* ISA configuration from EEPROM */
+	int irq_map;		/* IRQ map from EEPROM */
+	int rx_mode;		/* what mode are we in? 0, RX_MULTCAST_ACCEPT, or RX_ALL_ACCEPT */
+	int curr_rx_cfg;	/* a copy of PP_RxCFG */
+	int linectl;		/* either 0 or LOW_RX_SQUELCH, depending on configuration. */
+	int send_underrun;	/* keep track of how many underruns in a row we get */
+	int force;		/* force various values; see FORCE* above. */
+	spinlock_t lock;
+#if ALLOW_DMA
+	int use_dma;		/* Flag: we're using dma */
+	int dma;		/* DMA channel */
+	int dmasize;		/* 16 or 64 */
+	unsigned char *dma_buff;	/* points to the beginning of the buffer */
+	unsigned char *end_dma_buff;	/* points to the end of the buffer */
+	unsigned char *rx_dma_ptr;	/* points to the next packet  */
+#endif
+};
+
+/* Index to functions, as function prototypes. */
+
+extern int cs89x0_probe(struct net_device *dev);
+
+static int cs89x0_probe1(struct net_device *dev, int ioaddr);
+static int net_open(struct net_device *dev);
+static int net_send_packet(struct sk_buff *skb, struct net_device *dev);
+static void net_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static void set_multicast_list(struct net_device *dev);
+static void net_timeout(struct net_device *dev);
+static void net_rx(struct net_device *dev);
+static int net_close(struct net_device *dev);
+static struct net_device_stats *net_get_stats(struct net_device *dev);
+static void reset_chip(struct net_device *dev);
+static int get_eeprom_data(struct net_device *dev, int off, int len, int *buffer);
+static int get_eeprom_cksum(int off, int len, int *buffer);
+static int set_mac_address(struct net_device *dev, void *addr);
+static void count_rx_errors(int status, struct net_local *lp);
+#if ALLOW_DMA
+static void get_dma_channel(struct net_device *dev);
+static void release_dma_buff(struct net_local *lp);
+#endif
+
+/* Example routines you must write ;->. */
+#define tx_done(dev) 1
+
+/*
+ * Permit 'cs89x0_dma=N' in the kernel boot environment
+ */
+#if !defined(MODULE) && (ALLOW_DMA != 0)
+static int g_cs89x0_dma;
+
+static int __init dma_fn(char *str)
+{
+	g_cs89x0_dma = simple_strtol(str,NULL,0);
+	return 1;
+}
+
+__setup("cs89x0_dma=", dma_fn);
+#endif	/* !defined(MODULE) && (ALLOW_DMA != 0) */
+
+#ifndef MODULE
+static int g_cs89x0_media__force;
+
+static int __init media_fn(char *str)
+{
+	if (!strcmp(str, "rj45")) g_cs89x0_media__force = FORCE_RJ45;
+	else if (!strcmp(str, "aui")) g_cs89x0_media__force = FORCE_AUI;
+	else if (!strcmp(str, "bnc")) g_cs89x0_media__force = FORCE_BNC;
+	return 1;
+}
+
+__setup("cs89x0_media=", media_fn);
+#endif
+
+
+/* Check for a network adaptor of this type, and return '0' iff one exists.
+   If dev->base_addr == 0, probe all likely locations.
+   If dev->base_addr == 1, always return failure.
+   If dev->base_addr == 2, allocate space for the device and return success
+   (detachable devices only).
+   Return 0 on success.
+   */
+
+int __init cs89x0_probe(struct net_device *dev)
+{
+	int i;
+	int base_addr = dev ? dev->base_addr : 0;
+
+	SET_MODULE_OWNER(dev);
+
+	if (net_debug)
+		printk("cs89x0:cs89x0_probe(0x%x)\n", base_addr);
+
+	if (base_addr > 0x1ff)		/* Check a single specified location. */
+		return cs89x0_probe1(dev, base_addr);
+	else if (base_addr != 0)	/* Don't probe at all. */
+		return -ENXIO;
+
+	for (i = 0; netcard_portlist[i]; i++) {
+		if (cs89x0_probe1(dev, netcard_portlist[i]) == 0)
+			return 0;
+	}
+	printk(KERN_WARNING "cs89x0: no cs8900 or cs8920 detected.  Be sure to disable PnP with SETUP\n");
+	return -ENODEV;
+}
+
+static int
+readreg(struct net_device *dev, int portno)
+{
+	outw(portno, dev->base_addr + ADD_PORT);
+	return inw(dev->base_addr + DATA_PORT);
+}
+
+static void
+writereg(struct net_device *dev, int portno, int value)
+{
+	outw(portno, dev->base_addr + ADD_PORT);
+	outw(value, dev->base_addr + DATA_PORT);
+}
+
+static int
+readword(struct net_device *dev, int portno)
+{
+	return inw(dev->base_addr + portno);
+}
+
+static void
+writeword(struct net_device *dev, int portno, int value)
+{
+	outw(value, dev->base_addr + portno);
+}
+
+static int __init
+wait_eeprom_ready(struct net_device *dev)
+{
+	int timeout = jiffies;
+	/* check to see if the EEPROM is ready, a timeout is used -
+	   just in case EEPROM is ready when SI_BUSY in the
+	   PP_SelfST is clear */
+	while(readreg(dev, PP_SelfST) & SI_BUSY)
+		if (jiffies - timeout >= 40)
+			return -1;
+	return 0;
+}
+
+static int __init
+get_eeprom_data(struct net_device *dev, int off, int len, int *buffer)
+{
+	int i;
+
+	if (net_debug > 3) printk("EEPROM data from %x for %x:\n",off,len);
+	for (i = 0; i < len; i++) {
+		if (wait_eeprom_ready(dev) < 0) return -1;
+		/* Now send the EEPROM read command and EEPROM location to read */
+		writereg(dev, PP_EECMD, (off + i) | EEPROM_READ_CMD);
+		if (wait_eeprom_ready(dev) < 0) return -1;
+		buffer[i] = readreg(dev, PP_EEData);
+		if (net_debug > 3) printk("%04x ", buffer[i]);
+	}
+	if (net_debug > 3) printk("\n");
+        return 0;
+}
+
+static int  __init
+get_eeprom_cksum(int off, int len, int *buffer)
+{
+	int i, cksum;
+
+	cksum = 0;
+	for (i = 0; i < len; i++)
+		cksum += buffer[i];
+	cksum &= 0xffff;
+	if (cksum == 0)
+		return 0;
+	return -1;
+}
+
+/* This is the real probe routine.  Linux has a history of friendly device
+   probes on the ISA bus.  A good device probes avoids doing writes, and
+   verifies that the correct device exists and functions.
+   Return 0 on success.
+ */
+
+static int __init
+cs89x0_probe1(struct net_device *dev, int ioaddr)
+{
+	struct net_local *lp;
+	static unsigned version_printed;
+	int i;
+	unsigned rev_type = 0;
+	int eeprom_buff[CHKSUM_LEN];
+	int retval;
+
+	/* Initialize the device structure. */
+	if (dev->priv == NULL) {
+		dev->priv = kmalloc(sizeof(struct net_local), GFP_KERNEL);
+		if (dev->priv == 0) {
+			retval = -ENOMEM;
+			goto out;
+		}
+		lp = (struct net_local *)dev->priv;
+		memset(lp, 0, sizeof(*lp));
+		spin_lock_init(&lp->lock);
+#if !defined(MODULE) && (ALLOW_DMA != 0)
+		if (g_cs89x0_dma) {
+			lp->use_dma = 1;
+			lp->dma = g_cs89x0_dma;
+			lp->dmasize = 16;	/* Could make this an option... */
+		}
+#endif
+#ifndef MODULE
+		lp->force = g_cs89x0_media__force;
+#endif
+        }
+	lp = (struct net_local *)dev->priv;
+
+	/* Grab the region so we can find another board if autoIRQ fails. */
+	if (!request_region(ioaddr & ~3, NETCARD_IO_EXTENT, dev->name)) {
+		printk(KERN_ERR "%s: request_region(0x%x, 0x%x) failed\n",
+				dev->name, ioaddr, NETCARD_IO_EXTENT);
+		retval = -EBUSY;
+		goto out1;
+	}
+
+#ifdef CONFIG_SH_HICOSH4
+	/* truely reset the chip */
+	outw(0x0114, ioaddr + ADD_PORT);
+	outw(0x0040, ioaddr + DATA_PORT);
+#endif
+
+	/* if they give us an odd I/O address, then do ONE write to
+           the address port, to get it back to address zero, where we
+           expect to find the EISA signature word. An IO with a base of 0x3
+ 	   will skip the test for the ADD_PORT. */
+	if (ioaddr & 1) {
+		if (net_debug > 1)
+			printk(KERN_INFO "%s: odd ioaddr 0x%x\n", dev->name, ioaddr);
+ 	        if ((ioaddr & 2) != 2)
+	        	if ((inw((ioaddr & ~3)+ ADD_PORT) & ADD_MASK) != ADD_SIG) {
+				printk(KERN_ERR "%s: bad signature 0x%x\n",
+					dev->name, inw((ioaddr & ~3)+ ADD_PORT));
+		        	retval = -ENODEV;
+				goto out2;
+			}
+ 		ioaddr &= ~3;
+		outw(PP_ChipID, ioaddr + ADD_PORT);
+	}
+printk("PP_addr=0x%x\n", inw(ioaddr + ADD_PORT));
+
+	if (inw(ioaddr + DATA_PORT) != CHIP_EISA_ID_SIG) {
+		printk(KERN_ERR "%s: incorrect signature 0x%x\n",
+			dev->name, inw(ioaddr + DATA_PORT));
+		retval = -ENODEV;
+  		goto out2;
+	}
+
+	/* Fill in the 'dev' fields. */
+	dev->base_addr = ioaddr;
+
+	/* get the chip type */
+	rev_type = readreg(dev, PRODUCT_ID_ADD);
+	lp->chip_type = rev_type &~ REVISON_BITS;
+	lp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';
+
+	/* Check the chip type and revision in order to set the correct send command
+	CS8920 revision C and CS8900 revision F can use the faster send. */
+	lp->send_cmd = TX_AFTER_381;
+	if (lp->chip_type == CS8900 && lp->chip_revision >= 'F')
+		lp->send_cmd = TX_NOW;
+	if (lp->chip_type != CS8900 && lp->chip_revision >= 'C')
+		lp->send_cmd = TX_NOW;
+
+	if (net_debug  &&  version_printed++ == 0)
+		printk(version);
+
+	printk(KERN_INFO "%s: cs89%c0%s rev %c found at %#3lx ",
+	       dev->name,
+	       lp->chip_type==CS8900?'0':'2',
+	       lp->chip_type==CS8920M?"M":"",
+	       lp->chip_revision,
+	       dev->base_addr);
+
+	reset_chip(dev);
+
+        /* Here we read the current configuration of the chip. If there
+	   is no Extended EEPROM then the idea is to not disturb the chip
+	   configuration, it should have been correctly setup by automatic
+	   EEPROM read on reset. So, if the chip says it read the EEPROM
+	   the driver will always do *something* instead of complain that
+	   adapter_cnf is 0. */
+
+#ifdef CONFIG_SH_HICOSH4
+	if (1) {
+		/* For the HiCO.SH4 board, things are different: we don't
+		   have EEPROM, but there is some data in flash, so we go
+		   get it there directly (MAC). */
+		__u16 *confd;
+		short cnt;
+		if (((* (volatile __u32 *) 0xa0013ff0) & 0x00ffffff)
+			== 0x006c3000) {
+			confd = (__u16*) 0xa0013fc0;
+		} else {
+			confd = (__u16*) 0xa001ffc0;
+		}
+		cnt = (*confd++ & 0x00ff) >> 1;
+		while (--cnt > 0) {
+			__u16 j = *confd++;
+			
+			switch (j & 0x0fff) {
+			case PP_IA:
+				for (i = 0; i < ETH_ALEN/2; i++) {
+					dev->dev_addr[i*2] = confd[i] & 0xFF;
+					dev->dev_addr[i*2+1] = confd[i] >> 8;
+				}
+				break;
+			}
+			j = (j >> 12) + 1;
+			confd += j;
+			cnt -= j;
+		}
+	} else
+#endif
+
+        if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) == 
+	      (EEPROM_OK|EEPROM_PRESENT)) {
+	        /* Load the MAC. */
+		for (i=0; i < ETH_ALEN/2; i++) {
+	                unsigned int Addr;
+			Addr = readreg(dev, PP_IA+i*2);
+		        dev->dev_addr[i*2] = Addr & 0xFF;
+		        dev->dev_addr[i*2+1] = Addr >> 8;
+		}
+   
+	   	/* Load the Adapter Configuration. 
+		   Note:  Barring any more specific information from some 
+		   other source (ie EEPROM+Schematics), we would not know 
+		   how to operate a 10Base2 interface on the AUI port. 
+		   However, since we  do read the status of HCB1 and use 
+		   settings that always result in calls to control_dc_dc(dev,0) 
+		   a BNC interface should work if the enable pin 
+		   (dc/dc converter) is on HCB1. It will be called AUI 
+		   however. */
+	   
+		lp->adapter_cnf = 0;
+		i = readreg(dev, PP_LineCTL);
+		/* Preserve the setting of the HCB1 pin. */
+		if ((i & (HCB1 | HCB1_ENBL)) ==  (HCB1 | HCB1_ENBL))
+			lp->adapter_cnf |= A_CNF_DC_DC_POLARITY;
+		/* Save the sqelch bit */
+		if ((i & LOW_RX_SQUELCH) == LOW_RX_SQUELCH)
+			lp->adapter_cnf |= A_CNF_EXTND_10B_2 | A_CNF_LOW_RX_SQUELCH;
+		/* Check if the card is in 10Base-t only mode */
+		if ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == 0)
+			lp->adapter_cnf |=  A_CNF_10B_T | A_CNF_MEDIA_10B_T;
+		/* Check if the card is in AUI only mode */
+		if ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUI_ONLY)
+			lp->adapter_cnf |=  A_CNF_AUI | A_CNF_MEDIA_AUI;
+		/* Check if the card is in Auto mode. */
+		if ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUTO_AUI_10BASET)
+			lp->adapter_cnf |=  A_CNF_AUI | A_CNF_10B_T | 
+			A_CNF_MEDIA_AUI | A_CNF_MEDIA_10B_T | A_CNF_MEDIA_AUTO;
+		
+		if (net_debug > 1)
+			printk(KERN_INFO "%s: PP_LineCTL=0x%x, adapter_cnf=0x%x\n",
+					dev->name, i, lp->adapter_cnf);
+
+		/* IRQ. Other chips already probe, see below. */
+		if (lp->chip_type == CS8900) 
+			lp->isa_config = readreg(dev, PP_CS8900_ISAINT) & INT_NO_MASK;
+	   
+		printk( "[Cirrus EEPROM] ");
+	}
+
+        printk("\n");
+   
+	/* First check to see if an EEPROM is attached. */
+#ifdef CONFIG_SH_HICOSH4 /* no EEPROM on HiCO, don't hazzle with it here */
+	if (1) {
+		printk(KERN_NOTICE "cs89x0: No EEPROM on HiCO.SH4\n");
+	} else
+#endif
+	if ((readreg(dev, PP_SelfST) & EEPROM_PRESENT) == 0)
+		printk(KERN_WARNING "cs89x0: No EEPROM, relying on command line....\n");
+	else if (get_eeprom_data(dev, START_EEPROM_DATA,CHKSUM_LEN,eeprom_buff) < 0) {
+		printk(KERN_WARNING "\ncs89x0: EEPROM read failed, relying on command line.\n");
+        } else if (get_eeprom_cksum(START_EEPROM_DATA,CHKSUM_LEN,eeprom_buff) < 0) {
+		/* Check if the chip was able to read its own configuration starting
+		   at 0 in the EEPROM*/
+		if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) !=
+		    (EEPROM_OK|EEPROM_PRESENT)) 
+                	printk(KERN_WARNING "cs89x0: Extended EEPROM checksum bad and no Cirrus EEPROM, relying on command line\n");
+		   
+        } else {
+		/* This reads an extended EEPROM that is not documented
+		   in the CS8900 datasheet. */
+		
+                /* get transmission control word  but keep the autonegotiation bits */
+                if (!lp->auto_neg_cnf) lp->auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET/2];
+                /* Store adapter configuration */
+                if (!lp->adapter_cnf) lp->adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET/2];
+                /* Store ISA configuration */
+                lp->isa_config = eeprom_buff[ISA_CNF_OFFSET/2];
+                dev->mem_start = eeprom_buff[PACKET_PAGE_OFFSET/2] << 8;
+
+                /* eeprom_buff has 32-bit ints, so we can't just memcpy it */
+                /* store the initial memory base address */
+                for (i = 0; i < ETH_ALEN/2; i++) {
+                        dev->dev_addr[i*2] = eeprom_buff[i];
+                        dev->dev_addr[i*2+1] = eeprom_buff[i] >> 8;
+                }
+		if (net_debug > 1)
+			printk(KERN_DEBUG "%s: new adapter_cnf: 0x%x\n",
+				dev->name, lp->adapter_cnf);
+        }
+
+        /* allow them to force multiple transceivers.  If they force multiple, autosense */
+        {
+		int count = 0;
+		if (lp->force & FORCE_RJ45)	{lp->adapter_cnf |= A_CNF_10B_T; count++; }
+		if (lp->force & FORCE_AUI) 	{lp->adapter_cnf |= A_CNF_AUI; count++; }
+		if (lp->force & FORCE_BNC)	{lp->adapter_cnf |= A_CNF_10B_2; count++; }
+		if (count > 1)			{lp->adapter_cnf |= A_CNF_MEDIA_AUTO; }
+		else if (lp->force & FORCE_RJ45){lp->adapter_cnf |= A_CNF_MEDIA_10B_T; }
+		else if (lp->force & FORCE_AUI)	{lp->adapter_cnf |= A_CNF_MEDIA_AUI; }
+		else if (lp->force & FORCE_BNC)	{lp->adapter_cnf |= A_CNF_MEDIA_10B_2; }
+        }
+
+	if (net_debug > 1)
+		printk(KERN_DEBUG "%s: after force 0x%x, adapter_cnf=0x%x\n",
+			dev->name, lp->force, lp->adapter_cnf);
+
+        /* FIXME: We don't let you set dc-dc polarity or low RX squelch from the command line: add it here */
+
+        /* FIXME: We don't let you set the IMM bit from the command line: add it to lp->auto_neg_cnf here */
+
+        /* FIXME: we don't set the Ethernet address on the command line.  Use
+           ifconfig IFACE hw ether AABBCCDDEEFF */
+
+	printk(KERN_INFO "cs89x0 media %s%s%s",
+	       (lp->adapter_cnf & A_CNF_10B_T)?"RJ-45,":"",
+	       (lp->adapter_cnf & A_CNF_AUI)?"AUI,":"",
+	       (lp->adapter_cnf & A_CNF_10B_2)?"BNC,":"");
+
+	lp->irq_map = 0xffff;
+
+	/* If this is a CS8900 then no pnp soft */
+	if (lp->chip_type != CS8900 &&
+	    /* Check if the ISA IRQ has been set  */
+		(i = readreg(dev, PP_CS8920_ISAINT) & 0xff,
+		 (i != 0 && i < CS8920_NO_INTS))) {
+		if (!dev->irq)
+			dev->irq = i;
+	} else {
+		i = lp->isa_config & INT_NO_MASK;
+		if (lp->chip_type == CS8900) {
+			/* Translate the IRQ using the IRQ mapping table. */
+			if (i >= sizeof(cs8900_irq_map)/sizeof(cs8900_irq_map[0]))
+				printk("\ncs89x0: invalid ISA interrupt number %d\n", i);
+			else
+				i = cs8900_irq_map[i];
+			
+			lp->irq_map = CS8900_IRQ_MAP; /* fixed IRQ map for CS8900 */
+		} else {
+			int irq_map_buff[IRQ_MAP_LEN/2];
+
+			if (get_eeprom_data(dev, IRQ_MAP_EEPROM_DATA,
+					    IRQ_MAP_LEN/2,
+					    irq_map_buff) >= 0) {
+				if ((irq_map_buff[0] & 0xff) == PNP_IRQ_FRMT)
+					lp->irq_map = (irq_map_buff[0]>>8) | (irq_map_buff[1] << 8);
+			}
+		}
+		if (!dev->irq)
+			dev->irq = i;
+	}
+
+	printk(" IRQ %d", dev->irq);
+
+#if ALLOW_DMA
+	if (lp->use_dma) {
+		get_dma_channel(dev);
+		printk(", DMA %d", dev->dma);
+	}
+	else
+#endif
+	{
+		printk(", programmed I/O");
+	}
+
+	/* print the ethernet address. */
+	printk(", MAC");
+	for (i = 0; i < ETH_ALEN; i++)
+	{
+		printk("%c%02x", i ? ':' : ' ', dev->dev_addr[i]);
+	}
+
+	dev->open		= net_open;
+	dev->stop		= net_close;
+	dev->tx_timeout		= net_timeout;
+	dev->watchdog_timeo	= HZ;
+	dev->hard_start_xmit 	= net_send_packet;
+	dev->get_stats		= net_get_stats;
+	dev->set_multicast_list = set_multicast_list;
+	dev->set_mac_address 	= set_mac_address;
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	ether_setup(dev);
+
+	printk("\n");
+	if (net_debug)
+		printk("cs89x0_probe1() successful\n");
+	return 0;
+out2:
+	release_region(ioaddr & ~3, NETCARD_IO_EXTENT);
+out1:
+	kfree(dev->priv);
+	dev->priv = 0;
+out:
+	return retval;
+}
+
+
+/*********************************
+ * This page contains DMA routines
+**********************************/
+
+#if ALLOW_DMA
+
+#define dma_page_eq(ptr1, ptr2) ((long)(ptr1)>>17 == (long)(ptr2)>>17)
+
+static void
+get_dma_channel(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	if (lp->dma) {
+		dev->dma = lp->dma;
+		lp->isa_config |= ISA_RxDMA;
+	} else {
+		if ((lp->isa_config & ANY_ISA_DMA) == 0)
+			return;
+		dev->dma = lp->isa_config & DMA_NO_MASK;
+		if (lp->chip_type == CS8900)
+			dev->dma += 5;
+		if (dev->dma < 5 || dev->dma > 7) {
+			lp->isa_config &= ~ANY_ISA_DMA;
+			return;
+		}
+	}
+	return;
+}
+
+static void
+write_dma(struct net_device *dev, int chip_type, int dma)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	if ((lp->isa_config & ANY_ISA_DMA) == 0)
+		return;
+	if (chip_type == CS8900) {
+		writereg(dev, PP_CS8900_ISADMA, dma-5);
+	} else {
+		writereg(dev, PP_CS8920_ISADMA, dma);
+	}
+}
+
+static void
+set_dma_cfg(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	if (lp->use_dma) {
+		if ((lp->isa_config & ANY_ISA_DMA) == 0) {
+			if (net_debug > 3)
+				printk("set_dma_cfg(): no DMA\n");
+			return;
+		}
+		if (lp->isa_config & ISA_RxDMA) {
+			lp->curr_rx_cfg |= RX_DMA_ONLY;
+			if (net_debug > 3)
+				printk("set_dma_cfg(): RX_DMA_ONLY\n");
+		} else {
+			lp->curr_rx_cfg |= AUTO_RX_DMA;	/* not that we support it... */
+			if (net_debug > 3)
+				printk("set_dma_cfg(): AUTO_RX_DMA\n");
+		}
+	}
+}
+
+static int
+dma_bufcfg(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	if (lp->use_dma)
+		return (lp->isa_config & ANY_ISA_DMA)? RX_DMA_ENBL : 0;
+	else
+		return 0;
+}
+
+static int
+dma_busctl(struct net_device *dev)
+{
+	int retval = 0;
+	struct net_local *lp = (struct net_local *)dev->priv;
+	if (lp->use_dma) {
+		if (lp->isa_config & ANY_ISA_DMA)
+			retval |= RESET_RX_DMA; /* Reset the DMA pointer */
+		if (lp->isa_config & DMA_BURST)
+			retval |= DMA_BURST_MODE; /* Does ISA config specify DMA burst ? */
+		if (lp->dmasize == 64)
+			retval |= RX_DMA_SIZE_64K; /* did they ask for 64K? */
+		retval |= MEMORY_ON;	/* we need memory enabled to use DMA. */
+	}
+	return retval;
+}
+
+static void
+dma_rx(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	struct sk_buff *skb;
+	int status, length;
+	unsigned char *bp = lp->rx_dma_ptr;
+
+	status = bp[0] + (bp[1]<<8);
+	length = bp[2] + (bp[3]<<8);
+	bp += 4;
+	if (net_debug > 5) {
+		printk(	"%s: receiving DMA packet at %lx, status %x, length %x\n",
+			dev->name, (unsigned long)bp, status, length);
+	}
+	if ((status & RX_OK) == 0) {
+		count_rx_errors(status, lp);
+		goto skip_this_frame;
+	}
+
+	/* Malloc up new buffer. */
+	skb = dev_alloc_skb(length + 2);
+	if (skb == NULL) {
+		if (net_debug)	/* I don't think we want to do this to a stressed system */
+			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
+		lp->stats.rx_dropped++;
+
+		/* AKPM: advance bp to the next frame */
+skip_this_frame:
+		bp += (length + 3) & ~3;
+		if (bp >= lp->end_dma_buff) bp -= lp->dmasize*1024;
+		lp->rx_dma_ptr = bp;
+		return;
+	}
+	skb_reserve(skb, 2);	/* longword align L3 header */
+	skb->dev = dev;
+
+	if (bp + length > lp->end_dma_buff) {
+		int semi_cnt = lp->end_dma_buff - bp;
+		memcpy(skb_put(skb,semi_cnt), bp, semi_cnt);
+		memcpy(skb_put(skb,length - semi_cnt), lp->dma_buff,
+		       length - semi_cnt);
+	} else {
+		memcpy(skb_put(skb,length), bp, length);
+	}
+	bp += (length + 3) & ~3;
+	if (bp >= lp->end_dma_buff) bp -= lp->dmasize*1024;
+	lp->rx_dma_ptr = bp;
+
+	if (net_debug > 3) {
+		printk(	"%s: received %d byte DMA packet of type %x\n",
+			dev->name, length,
+			(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);
+	}
+        skb->protocol=eth_type_trans(skb,dev);
+	netif_rx(skb);
+	dev->last_rx = jiffies;
+	lp->stats.rx_packets++;
+	lp->stats.rx_bytes += length;
+}
+
+#endif	/* ALLOW_DMA */
+
+void  __init reset_chip(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	int ioaddr = dev->base_addr;
+	int reset_start_time;
+
+	writereg(dev, PP_SelfCTL, readreg(dev, PP_SelfCTL) | POWER_ON_RESET);
+
+	/* wait 30 ms */
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(30*HZ/1000);
+
+	if (lp->chip_type != CS8900) {
+		/* Hardware problem requires PNP registers to be reconfigured after a reset */
+		outw(PP_CS8920_ISAINT, ioaddr + ADD_PORT);
+		outb(dev->irq, ioaddr + DATA_PORT);
+		outb(0,      ioaddr + DATA_PORT + 1);
+
+		outw(PP_CS8920_ISAMemB, ioaddr + ADD_PORT);
+		outb((dev->mem_start >> 16) & 0xff, ioaddr + DATA_PORT);
+		outb((dev->mem_start >> 8) & 0xff,   ioaddr + DATA_PORT + 1);
+	}
+	/* Wait until the chip is reset */
+	reset_start_time = jiffies;
+	while( (readreg(dev, PP_SelfST) & INIT_DONE) == 0 && jiffies - reset_start_time < 2)
+		;
+}
+
+
+static void
+control_dc_dc(struct net_device *dev, int on_not_off)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	unsigned int selfcontrol;
+	int timenow = jiffies;
+	/* control the DC to DC convertor in the SelfControl register.  
+	   Note: This is hooked up to a general purpose pin, might not
+	   always be a DC to DC convertor. */
+
+	selfcontrol = HCB1_ENBL; /* Enable the HCB1 bit as an output */
+	if (((lp->adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)
+		selfcontrol |= HCB1;
+	else
+		selfcontrol &= ~HCB1;
+	writereg(dev, PP_SelfCTL, selfcontrol);
+
+	/* Wait for the DC/DC converter to power up - 500ms */
+	while (jiffies - timenow < HZ)
+		;
+}
+
+#define DETECTED_NONE  0
+#define DETECTED_RJ45H 1
+#define DETECTED_RJ45F 2
+#define DETECTED_AUI   3
+#define DETECTED_BNC   4
+
+static int
+detect_tp(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	int timenow = jiffies;
+	int fdx;
+
+	if (net_debug > 1) printk("%s: Attempting TP\n", dev->name);
+
+        /* If connected to another full duplex capable 10-Base-T card the link pulses
+           seem to be lost when the auto detect bit in the LineCTL is set.
+           To overcome this the auto detect bit will be cleared whilst testing the
+           10-Base-T interface.  This would not be necessary for the sparrow chip but
+           is simpler to do it anyway. */
+	writereg(dev, PP_LineCTL, lp->linectl &~ AUI_ONLY);
+	control_dc_dc(dev, 0);
+
+        /* Delay for the hardware to work out if the TP cable is present - 150ms */
+	for (timenow = jiffies; jiffies - timenow < 15; )
+                ;
+	if ((readreg(dev, PP_LineST) & LINK_OK) == 0)
+		return DETECTED_NONE;
+
+	if (lp->chip_type == CS8900) {
+                switch (lp->force & 0xf0) {
+#if 0
+                case FORCE_AUTO:
+			printk("%s: cs8900 doesn't autonegotiate\n",dev->name);
+                        return DETECTED_NONE;
+#endif
+		/* CS8900 doesn't support AUTO, change to HALF*/
+                case FORCE_AUTO:
+			lp->force &= ~FORCE_AUTO;
+                        lp->force |= FORCE_HALF;
+			break;
+		case FORCE_HALF:
+			break;
+                case FORCE_FULL:
+			writereg(dev, PP_TestCTL, readreg(dev, PP_TestCTL) | FDX_8900);
+			break;
+                }
+		fdx = readreg(dev, PP_TestCTL) & FDX_8900;
+	} else {
+		switch (lp->force & 0xf0) {
+		case FORCE_AUTO:
+			lp->auto_neg_cnf = AUTO_NEG_ENABLE;
+			break;
+		case FORCE_HALF:
+			lp->auto_neg_cnf = 0;
+			break;
+		case FORCE_FULL:
+			lp->auto_neg_cnf = RE_NEG_NOW | ALLOW_FDX;
+			break;
+                }
+
+		writereg(dev, PP_AutoNegCTL, lp->auto_neg_cnf & AUTO_NEG_MASK);
+
+		if ((lp->auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {
+			printk(KERN_INFO "%s: negotiating duplex...\n",dev->name);
+			while (readreg(dev, PP_AutoNegST) & AUTO_NEG_BUSY) {
+				if (jiffies - timenow > 4000) {
+					printk(KERN_ERR "**** Full / half duplex auto-negotiation timed out ****\n");
+					break;
+				}
+			}
+		}
+		fdx = readreg(dev, PP_AutoNegST) & FDX_ACTIVE;
+	}
+	if (fdx)
+		return DETECTED_RJ45F;
+	else
+		return DETECTED_RJ45H;
+}
+
+/* send a test packet - return true if carrier bits are ok */
+static int
+send_test_pkt(struct net_device *dev)
+{
+	char test_packet[] = { 0,0,0,0,0,0, 0,0,0,0,0,0,
+				 0, 46, /* A 46 in network order */
+				 0, 0, /* DSAP=0 & SSAP=0 fields */
+				 0xf3, 0 /* Control (Test Req + P bit set) */ };
+	long timenow = jiffies;
+
+	writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_TX_ON);
+
+	memcpy(test_packet,          dev->dev_addr, ETH_ALEN);
+	memcpy(test_packet+ETH_ALEN, dev->dev_addr, ETH_ALEN);
+
+        writeword(dev, TX_CMD_PORT, TX_AFTER_ALL);
+        writeword(dev, TX_LEN_PORT, ETH_ZLEN);
+
+	/* Test to see if the chip has allocated memory for the packet */
+	while (jiffies - timenow < 5)
+		if (readreg(dev, PP_BusST) & READY_FOR_TX_NOW)
+			break;
+	if (jiffies - timenow >= 5)
+		return 0;	/* this shouldn't happen */
+
+	/* Write the contents of the packet */
+	outsw(dev->base_addr + TX_FRAME_PORT,test_packet,(ETH_ZLEN+1) >>1);
+
+	if (net_debug > 1) printk("Sending test packet ");
+	/* wait a couple of jiffies for packet to be received */
+	for (timenow = jiffies; jiffies - timenow < 3; )
+                ;
+        if ((readreg(dev, PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {
+                if (net_debug > 1) printk("succeeded\n");
+                return 1;
+        }
+	if (net_debug > 1) printk("failed\n");
+	return 0;
+}
+
+
+static int
+detect_aui(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	if (net_debug > 1) printk("%s: Attempting AUI\n", dev->name);
+	control_dc_dc(dev, 0);
+
+	writereg(dev, PP_LineCTL, (lp->linectl &~ AUTO_AUI_10BASET) | AUI_ONLY);
+
+	if (send_test_pkt(dev))
+		return DETECTED_AUI;
+	else
+		return DETECTED_NONE;
+}
+
+static int
+detect_bnc(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	if (net_debug > 1) printk("%s: Attempting BNC\n", dev->name);
+	control_dc_dc(dev, 1);
+
+	writereg(dev, PP_LineCTL, (lp->linectl &~ AUTO_AUI_10BASET) | AUI_ONLY);
+
+	if (send_test_pkt(dev))
+		return DETECTED_BNC;
+	else
+		return DETECTED_NONE;
+}
+
+
+static void
+write_irq(struct net_device *dev, int chip_type, int irq)
+{
+	int i;
+
+	if (chip_type == CS8900) {
+		/* Search the mapping table for the corresponding IRQ pin. */
+		for (i = 0; i != sizeof(cs8900_irq_map)/sizeof(cs8900_irq_map[0]); i++)
+			if (cs8900_irq_map[i] == irq)
+				break;
+		/* Not found */
+		if (i == sizeof(cs8900_irq_map)/sizeof(cs8900_irq_map[0]))
+			i = 3;
+		writereg(dev, PP_CS8900_ISAINT, i);
+	} else {
+		writereg(dev, PP_CS8920_ISAINT, irq);
+	}
+}
+
+/* Open/initialize the board.  This is called (in the current kernel)
+   sometime after booting when the 'ifconfig' program is run.
+
+   This routine should set everything up anew at each open, even
+   registers that "should" only need to be set once at boot, so that
+   there is non-reboot way to recover if something goes wrong.
+   */
+
+/* AKPM: do we need to do any locking here? */
+
+static int
+net_open(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	int result = 0;
+	int i;
+	int ret;
+
+#ifndef CONFIG_SH_HICOSH4 /* uses irq#1, so this wont work */
+	if (dev->irq < 2) {
+		/* Allow interrupts to be generated by the chip */
+/* Cirrus' release had this: */
+#if 0
+		writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+#endif
+/* And 2.3.47 had this: */
+		writereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);
+
+		for (i = 2; i < CS8920_NO_INTS; i++) {
+			if ((1 << i) & lp->irq_map) {
+				if (request_irq(i, net_interrupt, 0, dev->name, dev) == 0) {
+					dev->irq = i;
+					write_irq(dev, lp->chip_type, i);
+					/* writereg(dev, PP_BufCFG, GENERATE_SW_INTERRUPT); */
+					break;
+				}
+			}
+		}
+
+		if (i >= CS8920_NO_INTS) {
+			writereg(dev, PP_BusCTL, 0);	/* disable interrupts. */
+			printk(KERN_ERR "cs89x0: can't get an interrupt\n");
+			ret = -EAGAIN;
+			goto bad_out;
+		}
+	}
+	else
+#endif
+	{
+		if (((1 << dev->irq) & lp->irq_map) == 0) {
+			printk(KERN_ERR "%s: IRQ %d is not in our map of allowable IRQs, which is %x\n",
+                               dev->name, dev->irq, lp->irq_map);
+			ret = -EAGAIN;
+			goto bad_out;
+		}
+/* FIXME: Cirrus' release had this: */
+		writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
+/* And 2.3.47 had this: */
+#if 0
+		writereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);
+#endif
+		write_irq(dev, lp->chip_type, dev->irq);
+		ret = request_irq(dev->irq, &net_interrupt, 0, dev->name, dev);
+		if (ret) {
+			if (net_debug)
+				printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+			goto bad_out;
+		}
+	}
+
+#if ALLOW_DMA
+	if (lp->use_dma) {
+		if (lp->isa_config & ANY_ISA_DMA) {
+			unsigned long flags;
+			lp->dma_buff = (unsigned char *)__get_dma_pages(GFP_KERNEL,
+							get_order(lp->dmasize * 1024));
+
+			if (!lp->dma_buff) {
+				printk(KERN_ERR "%s: cannot get %dK memory for DMA\n", dev->name, lp->dmasize);
+				goto release_irq;
+			}
+			if (net_debug > 1) {
+				printk(	"%s: dma %lx %lx\n",
+					dev->name,
+					(unsigned long)lp->dma_buff,
+					(unsigned long)virt_to_bus(lp->dma_buff));
+			}
+			if ((unsigned long) lp->dma_buff >= MAX_DMA_ADDRESS ||
+			    !dma_page_eq(lp->dma_buff, lp->dma_buff+lp->dmasize*1024-1)) {
+				printk(KERN_ERR "%s: not usable as DMA buffer\n", dev->name);
+				goto release_irq;
+			}
+			memset(lp->dma_buff, 0, lp->dmasize * 1024);	/* Why? */
+			if (request_dma(dev->dma, dev->name)) {
+				printk(KERN_ERR "%s: cannot get dma channel %d\n", dev->name, dev->dma);
+				goto release_irq;
+			}
+			write_dma(dev, lp->chip_type, dev->dma);
+			lp->rx_dma_ptr = lp->dma_buff;
+			lp->end_dma_buff = lp->dma_buff + lp->dmasize*1024;
+			spin_lock_irqsave(&lp->lock, flags);
+			disable_dma(dev->dma);
+			clear_dma_ff(dev->dma);
+			set_dma_mode(dev->dma, 0x14); /* auto_init as well */
+			set_dma_addr(dev->dma, virt_to_bus(lp->dma_buff));
+			set_dma_count(dev->dma, lp->dmasize*1024);
+			enable_dma(dev->dma);
+			spin_unlock_irqrestore(&lp->lock, flags);
+		}
+	}
+#endif	/* ALLOW_DMA */
+
+	/* set the Ethernet address */
+	for (i=0; i < ETH_ALEN/2; i++)
+		writereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));
+
+	/* while we're testing the interface, leave interrupts disabled */
+	writereg(dev, PP_BusCTL, MEMORY_ON);
+
+	/* Set the LineCTL quintuplet based on adapter configuration read from EEPROM */
+	if ((lp->adapter_cnf & A_CNF_EXTND_10B_2) && (lp->adapter_cnf & A_CNF_LOW_RX_SQUELCH))
+                lp->linectl = LOW_RX_SQUELCH;
+	else
+                lp->linectl = 0;
+
+        /* check to make sure that they have the "right" hardware available */
+	switch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {
+	case A_CNF_MEDIA_10B_T: result = lp->adapter_cnf & A_CNF_10B_T; break;
+	case A_CNF_MEDIA_AUI:   result = lp->adapter_cnf & A_CNF_AUI; break;
+	case A_CNF_MEDIA_10B_2: result = lp->adapter_cnf & A_CNF_10B_2; break;
+        default: result = lp->adapter_cnf & (A_CNF_10B_T | A_CNF_AUI | A_CNF_10B_2);
+        }
+        if (!result) {
+                printk(KERN_ERR "%s: EEPROM is configured for unavailable media\n", dev->name);
+        release_irq:
+#if ALLOW_DMA
+		release_dma_buff(lp);
+#endif
+                writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) & ~(SERIAL_TX_ON | SERIAL_RX_ON));
+                free_irq(dev->irq, dev);
+		ret = -EAGAIN;
+		goto bad_out;
+	}
+
+        /* set the hardware to the configured choice */
+	switch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {
+	case A_CNF_MEDIA_10B_T:
+                result = detect_tp(dev);
+                if (result==DETECTED_NONE) {
+                        printk(KERN_WARNING "%s: 10Base-T (RJ-45) has no cable\n", dev->name);
+                        if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
+                                result = DETECTED_RJ45H; /* Yes! I don't care if I see a link pulse */
+                }
+		break;
+	case A_CNF_MEDIA_AUI:
+                result = detect_aui(dev);
+                if (result==DETECTED_NONE) {
+                        printk(KERN_WARNING "%s: 10Base-5 (AUI) has no cable\n", dev->name);
+                        if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
+                                result = DETECTED_AUI; /* Yes! I don't care if I see a carrrier */
+                }
+		break;
+	case A_CNF_MEDIA_10B_2:
+                result = detect_bnc(dev);
+                if (result==DETECTED_NONE) {
+                        printk(KERN_WARNING "%s: 10Base-2 (BNC) has no cable\n", dev->name);
+                        if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
+                                result = DETECTED_BNC; /* Yes! I don't care if I can xmit a packet */
+                }
+		break;
+	case A_CNF_MEDIA_AUTO:
+		writereg(dev, PP_LineCTL, lp->linectl | AUTO_AUI_10BASET);
+		if (lp->adapter_cnf & A_CNF_10B_T)
+			if ((result = detect_tp(dev)) != DETECTED_NONE)
+				break;
+		if (lp->adapter_cnf & A_CNF_AUI)
+			if ((result = detect_aui(dev)) != DETECTED_NONE)
+				break;
+		if (lp->adapter_cnf & A_CNF_10B_2)
+			if ((result = detect_bnc(dev)) != DETECTED_NONE)
+				break;
+		printk(KERN_ERR "%s: no media detected\n", dev->name);
+                goto release_irq;
+	}
+	switch(result) {
+	case DETECTED_NONE:
+		printk(KERN_ERR "%s: no network cable attached to configured media\n", dev->name);
+                goto release_irq;
+	case DETECTED_RJ45H:
+		printk(KERN_INFO "%s: using half-duplex 10Base-T (RJ-45)\n", dev->name);
+		break;
+	case DETECTED_RJ45F:
+		printk(KERN_INFO "%s: using full-duplex 10Base-T (RJ-45)\n", dev->name);
+		break;
+	case DETECTED_AUI:
+		printk(KERN_INFO "%s: using 10Base-5 (AUI)\n", dev->name);
+		break;
+	case DETECTED_BNC:
+		printk(KERN_INFO "%s: using 10Base-2 (BNC)\n", dev->name);
+		break;
+	}
+
+	/* Turn on both receive and transmit operations */
+	writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);
+
+	/* Receive only error free packets addressed to this card */
+	lp->rx_mode = 0;
+	writereg(dev, PP_RxCTL, DEF_RX_ACCEPT);
+
+	lp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;
+
+	if (lp->isa_config & STREAM_TRANSFER)
+		lp->curr_rx_cfg |= RX_STREAM_ENBL;
+#if ALLOW_DMA
+	set_dma_cfg(dev);
+#endif
+	writereg(dev, PP_RxCFG, lp->curr_rx_cfg);
+
+	writereg(dev, PP_TxCFG, TX_LOST_CRS_ENBL | TX_SQE_ERROR_ENBL | TX_OK_ENBL |
+		TX_LATE_COL_ENBL | TX_JBR_ENBL | TX_ANY_COL_ENBL | TX_16_COL_ENBL);
+
+	writereg(dev, PP_BufCFG, READY_FOR_TX_ENBL | RX_MISS_COUNT_OVRFLOW_ENBL |
+#if ALLOW_DMA
+		dma_bufcfg(dev) |
+#endif
+		TX_COL_COUNT_OVRFLOW_ENBL | TX_UNDERRUN_ENBL);
+
+	/* now that we've got our act together, enable everything */
+	writereg(dev, PP_BusCTL, ENABLE_IRQ
+		 | (dev->mem_start?MEMORY_ON : 0) /* turn memory on */
+#if ALLOW_DMA
+		 | dma_busctl(dev)
+#endif
+                 );
+        netif_start_queue(dev);
+	if (net_debug > 1)
+		printk("cs89x0: net_open() succeeded\n");
+	return 0;
+bad_out:
+	return ret;
+}
+
+static void net_timeout(struct net_device *dev)
+{
+	/* If we get here, some higher level has decided we are broken.
+	   There should really be a "kick me" function call instead. */
+	if (net_debug > 0) printk("%s: transmit timed out, %s?\n", dev->name,
+		   tx_done(dev) ? "IRQ conflict ?" : "network cable problem");
+	/* Try to restart the adaptor. */
+	netif_wake_queue(dev);
+}
+
+static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	if (net_debug > 3) {
+		printk("%s: sent %d byte packet of type %x\n",
+			dev->name, skb->len,
+			(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);
+	}
+
+	/* keep the upload from being interrupted, since we
+                  ask the chip to start transmitting before the
+                  whole packet has been completely uploaded. */
+
+	spin_lock_irq(&lp->lock);
+	netif_stop_queue(dev);
+
+	/* initiate a transmit sequence */
+	writeword(dev, TX_CMD_PORT, lp->send_cmd);
+	writeword(dev, TX_LEN_PORT, skb->len);
+
+	/* Test to see if the chip has allocated memory for the packet */
+	if ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {
+		/*
+		 * Gasp!  It hasn't.  But that shouldn't happen since
+		 * we're waiting for TxOk, so return 1 and requeue this packet.
+		 */
+		
+		spin_unlock_irq(&lp->lock);
+		if (net_debug) printk("cs89x0: Tx buffer not free!\n");
+		return 1;
+	}
+	/* Write the contents of the packet */
+	outsw(dev->base_addr + TX_FRAME_PORT,skb->data,(skb->len+1) >>1);
+	spin_unlock_irq(&lp->lock);
+	dev->trans_start = jiffies;
+	dev_kfree_skb (skb);
+
+	/*
+	 * We DO NOT call netif_wake_queue() here.
+	 * We also DO NOT call netif_start_queue().
+	 *
+	 * Either of these would cause another bottom half run through
+	 * net_send_packet() before this packet has fully gone out.  That causes
+	 * us to hit the "Gasp!" above and the send is rescheduled.  it runs like
+	 * a dog.  We just return and wait for the Tx completion interrupt handler
+	 * to restart the netdevice layer
+	 */
+
+	return 0;
+}
+
+/* The typical workload of the driver:
+   Handle the network interface interrupts. */
+   
+static void net_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = dev_id;
+	struct net_local *lp;
+	int ioaddr, status;
+ 
+	ioaddr = dev->base_addr;
+	lp = (struct net_local *)dev->priv;
+
+	/* we MUST read all the events out of the ISQ, otherwise we'll never
+           get interrupted again.  As a consequence, we can't have any limit
+           on the number of times we loop in the interrupt handler.  The
+           hardware guarantees that eventually we'll run out of events.  Of
+           course, if you're on a slow machine, and packets are arriving
+           faster than you can read them off, you're screwed.  Hasta la
+           vista, baby!  */
+	while ((status = readword(dev, ISQ_PORT))) {
+		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
+		switch(status & ISQ_EVENT_MASK) {
+		case ISQ_RECEIVER_EVENT:
+			/* Got a packet(s). */
+			net_rx(dev);
+			break;
+		case ISQ_TRANSMITTER_EVENT:
+			lp->stats.tx_packets++;
+			netif_wake_queue(dev);	/* Inform upper layers. */
+			if ((status & (	TX_OK |
+					TX_LOST_CRS |
+					TX_SQE_ERROR |
+					TX_LATE_COL |
+					TX_16_COL)) != TX_OK) {
+				if ((status & TX_OK) == 0) lp->stats.tx_errors++;
+				if (status & TX_LOST_CRS) lp->stats.tx_carrier_errors++;
+				if (status & TX_SQE_ERROR) lp->stats.tx_heartbeat_errors++;
+				if (status & TX_LATE_COL) lp->stats.tx_window_errors++;
+				if (status & TX_16_COL) lp->stats.tx_aborted_errors++;
+			}
+			break;
+		case ISQ_BUFFER_EVENT:
+			if (status & READY_FOR_TX) {
+				/* we tried to transmit a packet earlier,
+                                   but inexplicably ran out of buffers.
+                                   That shouldn't happen since we only ever
+                                   load one packet.  Shrug.  Do the right
+                                   thing anyway. */
+				netif_wake_queue(dev);	/* Inform upper layers. */
+			}
+			if (status & TX_UNDERRUN) {
+				if (net_debug > 0) printk("%s: transmit underrun\n", dev->name);
+                                lp->send_underrun++;
+                                if (lp->send_underrun == 3) lp->send_cmd = TX_AFTER_381;
+                                else if (lp->send_underrun == 6) lp->send_cmd = TX_AFTER_ALL;
+				/* transmit cycle is done, although
+				   frame wasn't transmitted - this
+				   avoids having to wait for the upper
+				   layers to timeout on us, in the
+				   event of a tx underrun */
+				netif_wake_queue(dev);	/* Inform upper layers. */
+                        }
+#if ALLOW_DMA
+			if (lp->use_dma && (status & RX_DMA)) {
+				int count = readreg(dev, PP_DmaFrameCnt);
+				while(count) {
+					if (net_debug > 5)
+						printk("%s: receiving %d DMA frames\n", dev->name, count);
+					if (net_debug > 2 && count >1)
+						printk("%s: receiving %d DMA frames\n", dev->name, count);
+					dma_rx(dev);
+					if (--count == 0)
+						count = readreg(dev, PP_DmaFrameCnt);
+					if (net_debug > 2 && count > 0)
+						printk("%s: continuing with %d DMA frames\n", dev->name, count);
+				}
+			}
+#endif
+			break;
+		case ISQ_RX_MISS_EVENT:
+			lp->stats.rx_missed_errors += (status >>6);
+			break;
+		case ISQ_TX_COL_EVENT:
+			lp->stats.collisions += (status >>6);
+			break;
+		}
+	}
+}
+
+static void
+count_rx_errors(int status, struct net_local *lp)
+{
+	lp->stats.rx_errors++;
+	if (status & RX_RUNT) lp->stats.rx_length_errors++;
+	if (status & RX_EXTRA_DATA) lp->stats.rx_length_errors++;
+	if (status & RX_CRC_ERROR) if (!(status & (RX_EXTRA_DATA|RX_RUNT)))
+		/* per str 172 */
+		lp->stats.rx_crc_errors++;
+	if (status & RX_DRIBBLE) lp->stats.rx_frame_errors++;
+	return;
+}
+
+/* We have a good packet(s), get it/them out of the buffers. */
+static void
+net_rx(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	struct sk_buff *skb;
+	int status, length;
+
+	int ioaddr = dev->base_addr;
+	status = inw(ioaddr + RX_FRAME_PORT);
+	length = inw(ioaddr + RX_FRAME_PORT);
+
+	if ((status & RX_OK) == 0) {
+		count_rx_errors(status, lp);
+		return;
+	}
+
+	/* Malloc up new buffer. */
+	skb = dev_alloc_skb(length + 2);
+	if (skb == NULL) {
+#if 0		/* Again, this seems a cruel thing to do */
+		printk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n", dev->name);
+#endif
+		lp->stats.rx_dropped++;
+		return;
+	}
+	skb_reserve(skb, 2);	/* longword align L3 header */
+	skb->dev = dev;
+
+	insw(ioaddr + RX_FRAME_PORT, skb_put(skb, length), length >> 1);
+	if (length & 1)
+		skb->data[length-1] = inw(ioaddr + RX_FRAME_PORT);
+
+	if (net_debug > 3) {
+		printk(	"%s: received %d byte packet of type %x\n",
+			dev->name, length,
+			(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);
+	}
+
+        skb->protocol=eth_type_trans(skb,dev);
+	netif_rx(skb);
+	dev->last_rx = jiffies;
+	lp->stats.rx_packets++;
+	lp->stats.rx_bytes += length;
+}
+
+#if ALLOW_DMA
+static void release_dma_buff(struct net_local *lp)
+{
+	if (lp->dma_buff) {
+		free_pages((unsigned long)(lp->dma_buff), get_order(lp->dmasize * 1024));
+		lp->dma_buff = 0;
+	}
+}
+#endif
+
+/* The inverse routine to net_open(). */
+static int
+net_close(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+
+	netif_stop_queue(dev);
+	
+	writereg(dev, PP_RxCFG, 0);
+	writereg(dev, PP_TxCFG, 0);
+	writereg(dev, PP_BufCFG, 0);
+	writereg(dev, PP_BusCTL, 0);
+
+	free_irq(dev->irq, dev);
+
+#if ALLOW_DMA
+	if (lp->use_dma && lp->dma) {
+		free_dma(dev->dma);
+		release_dma_buff(lp);
+	}
+#endif
+
+	/* Update the statistics here. */
+	return 0;
+}
+
+/* Get the current statistics.	This may be called with the card open or
+   closed. */
+static struct net_device_stats *
+net_get_stats(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lp->lock, flags);
+	/* Update the statistics from the device registers. */
+	lp->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);
+	lp->stats.collisions += (readreg(dev, PP_TxCol) >> 6);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	return &lp->stats;
+}
+
+static void set_multicast_list(struct net_device *dev)
+{
+	struct net_local *lp = (struct net_local *)dev->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lp->lock, flags);
+	if(dev->flags&IFF_PROMISC)
+	{
+		lp->rx_mode = RX_ALL_ACCEPT;
+	}
+	else if((dev->flags&IFF_ALLMULTI)||dev->mc_list)
+	{
+		/* The multicast-accept list is initialized to accept-all, and we
+		   rely on higher-level filtering for now. */
+		lp->rx_mode = RX_MULTCAST_ACCEPT;
+	} 
+	else
+		lp->rx_mode = 0;
+
+	writereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);
+
+	/* in promiscuous mode, we accept errored packets, so we have to enable interrupts on them also */
+	writereg(dev, PP_RxCFG, lp->curr_rx_cfg |
+	     (lp->rx_mode == RX_ALL_ACCEPT? (RX_CRC_ERROR_ENBL|RX_RUNT_ENBL|RX_EXTRA_DATA_ENBL) : 0));
+	spin_unlock_irqrestore(&lp->lock, flags);
+}
+
+
+static int set_mac_address(struct net_device *dev, void *addr)
+{
+	int i;
+
+	if (netif_running(dev))
+		return -EBUSY;
+	if (net_debug) {
+		printk("%s: Setting MAC address to ", dev->name);
+		for (i = 0; i < 6; i++)
+			printk(" %2.2x", dev->dev_addr[i] = ((unsigned char *)addr)[i]);
+		printk(".\n");
+	}
+	/* set the Ethernet address */
+	for (i=0; i < ETH_ALEN/2; i++)
+		writereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));
+
+	return 0;
+}
+
+#ifdef MODULE
+
+static struct net_device dev_cs89x0 = {
+        "",
+        0, 0, 0, 0,
+        0, 0,
+        0, 0, 0, NULL, NULL };
+
+/*
+ * Support the 'debug' module parm even if we're compiled for non-debug to 
+ * avoid breaking someone's startup scripts 
+ */
+
+static int io;
+static int irq;
+static int debug;
+static char media[8];
+static int duplex=-1;
+
+static int use_dma;			/* These generate unused var warnings if ALLOW_DMA = 0 */
+static int dma;
+static int dmasize=16;			/* or 64 */
+
+MODULE_PARM(io, "i");
+MODULE_PARM(irq, "i");
+MODULE_PARM(debug, "i");
+MODULE_PARM(media, "c8");
+MODULE_PARM(duplex, "i");
+MODULE_PARM(dma , "i");
+MODULE_PARM(dmasize , "i");
+MODULE_PARM(use_dma , "i");
+MODULE_PARM_DESC(io, "cs89x0 I/O base address");
+MODULE_PARM_DESC(irq, "cs89x0 IRQ number");
+#if DEBUGGING
+MODULE_PARM_DESC(debug, "cs89x0 debug level (0-6)");
+#else
+MODULE_PARM_DESC(debug, "(ignored)");
+#endif
+MODULE_PARM_DESC(media, "Set cs89x0 adapter(s) media type(s) (rj45,bnc,aui)");
+/* No other value than -1 for duplex seems to be currently interpreted */
+MODULE_PARM_DESC(duplex, "(ignored)");
+#if ALLOW_DMA
+MODULE_PARM_DESC(dma , "cs89x0 ISA DMA channel; ignored if use_dma=0");
+MODULE_PARM_DESC(dmasize , "cs89x0 DMA size in kB (16,64); ignored if use_dma=0");
+MODULE_PARM_DESC(use_dma , "cs89x0 using DMA (0-1)");
+#else
+MODULE_PARM_DESC(dma , "(ignored)");
+MODULE_PARM_DESC(dmasize , "(ignored)");
+MODULE_PARM_DESC(use_dma , "(ignored)");
+#endif
+
+MODULE_AUTHOR("Mike Cruse, Russwll Nelson <nelson@crynwr.com>, Andrew Morton <andrewm@uow.edu.au>");
+MODULE_LICENSE("GPL");
+
+
+EXPORT_NO_SYMBOLS;
+
+/*
+* media=t             - specify media type
+   or media=2
+   or media=aui
+   or medai=auto
+* duplex=0            - specify forced half/full/autonegotiate duplex
+* debug=#             - debug level
+
+
+* Default Chip Configuration:
+  * DMA Burst = enabled
+  * IOCHRDY Enabled = enabled
+    * UseSA = enabled
+    * CS8900 defaults to half-duplex if not specified on command-line
+    * CS8920 defaults to autoneg if not specified on command-line
+    * Use reset defaults for other config parameters
+
+* Assumptions:
+  * media type specified is supported (circuitry is present)
+  * if memory address is > 1MB, then required mem decode hw is present
+  * if 10B-2, then agent other than driver will enable DC/DC converter
+    (hw or software util)
+
+
+*/
+
+int
+init_module(void)
+{
+	struct net_local *lp;
+	int ret = 0;
+
+#if DEBUGGING
+	net_debug = debug;
+#else
+	debug = 0;
+#endif
+
+	dev_cs89x0.irq = irq;
+	dev_cs89x0.base_addr = io;
+
+        dev_cs89x0.init = cs89x0_probe;
+        dev_cs89x0.priv = kmalloc(sizeof(struct net_local), GFP_KERNEL);
+	if (dev_cs89x0.priv == 0) {
+		printk(KERN_ERR "cs89x0.c: Out of memory.\n");
+		return -ENOMEM;
+	}
+	memset(dev_cs89x0.priv, 0, sizeof(struct net_local));
+	lp = (struct net_local *)dev_cs89x0.priv;
+
+#if ALLOW_DMA
+	if (use_dma) {
+		lp->use_dma = use_dma;
+		lp->dma = dma;
+		lp->dmasize = dmasize;
+	}
+#endif
+
+	spin_lock_init(&lp->lock);
+
+        /* boy, they'd better get these right */
+        if (!strcmp(media, "rj45"))
+		lp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;
+	else if (!strcmp(media, "aui"))
+		lp->adapter_cnf = A_CNF_MEDIA_AUI   | A_CNF_AUI;
+	else if (!strcmp(media, "bnc"))
+		lp->adapter_cnf = A_CNF_MEDIA_10B_2 | A_CNF_10B_2;
+	else
+		lp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;
+
+        if (duplex==-1)
+		lp->auto_neg_cnf = AUTO_NEG_ENABLE;
+
+        if (io == 0) {
+                printk(KERN_ERR "cs89x0.c: Module autoprobing not allowed.\n");
+                printk(KERN_ERR "cs89x0.c: Append io=0xNNN\n");
+                ret = -EPERM;
+		goto out;
+        }
+
+#if ALLOW_DMA
+	if (use_dma && dmasize != 16 && dmasize != 64) {
+		printk(KERN_ERR "cs89x0.c: dma size must be either 16K or 64K, not %dK\n", dmasize);
+		ret = -EPERM;
+		goto out;
+	}
+#endif
+
+        if (register_netdev(&dev_cs89x0) != 0) {
+                printk(KERN_ERR "cs89x0.c: No card found at 0x%x\n", io);
+                ret = -ENXIO;
+		goto out;
+        }
+out:
+	if (ret)
+		kfree(dev_cs89x0.priv);
+	return ret;
+}
+
+void
+cleanup_module(void)
+{
+        if (dev_cs89x0.priv != NULL) {
+                /* Free up the private structure, or leak memory :-)  */
+                unregister_netdev(&dev_cs89x0);
+		outw(PP_ChipID, dev_cs89x0.base_addr + ADD_PORT);
+                kfree(dev_cs89x0.priv);
+                dev_cs89x0.priv = NULL;	/* gets re-allocated by cs89x0_probe1 */
+                /* If we don't do this, we can't re-insmod it later. */
+                release_region(dev_cs89x0.base_addr, NETCARD_IO_EXTENT);
+        }
+}
+#endif /* MODULE */
+
+/*
+ * Local variables:
+ *  version-control: t
+ *  kept-new-versions: 5
+ *  c-indent-level: 8
+ *  tab-width: 8
+ * End:
+ *
+ */
Index: drivers/net/cs89x0-old.h
===================================================================
--- a/drivers/net/cs89x0-old.h	(revision 0)
+++ b/drivers/net/cs89x0-old.h	(revision 675)
@@ -0,0 +1,469 @@
+/*  Copyright, 1988-1992, Russell Nelson, Crynwr Software
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, version 1.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+   */
+
+#include <linux/config.h>
+
+#define PP_ChipID 0x0000	/* offset   0h -> Corp -ID              */
+				/* offset   2h -> Model/Product Number  */
+				/* offset   3h -> Chip Revision Number  */
+
+#define PP_ISAIOB 0x0020	/*  IO base address */
+#define PP_CS8900_ISAINT 0x0022	/*  ISA interrupt select */
+#define PP_CS8920_ISAINT 0x0370	/*  ISA interrupt select */
+#define PP_CS8900_ISADMA 0x0024	/*  ISA Rec DMA channel */
+#define PP_CS8920_ISADMA 0x0374	/*  ISA Rec DMA channel */
+#define PP_ISASOF 0x0026	/*  ISA DMA offset */
+#define PP_DmaFrameCnt 0x0028	/*  ISA DMA Frame count */
+#define PP_DmaByteCnt 0x002A	/*  ISA DMA Byte count */
+#define PP_CS8900_ISAMemB 0x002C	/*  Memory base */
+#define PP_CS8920_ISAMemB 0x0348 /*  */
+
+#define PP_ISABootBase 0x0030	/*  Boot Prom base  */
+#define PP_ISABootMask 0x0034	/*  Boot Prom Mask */
+
+/* EEPROM data and command registers */
+#define PP_EECMD 0x0040		/*  NVR Interface Command register */
+#define PP_EEData 0x0042	/*  NVR Interface Data Register */
+#define PP_DebugReg 0x0044	/*  Debug Register */
+
+#define PP_RxCFG 0x0102		/*  Rx Bus config */
+#define PP_RxCTL 0x0104		/*  Receive Control Register */
+#define PP_TxCFG 0x0106		/*  Transmit Config Register */
+#define PP_TxCMD 0x0108		/*  Transmit Command Register */
+#define PP_BufCFG 0x010A	/*  Bus configuration Register */
+#define PP_LineCTL 0x0112	/*  Line Config Register */
+#define PP_SelfCTL 0x0114	/*  Self Command Register */
+#define PP_BusCTL 0x0116	/*  ISA bus control Register */
+#define PP_TestCTL 0x0118	/*  Test Register */
+#define PP_AutoNegCTL 0x011C	/*  Auto Negotiation Ctrl */
+
+#define PP_ISQ 0x0120		/*  Interrupt Status */
+#define PP_RxEvent 0x0124	/*  Rx Event Register */
+#define PP_TxEvent 0x0128	/*  Tx Event Register */
+#define PP_BufEvent 0x012C	/*  Bus Event Register */
+#define PP_RxMiss 0x0130	/*  Receive Miss Count */
+#define PP_TxCol 0x0132		/*  Transmit Collision Count */
+#define PP_LineST 0x0134	/*  Line State Register */
+#define PP_SelfST 0x0136	/*  Self State register */
+#define PP_BusST 0x0138		/*  Bus Status */
+#define PP_TDR 0x013C		/*  Time Domain Reflectometry */
+#define PP_AutoNegST 0x013E	/*  Auto Neg Status */
+#define PP_TxCommand 0x0144	/*  Tx Command */
+#define PP_TxLength 0x0146	/*  Tx Length */
+#define PP_LAF 0x0150		/*  Hash Table */
+#define PP_IA 0x0158		/*  Physical Address Register */
+
+#define PP_RxStatus 0x0400	/*  Receive start of frame */
+#define PP_RxLength 0x0402	/*  Receive Length of frame */
+#define PP_RxFrame 0x0404	/*  Receive frame pointer */
+#define PP_TxFrame 0x0A00	/*  Transmit frame pointer */
+
+/*  Primary I/O Base Address. If no I/O base is supplied by the user, then this */
+/*  can be used as the default I/O base to access the PacketPage Area. */
+#define DEFAULTIOBASE 0x0300
+#define FIRST_IO 0x020C		/*  First I/O port to check */
+#define LAST_IO 0x037C		/*  Last I/O port to check (+10h) */
+#define ADD_MASK 0x3000		/*  Mask it use of the ADD_PORT register */
+#define ADD_SIG 0x3000		/*  Expected ID signature */
+
+/* On Macs, we only need use the ISA I/O stuff until we do MEMORY_ON */
+#ifdef CONFIG_MAC
+#define LCSLOTBASE 0xfee00000
+#define MMIOBASE 0x40000
+#endif
+
+#define CHIP_EISA_ID_SIG 0x630E   /*  Product ID Code for Crystal Chip (CS8900 spec 4.3) */
+
+#ifdef IBMEIPKT
+#define EISA_ID_SIG 0x4D24	/*  IBM */
+#define PART_NO_SIG 0x1010	/*  IBM */
+#define MONGOOSE_BIT 0x0000	/*  IBM */
+#else
+#define EISA_ID_SIG 0x630E	/*  PnP Vendor ID (same as chip id for Crystal board) */
+#define PART_NO_SIG 0x4000	/*  ID code CS8920 board (PnP Vendor Product code) */
+#define MONGOOSE_BIT 0x2000	/*  PART_NO_SIG + MONGOOSE_BUT => ID of mongoose */
+#endif
+
+#define PRODUCT_ID_ADD 0x0002   /*  Address of product ID */
+
+/*  Mask to find out the types of  registers */
+#define REG_TYPE_MASK 0x001F
+
+/*  Eeprom Commands */
+#define ERSE_WR_ENBL 0x00F0
+#define ERSE_WR_DISABLE 0x0000
+
+/*  Defines Control/Config register quintuplet numbers */
+#define RX_BUF_CFG 0x0003
+#define RX_CONTROL 0x0005
+#define TX_CFG 0x0007
+#define TX_COMMAND 0x0009
+#define BUF_CFG 0x000B
+#define LINE_CONTROL 0x0013
+#define SELF_CONTROL 0x0015
+#define BUS_CONTROL 0x0017
+#define TEST_CONTROL 0x0019
+
+/*  Defines Status/Count registers quintuplet numbers */
+#define RX_EVENT 0x0004
+#define TX_EVENT 0x0008
+#define BUF_EVENT 0x000C
+#define RX_MISS_COUNT 0x0010
+#define TX_COL_COUNT 0x0012
+#define LINE_STATUS 0x0014
+#define SELF_STATUS 0x0016
+#define BUS_STATUS 0x0018
+#define TDR 0x001C
+
+/* PP_RxCFG - Receive  Configuration and Interrupt Mask bit definition -  Read/write */
+#define SKIP_1 0x0040
+#define RX_STREAM_ENBL 0x0080
+#define RX_OK_ENBL 0x0100
+#define RX_DMA_ONLY 0x0200
+#define AUTO_RX_DMA 0x0400
+#define BUFFER_CRC 0x0800
+#define RX_CRC_ERROR_ENBL 0x1000
+#define RX_RUNT_ENBL 0x2000
+#define RX_EXTRA_DATA_ENBL 0x4000
+
+/* PP_RxCTL - Receive Control bit definition - Read/write */
+#define RX_IA_HASH_ACCEPT 0x0040
+#define RX_PROM_ACCEPT 0x0080
+#define RX_OK_ACCEPT 0x0100
+#define RX_MULTCAST_ACCEPT 0x0200
+#define RX_IA_ACCEPT 0x0400
+#define RX_BROADCAST_ACCEPT 0x0800
+#define RX_BAD_CRC_ACCEPT 0x1000
+#define RX_RUNT_ACCEPT 0x2000
+#define RX_EXTRA_DATA_ACCEPT 0x4000
+#define RX_ALL_ACCEPT (RX_PROM_ACCEPT|RX_BAD_CRC_ACCEPT|RX_RUNT_ACCEPT|RX_EXTRA_DATA_ACCEPT)
+/*  Default receive mode - individually addressed, broadcast, and error free */
+#define DEF_RX_ACCEPT (RX_IA_ACCEPT | RX_BROADCAST_ACCEPT | RX_OK_ACCEPT)
+
+/* PP_TxCFG - Transmit Configuration Interrupt Mask bit definition - Read/write */
+#define TX_LOST_CRS_ENBL 0x0040
+#define TX_SQE_ERROR_ENBL 0x0080
+#define TX_OK_ENBL 0x0100
+#define TX_LATE_COL_ENBL 0x0200
+#define TX_JBR_ENBL 0x0400
+#define TX_ANY_COL_ENBL 0x0800
+#define TX_16_COL_ENBL 0x8000
+
+/* PP_TxCMD - Transmit Command bit definition - Read-only */
+#define TX_START_4_BYTES 0x0000
+#define TX_START_64_BYTES 0x0040
+#define TX_START_128_BYTES 0x0080
+#define TX_START_ALL_BYTES 0x00C0
+#define TX_FORCE 0x0100
+#define TX_ONE_COL 0x0200
+#define TX_TWO_PART_DEFF_DISABLE 0x0400
+#define TX_NO_CRC 0x1000
+#define TX_RUNT 0x2000
+
+/* PP_BufCFG - Buffer Configuration Interrupt Mask bit definition - Read/write */
+#define GENERATE_SW_INTERRUPT 0x0040
+#define RX_DMA_ENBL 0x0080
+#define READY_FOR_TX_ENBL 0x0100
+#define TX_UNDERRUN_ENBL 0x0200
+#define RX_MISS_ENBL 0x0400
+#define RX_128_BYTE_ENBL 0x0800
+#define TX_COL_COUNT_OVRFLOW_ENBL 0x1000
+#define RX_MISS_COUNT_OVRFLOW_ENBL 0x2000
+#define RX_DEST_MATCH_ENBL 0x8000
+
+/* PP_LineCTL - Line Control bit definition - Read/write */
+#define SERIAL_RX_ON 0x0040
+#define SERIAL_TX_ON 0x0080
+#define AUI_ONLY 0x0100
+#define AUTO_AUI_10BASET 0x0200
+#define MODIFIED_BACKOFF 0x0800
+#define NO_AUTO_POLARITY 0x1000
+#define TWO_PART_DEFDIS 0x2000
+#define LOW_RX_SQUELCH 0x4000
+
+/* PP_SelfCTL - Software Self Control bit definition - Read/write */
+#define POWER_ON_RESET 0x0040
+#define SW_STOP 0x0100
+#define SLEEP_ON 0x0200
+#define AUTO_WAKEUP 0x0400
+#define HCB0_ENBL 0x1000
+#define HCB1_ENBL 0x2000
+#define HCB0 0x4000
+#define HCB1 0x8000
+
+/* PP_BusCTL - ISA Bus Control bit definition - Read/write */
+#define RESET_RX_DMA 0x0040
+#define MEMORY_ON 0x0400
+#define DMA_BURST_MODE 0x0800
+#define IO_CHANNEL_READY_ON 0x1000
+#define RX_DMA_SIZE_64K 0x2000
+#define ENABLE_IRQ 0x8000
+
+/* PP_TestCTL - Test Control bit definition - Read/write */
+#define LINK_OFF 0x0080
+#define ENDEC_LOOPBACK 0x0200
+#define AUI_LOOPBACK 0x0400
+#define BACKOFF_OFF 0x0800
+#define FDX_8900 0x4000
+#define FAST_TEST 0x8000
+
+/* PP_RxEvent - Receive Event Bit definition - Read-only */
+#define RX_IA_HASHED 0x0040
+#define RX_DRIBBLE 0x0080
+#define RX_OK 0x0100
+#define RX_HASHED 0x0200
+#define RX_IA 0x0400
+#define RX_BROADCAST 0x0800
+#define RX_CRC_ERROR 0x1000
+#define RX_RUNT 0x2000
+#define RX_EXTRA_DATA 0x4000
+
+#define HASH_INDEX_MASK 0x0FC00
+
+/* PP_TxEvent - Transmit Event Bit definition - Read-only */
+#define TX_LOST_CRS 0x0040
+#define TX_SQE_ERROR 0x0080
+#define TX_OK 0x0100
+#define TX_LATE_COL 0x0200
+#define TX_JBR 0x0400
+#define TX_16_COL 0x8000
+#define TX_SEND_OK_BITS (TX_OK|TX_LOST_CRS)
+#define TX_COL_COUNT_MASK 0x7800
+
+/* PP_BufEvent - Buffer Event Bit definition - Read-only */
+#define SW_INTERRUPT 0x0040
+#define RX_DMA 0x0080
+#define READY_FOR_TX 0x0100
+#define TX_UNDERRUN 0x0200
+#define RX_MISS 0x0400
+#define RX_128_BYTE 0x0800
+#define TX_COL_OVRFLW 0x1000
+#define RX_MISS_OVRFLW 0x2000
+#define RX_DEST_MATCH 0x8000
+
+/* PP_LineST - Ethernet Line Status bit definition - Read-only */
+#define LINK_OK 0x0080
+#define AUI_ON 0x0100
+#define TENBASET_ON 0x0200
+#define POLARITY_OK 0x1000
+#define CRS_OK 0x4000
+
+/* PP_SelfST - Chip Software Status bit definition */
+#define ACTIVE_33V 0x0040
+#define INIT_DONE 0x0080
+#define SI_BUSY 0x0100
+#define EEPROM_PRESENT 0x0200
+#define EEPROM_OK 0x0400
+#define EL_PRESENT 0x0800
+#define EE_SIZE_64 0x1000
+
+/* PP_BusST - ISA Bus Status bit definition */
+#define TX_BID_ERROR 0x0080
+#define READY_FOR_TX_NOW 0x0100
+
+/* PP_AutoNegCTL - Auto Negotiation Control bit definition */
+#define RE_NEG_NOW 0x0040
+#define ALLOW_FDX 0x0080
+#define AUTO_NEG_ENABLE 0x0100
+#define NLP_ENABLE 0x0200
+#define FORCE_FDX 0x8000
+#define AUTO_NEG_BITS (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE)
+#define AUTO_NEG_MASK (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE|ALLOW_FDX|RE_NEG_NOW)
+
+/* PP_AutoNegST - Auto Negotiation Status bit definition */
+#define AUTO_NEG_BUSY 0x0080
+#define FLP_LINK 0x0100
+#define FLP_LINK_GOOD 0x0800
+#define LINK_FAULT 0x1000
+#define HDX_ACTIVE 0x4000
+#define FDX_ACTIVE 0x8000
+
+/*  The following block defines the ISQ event types */
+#define ISQ_RECEIVER_EVENT 0x04
+#define ISQ_TRANSMITTER_EVENT 0x08
+#define ISQ_BUFFER_EVENT 0x0c
+#define ISQ_RX_MISS_EVENT 0x10
+#define ISQ_TX_COL_EVENT 0x12
+
+#define ISQ_EVENT_MASK 0x003F   /*  ISQ mask to find out type of event */
+#define ISQ_HIST 16		/*  small history buffer */
+#define AUTOINCREMENT 0x8000	/*  Bit mask to set bit-15 for autoincrement */
+
+#define TXRXBUFSIZE 0x0600
+#define RXDMABUFSIZE 0x8000
+#define RXDMASIZE 0x4000
+#define TXRX_LENGTH_MASK 0x07FF
+
+/*  rx options bits */
+#define RCV_WITH_RXON	1       /*  Set SerRx ON */
+#define RCV_COUNTS	2       /*  Use Framecnt1 */
+#define RCV_PONG	4       /*  Pong respondent */
+#define RCV_DONG	8       /*  Dong operation */
+#define RCV_POLLING	0x10	/*  Poll RxEvent */
+#define RCV_ISQ		0x20	/*  Use ISQ, int */
+#define RCV_AUTO_DMA	0x100	/*  Set AutoRxDMAE */
+#define RCV_DMA		0x200	/*  Set RxDMA only */
+#define RCV_DMA_ALL	0x400	/*  Copy all DMA'ed */
+#define RCV_FIXED_DATA	0x800	/*  Every frame same */
+#define RCV_IO		0x1000	/*  Use ISA IO only */
+#define RCV_MEMORY	0x2000	/*  Use ISA Memory */
+
+#define RAM_SIZE	0x1000       /*  The card has 4k bytes or RAM */
+#define PKT_START PP_TxFrame  /*  Start of packet RAM */
+
+#define RX_FRAME_PORT	0x0000
+#define TX_FRAME_PORT RX_FRAME_PORT
+#define TX_CMD_PORT	0x0004
+#define TX_NOW		0x0000       /*  Tx packet after   5 bytes copied */
+#define TX_AFTER_381	0x0040       /*  Tx packet after 381 bytes copied */
+#define TX_AFTER_ALL	0x00c0       /*  Tx packet after all bytes copied */
+#define TX_LEN_PORT	0x0006
+#define ISQ_PORT	0x0008
+#define ADD_PORT	0x000A
+#define DATA_PORT	0x000C
+
+#define EEPROM_WRITE_EN		0x00F0
+#define EEPROM_WRITE_DIS	0x0000
+#define EEPROM_WRITE_CMD	0x0100
+#define EEPROM_READ_CMD		0x0200
+
+/*  Receive Header */
+/*  Description of header of each packet in receive area of memory */
+#define RBUF_EVENT_LOW	0   /*  Low byte of RxEvent - status of received frame */
+#define RBUF_EVENT_HIGH	1   /*  High byte of RxEvent - status of received frame */
+#define RBUF_LEN_LOW	2   /*  Length of received data - low byte */
+#define RBUF_LEN_HI	3   /*  Length of received data - high byte */
+#define RBUF_HEAD_LEN	4   /*  Length of this header */
+
+#define CHIP_READ 0x1   /*  Used to mark state of the repins code (chip or dma) */
+#define DMA_READ 0x2   /*  Used to mark state of the repins code (chip or dma) */
+
+/*  for bios scan */
+/*  */
+#ifdef CSDEBUG
+/*  use these values for debugging bios scan */
+#define BIOS_START_SEG 0x00000
+#define BIOS_OFFSET_INC 0x0010
+#else
+#define BIOS_START_SEG 0x0c000
+#define BIOS_OFFSET_INC 0x0200
+#endif
+
+#define BIOS_LAST_OFFSET 0x0fc00
+
+/*  Byte offsets into the EEPROM configuration buffer */
+#define ISA_CNF_OFFSET 0x6
+#define TX_CTL_OFFSET (ISA_CNF_OFFSET + 8)			/*  8900 eeprom */
+#define AUTO_NEG_CNF_OFFSET (ISA_CNF_OFFSET + 8)		/*  8920 eeprom */
+
+  /*  the assumption here is that the bits in the eeprom are generally  */
+  /*  in the same position as those in the autonegctl register. */
+  /*  Of course the IMM bit is not in that register so it must be  */
+  /*  masked out */
+#define EE_FORCE_FDX  0x8000
+#define EE_NLP_ENABLE 0x0200
+#define EE_AUTO_NEG_ENABLE 0x0100
+#define EE_ALLOW_FDX 0x0080
+#define EE_AUTO_NEG_CNF_MASK (EE_FORCE_FDX|EE_NLP_ENABLE|EE_AUTO_NEG_ENABLE|EE_ALLOW_FDX)
+
+#define IMM_BIT 0x0040		/*  ignore missing media	 */
+
+#define ADAPTER_CNF_OFFSET (AUTO_NEG_CNF_OFFSET + 2)
+#define A_CNF_10B_T 0x0001
+#define A_CNF_AUI 0x0002
+#define A_CNF_10B_2 0x0004
+#define A_CNF_MEDIA_TYPE 0x0060
+#define A_CNF_MEDIA_AUTO 0x0000
+#define A_CNF_MEDIA_10B_T 0x0020
+#define A_CNF_MEDIA_AUI 0x0040
+#define A_CNF_MEDIA_10B_2 0x0060
+#define A_CNF_DC_DC_POLARITY 0x0080
+#define A_CNF_NO_AUTO_POLARITY 0x2000
+#define A_CNF_LOW_RX_SQUELCH 0x4000
+#define A_CNF_EXTND_10B_2 0x8000
+
+#define PACKET_PAGE_OFFSET 0x8
+
+/*  Bit definitions for the ISA configuration word from the EEPROM */
+#define INT_NO_MASK 0x000F
+#define DMA_NO_MASK 0x0070
+#define ISA_DMA_SIZE 0x0200
+#define ISA_AUTO_RxDMA 0x0400
+#define ISA_RxDMA 0x0800
+#define DMA_BURST 0x1000
+#define STREAM_TRANSFER 0x2000
+#define ANY_ISA_DMA (ISA_AUTO_RxDMA | ISA_RxDMA)
+
+/*  DMA controller registers */
+#define DMA_BASE 0x00     /*  DMA controller base */
+#define DMA_BASE_2 0x0C0    /*  DMA controller base */
+
+#define DMA_STAT 0x0D0    /*  DMA controller status register */
+#define DMA_MASK 0x0D4    /*  DMA controller mask register */
+#define DMA_MODE 0x0D6    /*  DMA controller mode register */
+#define DMA_RESETFF 0x0D8    /*  DMA controller first/last flip flop */
+
+/*  DMA data */
+#define DMA_DISABLE 0x04     /*  Disable channel n */
+#define DMA_ENABLE 0x00     /*  Enable channel n */
+/*  Demand transfers, incr. address, auto init, writes, ch. n */
+#define DMA_RX_MODE 0x14
+/*  Demand transfers, incr. address, auto init, reads, ch. n */
+#define DMA_TX_MODE 0x18
+
+#define DMA_SIZE (16*1024) /*  Size of dma buffer - 16k */
+
+#define CS8900 0x0000
+#define CS8920 0x4000   
+#define CS8920M 0x6000   
+#define REVISON_BITS 0x1F00
+#define EEVER_NUMBER 0x12
+#define CHKSUM_LEN 0x14
+#define CHKSUM_VAL 0x0000
+#define START_EEPROM_DATA 0x001c /*  Offset into eeprom for start of data */
+#define IRQ_MAP_EEPROM_DATA 0x0046 /*  Offset into eeprom for the IRQ map */
+#define IRQ_MAP_LEN 0x0004 /*  No of bytes to read for the IRQ map */
+#define PNP_IRQ_FRMT 0x0022 /*  PNP small item IRQ format */
+#ifdef CONFIG_SH_HICOSH4
+#define CS8900_IRQ_MAP 0x0002 /* HiCO-SH4 board has its IRQ on #1 */
+#else
+#define CS8900_IRQ_MAP 0x1c20 /*  This IRQ map is fixed */
+#endif
+
+#define CS8920_NO_INTS 0x0F   /*  Max CS8920 interrupt select # */
+
+#define PNP_ADD_PORT 0x0279
+#define PNP_WRITE_PORT 0x0A79
+
+#define GET_PNP_ISA_STRUCT 0x40
+#define PNP_ISA_STRUCT_LEN 0x06
+#define PNP_CSN_CNT_OFF 0x01
+#define PNP_RD_PORT_OFF 0x02
+#define PNP_FUNCTION_OK 0x00
+#define PNP_WAKE 0x03
+#define PNP_RSRC_DATA 0x04
+#define PNP_RSRC_READY 0x01
+#define PNP_STATUS 0x05
+#define PNP_ACTIVATE 0x30
+#define PNP_CNF_IO_H 0x60
+#define PNP_CNF_IO_L 0x61
+#define PNP_CNF_INT 0x70
+#define PNP_CNF_DMA 0x74
+#define PNP_CNF_MEM 0x48
+
+#define BIT0 1
+#define BIT15 0x8000
+
Index: drivers/net/arm/Makefile
===================================================================
--- a/drivers/net/arm/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/net/arm/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -8,3 +8,4 @@
 obj-$(CONFIG_ARM_ETHERH)	+= etherh.o
 obj-$(CONFIG_ARM_ETHER3)	+= ether3.o
 obj-$(CONFIG_ARM_ETHER1)	+= ether1.o
+
Index: drivers/pcmcia/pxa2xx_pnp2110.c
===================================================================
--- a/drivers/pcmcia/pxa2xx_pnp2110.c	(revision 0)
+++ b/drivers/pcmcia/pxa2xx_pnp2110.c	(revision 675)
@@ -0,0 +1,175 @@
+/*
+ * linux/drivers/pcmcia/pxa2xx_pnp2110.c
+ *
+ * Mainstone PCMCIA specific routines.
+ *
+ * Created:	May 12, 2004
+ * Author:	Nicolas Pitre
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+#include <pcmcia/ss.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include "soc_common.h"
+
+#define PNP2110_PCMCIA_RESET 69
+#define PNP2110_PCMCIA_RDY   70
+
+static struct pcmcia_irqs irqs[] = {
+	{ 0, IRQ_GPIO(70), "PCMCIA0 STSCHG" },
+};
+
+static int pnp2110_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
+{
+	printk("%s\n",__FUNCTION__);
+	skt->irq = IRQ_GPIO(70);
+	return soc_pcmcia_request_irqs(skt, irqs, 0);
+//	return 0;
+}
+
+static void pnp2110_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
+{
+	printk("%s\n",__FUNCTION__);
+	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
+}
+
+static unsigned long pnp2110_pcmcia_status[2];
+
+static void pnp2110_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
+				    struct pcmcia_state *state)
+{
+	unsigned long status, flip;
+//	printk("%s\n",__FUNCTION__);
+
+	state->detect = 1;
+	state->ready  = (GPLR(PNP2110_PCMCIA_RDY) & GPIO_bit(PNP2110_PCMCIA_RDY)) ? 1 : 0;
+	state->bvd1   = 1;
+	state->bvd2   = 1;
+	state->vs_3v  = 1;
+	state->vs_Xv  = 0;
+	state->wrprot = 0;  /* not available */
+}
+
+static int pnp2110_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
+				       const socket_state_t *state)
+{
+	unsigned long power = 0;
+	int ret = 0;
+	printk("%s\n",__FUNCTION__);
+
+	switch (state->Vcc) {
+	case 0:  break;
+	case 33: break;
+	case 50: break;
+	default:
+		 printk(KERN_ERR "%s(): bad Vcc %u\n",
+				 __FUNCTION__, state->Vcc);
+		 ret = -1;
+	}
+
+	switch (state->Vpp) {
+	case 0:   break;
+	case 120: break;
+	default:
+		  if(state->Vpp == state->Vcc) {
+			  power |= 1;
+		  } else {
+			  printk(KERN_ERR "%s(): bad Vpp %u\n",
+					  __FUNCTION__, state->Vpp);
+			  ret = -1;
+		  }
+	}
+
+	if (state->flags & SS_RESET) {
+		printk("resetting card\n");
+		GPSR(PNP2110_PCMCIA_RESET) = GPIO_bit(PNP2110_PCMCIA_RESET);
+	} else {
+		GPCR(PNP2110_PCMCIA_RESET) = GPIO_bit(PNP2110_PCMCIA_RESET);
+	}
+
+//	switch (skt->nr) {
+//	case 0:  MST_PCMCIA0 = power; break;
+//	case 1:  MST_PCMCIA1 = power; break;
+//	default: ret = -1;
+//	}
+
+	return ret;
+}
+
+static void pnp2110_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
+{
+	printk("%s\n",__FUNCTION__);
+}
+
+static void pnp2110_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
+{
+	printk("%s\n",__FUNCTION__);
+}
+
+static struct pcmcia_low_level pnp2110_pcmcia_ops = {
+	.owner			= THIS_MODULE,
+	.hw_init		= pnp2110_pcmcia_hw_init,
+	.hw_shutdown		= pnp2110_pcmcia_hw_shutdown,
+	.socket_state		= pnp2110_pcmcia_socket_state,
+	.configure_socket	= pnp2110_pcmcia_configure_socket,
+	.socket_init		= pnp2110_pcmcia_socket_init,
+	.socket_suspend		= pnp2110_pcmcia_socket_suspend,
+	.nr			= 1,
+};
+
+static struct platform_device *pnp2110_pcmcia_device;
+
+static int __init pnp2110_pcmcia_init(void)
+{
+	int ret;
+	printk("%s\n",__FUNCTION__);
+
+	pxa_gpio_mode(PNP2110_PCMCIA_RESET | GPIO_OUT);
+//	pxa_gpio_mode(54 | GPIO_OUT);
+//	GPSR(54) = GPIO_bit(54);
+	pxa_gpio_mode(PNP2110_PCMCIA_RDY | GPIO_IN);
+
+	pnp2110_pcmcia_device = kmalloc(sizeof(*pnp2110_pcmcia_device), GFP_KERNEL);
+	if (!pnp2110_pcmcia_device)
+		return -ENOMEM;
+	memset(pnp2110_pcmcia_device, 0, sizeof(*pnp2110_pcmcia_device));
+	pnp2110_pcmcia_device->name = "pxa2xx-pcmcia";
+	pnp2110_pcmcia_device->dev.platform_data = &pnp2110_pcmcia_ops;
+
+	ret = platform_device_register(pnp2110_pcmcia_device);
+	if (ret)
+		kfree(pnp2110_pcmcia_device);
+
+	return ret;
+}
+
+static void __exit pnp2110_pcmcia_exit(void)
+{
+	printk("%s\n",__FUNCTION__);
+	/*
+	 * This call is supposed to free our pnp2110_pcmcia_device.
+	 * Unfortunately platform_device don't have a free method, and
+	 * we can't assume it's free of any reference at this point so we
+	 * can't free it either.
+	 */
+	platform_device_unregister(pnp2110_pcmcia_device);
+}
+
+module_init(pnp2110_pcmcia_init);
+module_exit(pnp2110_pcmcia_exit);
+
+MODULE_LICENSE("GPL");
Index: drivers/pcmcia/pxa2xx_base.c
===================================================================
--- a/drivers/pcmcia/pxa2xx_base.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/pcmcia/pxa2xx_base.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -179,6 +179,40 @@
 	first = ops->first;
 	nr = ops->nr;
 
+	/* Setup GPIOs for PCMCIA/CF alternate function mode.
+	 *
+	 * It would be nice if set_GPIO_mode included support
+	 * for driving GPIO outputs to default high/low state
+	 * before programming GPIOs as outputs. Setting GPIO
+	 * outputs to default high/low state via GPSR/GPCR
+	 * before defining them as outputs should reduce
+	 * the possibility of glitching outputs during GPIO
+	 * setup. This of course assumes external terminators
+	 * are present to hold GPIOs in a defined state.
+	 *
+	 * In the meantime, setup default state of GPIO
+	 * outputs before we enable them as outputs.
+	 */
+
+	GPSR(GPIO48_nPOE) = GPIO_bit(GPIO48_nPOE) |
+		GPIO_bit(GPIO49_nPWE) |
+		GPIO_bit(GPIO50_nPIOR) |
+		GPIO_bit(GPIO51_nPIOW) |
+		GPIO_bit(GPIO52_nPCE_1) |
+		GPIO_bit(GPIO53_nPCE_2);
+
+	pxa_gpio_mode(GPIO48_nPOE_MD);
+	pxa_gpio_mode(GPIO49_nPWE_MD);
+	pxa_gpio_mode(GPIO50_nPIOR_MD);
+	pxa_gpio_mode(GPIO51_nPIOW_MD);
+	pxa_gpio_mode(GPIO52_nPCE_1_MD);
+	pxa_gpio_mode(GPIO53_nPCE_2_MD);
+	if(nr>1)
+		pxa_gpio_mode(GPIO54_pSKTSEL_MD);
+	pxa_gpio_mode(GPIO55_nPREG_MD);
+	pxa_gpio_mode(GPIO56_nPWAIT_MD);
+	pxa_gpio_mode(GPIO57_nIOIS16_MD);
+
 	/* Provide our PXA2xx specific timing routines. */
 	ops->set_timing  = pxa2xx_pcmcia_set_timing;
 #ifdef CONFIG_CPU_FREQ
Index: drivers/pcmcia/Makefile
===================================================================
--- a/drivers/pcmcia/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/pcmcia/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -62,4 +62,5 @@
 pxa2xx_cs-$(CONFIG_ARCH_LUBBOCK)		+= pxa2xx_lubbock.o sa1111_generic.o
 pxa2xx_cs-$(CONFIG_MACH_MAINSTONE)		+= pxa2xx_mainstone.o
 pxa2xx_cs-$(CONFIG_PXA_SHARPSL)			+= pxa2xx_sharpsl.o
+pxa2xx_cs-$(CONFIG_ARCH_PXA_PNP2110)		+= pxa2xx_pnp2110.o
 
Index: drivers/ide/Kconfig
===================================================================
--- a/drivers/ide/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/ide/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -946,6 +946,14 @@
 
 	  People with SCSI-only systems can say N here.
 
+config BLK_DEV_FZKIDE
+	tristate "FZK IDE Port"
+	depends on ARCH_PXA && IDE_GENERIC
+	help
+	  Support for the FZK IDE port on some PNP2110 base boards. This is a
+	  CPLD based port which makes a real IDE port out of a PXA2xx PCMCIA 
+	  port. 
+
 if IDE_CHIPSETS
 
 comment "Note: most of these also require special kernel boot parameters"
Index: drivers/ide/ide-rpc.c
===================================================================
--- a/drivers/ide/ide-rpc.c	(revision 0)
+++ b/drivers/ide/ide-rpc.c	(revision 675)
@@ -0,0 +1,393 @@
+/*
+ * linux/drivers/ide/legacy/rpcide.c		Version 0.1	Jan 19, 2004
+ *
+ * Copyright (C) 2004 Weihua Zhang, FZK
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * Jan 19, 2004 support only pio mode
+ * 
+ */
+
+#define USE_PXA_DMA
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/blkpg.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+
+#if !defined(CONFIG_ARCH_PXA_PNP2110) 
+#error "Nobody has tested this on a non-PNP2110 board yet..."
+#endif
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+
+#define DRIVER_NAME "rpcide"
+
+#define PNP2110_PCMCIA_RESET 69
+static uint mcmem0 = 0x00014699;
+module_param(mcmem0, uint, 0400);
+MODULE_PARM_DESC(mcmem0, "PCMCIA MCMEM0 timing value (0x00014699)");
+
+/* 
+ * The followings are originally defined in drivers/pcmcia/pxa/pxa.h
+ * FIXME: check for conflicts
+ */
+#define MCXX_SETUP_MASK     (0x7f)
+#define MCXX_ASST_MASK      (0x1f)
+#define MCXX_HOLD_MASK      (0x3f)
+#define MCXX_SETUP_SHIFT    (0)
+#define MCXX_ASST_SHIFT     (7)
+#define MCXX_HOLD_SHIFT     (14)
+
+extern int platform_add_devices(struct platform_device **devs, int num);
+
+/* 
+ * The following table is according to the ATA/ATAIP-6 T13 1410D Revision 3b.
+ * It is noted that there is a pio mode 5, but the timing is not included
+ * in the Revision 3b.
+ *                                             setup asst  hold (ns)
+ */
+unsigned short rpcide_pio_timing[5][3] = {{70,  165, 20}, /* pio mode 0 */
+                                          {50,  125, 15}, /* pio mode 1 */
+                                          {30,  100, 10}, /* pio mode 2 */
+                                          {30,   80, 10}, /* pio mode 3 */
+                                          {25,   70, 10}  /* pio mode 4 */
+};
+
+static inline u_int pxa_mcxx_hold(u_int pcmcia_cycle_ns, u_int mem_clk_10khz)
+{
+	u_int code = pcmcia_cycle_ns * mem_clk_10khz;
+	u_int ret = (code / 300000) + ((code % 300000) ? 1 : 0);
+	return ret;
+}
+
+static inline u_int pxa_mcxx_asst(u_int pcmcia_cycle_ns, u_int mem_clk_10khz)
+{
+	u_int code = pcmcia_cycle_ns * mem_clk_10khz;
+	u_int ret = (code / 300000) + ((code % 300000) ? 1 : 0);
+	return ret;
+}
+
+static inline u_int pxa_mcxx_setup(u_int pcmcia_cycle_ns, u_int mem_clk_10khz)
+{
+	u_int code = pcmcia_cycle_ns * mem_clk_10khz;
+	u_int ret = (code / 100000) + ((code % 100000) ? 1 : 0) + 1;
+	return ret;
+}
+
+static void rpcide_tune_drive(ide_drive_t *drive, u8 pio_mode_wanted)
+{
+	u8 pio_mode = ide_get_best_pio_mode(drive, 255, 5, NULL);
+//	unsigned int clock = get_memclk_frequency_10khz();
+
+	if (pio_mode > 4)
+		pio_mode = 4;
+
+	pio_mode = 4;
+	printk("using pio mode %d\n", pio_mode);
+	/* 
+	 * set PCMCIA I/O timing for this best pio mode 
+	 * FIXME: make this use only "legal" ressources...
+	 */
+//	MCMEM0 = ((pxa_mcxx_setup(rpcide_pio_timing[pio_mode][0], clock) & MCXX_SETUP_MASK) << MCXX_SETUP_SHIFT)
+//	      | ((pxa_mcxx_asst (rpcide_pio_timing[pio_mode][1], clock) & MCXX_ASST_MASK)  << MCXX_ASST_SHIFT)
+//	      | ((pxa_mcxx_hold (rpcide_pio_timing[pio_mode][2], clock) & MCXX_HOLD_MASK)  << MCXX_HOLD_SHIFT);
+
+	MCMEM0 = mcmem0;
+//	MCMEM0 = 0x00004083;
+	return;
+}
+
+#ifdef USE_PXA_DMA
+static unsigned long rpcide_physaddr;
+static unsigned int rpcide_dma = 0;
+
+static void rpcide_outsw (unsigned long port, void *addr, u32 count)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (rpcide_dma == (unsigned char)-1) 
+	{
+		writesw(port, addr, count);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)addr & 6) 
+	{
+		outw(*(u16 *)addr, port);
+		((u16 *)addr)++;
+		count--;
+	}
+	
+	count *= 2;
+	dmabuf = dma_map_single(NULL, addr, count, DMA_TO_DEVICE);
+	DCSR(rpcide_dma) = DCSR_NODESC;
+	DSADR(rpcide_dma) = dmabuf;
+	DTADR(rpcide_dma) = rpcide_physaddr;
+	DCMD(rpcide_dma) = (DCMD_INCSRCADDR | DCMD_BURST32 |
+		     DCMD_WIDTH2 | (DCMD_LENGTH & count));
+	DCSR(rpcide_dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(rpcide_dma) & DCSR_STOPSTATE));
+
+	DCSR(rpcide_dma) = 0;
+	dma_unmap_single(NULL, dmabuf, count, DMA_TO_DEVICE);
+}
+
+static void rpcide_insw (unsigned long port, void *addr, u32 count)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (rpcide_dma == (unsigned char)-1) 
+	{
+		readsw(port, addr, count);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)addr & 6) 
+	{
+		*((u16 *)addr)++ = inw(port);
+		count--;
+	}
+	
+	count *= 2;
+	dmabuf = dma_map_single(NULL, addr, count, DMA_FROM_DEVICE);
+	DCSR(rpcide_dma) = DCSR_NODESC;
+	DTADR(rpcide_dma) = dmabuf;
+	DSADR(rpcide_dma) = rpcide_physaddr;
+	DCMD(rpcide_dma) = (DCMD_INCTRGADDR | DCMD_BURST32 |
+		     DCMD_WIDTH2 | (DCMD_LENGTH & count));
+	DCSR(rpcide_dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(rpcide_dma) & DCSR_STOPSTATE));
+
+	DCSR(rpcide_dma) = 0;
+	dma_unmap_single(NULL, dmabuf, count, DMA_FROM_DEVICE);
+}
+
+static void
+    rpcide_pxa_dma_irq(int dma, void *_lp, struct pt_regs *regs)
+{
+	printk("%s: dma irq??\n",DRIVER_NAME);
+	DCSR(dma) = DCSR_ENDINTR;
+}
+#endif /* USE_PXA_DMA */
+
+static int rpcide_probe(struct device *dev)
+{
+	hw_regs_t hw;
+	ide_hwif_t *hwif;
+	int i;
+	unsigned long reg;
+	int ret = -ENODEV;
+	struct resource *res = NULL;
+	unsigned long physaddr, ioaddr;
+	size_t iosize;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	MECR |= MECR_CIT;
+	MECR &= ~MECR_NOS;
+
+	pxa_gpio_mode(GPIO48_nPOE_MD);
+	pxa_gpio_mode(GPIO49_nPWE_MD);
+	pxa_gpio_mode(GPIO50_nPIOR_MD);
+	pxa_gpio_mode(GPIO51_nPIOW_MD);
+	pxa_gpio_mode(GPIO52_nPCE_1_MD);
+	pxa_gpio_mode(GPIO53_nPCE_2_MD);
+	pxa_gpio_mode(GPIO54_pSKTSEL_MD);
+	pxa_gpio_mode(GPIO55_nPREG_MD);
+	pxa_gpio_mode(GPIO56_nPWAIT_MD);
+	pxa_gpio_mode(GPIO57_nIOIS16_MD);
+
+	MCMEM0 = mcmem0;
+
+	printk("resetting card\n");
+	pxa_gpio_mode(PNP2110_PCMCIA_RESET | GPIO_OUT);
+	GPSR(PNP2110_PCMCIA_RESET) = GPIO_bit(PNP2110_PCMCIA_RESET);
+	udelay(10);
+	GPCR(PNP2110_PCMCIA_RESET) = GPIO_bit(PNP2110_PCMCIA_RESET);
+	udelay(10);
+
+	/* allocate & register memory */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+                printk("%s: no mem resource defined.\n", DRIVER_NAME);
+                goto out;
+        }	
+
+	physaddr = res->start;
+#ifdef USE_PXA_DMA
+	rpcide_physaddr = res->start;
+#endif
+	iosize   = res->end - res->start;
+
+	if (!request_mem_region(physaddr, iosize, DRIVER_NAME)) {
+                printk("%s: device busy.\n", DRIVER_NAME);
+                ret = -EBUSY;
+                goto out;
+        }
+
+	ioaddr = (u32)ioremap(physaddr, iosize);
+        if (!ioaddr) {
+                printk("%s: ioremap failed.\n", DRIVER_NAME);
+		ret = -ENOMEM;
+		goto rel_mem;
+        }
+
+	memset(&hw, 0, sizeof(hw));
+
+	reg = ioaddr + 0x0000;			/* data port */
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw.io_ports[i] = reg;
+		reg++;
+	}
+	
+	hw.io_ports[IDE_CONTROL_OFFSET] =
+		ioaddr + 0xe;		/* control port */
+
+	hw.dma = NO_DMA;
+
+#ifdef USE_PXA_DMA
+	rpcide_dma = pxa_request_dma("rpcide", DMA_PRIO_LOW,
+			  rpcide_pxa_dma_irq, NULL);
+	printk("%s: dma %d\n",DRIVER_NAME,rpcide_dma);
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res->start) {
+                printk("%s: IRQ not defined.\n", DRIVER_NAME);
+		ret = -EIO;
+		goto rel_mem;
+        }
+
+	hw.irq = res->start;
+
+	/* register IDE device */
+	i = ide_register_hw(&hw, &hwif);
+
+#ifdef USE_PXA_DMA
+	hwif->OUTSW = rpcide_outsw;
+	hwif->INSW = rpcide_insw;
+#endif
+
+        if (res->flags & IORESOURCE_IRQ_HIGHEDGE)
+            set_irq_type(hw.irq, IRQT_RISING);
+        if (res->flags & IORESOURCE_IRQ_LOWEDGE)
+            set_irq_type(hw.irq, IRQT_FALLING);
+
+        hwif->tuneproc = &rpcide_tune_drive;
+        hwif->drives[0].autotune = 1;
+        hwif->drives[1].autotune = 1;
+
+	if (i == -1) {
+		printk(KERN_WARNING "%s: registering IDE failed\n", DRIVER_NAME);
+		ret = -EIO;
+		goto rel_mem;
+	}
+
+	dev_set_drvdata(dev, hwif);
+	ret = 0; 
+	goto out;
+
+rel_mem:
+	release_mem_region(physaddr, iosize);
+out:
+	return ret;
+}
+
+static int rpcide_remove(struct device *dev)
+{
+	struct resource *res = NULL;
+	ide_hwif_t *hwif = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+	unsigned long physaddr;
+	size_t iosize;
+
+	if (!hwif) {
+		printk(KERN_ERR "%s: Unable to remove device, please report.\n", DRIVER_NAME);
+		return -EIO;
+	}
+
+	ide_unregister(hwif->index);
+
+        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        if (!res) {
+                printk("%s: no mem resource defined.\n", DRIVER_NAME);
+                return -EIO; 
+        }
+
+        physaddr = res->start;
+        iosize   = res->end - res->start;
+	
+#ifdef USE_PXA_DMA
+	if(rpcide_dma)
+		pxa_free_dma(rpcide_dma);
+#endif
+
+	release_mem_region(physaddr, iosize);
+
+	return 0;
+}
+
+/* driver model */
+
+static struct device_driver rpcide_driver = {
+        .name           = "rpcide",
+        .bus            = &platform_bus_type,
+        .probe          = rpcide_probe,
+        .remove         = rpcide_remove,
+};
+
+static int __init rpcide_init(void)
+{
+	return driver_register(&rpcide_driver);
+}
+
+static void __exit rpcide_exit(void)
+{
+	driver_unregister(&rpcide_driver);
+}
+
+module_init(rpcide_init);
+module_exit(rpcide_exit);
+
+MODULE_DESCRIPTION("IDE driver connected to the pxa PCMCIA port");
+MODULE_LICENSE("GPL");
Index: drivers/ide/diff
===================================================================
--- a/drivers/ide/diff	(revision 0)
+++ b/drivers/ide/diff	(revision 675)
@@ -0,0 +1,32 @@
+--- /ptx/kernel/linux-2.4.19-rmk7-pxa2-ssv1-ide/drivers/ide/ide.c	2003-10-01 09:31:51.000000000 +0200
++++ ide-weihua.c	2004-07-13 13:16:28.429882240 +0200
+@@ -158,6 +161,7 @@
+ #include <asm/bitops.h>
+ 
+ #include "ide_modes.h"
++#include "pnpX110-ipe-pii.h"
+ 
+ #ifdef CONFIG_KMOD
+ #include <linux/kmod.h>
+@@ -326,7 +330,11 @@
+ 
+ 	/* Add default hw interfaces */
+ 	ide_old_init_default_hwifs();
++#if defined(CONFIG_SA1100_PNP1110) || defined(CONFIG_ARCH_PXA_PNP2110) 
++	ide_init_default_pnpx110_hwifs();
++#else
+ 	ide_init_default_hwifs();
++#endif
+ 
+ #ifdef CONFIG_BLK_DEV_HD
+ 	/* Check for any clashes with hd.c driver */
+@@ -3697,6 +3705,9 @@
+ 		pnpide_init(1);
+ 	}
+ #endif /* CONFIG_BLK_DEV_ISAPNP */
++#if defined(CONFIG_SA1100_PNP1110) || defined(CONFIG_ARCH_PXA_PNP2110)
++	    pnpx110_ide_init();
++#endif
+ }
+ 
+ void __init ide_init_builtin_drivers (void)
Index: drivers/ide/ide-fzk.c
===================================================================
--- a/drivers/ide/ide-fzk.c	(revision 0)
+++ b/drivers/ide/ide-fzk.c	(revision 675)
@@ -0,0 +1,428 @@
+/*
+ * linux/drivers/ide/legacy/fzkide.c		Version 0.1	Jan 19, 2004
+ *
+ * Copyright (C) 2004 Weihua Zhang, FZK
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * Jan 19, 2004 support only pio mode
+ * 
+ */
+
+//#define USE_PXA_DMA
+#include <linux/config.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/blkpg.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/completion.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+
+#if !defined(CONFIG_ARCH_PXA_PNP2110) 
+#error "Nobody has tested this on a non-PNP2110 board yet..."
+#endif
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+
+#define DRIVER_NAME "fzkide"
+
+/* 
+ * The followings are originally defined in drivers/pcmcia/pxa/pxa.h
+ * FIXME: check for conflicts
+ */
+#define MCXX_SETUP_MASK     (0x7f)
+#define MCXX_ASST_MASK      (0x1f)
+#define MCXX_HOLD_MASK      (0x3f)
+#define MCXX_SETUP_SHIFT    (0)
+#define MCXX_ASST_SHIFT     (7)
+#define MCXX_HOLD_SHIFT     (14)
+
+//extern int platform_add_devices(struct platform_device **devs, int num);
+
+/* 
+ * The following table is according to the ATA/ATAIP-6 T13 1410D Revision 3b.
+ * It is noted that there is a pio mode 5, but the timing is not included
+ * in the Revision 3b.
+ *                                             setup asst  hold (ns)
+ */
+unsigned short fzkide_pio_timing[5][3] = {{70,  165, 20}, /* pio mode 0 */
+                                          {50,  125, 15}, /* pio mode 1 */
+                                          {30,  100, 10}, /* pio mode 2 */
+                                          {30,   80, 10}, /* pio mode 3 */
+                                          {25,   70, 10}  /* pio mode 4 */
+};
+
+static inline u_int pxa_mcxx_hold(u_int pcmcia_cycle_ns, u_int mem_clk_10khz)
+{
+	u_int code = pcmcia_cycle_ns * mem_clk_10khz;
+	u_int ret = (code / 300000) + ((code % 300000) ? 1 : 0);
+	return ret;
+}
+
+static inline u_int pxa_mcxx_asst(u_int pcmcia_cycle_ns, u_int mem_clk_10khz)
+{
+	u_int code = pcmcia_cycle_ns * mem_clk_10khz;
+	u_int ret = (code / 300000) + ((code % 300000) ? 1 : 0);
+	return ret;
+}
+
+static inline u_int pxa_mcxx_setup(u_int pcmcia_cycle_ns, u_int mem_clk_10khz)
+{
+	u_int code = pcmcia_cycle_ns * mem_clk_10khz;
+	u_int ret = (code / 100000) + ((code % 100000) ? 1 : 0) + 1;
+	return ret;
+}
+
+static void fzkide_tune_drive(ide_drive_t *drive, u8 pio_mode_wanted)
+{
+	u8 pio_mode = ide_get_best_pio_mode(drive, 255, 5, NULL);
+//	unsigned int clock = get_memclk_frequency_10khz();
+
+	if (pio_mode > 4)
+		pio_mode = 4;
+
+	pio_mode = 4;
+	printk("using pio mode %d\n", pio_mode);
+	/* 
+	 * set PCMCIA I/O timing for this best pio mode 
+	 * FIXME: make this use only "legal" ressources...
+	 */
+//	MCIO1 = ((pxa_mcxx_setup(fzkide_pio_timing[pio_mode][0], clock) & MCXX_SETUP_MASK) << MCXX_SETUP_SHIFT)
+//	      | ((pxa_mcxx_asst (fzkide_pio_timing[pio_mode][1], clock) & MCXX_ASST_MASK)  << MCXX_ASST_SHIFT)
+//	      | ((pxa_mcxx_hold (fzkide_pio_timing[pio_mode][2], clock) & MCXX_HOLD_MASK)  << MCXX_HOLD_SHIFT);
+
+	MCIO1 = 0x00004083;
+	MCIO0 = 0x00004083;
+
+	return;
+}
+
+#ifdef USE_PXA_DMA
+static unsigned long fzkide_physaddr;
+static unsigned int fzkide_dma = 0;
+
+static void fzkide_outsw (unsigned long port, void *addr, u32 count)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (fzkide_dma == (unsigned char)-1) 
+	{
+		writesw(port, addr, count);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)addr & 6) 
+	{
+		outw(*(u16 *)addr, port);
+		((u16 *)addr)++;
+		count--;
+	}
+	
+	count *= 2;
+	dmabuf = dma_map_single(NULL, addr, count, DMA_TO_DEVICE);
+	DCSR(fzkide_dma) = DCSR_NODESC;
+	DSADR(fzkide_dma) = dmabuf;
+	DTADR(fzkide_dma) = fzkide_physaddr;
+	DCMD(fzkide_dma) = (DCMD_INCSRCADDR | DCMD_BURST32 |
+		     DCMD_WIDTH2 | (DCMD_LENGTH & count));
+	DCSR(fzkide_dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(fzkide_dma) & DCSR_STOPSTATE));
+
+	DCSR(fzkide_dma) = 0;
+	dma_unmap_single(NULL, dmabuf, count, DMA_TO_DEVICE);
+}
+
+static void fzkide_insw (unsigned long port, void *addr, u32 count)
+{
+	dma_addr_t dmabuf;
+	
+	/* fallback if no DMA available */
+	if (fzkide_dma == (unsigned char)-1) 
+	{
+		readsw(port, addr, count);
+		return;
+	}
+	
+	/* 64 bit alignment is required for memory to memory DMA */
+	while ((long)addr & 6) 
+	{
+		*((u16 *)addr)++ = inw(port);
+		count--;
+	}
+	
+	count *= 2;
+	dmabuf = dma_map_single(NULL, addr, count, DMA_FROM_DEVICE);
+	DCSR(fzkide_dma) = DCSR_NODESC;
+	DTADR(fzkide_dma) = dmabuf;
+	DSADR(fzkide_dma) = fzkide_physaddr;
+	DCMD(fzkide_dma) = (DCMD_INCTRGADDR | DCMD_BURST32 |
+		     DCMD_WIDTH2 | (DCMD_LENGTH & count));
+	DCSR(fzkide_dma) = DCSR_NODESC | DCSR_RUN;
+	while (!(DCSR(fzkide_dma) & DCSR_STOPSTATE));
+
+	DCSR(fzkide_dma) = 0;
+	dma_unmap_single(NULL, dmabuf, count, DMA_FROM_DEVICE);
+}
+
+static void
+    fzkide_pxa_dma_irq(int dma, void *_lp, struct pt_regs *regs)
+{
+	printk("%s: dma irq??\n",DRIVER_NAME);
+	DCSR(dma) = DCSR_ENDINTR;
+}
+#endif /* USE_PXA_DMA */
+
+static int fzkide_probe(struct device *dev)
+{
+	hw_regs_t hw;
+	ide_hwif_t *hwif;
+	int i;
+	unsigned long reg;
+	int ret = -ENODEV;
+	struct resource *res = NULL;
+	unsigned long physaddr, ioaddr;
+	size_t iosize;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	pxa_gpio_mode(GPIO48_nPOE_MD);
+	pxa_gpio_mode(GPIO50_nPIOR_MD);
+	pxa_gpio_mode(GPIO51_nPIOW_MD);
+	pxa_gpio_mode(GPIO52_nPCE_1_MD);
+	pxa_gpio_mode(GPIO53_nPCE_2_MD);
+	pxa_gpio_mode(GPIO54_pSKTSEL_MD);
+	pxa_gpio_mode(GPIO55_nPREG_MD);
+	pxa_gpio_mode(GPIO56_nPWAIT_MD);
+	pxa_gpio_mode(GPIO57_nIOIS16_MD);
+
+//	MCIO0 = 0x00014699;
+//	MCIO1 = 0x00014699;
+	MCIO0 = 0x00004083;
+	MCIO1 = 0x00004083;
+
+	/* allocate & register memory */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+                printk("%s: no mem resource defined.\n", DRIVER_NAME);
+                goto out;
+        }	
+
+	physaddr = res->start;
+	printk(KERN_INFO "probing fzkide IDE port");
+
+#ifdef USE_PXA_DMA
+	fzkide_physaddr = res->start;
+#endif
+	iosize   = res->end - res->start;
+
+	if (!request_mem_region(physaddr, iosize, DRIVER_NAME)) {
+                printk("%s: device busy.\n", DRIVER_NAME);
+                ret = -EBUSY;
+                goto out;
+        }
+
+	ioaddr = (unsigned long)ioremap(physaddr, iosize);
+        if (!ioaddr) {
+                printk("%s: ioremap failed.\n", DRIVER_NAME);
+		ret = -ENOMEM;
+		goto rel_mem;
+        }
+printk("idefzk: ioremapped to 0x%08lx\n",ioaddr);
+	memset(&hw, 0, sizeof(hw));
+
+	reg = ioaddr + 0x0000;			/* data port */
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw.io_ports[i] = reg;
+		reg += 2; /* Weihua doesn't use A0 for IDE */
+	}
+	
+	hw.io_ports[IDE_CONTROL_OFFSET] = 
+		ioaddr + 0x100C;		/* control port */
+
+	hw.dma = NO_DMA;
+
+#ifdef USE_PXA_DMA
+	fzkide_dma = pxa_request_dma("fzkide", DMA_PRIO_LOW,
+			  fzkide_pxa_dma_irq, NULL);
+	printk("%s: dma %d\n",DRIVER_NAME,fzkide_dma);
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res->start) {
+                printk("%s: IRQ not defined.\n", DRIVER_NAME);
+		ret = -EIO;
+		goto rel_mem;
+        }
+
+	hw.irq = res->start;
+
+	printk("registering ide port on address 0x%08lx, irq %d\n",physaddr,hw.irq);
+	/* register IDE device */
+	i = ide_register_hw(&hw, &hwif);
+
+#ifdef USE_PXA_DMA
+	hwif->OUTSW = fzkide_outsw;
+	hwif->INSW = fzkide_insw;
+#endif
+
+        if (res->flags & IORESOURCE_IRQ_HIGHEDGE)
+            set_irq_type(hw.irq, IRQT_RISING);
+        if (res->flags & IORESOURCE_IRQ_LOWEDGE)
+            set_irq_type(hw.irq, IRQT_FALLING);
+
+        hwif->tuneproc = &fzkide_tune_drive;
+        hwif->drives[0].autotune = 1;
+        hwif->drives[1].autotune = 1;
+
+	if (i == -1) {
+		printk(KERN_WARNING "%s: registering IDE failed\n", DRIVER_NAME);
+		ret = -EIO;
+		goto rel_mem;
+	}
+
+	dev_set_drvdata(dev, hwif);
+	ret = 0; 
+	goto out;
+
+rel_mem:
+	release_mem_region(physaddr, iosize);
+out:
+	return ret;
+}
+
+static int fzkide_remove(struct device *dev)
+{
+	struct resource *res = NULL;
+	ide_hwif_t *hwif = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+	unsigned long physaddr;
+	size_t iosize;
+
+	if (!hwif) {
+		printk(KERN_ERR "%s: Unable to remove device, please report.\n", DRIVER_NAME);
+		return -EIO;
+	}
+
+	ide_unregister(hwif->index);
+
+        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        if (!res) {
+                printk("%s: no mem resource defined.\n", DRIVER_NAME);
+                return -EIO; 
+        }
+
+        physaddr = res->start;
+        iosize   = res->end - res->start;
+	
+#ifdef USE_PXA_DMA
+	if(fzkide_dma)
+		pxa_free_dma(fzkide_dma);
+#endif
+
+	release_mem_region(physaddr, iosize);
+
+	return 0;
+}
+
+/* driver model */
+
+static struct device_driver fzkide_driver = {
+        .name           = "fzkide",
+        .bus            = &platform_bus_type,
+        .probe          = fzkide_probe,
+        .remove         = fzkide_remove,
+};
+
+/* device and ressources */
+
+static struct resource fzkide_resources_0[] = {
+	{
+		.start = _PCMCIA(0),
+		.end   = _PCMCIA(0) + PCMCIAIOSp,
+		.flags = IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+	},
+	{
+		.start = IRQ_GPIO(77),
+		.end   = IRQ_GPIO(77),
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+	},
+};
+
+static struct platform_device fzkide_device_0 = {
+        .name           = "fzkide",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(fzkide_resources_0),
+        .resource       = fzkide_resources_0,
+};
+
+static struct resource fzkide_resources_1[] = {
+	{
+		.start = _PCMCIA(1),
+		.end   = _PCMCIA(1) + PCMCIAIOSp,
+		.flags = IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+	},
+	{
+		.start = IRQ_GPIO(70),
+		.end   = IRQ_GPIO(70),
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
+	},
+};
+
+static struct platform_device fzkide_device_1 = {
+        .name           = "fzkide",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(fzkide_resources_1),
+        .resource       = fzkide_resources_1,
+};
+
+static struct platform_device *devices[] __initdata = {
+        &fzkide_device_0,
+        &fzkide_device_1,
+};
+
+static int __init fzkide_init(void)
+{
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	return driver_register(&fzkide_driver);
+}
+
+module_init(fzkide_init);
+
+MODULE_AUTHOR("Pengutronix");
+MODULE_LICENSE("GPL");
+
Index: drivers/ide/Makefile
===================================================================
--- a/drivers/ide/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/ide/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -17,6 +17,7 @@
 	ide-taskfile.o
 
 ide-core-$(CONFIG_BLK_DEV_CMD640)	+= pci/cmd640.o
+obj-$(CONFIG_BLK_DEV_FZKIDE)		+= ide-fzk.o
 
 # Core IDE code - must come before legacy
 ide-core-$(CONFIG_BLK_DEV_IDEPCI)	+= setup-pci.o
@@ -24,6 +25,7 @@
 ide-core-$(CONFIG_BLK_DEV_IDE_TCQ)	+= ide-tcq.o
 ide-core-$(CONFIG_PROC_FS)		+= ide-proc.o
 ide-core-$(CONFIG_BLK_DEV_IDEPNP)	+= ide-pnp.o
+ide-core-$(CONFIG_BLK_DEV_FZKIDE)	+= ide-fzk.o
 
 # built-in only drivers from arm/
 ide-core-$(CONFIG_IDE_ARM)		+= arm/ide_arm.o
Index: drivers/base/platform.c
===================================================================
--- a/drivers/base/platform.c	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/base/platform.c	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -341,6 +341,7 @@
 
 EXPORT_SYMBOL_GPL(platform_bus);
 EXPORT_SYMBOL_GPL(platform_bus_type);
+EXPORT_SYMBOL_GPL(platform_add_devices);
 EXPORT_SYMBOL_GPL(platform_device_register);
 EXPORT_SYMBOL_GPL(platform_device_register_simple);
 EXPORT_SYMBOL_GPL(platform_device_unregister);
Index: drivers/i2c/busses/Kconfig
===================================================================
--- a/drivers/i2c/busses/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/i2c/busses/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -486,4 +486,15 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-pca-isa.
 
+config I2C_PXA
+	tristate "I2C interface in Intel PXA2x0"
+	depends on ARCH_PXA && I2C
+	help
+	  This supports the use of the PXA I2C interface found on the Intel
+	  PXA 25x and PXA 26x systems. Say Y if you have one of these. 
+	  You should also say Y for the PXA I2C peripheral driver support below.
+
+	  To compile this driver as a module, say M here: the
+	  modules will be called i2c-pxa and i2c-algo-pxa.
+
 endmenu
Index: drivers/i2c/busses/Makefile
===================================================================
--- a/drivers/i2c/busses/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/i2c/busses/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -27,6 +27,7 @@
 obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa.o
 obj-$(CONFIG_I2C_PIIX4)		+= i2c-piix4.o
 obj-$(CONFIG_I2C_PROSAVAGE)	+= i2c-prosavage.o
+obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
 obj-$(CONFIG_I2C_RPXLITE)	+= i2c-rpx.o
 obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
 obj-$(CONFIG_I2C_SAVAGE4)	+= i2c-savage4.o
@@ -38,6 +39,7 @@
 obj-$(CONFIG_I2C_VIA)		+= i2c-via.o
 obj-$(CONFIG_I2C_VIAPRO)	+= i2c-viapro.o
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
+obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
 
Index: drivers/i2c/busses/i2c-pxa.c
===================================================================
--- a/drivers/i2c/busses/i2c-pxa.c	(revision 0)
+++ b/drivers/i2c/busses/i2c-pxa.c	(revision 675)
@@ -0,0 +1,369 @@
+/*
+ *  i2c_pxa.c
+ *
+ *  I2C adapter for the PXA I2C bus access
+ *
+ *  Copyright (C) 2002 Intrinsyc Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  History:
+ *    Apr 2002: Initial version [CS]
+ *    Jun 2002: Properly seperated algo/adap [FB]
+ *    Jan 2003: Fixed several bugs concerning interrupt handling [Kai-Uwe Bloem]
+ *    Jan 2003: added limited signal handling [Kai-Uwe Bloem]
+ *    Jun 2003: updated for 2.5 [Dustin McIntire]
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/irq.h>
+#include <asm/arch/irqs.h>	      /* for IRQ_I2C */
+#include <asm/arch/i2c-pxa.h>
+
+/*
+ * Set this to zero to remove all debug statements via dead code elimination.
+ */
+//#define DEBUG       1
+
+#if DEBUG
+static unsigned int i2c_debug = DEBUG;
+#else
+#define i2c_debug	0
+#endif
+
+static int irq = 0;
+static volatile int i2c_pending = 0;	     /* interrupt pending when 1 */
+static volatile int bus_error = 0;
+static volatile int tx_finished = 0;
+static volatile int rx_finished = 0;
+
+static wait_queue_head_t i2c_wait;
+static void i2c_pxa_transfer( int lastbyte, int receive, int midbyte);
+
+static spinlock_t i2c_pxa_irqlock = SPIN_LOCK_UNLOCKED;
+
+/* place a byte in the transmit register */
+static void i2c_pxa_write_byte(u8 value)
+{
+	IDBR = value;
+}
+
+/* read byte in the receive register */
+static u8 i2c_pxa_read_byte(void)
+{
+	return (u8) (0xff & IDBR);
+}
+
+static void i2c_pxa_start(void)
+{
+	unsigned long icr = ICR;
+	icr |= ICR_START;
+	icr &= ~(ICR_STOP | ICR_ALDIE | ICR_ACKNAK);
+	ICR = icr;
+
+	bus_error=0;	    /* clear any bus_error from previous txfers */
+	tx_finished=0;	  /* clear rx and tx interrupts from previous txfers */
+	rx_finished=0;
+	i2c_pending = 0;
+}
+
+static void i2c_pxa_repeat_start(void)
+{
+	unsigned long icr = ICR;
+	icr |= ICR_START;
+	icr &= ~(ICR_STOP | ICR_ALDIE);
+	ICR = icr;
+
+	bus_error=0;	    /* clear any bus_error from previous txfers */
+	tx_finished=0;	  /* clear rx and tx interrupts from previous txfers */
+	rx_finished=0;
+	i2c_pending = 0;
+}
+
+static void i2c_pxa_stop(void)
+{
+	unsigned long icr = ICR;
+	icr |= ICR_STOP;
+	icr &= ~(ICR_START);
+	ICR = icr;
+}
+
+static void i2c_pxa_midbyte(void)
+{
+	unsigned long icr = ICR;
+	icr &= ~(ICR_START | ICR_STOP);
+	ICR = icr;
+}
+
+static void i2c_pxa_abort(void)
+{
+	unsigned long timeout = jiffies + HZ/4;
+
+#ifdef PXA_ABORT_MA
+	while ((long)(timeout - jiffies) > 0 && (ICR & ICR_TB)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+
+	ICR |= ICR_MA;
+	udelay(100);
+#else
+	while ((long)(timeout - jiffies) > 0 && (IBMR & 0x1) == 0) {
+		i2c_pxa_transfer( 1, I2C_RECEIVE, 1);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+#endif
+	ICR &= ~(ICR_MA | ICR_START | ICR_STOP);
+}
+
+static int i2c_pxa_wait_bus_not_busy(void)
+{
+	int timeout = DEF_TIMEOUT;
+
+	while (timeout-- && (ISR & ISR_IBB)) {
+		udelay(100); /* wait for 100 us */
+	}
+
+	return (timeout<=0);
+}
+
+static void i2c_pxa_wait_for_ite(void)
+{ 
+	unsigned long flags;
+	if (irq > 0) {
+	    spin_lock_irqsave(&i2c_pxa_irqlock, flags);
+		if (i2c_pending == 0) {
+			interruptible_sleep_on_timeout(&i2c_wait, I2C_SLEEP_TIMEOUT );
+		}
+		i2c_pending = 0;
+		spin_unlock_irqrestore(&i2c_pxa_irqlock, flags);
+	} else {
+		udelay(100);
+	}
+}
+
+static int i2c_pxa_wait_for_int(int wait_type)
+{
+	int timeout = DEF_TIMEOUT;
+#ifdef DEBUG
+	if (bus_error)
+		printk(KERN_INFO"i2c_pxa_wait_for_int: Bus error on enter\n");
+	if (rx_finished)
+		printk(KERN_INFO"i2c_pxa_wait_for_int: Receive interrupt on enter\n");
+	if (tx_finished)
+		printk(KERN_INFO"i2c_pxa_wait_for_int: Transmit interrupt on enter\n");
+#endif
+
+	if (wait_type == I2C_RECEIVE) {	/* wait on receive */
+
+		do {
+			i2c_pxa_wait_for_ite();
+		} while (!(rx_finished) && timeout-- && !signal_pending(current));
+
+#ifdef DEBUG
+		if (timeout<0) {
+			if (tx_finished)
+				printk("I2C: received a tx interrupt while waiting on a rx in wait_for_int\n");
+		}
+#endif
+	} else {		  /* wait on transmit */
+
+		do {
+			i2c_pxa_wait_for_ite();
+		} while (!(tx_finished) && timeout-- && !signal_pending(current));
+
+#ifdef DEBUG
+		if (timeout<0) {
+			if (rx_finished)
+				printk("i2c: received a rx interrupt while waiting on a tx in wait_for_int\n");
+		}
+#endif
+	}
+
+	udelay(ACK_DELAY);      /* this is needed for the bus error */
+
+	tx_finished=0;
+	rx_finished=0;
+
+	if (bus_error) {
+		bus_error=0;
+		if (i2c_debug > 2)printk("wait_for_int: error - no ack\n");
+		return BUS_ERROR;
+	}
+
+	if (signal_pending(current)) {
+		return (-ERESTARTSYS);
+	} else
+	if (timeout < 0) {
+		if (i2c_debug > 2)printk("wait_for_int: timeout\n");
+		return(-EIO);
+	} else
+		return(0);
+}
+
+static void i2c_pxa_transfer(int lastbyte, int receive, int midbyte)
+{
+	if (lastbyte) {
+		if (receive==I2C_RECEIVE) ICR |= ICR_ACKNAK;
+		i2c_pxa_stop();
+	} else
+	if (midbyte) {
+		i2c_pxa_midbyte();
+	}
+	ICR |= ICR_TB;
+}
+
+static void i2c_pxa_reset( void)
+{
+#ifdef DEBUG
+	printk("Resetting I2C Controller Unit\n");
+#endif
+
+	/* abort any transfer currently under way */
+	i2c_pxa_abort();
+
+	/* reset according to 9.8 */
+	ICR = ICR_UR;
+	ISR = I2C_ISR_INIT;
+	ICR &= ~ICR_UR;
+
+	/* set the global I2C clock on */
+	CKEN |= CKEN14_I2C;
+
+	/* set our slave address */
+	ISAR = I2C_PXA_SLAVE_ADDR;
+
+	/* set control register values */
+	ICR = I2C_ICR_INIT;
+
+	/* clear any leftover states from prior transmissions */
+	i2c_pending = rx_finished = tx_finished = bus_error = 0;
+
+	/* enable unit */
+	ICR |= ICR_IUE;
+	udelay(100);
+}
+
+static irqreturn_t i2c_pxa_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long flags;
+	int status, wakeup = 0;
+	status = (ISR);
+
+	if (status & ISR_BED) {
+		(ISR) |= ISR_BED;
+		bus_error=ISR_BED;
+		wakeup = 1;
+	}
+	if (status & ISR_ITE) {
+		(ISR) |= ISR_ITE;
+		tx_finished=ISR_ITE;
+		wakeup = 1;
+	}
+	if (status & ISR_IRF) {
+		(ISR) |= ISR_IRF;
+		rx_finished=ISR_IRF;
+		wakeup = 1;
+	}
+	if (wakeup) {
+		spin_lock_irqsave(&i2c_pxa_irqlock, flags);
+		i2c_pending = 1;
+		spin_unlock_irqrestore(&i2c_pxa_irqlock, flags);
+		wake_up_interruptible(&i2c_wait);
+	}
+	return IRQ_HANDLED;
+}
+
+static int i2c_pxa_resource_init(void)
+{
+	init_waitqueue_head(&i2c_wait);
+
+	if (request_irq(IRQ_I2C, &i2c_pxa_handler, 0, "I2C", 0) < 0) {
+		irq = 0;
+		if (i2c_debug)
+			printk(KERN_INFO "I2C: Failed to register I2C irq %i\n", IRQ_I2C);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void i2c_pxa_resource_release( void)
+{
+	if (irq > 0) {
+		free_irq(irq,0);
+		irq=0;
+	}
+}
+
+static struct i2c_algo_pxa_data i2c_pxa_data = {
+	write_byte:		i2c_pxa_write_byte,
+	read_byte:		i2c_pxa_read_byte,
+
+	start:			i2c_pxa_start,
+	repeat_start:		i2c_pxa_repeat_start,
+	stop:			i2c_pxa_stop,
+	abort:			i2c_pxa_abort,
+
+	wait_bus_not_busy:	i2c_pxa_wait_bus_not_busy,
+	wait_for_interrupt:	i2c_pxa_wait_for_int,
+	transfer:		i2c_pxa_transfer,
+	reset:			i2c_pxa_reset,
+
+	udelay:			10,
+	timeout:		DEF_TIMEOUT,
+};
+
+static struct i2c_adapter i2c_pxa_ops = {
+	.owner		= THIS_MODULE,
+	.id		= I2C_ALGO_PXA,
+	.class		= I2C_CLASS_HWMON,
+	.name		= "PXA i2c adapter",
+	.algo_data	= &i2c_pxa_data,
+	.retries	= 2,
+};
+
+extern int i2c_pxa_add_bus(struct i2c_adapter *);
+extern int i2c_pxa_del_bus(struct i2c_adapter *);
+
+static int __init i2c_adap_pxa_init(void)
+{
+	if (i2c_pxa_resource_init() == 0) {
+		if (i2c_pxa_add_bus(&i2c_pxa_ops) < 0) {
+			i2c_pxa_resource_release();
+			printk(KERN_INFO "I2C: Failed to add bus\n");
+			return -ENODEV;
+		}
+	} else {
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void i2c_adap_pxa_exit(void)
+{
+	i2c_pxa_del_bus(&i2c_pxa_ops);
+	i2c_pxa_resource_release();
+}
+
+MODULE_DESCRIPTION("PXA2x0 i2c driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_adap_pxa_init);
+module_exit(i2c_adap_pxa_exit);
Index: drivers/i2c/algos/i2c-algo-pxa.c
===================================================================
--- a/drivers/i2c/algos/i2c-algo-pxa.c	(revision 0)
+++ b/drivers/i2c/algos/i2c-algo-pxa.c	(revision 675)
@@ -0,0 +1,343 @@
+/*
+ *  i2c-algo-pxa.c
+ *
+ *  I2C algorithm for the PXA I2C bus access.
+ *  Byte driven algorithm similar to pcf.
+ *
+ *  Copyright (C) 2002 Intrinsyc Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  History:
+ *  Apr 2002: Initial version [CS]
+ *  Jun 2002: Properly seperated algo/adap [FB]
+ *  Jan 2003: added limited signal handling [Kai-Uwe Bloem]
+ *  Jan 2003: allow SMBUS_QUICK as valid msg [FB]
+ *  Jun 2003: updated for 2.5 [Dustin McIntire]
+ *  ...: more updates for 2.6 [Holger Schurig]
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>		/* struct i2c_msg and others */
+#include <linux/i2c-id.h>
+
+#include <asm/arch/i2c-pxa.h>
+
+/*
+ * Set this to zero to remove all the debug statements via dead code elimination.
+ */
+//#define DEBUG		1
+
+static int pxa_scan = 1;
+
+static int i2c_pxa_readbytes(struct i2c_adapter *i2c_adap, char *buf,
+			int count, int last)
+{
+
+	int i, timeout=0;
+	struct i2c_algo_pxa_data *adap = i2c_adap->algo_data;
+
+	/* increment number of bytes to read by one -- read dummy byte */
+	for (i = 0; i <= count; i++) {
+		if (i!=0) {
+			/* set ACK to NAK for last received byte ICR[ACKNAK] = 1
+			   only if not a repeated start */
+
+			if ((i == count) && last) {
+				adap->transfer( last, I2C_RECEIVE, 0);
+			} else {
+				adap->transfer( 0, I2C_RECEIVE, 1);
+			}
+
+			timeout = adap->wait_for_interrupt(I2C_RECEIVE);
+
+#ifdef DEBUG
+			if (timeout==BUS_ERROR) {
+				dev_dbg(&i2c_adap->dev, "read bus error, forcing reset\n");
+				adap->reset();
+				return I2C_RETRY;
+			} else
+#endif
+			if (timeout == -ERESTARTSYS) {
+				adap->abort();
+				return timeout;
+			} else
+			if (timeout) {
+				dev_dbg(&i2c_adap->dev, "read timeout, forcing reset\n");
+				adap->reset();
+				return I2C_RETRY;
+			}
+
+		}
+
+		if (i) {
+			buf[i - 1] = adap->read_byte();
+		} else {
+			adap->read_byte(); /* dummy read */
+		}
+	}
+	return (i - 1);
+}
+
+static int i2c_pxa_sendbytes(struct i2c_adapter *i2c_adap, const char *buf,
+			 int count, int last)
+{
+
+	struct i2c_algo_pxa_data *adap = i2c_adap->algo_data;
+	int wrcount, timeout;
+
+	for (wrcount=0; wrcount<count; ++wrcount) {
+
+		adap->write_byte(buf[wrcount]);
+		if ((wrcount==(count-1)) && last) {
+			adap->transfer( last, I2C_TRANSMIT, 0);
+		} else {
+			adap->transfer( 0, I2C_TRANSMIT, 1);
+		}
+
+		timeout = adap->wait_for_interrupt(I2C_TRANSMIT);
+
+#ifdef DEBUG
+		if (timeout==BUS_ERROR) {
+			dev_dbg(&i2c_adap->dev, "send bus error, forcing reset\n");
+			adap->reset();
+			return I2C_RETRY;
+		} else
+#endif
+		if (timeout == -ERESTARTSYS) {
+			adap->abort();
+			return timeout;
+		} else
+		if (timeout) {
+			dev_dbg(&i2c_adap->dev, "send timeout, forcing reset\n");
+			adap->reset();
+			return I2C_RETRY;
+		}
+	}
+	return (wrcount);
+}
+
+
+static inline int i2c_pxa_set_ctrl_byte(struct i2c_algo_pxa_data * adap, struct i2c_msg *msg)
+{
+	u16 flags = msg->flags;
+	u8 addr;
+	addr = (u8) ( (0x7f & msg->addr) << 1 );
+	if (flags & I2C_M_RD )
+		addr |= 1;
+	if (flags & I2C_M_REV_DIR_ADDR )
+		addr ^= 1;
+	adap->write_byte(addr);
+	return 0;
+}
+
+static int i2c_pxa_do_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_algo_pxa_data * adap;
+	struct i2c_msg *pmsg=NULL;
+	int i;
+	int ret=0, timeout;
+
+	adap = i2c_adap->algo_data;
+
+	timeout = adap->wait_bus_not_busy();
+
+	if (timeout) {
+		return I2C_RETRY;
+	}
+
+	for (i = 0;ret >= 0 && i < num; i++) {
+		int last = i + 1 == num;
+		pmsg = &msgs[i];
+
+		ret = i2c_pxa_set_ctrl_byte(adap,pmsg);
+
+		/* Send START */
+		if (i == 0) {
+			adap->start();
+		} else {
+			adap->repeat_start();
+		}
+
+		adap->transfer(0, I2C_TRANSMIT, 0);
+
+		/* Wait for ITE (transmit empty) */
+		timeout = adap->wait_for_interrupt(I2C_TRANSMIT);
+
+#ifdef DEBUG
+		/* Check for ACK (bus error) */
+		if (timeout==BUS_ERROR) {
+			dev_dbg(&i2c_adap->dev, "xfer bus error, forcing reset\n");
+			adap->reset();
+			return I2C_RETRY;
+		} else
+#endif
+		if (timeout == -ERESTARTSYS) {
+			adap->abort();
+			return timeout;
+		} else
+		if (timeout) {
+			dev_dbg(&i2c_adap->dev, "xfer timeout, forcing reset\n");
+			adap->reset();
+			return I2C_RETRY;
+		}
+/* FIXME: handle arbitration... */
+#if 0
+		/* Check for bus arbitration loss */
+		if (adap->arbitration_loss()) {
+			printk("Arbitration loss detected \n");
+			adap->reset();
+			return I2C_RETRY;
+		}
+#endif
+
+		/* Read */
+		if (pmsg->flags & I2C_M_RD) {
+			/* read bytes into buffer*/
+			ret = i2c_pxa_readbytes(i2c_adap, pmsg->buf, pmsg->len, last);
+#if DEBUG > 2
+			if (ret != pmsg->len) {
+				dev_dbg(&i2c_adap->dev, "i2c_pxa_do_xfer read %d/%d bytes\n",
+					ret, pmsg->len);
+			} else {
+				dev_dbg(&i2c_adap->dev, "i2c_pxa_do_xfer: read %d bytes\n",ret);
+			}
+#endif
+		} else { /* Write */
+			ret = i2c_pxa_sendbytes(i2c_adap, pmsg->buf, pmsg->len, last);
+#if DEBUG > 2
+			if (ret != pmsg->len) {
+				dev_dbg(&i2c_adap->dev, "i2c_pxa_do_xfer wrote %d/%d bytes\n",
+					ret, pmsg->len);
+			} else {
+				dev_info(&i2c_adap->dev, "i2c_pxa_do_xfer wrote %d bytes\n",ret);
+			}
+#endif
+		}
+	}
+
+	if (ret<0) {
+		return ret;
+	} else {
+		return i;
+	}
+}
+
+static int i2c_pxa_valid_messages( struct device *dev, struct i2c_msg msgs[], int num)
+{
+	int i;
+	if (num < 1 || num > MAX_MESSAGES) {
+		dev_dbg(dev, "%d messages of max %d\n", num, MAX_MESSAGES);
+		return -EINVAL;
+	}
+
+	/* check consistency of our messages */
+	for (i=0; i<num; i++) {
+		if (&msgs[i]==NULL) {
+			dev_dbg(dev, "msgs is NULL\n");
+			return -EINVAL;
+		} else {
+			if (msgs[i].buf == NULL) {
+				dev_dbg(dev, "length less than zero");
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 1;
+}
+
+static int i2c_pxa_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	int retval = i2c_pxa_valid_messages(&i2c_adap->dev, msgs, num);
+	if (retval > 0)
+	{
+		int i;
+		for (i=i2c_adap->retries; i>=0; i--) {
+			int retval = i2c_pxa_do_xfer(i2c_adap,msgs,num);
+			if (retval != I2C_RETRY) {
+				return retval;
+			}
+			dev_dbg(&i2c_adap->dev, "retrying transmission\n");
+			udelay(100);
+		}
+		dev_dbg(&i2c_adap->dev, "retried %i times\n", i2c_adap->retries);
+		return -EREMOTEIO;
+
+	}
+	return retval;
+}
+
+static u32 i2c_pxa_functionality(struct i2c_adapter * adapter)
+{
+	/* Emulate the SMBUS functions */
+	return I2C_FUNC_SMBUS_EMUL;
+}
+
+struct i2c_algorithm i2c_pxa_algorithm  = {
+	.name = "PXA I2C Algorithm",
+	.id   = I2C_ALGO_PXA,
+	.master_xfer   = i2c_pxa_xfer,
+	.functionality = i2c_pxa_functionality,
+};
+
+/*
+ * registering functions to load algorithms at runtime
+ */
+int i2c_pxa_add_bus(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_pxa_data *adap = i2c_adap->algo_data;
+
+	i2c_adap->algo = &i2c_pxa_algorithm;
+
+	/* register new adapter to i2c module... */
+	i2c_add_adapter(i2c_adap);
+
+	adap->reset();
+
+	/* scan bus */
+	if (pxa_scan) {
+		int i;
+		for (i = 0x02; i < 0xff; i+=2) {
+			if (i==(I2C_PXA_SLAVE_ADDR<<1)) continue;
+
+			if (adap->wait_bus_not_busy()) {
+				dev_err(&i2c_adap->dev, "TIMEOUT while scanning bus\n");
+				return -EIO;
+			}
+			adap->write_byte(i);
+			adap->start();
+			adap->transfer(0, I2C_TRANSMIT, 0);
+
+			if ((adap->wait_for_interrupt(I2C_TRANSMIT) != BUS_ERROR)) {
+				dev_info(&i2c_adap->dev, "found device 0x%02x\n", i>>1);
+				adap->abort();
+			} else {
+				adap->stop();
+			}
+			udelay(adap->udelay);
+		}
+	}
+	return 0;
+}
+
+int i2c_pxa_del_bus(struct i2c_adapter *i2c_adap)
+{
+	return i2c_del_adapter(i2c_adap);
+}
+
+EXPORT_SYMBOL(i2c_pxa_add_bus);
+EXPORT_SYMBOL(i2c_pxa_del_bus);
+
+MODULE_PARM(pxa_scan, "i");
+MODULE_PARM_DESC(pxa_scan, "Scan for active chips on the bus");
+
+MODULE_AUTHOR("Intrinsyc Software Inc.");
+MODULE_LICENSE("GPL");
Index: drivers/i2c/algos/Makefile
===================================================================
--- a/drivers/i2c/algos/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/i2c/algos/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -8,6 +8,7 @@
 obj-$(CONFIG_I2C_ALGOITE)	+= i2c-algo-ite.o
 obj-$(CONFIG_I2C_ALGO_SIBYTE)	+= i2c-algo-sibyte.o
 obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
+obj-$(CONFIG_I2C_PXA)		+= i2c-algo-pxa.o
 
 ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
 EXTRA_CFLAGS += -DDEBUG
Index: drivers/i2c/chips/Kconfig
===================================================================
--- a/drivers/i2c/chips/Kconfig	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/i2c/chips/Kconfig	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -371,4 +371,20 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called isp1301_omap.
 
+config SENSOR_X1226_RTC
+        tristate "XICOR X1226 (rtc part)"
+        depends on I2C && EXPERIMENTAL
+        select I2C_SENSOR
+
+config SENSOR_X1226_EEPROM
+        tristate "XICOR X1226 (eeprom part)"
+        depends on I2C && EXPERIMENTAL
+        select SENSOR_X1226_RTC
+        select I2C_SENSOR
+
+config SENSOR_ST24CXX
+        tristate "24cxx eeproms"
+        depends on I2C && EXPERIMENTAL
+        select I2C_SENSOR
+
 endmenu
Index: drivers/i2c/chips/x1226-eeprom.c
===================================================================
--- a/drivers/i2c/chips/x1226-eeprom.c	(revision 0)
+++ b/drivers/i2c/chips/x1226-eeprom.c	(revision 675)
@@ -0,0 +1,579 @@
+/*
+ * x1226-eeprom.c
+ *
+ * Copyright (C) 2004       GE Energy - PII Pipetronix GmbH - Karlsruhe - Germany
+ *                          Author: Norbert Teulings
+ * Copyright (C) 2004, 2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *
+ * based on:
+ * - linux-2.6.9-rc2/kernel/power/main.c
+ *   PM subsystem core functionality.
+ *   Copyright (c) 2003 Patrick Mochel
+ *   Copyright (c) 2003 Open Source Development Lab
+ * - linux-2.6.9-rc2/drivers/i2c/chips/eeprom.c
+ *   Part of lm_sensors, Linux kernel modules for hardware monitoring
+ *   Copyright (C) 1998, 1999 Frodo Looijaard <frodol@dds.nl> and
+ *	                      Philip Edelbrock <phil@netroedge.com>
+ *   Copyright (C) 2003       Greg Kroah-Hartman <greg@kroah.com>
+ *   Copyright (C) 2003       IBM Corp.
+ * - linux-2.6.0-test10-obs266/drivers/char/eepromi2c.c
+ *   Copyright 
+ *   Author: 2002 AXE Inc.  
+ *     takawata@axe-inc.co.jp
+ *   Based On 
+ *     linux/drivers/char/x1226-rtc.c
+ *
+ *     I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *
+ *     Copyright 2002 MontaVista Software Inc.
+ *     Author: MontaVista Software, Inc.
+ *       stevel@mvista.com or source@mvista.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+
+#include "x1226.h"
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = { DEVID_X1226_EEPROM, I2C_CLIENT_END };
+static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
+
+/* Insmod parameters */
+SENSORS_INSMOD_0;
+
+/* Each client has this additional data */
+struct x1226_eeprom_data {
+	struct i2c_client client;
+        struct i2c_client *rtc;
+};
+
+static int x1226_eeprom_attach_adapter(struct i2c_adapter *adapter);
+static int x1226_eeprom_detect(struct i2c_adapter *adapter, int address, int kind);
+static int x1226_eeprom_detach_client(struct i2c_client *client);
+
+static struct i2c_client *this_client = NULL;
+
+/* This is the driver that will be inserted */
+static struct i2c_driver x1226_eeprom_driver = {
+	.owner		= THIS_MODULE,
+	.name		= X1226_EEPROM_MODULE_NAME,
+	.id		= I2C_DRIVERID_X1226_EEPROM,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= x1226_eeprom_attach_adapter,
+	.detach_client	= x1226_eeprom_detach_client,
+};
+
+static int x1226_eeprom_id = 0;
+
+
+static int x1226_read(struct i2c_client *client,
+                      u8 *buf, u16 off, int count)
+{
+        int ret;
+	u8 regbuf[2] = { (off >> 8) & 0xff, off & 0xff};
+
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			0,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if count>1,
+			   "Current Address Read" if count=1 */
+			client->addr ,
+			I2C_M_RD,
+			count,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+        return ret;
+}
+
+
+static int __x1226_write(struct i2c_client *client,
+                        u8 *buf, u16 off, int count)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { (off >> 8) & 0xff, off & 0xff};
+
+	struct i2c_msg page_write = {
+		client->addr,
+		0,
+		count + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(count + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		dev_err(&client->dev, "buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, count);
+	page_write.buf = local_buf;
+
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+
+	return ret;
+}
+
+
+/*
+ * write to nonvolatile mem region (eprom, eg.) and wait
+ */
+static int x1226_write_wait(struct i2c_client *client,
+                            u8 *buf, u16 off, int count)
+{
+        int ret;
+        
+        ret = __x1226_write(client, buf, off, count);
+        if (ret < 0)
+                return ret;
+
+        /* wait for device to flush it's write buffers */
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(X1226_WRITE_WAIT);
+        
+        return ret;
+}
+
+
+/*
+ * write to volatile mem region (config regs) no waiting needed
+ */
+static inline int x1226_write_nowait(struct i2c_client *client,
+                                   u8 *buf, u16 off, int count)
+{
+        return __x1226_write(client, buf, off, count);
+}
+
+
+static inline int eeprom_write_enable(struct i2c_client *client)
+{
+        struct x1226_eeprom_data *data = i2c_get_clientdata(client);
+
+	return data->rtc->driver->command(data->rtc, EEPROM_RW, NULL);
+}
+
+
+static inline int eeprom_write_disable(struct i2c_client *client)
+{
+        struct x1226_eeprom_data *data = i2c_get_clientdata(client);
+
+        return data->rtc->driver->command(data->rtc, EEPROM_RO, NULL);
+}
+
+
+static ssize_t x1226_eeprom_read(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+	int remaining, copysize;
+        int ret;
+
+	if (off > X1226_EEPROM_SIZE)
+                return 0;
+	if (off + count > X1226_EEPROM_SIZE)
+		count = X1226_EEPROM_SIZE - off;
+
+	remaining = count;
+	do {
+		copysize = (remaining > X1226_EEPROM_PAGE_SIZE)
+                        ? X1226_EEPROM_PAGE_SIZE : remaining;
+
+		dev_dbg(&client->dev, "copysize=%d\n", copysize);	
+
+		ret = x1226_read(client, buf, off, copysize);
+                if (ret < 0)
+                        return ret;
+
+		off += copysize;
+		buf += copysize;
+		remaining -= copysize;
+	} while (remaining > 0);
+
+	return count;
+}
+
+
+static ssize_t x1226_eeprom_write(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+	int remaining, copysize;
+        int ret;
+
+	if (off > X1226_EEPROM_SIZE)
+                return 0;
+	if (off + count > X1226_EEPROM_SIZE)
+		count = X1226_EEPROM_SIZE - off;
+
+        ret = eeprom_write_enable(client);
+        if (ret < 0)
+                return ret;
+
+	/* Write regeon should be aligned */
+	copysize = (count > X1226_EEPROM_PAGE_SIZE)
+                ? X1226_EEPROM_PAGE_SIZE : count;
+	if ((off / X1226_EEPROM_PAGE_SIZE) != ((off + copysize) / X1226_EEPROM_PAGE_SIZE))
+		copysize = X1226_EEPROM_PAGE_SIZE - (off % X1226_EEPROM_PAGE_SIZE);
+
+	dev_dbg(&client->dev, "offset=%lli\n", off);
+	remaining = count;
+
+	do {
+		dev_dbg(&client->dev, "copysize=%d\n", copysize);
+
+		ret = x1226_write_wait(client, buf, off, copysize);
+                if (ret < 0)
+                        return ret;
+
+		off += copysize;
+		buf += copysize;
+		remaining -= copysize;
+
+		copysize = (remaining > X1226_EEPROM_PAGE_SIZE)
+                        ? X1226_EEPROM_PAGE_SIZE : remaining;
+	} while (remaining > 0);
+
+        ret = eeprom_write_disable(client);
+        if (ret < 0)
+                return ret;
+
+	return count;
+}
+
+
+static struct bin_attribute eeprom_attr = {
+	attr:   {
+		name:   "eeprom",
+		mode:   S_IWUSR|S_IRUGO,
+		owner:  THIS_MODULE,
+	},
+	size:   X1226_EEPROM_SIZE,
+	read:   x1226_eeprom_read,
+        write:  x1226_eeprom_write,
+};
+
+
+/*
+ * Block Protect area - maps string to number
+ */
+static char *bp_areas[] = {
+	[BP_0_0]	= "0-0",
+        [BP_0_63]       = "0-63",
+        [BP_0_127]      = "0-127",
+        [BP_0_255]      = "0-255",
+        [BP_0_511]      = "0-511",
+        [BP_256_511]    = "256-511",
+        [BP_384_511]    = "384-511",
+	NULL,
+};
+
+
+/*
+ * maps number to BL reg content
+ */
+static const u8 bp_area2bl_reg[] = {
+	[BP_0_0]	=                                      0,       /* none          */
+        [BP_384_511]    =                           X1226_BL_BP0,       /* upper 1/4     */
+        [BP_256_511]    =              X1226_BL_BP1             ,       /* upper 1/2     */
+        [BP_0_511]      =              X1226_BL_BP1|X1226_BL_BP0,       /* full array    */
+        [BP_0_63]       = X1226_BL_BP2                          ,       /* first page    */
+        [BP_0_127]      = X1226_BL_BP2             |X1226_BL_BP0,       /* first 2 pages */
+        [BP_0_255]      = X1226_BL_BP2|X1226_BL_BP1             ,       /* first 4 pages */
+};
+
+
+static ssize_t set_protected_area(struct device *dev, const char *buf, size_t n)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct x1226_eeprom_data *data = i2c_get_clientdata(client);
+	u32 area = BP_0_0;              /* first area to be tryed to match */
+	char **s;
+	char *p;
+	int ret;
+	int len;
+
+	p = memchr(buf, '\n', n);
+	len = p ? p - buf : n;
+
+	for (s = &bp_areas[area]; *s; s++, area++) {
+		if (!strncmp(buf, *s, len))
+			break;
+	}
+	if (*s) {
+                int bl = bp_area2bl_reg[area];
+		ret = data->rtc->driver->command(data->rtc, SET_BLOCKPROTECT, (void *)bl);
+        } else
+		ret = -EINVAL;
+
+	return ret ? ret : n;
+}
+
+
+static ssize_t show_protected_area(struct device *dev, char *buf)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct x1226_eeprom_data *data = i2c_get_clientdata(client);
+        int ret;
+        int area;
+        u8 bl;
+
+        if ((ret = data->rtc->driver->command(data->rtc, GET_BLOCKPROTECT, &bl)))
+                return ret;
+
+        for (area = 0; area < ARRAY_SIZE(bp_area2bl_reg); area++) {
+                if (bp_area2bl_reg[area] == bl)
+                        return sprintf(buf, "%s\n", bp_areas[area]);
+        }
+
+        return sprintf(buf, "unknown - sorry\n");
+}
+
+
+static ssize_t show_areas(struct device *dev, char *buf)
+{
+        int i;
+        char *s = buf;
+
+        for (i = 0; i < BP_MAX; i++) {
+		if (bp_areas[i])
+                        s += sprintf(s,"%s ", bp_areas[i]);
+        }
+
+	s += sprintf(s,"\n");
+	return (s - buf);
+}
+
+
+static DEVICE_ATTR(protected_area, S_IWUSR|S_IRUGO, show_protected_area, set_protected_area);
+static DEVICE_ATTR(areas, S_IRUGO, show_areas, NULL);
+
+
+static int x1226_eeprom_attach_adapter(struct i2c_adapter *adapter)
+{
+        return i2c_detect(adapter, &addr_data, x1226_eeprom_detect);
+}
+
+
+/* This function is called by i2c_detect */
+int x1226_eeprom_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct x1226_eeprom_data *data;
+	int err = 0;
+
+	/* Make sure we aren't probing the ISA bus!! This is just a safety check
+	   at this moment; i2c_detect really won't call us. */
+#ifdef DEBUG
+	if (i2c_is_isa_adapter(adapter)) {
+		dev_dbg(&adapter->dev, "eeprom_detect called for an ISA bus adapter?!?\n");
+		return 0;
+	}
+#endif
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		goto exit;
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	   client structure, even though we cannot fill it completely yet.
+	   But it allows us to access eeprom_{read,write}_value. */
+	if (!(data = kmalloc(sizeof(struct x1226_eeprom_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	memset(data, 0, sizeof(struct x1226_eeprom_data));
+
+	this_client = new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &x1226_eeprom_driver;
+	new_client->flags = 0;
+
+	/* prevent 24RF08 corruption */
+	i2c_smbus_write_quick(new_client, 0);
+
+	/* Fill in the remaining client fields */
+	strncpy(new_client->name, "XICOR X1226 (eeprom part)", I2C_NAME_SIZE);
+	new_client->id = x1226_eeprom_id++;
+
+	/* Tell the I2C layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto exit_kfree;
+
+	/* create the sysfs eeprom file */
+	if ((err = sysfs_create_bin_file(&new_client->dev.kobj, &eeprom_attr)))
+                goto exit_detach_client;
+
+        if ((err = device_create_file(&new_client->dev, &dev_attr_protected_area)))
+                goto exit_remove_bin_file;
+
+        if ((err = device_create_file(&new_client->dev, &dev_attr_areas)))
+                goto exit_remove_file_protected_area;
+
+	return 0;
+
+/*  exit_remove_file_protected_area: */
+/*         device_remove_file(&new_client->dev, &dev_attr_areas); */
+ exit_remove_file_protected_area:
+        device_remove_file(&new_client->dev, &dev_attr_protected_area);
+ exit_remove_bin_file:
+        sysfs_remove_bin_file(&new_client->dev.kobj, &eeprom_attr);
+ exit_detach_client:
+        i2c_detach_client(new_client);
+ exit_kfree:
+	kfree(data);
+ exit:
+	return err;
+}
+
+
+static int x1226_eeprom_detach_client(struct i2c_client *client)
+{
+	int ret;
+
+	ret = i2c_detach_client(client);
+	if (ret) {
+		dev_err(&client->dev, "Client deregistration failed, client not detached.\n");
+		return ret;
+	}
+
+	kfree(i2c_get_clientdata(client));
+
+	return 0;
+}
+
+
+static int x1226_use_rtc(void)
+{
+        struct x1226_eeprom_data *data;
+        struct list_head *item;
+	struct i2c_client *adapter_client;
+        int ret;
+
+        data = i2c_get_clientdata(this_client);
+
+        if (request_module("x1226-rtc") < 0) {
+                dev_err(&this_client->dev, "x1226-rtc module not available.\n");
+                ret = -ENODEV;
+                goto exit;
+        }
+
+        list_for_each(item, &this_client->adapter->clients) {
+                adapter_client = list_entry(item, struct i2c_client, list);
+                if (DEVID_X1226_RTC == adapter_client->addr)
+                        data->rtc = adapter_client;
+        }
+
+        if (!data->rtc) {
+                dev_err(&this_client->dev, "did not find x1226-rtc i2c device, aborting.\n");
+                ret = -ENODEV;
+                goto exit;
+        }
+
+        ret = i2c_use_client(data->rtc);
+        if (ret < 0) {
+                dev_err(&this_client->dev, "x1226-rtc in use, aborting.\n");
+                goto exit;
+        }
+
+        return 0;
+
+ exit:
+        return ret;
+}
+
+
+static int x1226_release_rtc(void)
+{
+        struct x1226_eeprom_data *data = i2c_get_clientdata(this_client);
+        int ret;
+
+        ret = i2c_release_client(data->rtc);
+        if (ret < 0) {
+                dev_dbg(&this_client->dev, "releasing of x1226-rtc failed.\n");
+                return ret;
+        }
+
+        return 0;
+}
+
+static int __init x1226_eeprom_init(void)
+{
+        int ret;
+      
+        ret = i2c_add_driver(&x1226_eeprom_driver);
+        if (ret < 0)
+                goto exit;
+        if (this_client == NULL)
+                return -ENODEV;
+
+        ret = x1226_use_rtc();
+        if (ret < 0)
+                goto exit_del_driver;
+
+        return 0;
+
+ exit_del_driver:
+        i2c_del_driver(&x1226_eeprom_driver);
+ exit:
+        return ret;
+}
+
+
+static void __exit x1226_eeprom_exit(void)
+{       
+        int ret;
+        
+        ret = x1226_release_rtc();
+        if (ret) {
+                dev_err(&this_client->dev, "releasing of x1226-rtc failed.\n");
+        }
+
+	i2c_del_driver(&x1226_eeprom_driver);
+}
+
+
+MODULE_AUTHOR("Marc Kleine-Budde <marc.kleine-budde@pengutronix.de>");
+MODULE_DESCRIPTION("I2C EEPROM driver");
+MODULE_LICENSE("GPL");
+
+module_init(x1226_eeprom_init);
+module_exit(x1226_eeprom_exit);
Index: drivers/i2c/chips/x1226-rtc.c
===================================================================
--- a/drivers/i2c/chips/x1226-rtc.c	(revision 0)
+++ b/drivers/i2c/chips/x1226-rtc.c	(revision 675)
@@ -0,0 +1,715 @@
+/*
+ * x1226-rtc.c
+ *
+ * Copyright (C) 2004       GE Energy - PII Pipetronix GmbH - Karlsruhe - Germany
+ *                          Author: Norbert Teulings
+ * Copyright (C) 2004, 2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *
+ * based on:
+ * - linux-2.6.0-test10-obs266/drivers/char/x1226-rtc.c
+ *   I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *   Copyright 2002 MontaVista Software Inc.
+ *   Author: MontaVista Software, Inc.
+ *           stevel@mvista.com or source@mvista.com
+ * - linux-2.6.9-rc2/drivers/char/ds1286.c
+ *   DS1286 Real Time Clock interface for Linux
+ *   Copyright (C) 1998, 1999, 2000 Ralf Baechle
+ *   Based on code written by Paul Gortmaker.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/bcd.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include "x1226.h"
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = { DEVID_X1226_RTC, I2C_CLIENT_END };
+static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
+
+/* Insmod parameters */
+SENSORS_INSMOD_0;
+
+/* Each client has this additional data */
+struct x1226_rtc_data {
+	struct i2c_client client;
+};
+
+#define X1226_MODULE_NAME               "x1226-rtc"
+#define PFX                             X1226_MODULE_NAME
+
+#define err(format, arg...)             printk(KERN_ERR     PFX ": " format , ## arg)
+#define info(format, arg...)            printk(KERN_INFO    PFX ": " format , ## arg)
+#define warn(format, arg...)            printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...)           printk(KERN_EMERG   PFX ": " format , ## arg)
+#define dbg(format, arg...)             printk(KERN_DEBUG   PFX ": " format , ## arg)
+
+#define EPOCH                           2000
+#define SYS_EPOCH                       1900
+
+/* This is an image of the RTC registers starting at offset 0x30 */
+struct rtc_registers {
+	unsigned char secs;             /* 30 */
+        unsigned char mins;             /* 31 */
+        unsigned char hours;            /* 32 */
+        unsigned char day;              /* 33 */
+        unsigned char mon;              /* 34 */
+        unsigned char year;             /* 35 */
+        unsigned char dayofweek;        /* 36 */
+        unsigned char epoch;            /* 37 */
+};
+
+static struct i2c_driver x1226_rtc_driver;
+
+static struct i2c_client *this_client = NULL;
+
+static spinlock_t x1226_rtc_lock = SPIN_LOCK_UNLOCKED;
+
+static const unsigned char days_in_mo[] = 
+{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+/*
+ *	Bits in x1226_rtc_status. (7 bits of room for future expansion)
+ */
+#define X1226_RTC_IS_OPEN		0x01	/* means /dev/rtc is in use */
+
+static unsigned char x1226_rtc_status;	        /* bitmapped status byte */
+
+static int x1226_rtc_id = 0;
+
+static int x1226_rtc_read_proc(char *page, char **start, off_t off,
+                               int count, int *eof, void *data);
+
+
+static int x1226_read (struct i2c_client *client,
+                       u8* buf, int len, u16 off)
+{
+        int ret;
+	u8 regbuf[2] = { (off >> 8) & 0xff, off & 0xff };
+
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			0,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if len>1,
+			   "Current Address Read" if len=1 */
+			client->addr ,
+			I2C_M_RD,
+			len,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+        return ret;
+}
+
+
+static int __x1226_write (struct i2c_client *client,
+                          u8* buf, int len, u16 off)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { (off >> 8) & 0xff, off & 0xff };
+
+	struct i2c_msg page_write = {
+		client->addr,
+		0,
+		len + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(len + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		dev_err(&client->dev, "buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, len);
+	page_write.buf = local_buf;
+
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+
+	return ret;
+}
+
+
+/*
+ * write to nonvolatile mem region (eprom, eg.) and wait
+ */
+static int x1226_write_wait(struct i2c_client *client,
+                            u8* buf, int len, u16 off)
+{
+        int ret;
+        
+        ret = __x1226_write(client, buf, len, off);
+        if (ret < 0)
+                return ret;
+
+        /* wait for device to flush it's write buffers */
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(X1226_WRITE_WAIT);
+        
+        return ret;
+}
+
+
+/*
+ * write to volatile mem region (config regs) no waiting needed
+ */
+static inline int x1226_write_nowait(struct i2c_client *client,
+                                     u8* buf, int len, u16 off)
+{
+        return __x1226_write(client, buf, len, off);
+}
+
+
+static int ccr_write_enable(struct i2c_client *client);
+static int ccr_write_disable(struct i2c_client *client);
+
+#define READ_REG(__reg, addr)                                           \
+static inline int read_reg_##__reg(struct i2c_client *client, u8 *value)\
+{                                                                       \
+        int ret;                                                        \
+                                                                        \
+        if ((ret = x1226_read(client, value, 1, addr)) < 0)             \
+                return ret;                                             \
+        else                                                            \
+                return 0;                                               \
+}
+
+#define WRITE_REG_V(__reg, addr)                                        \
+static inline int write_reg_##__reg(struct i2c_client *client, u8 value)\
+{                                                                       \
+        int ret;                                                        \
+                                                                        \
+        if ((ret = x1226_write_nowait(client, &value, 1, addr)) < 0)    \
+                return ret;                                             \
+        else                                                            \
+                return 0;                                               \
+}
+
+#define WRITE_REG_NV(__reg, addr)                                       \
+static inline int write_reg_##__reg(struct i2c_client *client, u8 value)\
+{                                                                       \
+        int ret;                                                        \
+                                                                        \
+	if ((ret = ccr_write_enable(client)) < 0)                       \
+		return ret;                                             \
+        if ((ret = x1226_write_wait(client, &value, 1, addr)) < 0)      \
+                return ret;                                             \
+	if ((ret = ccr_write_disable(client)) < 0)                      \
+                return ret;                                             \
+                                                                        \
+        return 0;                                                       \
+}
+
+
+WRITE_REG_V(sr, X1226_STATUS);
+READ_REG(sr, X1226_STATUS);
+
+WRITE_REG_NV(bl, X1226_CONTROL_BL);
+READ_REG(bl, X1226_CONTROL_BL);
+
+
+static int ccr_write_enable(struct i2c_client *client)
+{
+	int ret;
+        u8 sr;
+
+	sr = X1226_FLAG_WEL;
+	if ((ret = write_reg_sr(client, sr)) < 0)
+		return ret;
+	sr |= X1226_FLAG_RWEL;
+	if ((ret = write_reg_sr(client, sr)) < 0)
+		return ret;
+	sr = 0;
+	if ((ret = read_reg_sr(client, &sr)) < 0)
+		return ret;
+
+	sr &= (X1226_FLAG_RWEL | X1226_FLAG_RWEL);
+	if (sr != (X1226_FLAG_RWEL | X1226_FLAG_RWEL)) {
+		dev_dbg(&client->dev, "verify SR failed\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+
+static int ccr_write_disable(struct i2c_client *client)
+{
+	int ret;
+	u8 sr;
+	
+        sr = 0;
+	if ((ret = write_reg_sr(client, sr)) < 0)
+		return ret;
+	if ((ret = read_reg_sr(client, &sr) < 0))
+		return ret;
+	if (sr != 0) {
+		dev_dbg(&client->dev, "verify SR failed\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+
+static int x1226_rtc_get_time(struct i2c_client *client, struct rtc_time *tm)
+{	
+	struct rtc_registers rtc;
+	u32 epoch;
+	int ret;
+	
+	/* read RTC registers */
+	if ((ret = x1226_read(client, (u8*)&rtc, sizeof(struct rtc_registers), X1226_RTC_BASE)) < 0) {
+		dev_dbg(&client->dev, "couldn't read RTC\n");
+		return ret;
+	}
+
+	dev_dbg(&client->dev, "IN: epoch=%02x, year=%02x, mon=%02x, day=%02x, hour=%02x, min=%02x, sec=%02x\n",
+                rtc.epoch, rtc.year, rtc.mon, rtc.day, rtc.hours, rtc.mins, rtc.secs);
+
+	epoch        = 100 * BCD2BIN(rtc.epoch);        /* 19 / 20 */
+	tm->tm_year  = BCD2BIN(rtc.year);               /* 0 - 99 */
+	tm->tm_year += (epoch - SYS_EPOCH);
+	tm->tm_mon   = BCD2BIN(rtc.mon);                /* 1 - 12 */
+	tm->tm_mon--;                                   /* tm_mon is 0 to 11 */
+	tm->tm_mday  = BCD2BIN(rtc.day);                /* 1 - 31 */
+	tm->tm_hour  = BCD2BIN(rtc.hours & ~(1<<7));    /* 24h format */
+
+	if (!(rtc.hours & (1<<7))) {                    /* AM/PM 1-12 format, convert to MIL */
+                tm->tm_hour--;                          /* 0 - 11 */
+		if (rtc.hours & (1<<5))
+			tm->tm_hour += 12;              /* PM */
+	}
+	
+	tm->tm_min = BCD2BIN(rtc.mins);
+	tm->tm_sec = BCD2BIN(rtc.secs);
+
+	dev_dbg(&client->dev, "OUT: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+                tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+	
+	return 0;
+}
+
+
+static int x1226_rtc_set_time(struct i2c_client *client, const struct rtc_time *tm)
+{
+	struct rtc_registers rtc;
+        unsigned char mon, day, hrs, min, sec, leap_yr;
+        unsigned int yrs;
+	int ret;
+
+	dev_dbg(&client->dev, "IN: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+                tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+        yrs = tm->tm_year + SYS_EPOCH;
+        mon = tm->tm_mon + 1;                           /* tm_mon starts at zero */
+        day = tm->tm_mday;
+        hrs = tm->tm_hour;
+        min = tm->tm_min;
+        sec = tm->tm_sec;
+
+        if (yrs < 1970)
+                return -EINVAL;
+
+        leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+        
+        if ((mon > 12) || (day == 0))
+                return -EINVAL;
+
+        if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))
+                return -EINVAL;
+
+        if ((hrs >= 24) || (min >= 60) || (sec >= 60))
+                return -EINVAL;
+
+        if ((yrs -= SYS_EPOCH) > 255)                   /* They are unsigned */
+                return -EINVAL;
+
+	rtc.epoch     = BIN2BCD((tm->tm_year + SYS_EPOCH) / 100);
+	rtc.year      = BIN2BCD(tm->tm_year + SYS_EPOCH - EPOCH);
+	rtc.mon       = BIN2BCD(tm->tm_mon + 1);        /* tm_mon is 0 to 11 */
+	rtc.day       = BIN2BCD(tm->tm_mday);
+	rtc.dayofweek = 0;                              /* ignore day of week */
+	rtc.hours     = BIN2BCD(tm->tm_hour) | (1<<7);  /* 24 hour format */
+	rtc.mins      = BIN2BCD(tm->tm_min);
+	rtc.secs      = BIN2BCD(tm->tm_sec);
+	
+	dev_dbg(&client->dev, "OUT: epoch=%02x, year=%02x, mon=%02x, day=%02x, hour=%02x, min=%02x, sec=%02x\n",
+                rtc.epoch, rtc.year, rtc.mon, rtc.day, rtc.hours, rtc.mins, rtc.secs);
+	
+	/* write RTC registers */
+	if ((ret = ccr_write_enable(client)) < 0)
+		return ret;
+	if ((ret = x1226_write_nowait(client, (u8*)&rtc, sizeof(struct rtc_registers), X1226_RTC_BASE)) < 0) {
+		dev_dbg(&client->dev, "couldn't write RTC\n");
+		return ret;
+	}
+	ccr_write_disable(client);
+
+	return 0;
+}
+
+
+static int x1226_rtc_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct rtc_time dummy_tm = { 0, 0, 0, 1, 0, 100, 0, 0 };
+	struct i2c_client *new_client;
+	struct x1226_rtc_data *data;
+	int err = 0;
+        char stat;
+
+	/* Make sure we aren't probing the ISA bus!! This is just a safety check
+	   at this moment; i2c_detect really won't call us. */
+#ifdef DEBUG
+	if (i2c_is_isa_adapter(adapter)) {
+		dev_dbg(&adapter->dev, "rtc_detect called for an ISA bus adapter?!?\n");
+		return 0;
+	}
+#endif
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+                goto exit;
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	   client structure, even though we cannot fill it completely yet.
+	   But it allows us to access eeprom_{read,write}_value. */
+	if (!(data = kmalloc(sizeof(struct x1226_rtc_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	memset(data, 0, sizeof(struct x1226_rtc_data));
+	this_client = new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &x1226_rtc_driver;
+	new_client->flags = I2C_CLIENT_ALLOW_USE;
+
+	/* Fill in the remaining client fields */
+	strncpy(new_client->name, "XICOR X1226 (rtc part)", I2C_NAME_SIZE);
+	new_client->id = x1226_rtc_id++;
+
+        if ((err = x1226_read(new_client, &stat, 1, X1226_STATUS_BASE)) < 0) {
+                dev_err(&adapter->dev, "Status register read failed, chip not detected\n");
+                goto exit_kfree;
+        }
+        dev_info(&adapter->dev, "Found X1226 RTC on %s\n", new_client->adapter->name);
+
+        if (stat & X1226_FLAG_RTCF) {
+                info( "Timer not initialized after power fail. Setting 2002/1/1/0:00\n");
+                err = x1226_rtc_set_time(new_client, &dummy_tm);
+	}
+
+#ifdef DEBUG
+        {
+                unsigned char crs[4];
+
+                dev_dbg(&adapter->dev, "stat %x\n", stat);
+                x1226_read(new_client, crs, 4, X1226_CONTROL_BASE);
+                dev_dbg(&adapter->dev, "CTLREG: %d %x %x %x %x\n", err, crs[0],crs[1],crs[2],crs[3]);
+        }
+#endif
+
+	if ((err = x1226_rtc_get_time(new_client, &dummy_tm)) < 0) {
+                dev_dbg(&adapter->dev, "Fetch Timer Failed\n");
+
+	} else {
+#ifdef DEBUG
+                struct rtc_time *tm = &dummy_tm;
+                dev_dbg(&adapter->dev, "OUT: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+                        tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
+#endif
+	}
+
+	/* Tell the I2C layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto exit_kfree;
+
+	return 0;
+
+/*  exit_detach_client: */
+/*         i2c_detach_client(new_client); */
+ exit_kfree:
+        kfree(new_client);
+ exit:
+	return err;
+}
+
+
+static int x1226_rtc_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_detect(adapter, &addr_data, x1226_rtc_detect);
+}
+
+
+static int x1226_rtc_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	err = i2c_detach_client(client);
+	if (err) {
+		dev_err(&client->dev, "Client deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	kfree(i2c_get_clientdata(client));
+
+	return 0;
+}
+
+
+static int x1226_rtc_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+        switch (cmd) {
+        case EEPROM_RW:
+                return ccr_write_enable(client);
+
+        case EEPROM_RO:
+                return ccr_write_disable(client);
+
+        case GET_BLOCKPROTECT:
+                return read_reg_bl(client, (u8 *)arg);
+
+        case SET_BLOCKPROTECT:
+                return write_reg_bl(client, (u8)((int)arg & 0xff));
+
+        default:
+                return -EINVAL;
+        }
+}
+
+
+static ssize_t x1226_rtc_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	return -EIO;
+}
+
+
+static int x1226_rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct rtc_time wtime;
+
+	switch (cmd) {
+	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
+	{
+		memset(&wtime, 0, sizeof(wtime));
+		x1226_rtc_get_time(this_client, &wtime);
+		break;
+	}
+	case RTC_SET_TIME:	/* Set the RTC */
+	{
+		struct rtc_time rtc_tm;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg,
+				   sizeof(struct rtc_time)))
+			return -EFAULT;
+
+		return x1226_rtc_set_time(this_client, &rtc_tm);
+                break;
+	}
+	default:
+		return -EINVAL;
+	}
+	return copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+}
+
+
+int x1226_rtc_open(struct inode *minode, struct file *mfile)
+{
+	spin_lock_irq (&x1226_rtc_lock);
+
+	if(x1226_rtc_status & X1226_RTC_IS_OPEN)
+		goto out_busy;
+
+	x1226_rtc_status |= X1226_RTC_IS_OPEN;
+
+	spin_unlock_irq (&x1226_rtc_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&x1226_rtc_lock);
+	return -EBUSY;
+}
+
+
+int x1226_rtc_release(struct inode *minode, struct file *mfile)
+{
+	spin_lock_irq (&x1226_rtc_lock);
+	x1226_rtc_status &= ~X1226_RTC_IS_OPEN;
+	spin_unlock_irq (&x1226_rtc_lock);
+	return 0;
+}
+
+
+static struct i2c_driver x1226_rtc_driver = {
+	name:		X1226_RTC_MODULE_NAME,
+	id:		I2C_DRIVERID_X1226_RTC,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	x1226_rtc_attach_adapter,
+	detach_client:	x1226_rtc_detach_client,
+ 	command:	x1226_rtc_command,
+};
+
+
+static struct file_operations x1226_rtc_fops = {
+	llseek:	        no_llseek,
+        read:           x1226_rtc_read,
+        ioctl:		x1226_rtc_ioctl,
+	open:		x1226_rtc_open,
+	release:	x1226_rtc_release,
+};
+
+static struct miscdevice x1226_rtc_miscdev = {
+	minor:          RTC_MINOR,
+	name:           "rtc",
+	fops:           &x1226_rtc_fops,
+};
+
+
+/*
+ *	Info exported via "/proc/driver/rtc".
+ */
+static int rtc_proc_output(char *buf)
+{
+	char *p;
+	struct rtc_time tm;
+	int ret;
+	
+	if ((ret = x1226_rtc_get_time(this_client, &tm)) < 0)
+		return ret;
+
+	p = buf;
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p,
+		     "rtc_time\t: %02d:%02d:%02d\n"
+		     "rtc_date\t: %04d-%02d-%02d\n"
+		     "rtc_epoch\t: %04d\n",
+		     tm.tm_hour, tm.tm_min, tm.tm_sec,
+		     tm.tm_year + SYS_EPOCH, tm.tm_mon + 1,
+		     tm.tm_mday, EPOCH);
+
+	return p - buf;
+}
+
+
+static int x1226_rtc_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len = rtc_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+
+static __init int x1226_rtc_init(void)
+{
+	int ret;
+
+	info("I2C based RTC driver.\n");
+	ret = i2c_add_driver(&x1226_rtc_driver);
+	if (ret) {
+		err("Register I2C driver failed.\n");
+                goto exit;
+        }
+
+	ret = misc_register(&x1226_rtc_miscdev);
+	if (ret) {
+		err("Register misc driver failed.\n");
+                goto exit_i2c_del_driver;
+	}
+
+	
+        if (!create_proc_read_entry("driver/rtc", 0, NULL, x1226_rtc_read_proc, NULL)) {
+                ret = -ENOMEM;
+                err("Register proc entry failed.\n");
+                goto exit_misc_deregister;
+        }
+
+        return 0;
+
+ exit_misc_deregister:
+        misc_deregister(&x1226_rtc_miscdev);
+
+ exit_i2c_del_driver:
+        i2c_del_driver(&x1226_rtc_driver);
+
+ exit:
+        return ret;
+}
+
+static void __exit x1226_rtc_exit(void)
+{
+        remove_proc_entry("driver/rtc", NULL);
+        misc_deregister(&x1226_rtc_miscdev);
+	i2c_del_driver(&x1226_rtc_driver);
+}
+
+module_init(x1226_rtc_init);
+module_exit(x1226_rtc_exit);
+
+MODULE_AUTHOR("Marc Kleine-Budde <marc.kleine-budde@pengutronix.de>");
+MODULE_LICENSE("GPL");
+
Index: drivers/i2c/chips/Makefile
===================================================================
--- a/drivers/i2c/chips/Makefile	(.../vanilla/linux-2.6.11)	(revision 675)
+++ b/drivers/i2c/chips/Makefile	(.../linux-pxa/releases/linux-2.6.11-pxa2)	(revision 675)
@@ -35,6 +35,9 @@
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l785ts.o
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
+obj-$(CONFIG_SENSOR_X1226_RTC)	+= x1226-rtc.o
+obj-$(CONFIG_SENSOR_X1226_EEPROM)+= x1226-eeprom.o
+obj-$(CONFIG_SENSOR_ST24CXX)	+= st24cxx.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
Index: drivers/i2c/chips/st24cxx.c
===================================================================
--- a/drivers/i2c/chips/st24cxx.c	(revision 0)
+++ b/drivers/i2c/chips/st24cxx.c	(revision 675)
@@ -0,0 +1,496 @@
+/*
+ * 24cxx.c
+ *
+ * Copyright (C) 2004       GE Energy - PII Pipetronix GmbH - Karlsruhe - Germany
+ *                          Author: Norbert Teulings
+ * Copyright (C) 2004, 2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ *
+ * based on:
+ * - linux-2.6.9-rc2/drivers/i2c/chips/eeprom.c
+ *   Part of lm_sensors, Linux kernel modules for hardware monitoring
+ *   Copyright (C) 1998, 1999 Frodo Looijaard <frodol@dds.nl> and
+ *	                      Philip Edelbrock <phil@netroedge.com>
+ *   Copyright (C) 2003       Greg Kroah-Hartman <greg@kroah.com>
+ *   Copyright (C) 2003       IBM Corp.
+ * - linux-2.6.0-test10-obs266/drivers/char/eepromi2c.c
+ *   Copyright 
+ *   Author: 2002 AXE Inc.  
+ *     takawata@axe-inc.co.jp
+ *   Based On 
+ *     linux/drivers/char/x1226-rtc.c
+ *
+ *     I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *
+ *     Copyright 2002 MontaVista Software Inc.
+ *     Author: MontaVista Software, Inc.
+ *       stevel@mvista.com or source@mvista.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+
+#include "st24cxx.h"
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
+
+/* Insmod parameters */
+SENSORS_INSMOD_1(st24c02);
+
+/* Each client has this additional data */
+struct st24cxx_eeprom_data {
+        int size;
+        int page_size;
+        int page_size_shift;
+        int (*read) (struct i2c_client *client, u8 *buf, int off, int count);
+        int (*write) (struct i2c_client *client, u8 *buf, int off, int count);
+	struct i2c_client client;
+        struct bin_attribute bin_attr;
+};
+
+struct st24cxx_eeprom_conf {
+        int size;
+        int page_size_shift;
+        char *name;
+};
+
+static const struct st24cxx_eeprom_conf eeprom_conf[] = {
+        [st24c02]       = {.size = 256,         .page_size_shift = 3,   .name = "24c02 eeprom" },
+};
+
+
+static int st24cxx_eeprom_attach_adapter(struct i2c_adapter *adapter);
+static int st24cxx_eeprom_detect(struct i2c_adapter *adapter, int address, int kind);
+static int st24cxx_eeprom_detach_client(struct i2c_client *client);
+
+/* This is the driver that will be inserted */
+static struct i2c_driver st24cxx_eeprom_driver = {
+	.owner		= THIS_MODULE,
+	.name		= ST24CXX_EEPROM_MODULE_NAME,
+	.id		= I2C_DRIVERID_ST24CXX_EEPROM,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= st24cxx_eeprom_attach_adapter,
+	.detach_client	= st24cxx_eeprom_detach_client,
+};
+
+static int st24cxx_eeprom_id = 0;
+
+
+static int st24cxx_read_16(struct i2c_client *client,
+                         u8 *buf, int off, int count)
+{
+        int ret;
+	u8 regbuf[2] = { (off >> 8) & 0xff, off & 0xff};
+
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			0,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if count>1,
+			   "Current Address Read" if count=1 */
+			client->addr ,
+			I2C_M_RD,
+			count,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+        return ret;
+}
+
+
+static inline int __st24cxx_write_16(struct i2c_client *client,
+                                   u8 *buf, int off, int count)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { (off >> 8) & 0xff, off & 0xff};
+
+	struct i2c_msg page_write = {
+		client->addr,
+		0,
+		count + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(count + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		dev_err(&client->dev, "buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, count);
+	page_write.buf = local_buf;
+
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+
+	return ret;
+}
+
+
+/*
+ * write to nonvolatile mem region (eprom, eg.) and wait
+ */
+static int st24cxx_write_16(struct i2c_client *client,
+                          u8 *buf, int off, int count)
+{
+        int ret;
+        
+        ret = __st24cxx_write_16(client, buf, off, count);
+        if (ret < 0)
+                return ret;
+
+        /* wait for device to flush it's write buffers */
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(ST24CXX_WRITE_WAIT);
+        
+        return ret;
+}
+
+
+static int st24cxx_read_8(struct i2c_client *client,
+                        u8 *buf, int off, int count)
+{
+        int ret;
+	u8 regbuf[1] = {off & 0xff};
+
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			0,
+			sizeof(regbuf),
+			regbuf
+                },
+		{
+			/* "Sequential Read" if count>1,
+			   "Current Address Read" if count=1 */
+			client->addr ,
+			I2C_M_RD,
+			count,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+        return ret;
+}
+
+
+static inline int __st24cxx_write_8(struct i2c_client *client,
+                                  u8 *buf, int off, int count)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[1] = {off & 0xff};
+
+	struct i2c_msg page_write = {
+		client->addr,
+		0,
+		count + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(count + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		dev_err(&client->dev, "buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, count);
+	page_write.buf = local_buf;
+
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dev_dbg(&client->dev, "i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+
+	return ret;
+}
+
+
+/*
+ * write to nonvolatile mem region (eprom, eg.) and wait
+ */
+static int st24cxx_write_8(struct i2c_client *client,
+                         u8 *buf, int off, int count)
+{
+        int ret;
+        
+        ret = __st24cxx_write_8(client, buf, off, count);
+        if (ret < 0)
+                return ret;
+
+        /* wait for device to flush it's write buffers */
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(ST24CXX_WRITE_WAIT);
+        
+        return ret;
+}
+
+
+static ssize_t st24cxx_eeprom_read(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+        struct st24cxx_eeprom_data *data = i2c_get_clientdata(client);
+	int remaining, copysize;
+        int ret;
+
+	if (off > data->size)
+                return 0;
+	if (off + count > data->size)
+		count = data->size - off;
+
+	remaining = count;
+	do {
+		copysize = (remaining > data->page_size)
+                        ? data->page_size : remaining;
+
+		dev_dbg(&client->dev, "copysize=%d\n", copysize);	
+
+		ret = data->read(client, buf, off, copysize);
+                if (ret < 0)
+                        return ret;
+
+		off += copysize;
+		buf += copysize;
+		remaining -= copysize;
+	} while (remaining > 0);
+
+	return count;
+}
+
+
+static ssize_t st24cxx_eeprom_write(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+        struct st24cxx_eeprom_data *data = i2c_get_clientdata(client);
+	int remaining, copysize;
+        int ret;
+
+	if (off > data->size)
+                return 0;
+	if (off + count > data->size)
+		count = data->size - off;
+
+	/* Write regeon should be aligned */
+	copysize = (count > data->page_size)
+                ? data->page_size : count;
+	if ((off >> data->page_size_shift) != ((off + copysize) >> data->page_size_shift))
+		copysize = data->page_size - (off & (data->page_size - 1));
+
+	dev_dbg(&client->dev, "offset=%lli\n", off);
+	remaining = count;
+
+	do {
+		dev_dbg(&client->dev, "copysize=%d\n", copysize);
+
+		ret = data->write(client, buf, off, copysize);
+                if (ret < 0)
+                        return ret;
+
+		off += copysize;
+		buf += copysize;
+		remaining -= copysize;
+
+		copysize = (remaining > data->page_size)
+                        ? data->page_size : remaining;
+	} while (remaining > 0);
+
+	return count;
+}
+
+
+static int st24cxx_eeprom_attach_adapter(struct i2c_adapter *adapter)
+{
+        return i2c_detect(adapter, &addr_data, st24cxx_eeprom_detect);
+}
+
+
+/* This function is called by i2c_detect */
+int st24cxx_eeprom_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct st24cxx_eeprom_data *data;
+	int err = 0;
+
+	/* Make sure we aren't probing the ISA bus!! This is just a safety check
+	   at this moment; i2c_detect really won't call us. */
+#ifdef DEBUG
+	if (i2c_is_isa_adapter(adapter)) {
+		dev_dbg(&adapter->dev, "eeprom_detect called for an ISA bus adapter?!?\n");
+		return 0;
+	}
+#endif
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		goto exit;
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	   client structure, even though we cannot fill it completely yet.
+	   But it allows us to access eeprom_{read,write}_value. */
+	if (!(data = kmalloc(sizeof(struct st24cxx_eeprom_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	memset(data, 0, sizeof(struct st24cxx_eeprom_data));
+
+	new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &st24cxx_eeprom_driver;
+	new_client->flags = 0;
+
+	/* prevent 24RF08 corruption */
+	i2c_smbus_write_quick(new_client, 0);
+
+        switch (kind) {
+        case st24c02:
+                break;
+        default:
+                return -ENODEV;
+                break;
+        }
+
+	/* Fill in the remaining client fields */
+	strncpy(new_client->name, eeprom_conf[kind].name, I2C_NAME_SIZE);
+	new_client->id = st24cxx_eeprom_id++;
+        
+        /* Fill in the remaining data fields */
+        data->size = eeprom_conf[kind].size;
+        data->page_size = 1 << eeprom_conf[kind].page_size_shift;
+        data->page_size_shift = eeprom_conf[kind].page_size_shift;
+        
+        /* detect if we need 8 or 16 bit to address the eeprom offset */
+        if ((data->size - 1)>> 8) {  /* 16 bit */
+                data->read = st24cxx_read_16;
+                data->write = st24cxx_write_16;
+        } else {                /*  8 bit */
+                data->read = st24cxx_read_8;
+                data->write = st24cxx_write_8;
+        }
+
+        /* Fill in the bin_attribute structure */
+        {
+                struct bin_attribute *bin_attr = &data->bin_attr;
+                
+                bin_attr->attr.name = "eeprom";
+                bin_attr->attr.mode = S_IWUSR|S_IRUGO;
+                bin_attr->attr.owner = THIS_MODULE;
+
+                bin_attr->size = data->size;
+                bin_attr->read = st24cxx_eeprom_read;
+                bin_attr->write = st24cxx_eeprom_write;
+        }
+
+	/* Tell the I2C layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto exit_kfree;
+
+	/* create the sysfs eeprom file */
+	if ((err = sysfs_create_bin_file(&new_client->dev.kobj, &data->bin_attr)))
+                goto exit_detach_client;
+
+	return 0;
+
+/*  exit_remove_bin_file: */
+/*         sysfs_remove_bin_file(&new_client->dev.kobj, &eeprom_attr); */
+ exit_detach_client:
+        i2c_detach_client(new_client);
+ exit_kfree:
+	kfree(data);
+ exit:
+	return err;
+}
+
+
+static int st24cxx_eeprom_detach_client(struct i2c_client *client)
+{
+	int ret;
+
+	ret = i2c_detach_client(client);
+	if (ret) {
+		dev_err(&client->dev, "Client deregistration failed, client not detached.\n");
+		return ret;
+	}
+
+	kfree(i2c_get_clientdata(client));
+
+	return 0;
+}
+
+
+static int __init st24cxx_eeprom_init(void)
+{
+        int ret;
+      
+        ret = i2c_add_driver(&st24cxx_eeprom_driver);
+        if (ret < 0)
+                goto exit;
+
+        return 0;
+
+/*  exit_del_driver: */
+/*         i2c_del_driver(&st24cxx_eeprom_driver); */
+ exit:
+        return ret;
+}
+
+
+static void __exit st24cxx_eeprom_exit(void)
+{       
+	i2c_del_driver(&st24cxx_eeprom_driver);
+}
+
+
+MODULE_AUTHOR("Marc Kleine-Budde <marc.kleine-budde@pengutronix.de>");
+MODULE_DESCRIPTION("I2C EEPROM driver");
+MODULE_LICENSE("GPL");
+
+module_init(st24cxx_eeprom_init);
+module_exit(st24cxx_eeprom_exit);
Index: drivers/i2c/chips/st24cxx.h
===================================================================
--- a/drivers/i2c/chips/st24cxx.h	(revision 0)
+++ b/drivers/i2c/chips/st24cxx.h	(revision 675)
@@ -0,0 +1,9 @@
+#define I2C_DRIVERID_ST24CXX_EEPROM     I2C_DRIVERID_EXP2
+
+#define ST24CXX_WRITE_WAIT              (2*HZ/100)
+
+#define ST24CXX_EEPROM_MODULE_NAME      "24cxx-eeprom"
+
+/* ST24CXX Device Identifier */
+#define DEVID_ST24CXX_EEPROM_LOWER	0x50
+#define DEVID_ST24CXX_EEPROM_UPPER      0x57
Index: drivers/i2c/chips/x1226.h
===================================================================
--- a/drivers/i2c/chips/x1226.h	(revision 0)
+++ b/drivers/i2c/chips/x1226.h	(revision 675)
@@ -0,0 +1,65 @@
+#define I2C_DRIVERID_X1226_EEPROM       I2C_DRIVERID_EXP0
+#define I2C_DRIVERID_X1226_RTC          I2C_DRIVERID_EXP1
+
+#define X1226_WRITE_WAIT                (2*HZ/100)
+
+#define X1226_RTC_MODULE_NAME           "x1226-rtc"
+#define X1226_EEPROM_MODULE_NAME        "x1226-eeprom"
+
+#define X1226_EEPROM_SIZE               512
+#define X1226_EEPROM_PAGE_SIZE          64
+
+/* XICOR X1226 Device Identifier */
+#define DEVID_X1226_RTC			0x6F
+#define DEVID_X1226_EEPROM		0x57
+
+/* XICOR X1226 status flags */
+#define X1226_FLAG_RTCF                 (1<<0)
+#define X1226_FLAG_WEL                  (1<<1)
+#define X1226_FLAG_RWEL                 (1<<2)
+#define X1226_FLAG_AL0                  (1<<5)
+#define X1226_FLAG_AL1                  (1<<6)
+#define X1226_FLAG_BAT                  (1<<7)
+
+/* X1226 CCR regions */
+#define X1226_ALARM0_BASE		0x00
+#define X1226_ALARM1_BASE		0x08
+#define X1226_RTC_BASE			0x30
+#define X1226_STATUS_BASE		0x3F
+
+/* control and status registers */
+#define X1226_STATUS			X1226_STATUS_BASE
+
+#define X1226_CONTROL_BASE		(0x10)
+#define X1226_CONTROL_BL		(X1226_CONTROL_BASE + 0)
+#define X1226_CONTROL_INT		(X1226_CONTROL_BASE + 1)
+#define X1226_CONTROL_ATR		(X1226_CONTROL_BASE + 2)
+#define X1226_CONTROL_DTR		(X1226_CONTROL_BASE + 3)
+
+#define X1226_BL_BP0                    (1<<5)
+#define X1226_BL_BP1                    (1<<6)
+#define X1226_BL_BP2                    (1<<7)
+
+struct mem {
+        unsigned int    loc;
+        unsigned int    nr;
+        unsigned char   *data;
+};
+
+enum RTC_CMD {
+        EEPROM_RW,
+        EEPROM_RO,
+        GET_BLOCKPROTECT,
+        SET_BLOCKPROTECT,
+};
+
+enum BP_AREAS {
+        BP_0_0,
+        BP_0_63,
+        BP_0_127,
+        BP_0_255,
+        BP_0_511,
+        BP_256_511,
+        BP_384_511,
+        BP_MAX
+};
