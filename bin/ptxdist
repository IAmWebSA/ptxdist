#!/bin/bash

#
# TODO
#
# - split images out of Makefile; we should have a command "image jffs2"
#   which starts a corresponding script in scripts/
#
#

PROMPT="ptxdist: "
PTXDIST_WORKSPACE=`pwd`
DEBUG=

# export this, so that children can call the master script, for example
# to find out the version number
PTXDIST=$0

if [ -L "$PTXDIST" ]; then
	PTXDIST_TOPDIR=`readlink -f "$PTXDIST"`
else
	PTXDIST_TOPDIR=$PTXDIST
fi
PTXDIST_TOPDIR=`dirname "$PTXDIST_TOPDIR"`
PTXDIST_TOPDIR=`cd "$PTXDIST_TOPDIR"/.. && pwd`

export PTXDIST PTXDIST_WORKSPACE PTXDIST_TOPDIR


#
# sanity check: is PTXdist already configured?
#

if [ ! -e "${PTXDIST_TOPDIR}/.done" ]; then
	echo
	echo "${PROMPT}error: PTXdist in ${PTXDIST_TOPDIR} is not built."
	echo
	exit 1
fi

#
# we need the PTXdist shell library
# we need the version definitions
# we need the static variable definitions
#
for file in \
	scripts/ptxdist_vars.sh \
	scripts/ptxdist_version.sh \
	scripts/libptxdist.sh \
; do
	if [ -e "$PTXDIST_TOPDIR/$file" ]; then
		. "$PTXDIST_TOPDIR/$file"
	else
		echo "${PROMPT}didn't find ${PTXDIST_TOPDIR}/$file"
		exit 1
	fi
done

# source the user's .ptxdistrc
[ -e "$HOME/.ptxdistrc.${FULLVERSION}" ] && . "$HOME/.ptxdistrc.${FULLVERSION}"

# use linked toolchain if available
[ -d ".toolchain" ] && export PATH=${PTXDIST_WORKSPACE}/.toolchain:$PATH

# dir might not be available yet, but will be created later
prefix_host="`ptxd_get_ptxconf PTXCONF_HOST_PREFIX`"
if test -n "${prefix_host}"; then
	export PATH="${prefix_host}/bin:${prefix_host}/sbin:$PATH"
fi

#
# board setup
#
boardsetup() {
	local tmpdir

	echo
	echo "${PROMPT}boardsetup..."

	if [ ! -e "${PTXDIST_WORKSPACE}/boardsetup/Kconfig" ]; then
		echo "${PROMPT}error: boardsetup/boardsetup or boardsetup/Kconfig missing"
		echo
		exit 1
	fi

	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see it's original environment
	if [ -e "${PTXDIST_WORKSPACE}/boardsetup/boardsetup" ]; then
	    cp "${PTXDIST_WORKSPACE}/boardsetup/boardsetup" .config
	fi

	# store boardsetup
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${PTXDIST_WORKSPACE}/boardsetup/Kconfig"
	echo "${PROMPT}saving ${PTXDIST_WORKSPACE}/boardsetup/boardsetup"
	cp .config "${PTXDIST_WORKSPACE}/boardsetup/boardsetup"

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}

# check a ptxdist version against a configfile version.
#
# - The ptxdist major version has to be equal to the configfile major version
# - The ptxdist minor version has to be equal to the configfile minor version
# - The ptxdist micro version has to greater than or equal to the configfile
#   micro version
# - If the configfile has no minor or micro version stop here and assume
#   everything is ok (this means 'can build with 0.10.x or 0.x').
# - If the ptxdist minor or micro version is "svn" then no further checks are
#   done. You know what you are doing when you use svn, don't you?
#
check_version () {
	ptxdist="$1"
	config="$2"

	ptxdist_major=`echo $ptxdist | awk -F. '{print $1}'`
	config_major=`echo $config | awk -F. '{print $1}'`
	[ "$ptxdist_major" != "$config_major" ] && return 1

	ptxdist_minor=`echo $ptxdist | awk -F. '{print $2}'`
	config_minor=`echo $config | awk -F. '{print $2}'`
	[ -z "$config_minor" ] && return 0
	[ "$ptxdist_minor" = "svn" ] && return 0
	[ "$ptxdist_minor" != "$config_minor" ] && return 1

	ptxdist_micro=`echo $ptxdist | awk -F. '{print $3}'`
	config_micro=`echo $config | awk -F. '{print $3}'`
	[ -z "$config_micro" ] && return 0
	[ "$ptxdist_micro" = "svn" ] && return 0
	[ "$ptxdist_micro" -lt "$config_micro" ] && return 1

	return 0
}

#
# Check for existence of a ptxconfig file
# check_ptxconfig()
#
check_ptxconfig() {

	if [ ! -e "${PTXCONFIG}" ]; then
		echo
		echo "${PROMPT}error: ptxconfig file is missing"
		echo "${PROMPT}error: please 'ptxdist clone' an existing project"
		echo
		exit 1
	fi

	if [ ! -e "${PLATFORMCONFIG}" ]; then
		echo
		echo "${PROMPT}error: 'platformconfig' is missing"
		echo
		exit 1
	fi

	PTXCONF_CONFIGFILE_VERSION=$(. "${PTXCONFIG}" && echo ${PTXCONF_CONFIGFILE_VERSION})

	check_version "${FULLVERSION}" "${PTXCONF_CONFIGFILE_VERSION}"
	if [ "$?" != 0 ]; then
		echo
		echo "${PROMPT}error: The configfile version and ptxdist version do not match:"
		echo
		echo "        configfile version: ${PTXCONF_CONFIGFILE_VERSION}"
		echo "        ptxdist version:    ${FULLVERSION}"
		echo
		exit 1
	fi
}

check_kernelconfig() {
	local kernelconfig

	if [ "$NATIVE" = "1" ]; then
		kernelconfig=$(. "${PTXCONFIG}" && echo ${PTXCONF_KERNEL_NATIVE_CONFIG})
	else
		kernelconfig=$(. "${PTXCONFIG}" && echo ${PTXCONF_KERNEL_CONFIG})
	fi
	if [ ! -e "$kernelconfig" ]; then
		echo
		echo "${PROMPT}error: You don't have a $kernelconfig file"
		echo
		exit 1
	fi
}

#
# abort if ptxdist is run as root
#
check_uid() {
	if [ ${UID} -eq 0 ]; then
		echo
		echo "${PROMPT}refusing to run PTXdist as root"
		echo
		exit 1
	fi
}

#
#
#
check_path() {
	case "${PATH}" in
		.:*)
			echo
			echo "${PROMPT}\".\" in your \$PATH detected, please remove it!"
			echo
			exit 1
			;;
		*)
			;;
	esac
}


#
# Check for defined compiler
# This only should be done when we build userland (chicken egg problem)
#
check_compiler() {
	local build_userland compiler vendor_should vendor_is vendor_def compiler_should compiler_is

	build_toolchain=$(. "${PTXCONFIG}" && echo ${PTXCONF_BUILD_TOOLCHAIN})

	[ -n "$build_toolchain" -o "$NATIVE" != "" ] && return

	#
	# Three things should be checked
	# 1) Correct compiler name
	# 2) Correct vendor if the vendor string is given
	# 3) Correct compiler version if a specific compiler version is given
	#

	compiler="$(ptxd_get_ptxconf PTXCONF_COMPILER_PREFIX)gcc"
	vendor_should="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_VENDOR)"

	if [ ! -z "$vendor_should" ]; then

		# yea! Vendor is specified in the project. So check for
		# toolchain vendor identification file

		vendor_def=$(type -p ptxconfig)
		if [ -z "$vendor_def" ]; then
			echo
			echo "${PROMPT}error: Cannot check toolchain vendor. If this is all right,"
			echo "${PROMPT}error: leave 'check for specific toolchain vendor' empty!"
			echo
			exit 1
		else
		# both vendor strings are present. Check them
			vendor_is=$(. $vendor_def && echo ${PTXCONF_PROJECT})
			if [ "$vendor_is" != "$vendor_should" ]; then
				echo
				echo "${PROMPT}error: Wrong toolchain vendor. Cannot continue! Vendor is <$vendor_is>,"
				echo "${PROMPT}error: but should be <$vendor_should> to build this project!"
				echo
				exit 1
			fi
		fi
	fi

	compiler_should="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_CHECK)"
	compiler_is=$($compiler -dumpversion 2> /dev/null)

	if [ -z "$compiler_is" ]; then
		echo
		echo "${PROMPT}error: Compiler '$compiler' not found.  Check PATH or"
		echo "${PROMPT}error: use 'ptxdist toolchain <path/to/toolchain>'."
		echo
		exit 1
	fi
	if [ "$compiler_is" != "$compiler_should" ]; then
		echo
		echo "${PROMPT}error: Compiler version $compiler_should expected,"
		echo "${PROMPT}error: but $compiler_is found."
		echo
		exit 1
	fi
}


#
# checks if the dependencies are allright (make for the poor)
#
check_deps() {
	"${DGENDIR}/dgen.sh"
}


check_dirs_prefix() {
	local prefix testfile

	prefix="${1}"

	if test -z "${prefix}"; then
		return
	fi

	if test \! -d "${prefix}"; then
		mkdir -p "${prefix}" 2> /dev/null
		if test $? -ne 0; then
			echo
			echo "error: \"${ptxconf_prefix}\""
			echo "       does not exist and cannot be created!"
			echo "       Please create that dir with write permissions for you."
			echo
			read -t 5 -p "press enter to let sudo do that job!"
			if test $? -ne 0; then
				echo
				exit 1
			fi
			echo
			echo sudo mkdir -p ${prefix}
			sudo mkdir -p "${prefix}"
			echo
			echo sudo chown $UID ${prefix}
			sudo chown $UID "${prefix}"
		fi
	fi

    	testfile=${prefix}/.secret-world-domination-project
	touch "${testfile}" 2> /dev/null
	if test $? -ne 0; then
		echo
		echo "error: \"${ptxconf_prefix}\""
		echo "       does exist, but is not writeable."
		echo "       Change the permissions and try again."
		echo
		read -t 5 -p "press enter to let sudo do the job!"
		if test $? -ne 0; then
			echo
			exit 1
		fi
		echo
		echo sudo chown $UID ${prefix}
		sudo chown $UID ${prefix}
		echo sudo chmod u+w ${prefix}
		sudo chmod u+w ${prefix}

		touch "${testfile}" 2> /dev/null
		if test $? -ne 0; then
			echo
			echo "error: cannot make \"${ptxconf_prefix}\" writeable, giving up"
			echo
			exit 1
		fi
	fi

	rm "${testfile}"

	mkdir -p "${prefix}"/{etc,lib,{,s}bin,include,{,share/}man/man{1,2,3,4,5,6,7,8,9}}
}


#
# Most install stages think that some standard directories are there, so
# they are created here.
#
check_dirs() {
	local ptxconf_prefix ptxconf_prefix_host ptxconf_prefix_cross dir
	local ptxconf_gnu_target testfile_upper testfile_lower i

	# prefix
	if [ -z "$PREFIX" ]; then
		ptxconf_prefix="$(ptxd_get_ptxconf PTXCONF_PREFIX)"
	else
		ptxconf_prefix=${PREFIX}
	fi

	ptxconf_prefix_host="$(ptxd_get_ptxconf PTXCONF_HOST_PREFIX)"
	ptxconf_prefix_cross="$(ptxd_get_ptxconf PTXCONF_CROSS_PREFIX)"

	for dir in "${ptxconf_prefix_host}" "${ptxconf_prefix_cross}"; do
		check_dirs_prefix "${dir}"
	done

	# sysroot - keep in sync with rules/pre/Rules.make -> SYSROOT
	ptxconf_gnu_target="$(ptxd_get_ptxconf PTXCONF_GNU_TARGET)"
	mkdir -p "${ptxconf_prefix}/sysroot/${ptxconf_gnu_target}"/{,usr/}{lib,{,s}bin,include,{,share/}man/man{1,2,3,4,5,6,7,8,9}}

	# builddirs
	for i in "${BUILDDIR}" "${CROSS_BUILDDIR}" "${HOST_BUILDDIR}" \
		"${STATEDIR}" "${IMAGEDIR}" "${ROOTDIR}" "${ROOTDIR_DEBUG}"; do
		mkdir -p "${i}"
	done

	for i in "${BUILDDIR}" "${CROSS_BUILDDIR}" "${HOST_BUILDDIR}"; do
		testfile_lower=${i}/.secret-world-domination-project
		testfile_upper=${i}/.Secret-World-Domination-Project

		echo lower > "${testfile_lower}"
		echo upper > "${testfile_upper}"

		if test "`cat \"${testfile_lower}\"`" != "lower" -o \
		    "`cat \"${testfile_upper}\"`" != "upper"; then
			echo
			echo "error: \"${i}\""
			echo "       is not a case sensitive filesystem."
			echo "       Please move your project to a case sensitive one"
			echo
			exit 1
		fi

		rm "${testfile_lower}" "${testfile_upper}"
	done
}

check_native() {
	[ -n "$NATIVE" ] && touch .build.native
	[ -z "$NATIVE" ] && touch .build.cross
	if [ -f ".build.native" ] && [ -f ".build.cross" ]; then
		if [ -z "$NATIVE" ]; then
			echo
			echo "error: trying to crosscompile in a native tree"
			echo
			rm -f .build.cross
			exit 1
		else
			echo
			echo "error: trying to compile natively in a cross tree"
			echo
			rm -f .build.native
			exit 1
		fi
	fi
}

check_if_selected() {
	if [ -z $1 ]; then
		echo
		echo "${PROMPT}error: please specify a target"
		echo
		exit 1
	fi
	local CONFIGVAR=PTXCONF_$(ptxd_name_to_NAME $1)
	local PTXCONFIG_CONFIGVAR=$(ptxd_get_ptxconf $CONFIGVAR)
	if [ -z ${PTXCONFIG_CONFIGVAR} ]; then
		echo
		echo "${PROMPT}error: $1 is not selected in ${PTXCONFIG}"
		echo
		exit 1
	fi
}

#
# usage()
#
usage() {
cat << EOF

PTXdist `printf "%-24s" ${FULLVERSION}` Build System for Embedded Linux Systems

  ptxdist <action [args]> [options]

Setup and Project Actions:

  setup                          setup per-user preferences
  boardsetup                     setup per-board preferences

  projects                       show available projects
  clone <from> <to>              create a new project, cloned from <from>.

  menuconfig                     configure the root filesystem
  oldconfig                      run 'make oldconfig' on ptxconfig file
  kernelconfig                   configure the kernel

  u_boot_config                  configure U-Boot (U-Boot V2 only)

  toolchain <path>               select this toolchain (path to binaries)
  select <config>                if there is no ptxconfig file you can
                                 select one of several configs to be used
Build Actions:

  go                             start building the current project

  get <package>                  get packet sources
  extract <package>              extract packet
  prepare <package>              run configure stages for packet
  compile <package>              compile the sources
  install <package>              install host side components into sysroot/
  targetinstall <package>        install files for target into root/
  clean <package>                cleanup packet
  autobuild                      search for "autobuild" scripts and run them
  drop <package>.<stage>         mark a stage of a packet as unbuilt

  images                         build images for target system

Clean Actions:

  clean                          cleanup build-host and build-cross dirs
  distclean                      cleanup everything
  (clean images)                 cleanup images directory
  clean root                     cleanup root directory for target
  (clean project)                cleanup project specific packages
  (clean maintainer)             maintainerclean

Misc

  run                            start a previously built native image

  --native                       build with native compiler instead of cross
  --version                      print out ptxdist version

  (svn up)                       run "svn update" in topdir and project dir
  (svn stat)                     run "svn stat" in topdir and project dir

  test <testname>                run tests

  newpacket <type>               create a new packet Makefile in a rules dir
                                 type can be one of:
                                 target, host, host-existing-target,
                                 cross, cross-existing-target, source,
                                 kernel_driver, font, simple

Environment:

  PREFIX=<path>                  build into this directory, instead of
			         building into PTXCONF_PREFIX from config

EOF
}

clean() {
	local dir bdir
	local ptxconf_prefix ptxconf_host_prefix ptxconf_cross_prefix

	if [ "$1" = "root" ]; then
		echo
		echo "${PROMPT}cleaning root directory..."
		rm -fr "${ROOTDIR}"
		rm -fr "${ROOTDIR_DEBUG}"
		echo "${PROMPT}cleaning targetinstall stages..."
		rm -f "${STATEDIR}"/*.targetinstall
		echo "${PROMPT}done."
		echo
		return
	fi

	if [ -n "$1" ]; then
		check_if_selected $1
		ptxd_make $1_clean
		return
	fi

	echo
	echo "${PROMPT}removing build directories..."
	for dir in "${BUILDDIR}" "${CROSS_BUILDDIR}" "${HOST_BUILDDIR}"; do
		if test \! -d "${dir}"; then
			continue
		fi
		for bdir in `find "${dir}" -maxdepth 1 -mindepth 1 -type l`; do
		    pushd "${bdir}" > /dev/null
		    echo -n "${PROMPT}running \"make clean\" in \"${bdir#${dir}/}\"... "
		    make clean 1> /dev/null 2>&1
		    echo "done"
		    popd > /dev/null
		done
		rm -rf "${dir}"
	done

	if test -f "${PTXCONFIG}"; then
		echo "${PROMPT}removing sysroot directories..."
		ptxconf_prefix="`ptxd_get_ptxconf PTXCONF_PREFIX`"
		ptxconf_host_prefix="`ptxd_get_ptxconf PTXCONF_HOST_PREFIX`"
		ptxconf_cross_prefix="`ptxd_get_ptxconf PTXCONF_CROSS_PREFIX`"

		for dir in "${ptxconf_prefix}" "${ptxconf_host_prefix}" "${ptxconf_cross_prefix}"; do
			if test \! -d "${dir}"; then
				continue
			fi
			case "${dir}" in
			    (${PTXDIST_WORKSPACE}/*)
				rm -rf "${dir}"
				;;
			    (*)
				;;
			esac
		done
	fi

	echo "${PROMPT}removing deps..."
	rm -f depend.out deptree-a4.ps deptree.ps
	echo "${PROMPT}removing imagedir..."
	rm -fr "${IMAGEDIR}"
	echo "${PROMPT}removing root..."
	rm -fr "${ROOTDIR}"
	rm -fr "${ROOTDIR_DEBUG}"
	echo "${PROMPT}removing state..."
	rm -fr "${STATEDIR}"
	echo "${PROMPT}removing logfile..."
	rm -f logfile
	echo "${PROMPT}removing test logfile..."
	rm -f test.log
	echo "${PROMPT}removing cross/native marker..."
	rm -f .build.cross .build.native
	echo "${PROMPT}done."
	echo
}

drop() {
	local statefile
	if [ -z "$2" ]; then
		statefile="$1"
	else
		statefile="$1.$2"
	fi

	echo
	if [ -e "${STATEDIR}/${statefile}" ]; then
		rm -f "${STATEDIR}/${statefile}"
		echo "dropping ${statefile}"
		echo
		exit 0
	else
		echo "stage ${statefile} isn't built, so we cannot drop it"
		echo
		exit 1
	fi
}

menuconfig_action() {
	echo "${PROMPT}menuconfig..."
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${PTXDIST_KCONFIG}"
}

newpacket () {
	local packet_name version url author year suffix overwrite \
	    template template_file template_suffix packet_filename packet_name packet PACKET packetdash filename \
	    class CLASS autoconf_class

	case $1 in
	    target|host|host-existing-target|cross|cross-existing-target|source|kernel_driver|font|simple)
		;;
	    *)	echo
		echo "${PROMPT}error: illegal packet type: $1"
		echo "must be one of host, host-existing-target, target,"
		echo "cross, cross-existing-target, source, kernel_driver, font, simple"
		echo
		exit 1
		;;
	esac

	echo
	echo "${PROMPT}creating a new packet:"
	echo
	echo -n "${PROMPT}enter packet name.......: "
	read packet_name
	echo -n "${PROMPT}enter version number....: "
	read version
	echo -n "${PROMPT}enter URL of basedir....: "
	read url
	echo -n "${PROMPT}enter packet author.....: "
	read author
	echo -n "${PROMPT}enter suffix............: "
	read suffix

	case $1 in
	    target)
		template=template
		class=
		autoconf_class=
		;;
	    host)
		template=template-class
		class=host-
		autoconf_class=HOST_
		;;
	    cross)
		template=template-class
		class=cross-
		autoconf_class=HOST_CROSS_
		;;
	    host-existing-target)
		template=template-class-existing-target
		class=host-
		autoconf_class=HOST_
		;;
	    cross-existing-target)
		template=template-class-existing-target
		class=cross-
		autoconf_class=HOST_CROSS_
		;;
	    source)
		template=template-src
		class=
		autoconf_class=
		;;
	    kernel_driver)
		template=template-driver
		class=
		autoconf_class=
		;;
	    font)
		template=template-font
		class=
		autoconf_class=
		;;
	    simple)
		template=template-file
		class=
		autoconf_class=
		;;
	esac

	packet_filename="${packet_name}"

	packet="`echo ${packet_name} | tr \"[A-Z]\" \"[a-z]\"`"
	packetdash="`echo ${packet} | tr \"[_]\" \"[\-]\"`"
	PACKET="`echo ${packet_name} | tr \"[a-z-]\" \"[A-Z_]\"`"
	CLASS="`echo ${class} | tr \"[a-z-]\" \"[A-Z_]\"`"

	year=`date +%Y`

	for template_suffix in "make" "in"; do
	    template_file="${RULESDIR}/${template}-${template_suffix}"
	    filename="${class}${packet_filename}.${template_suffix}"

	    if test \! -f "${template_file}"; then
		echo
		echo "${PROMPT}warning: template \"${template_file}\" does not exist"
		echo
		continue
	    fi

	    if [ -f "${filename}" ]; then
		echo
		echo -n "${PROMPT}warning: ${filename} does already exist, overwrite? [y/n]"
		read overwrite
		if [ "$overwrite" != "y" ]; then
		    echo "${PROMPT}aborted."
		    echo
		    exit 0
		fi
	    fi

	    sed \
		-e "s#\@packet_filename@#${packet_filename}#g" \
		-e "s#\@PACKET@#${PACKET}#g" \
		-e "s#\@packet@#${packet}#g" \
		-e "s#\@packetdash@#${packetdash}#g" \
		-e "s#\@class@#${class}#g" \
		-e "s#\@CLASS@#${CLASS}#g" \
		-e "s#\@AUTOCONF_CLASS@#${autoconf_class}#g" \
		-e "s#\@VERSION@#${version}#g" \
		-e "s#\@URL@#${url}#g" \
		-e "s#\@YEAR@#${year}#g" \
		-e "s#\@AUTHOR@#${author}#g" \
		-e "s#\@SUFFIX@#${suffix}#g" \
		"${template_file}" \
		> "${filename}"
	done
}

oldconfig_action() {
	"${PTXDIST_TOPDIR}/scripts/kconfig/conf" -s "${PTXDIST_KCONFIG}"
}

#
# platform config
#
platformconfig() {
	local tmpdir kconfig

	echo
	echo "${PROMPT}platformconfig..."

	if [ -e "${PTXDIST_WORKSPACE}/platforms/Kconfig" ]; then
		kconfig=${PTXDIST_WORKSPACE}/platforms/Kconfig
	else
		kconfig=${PTXDIST_TOPDIR}/platforms/Kconfig
	fi

	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null
	ln -sf "${PTXDIST_TOPDIR}/platforms"
	ln -sf "${PTXDIST_WORKSPACE}" workspace

	# prepare everything to make kconfig see it's original environment
	if [ -e "${PLATFORMCONFIG}" ]; then
		cp "$(readlink -f ${PLATFORMCONFIG})" .config
	fi

	# store boardsetup
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${kconfig}"
	echo "${PROMPT}saving ${PLATFORMCONFIG}"
	cp .config "$(readlink -f ${PLATFORMCONFIG})"

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}


projects() {
	local ifs_old projects projectdir
	echo
	echo "${PROMPT}searching for projects:"
	ifs_old=$IFS
	IFS=:
	projects=
	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do
		echo "${PROMPT}scanning ${projectdir}..."
		if [ ! -d ${projectdir} ]; then
			echo
			echo "${PROMPT}error: directory does not exist"
			echo "${PROMPT}please check PTXCONF_SETUP_PROJECTPATH in 'ptxdist setup'"
			exit 1
		fi
		projects="$projects $(cd ${projectdir} && find .  -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;)"
	done
	IFS=$ifs_old
	projects=$(echo $projects | sort -u)
	echo
	echo "---------------------- Available PTXdist Projects: ----------------------------"
	for i in $projects; do echo $i; done
	echo "-------------------------------------------------------------------------------"
	echo
}

setup() {
	local tmpdir

	echo
	echo "${PROMPT}setup..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see its original environment
	cp "${PTXDIST_TOPDIR}/config/setup/ptxdistrc.default" .config
	if [ -f "$HOME/.ptxdistrc.${FULLVERSION}" ]; then
		echo "using \$HOME/.ptxdistrc.${FULLVERSION}"
		cp "$HOME/.ptxdistrc.${FULLVERSION}" .config
	fi

	# store ~/.ptxdistrc
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${PTXDIST_TOPDIR}/config/setup/Kconfig"
	echo "${PROMPT}saving \$HOME/.ptxdistrc.${FULLVERSION}"
	cp .config "$HOME/.ptxdistrc.${FULLVERSION}"

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}


clone() {
	local ifs_old projectdir

	if [ -z "$1" ]; then usage; exit 1; fi
	if [ -z "$2" ]; then usage; exit 1; fi

	if [ -d "$2" ]; then
		echo
		echo "${PROMPT}error: directory $2 does already exist"
		echo
		exit 1
	fi

	ifs_old=$IFS
	IFS=:

	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do

		echo "${PROMPT}scanning $projectdir..."

		if [ -d "${projectdir}/$1" ] ; then

			mkdir -p $2
			tar -C ${projectdir}/$1 -cf - \
			    --exclude .svn --exclude state --exclude debian . | \
			    tar -C $2 -xvf -

			echo "${PROMPT}done."
			echo
			return 0
		fi
	done
	IFS=$ifs_old

	echo "${PROMPT}project $1 is to be cloned, but could not be found"
	echo
}


#
# main()
#
if [ "$#" = "0" ]; then
	usage
	exit 0
fi

check_uid
check_path

while [ "$#" != "0" ]; do

	case $1 in
	autobuild)	echo
			echo "${PROMPT}running autobuild"
			echo
			AUTOBUILDS=$(find . -name "autobuild*" | grep -v .svn)
			AUTOBUILD_TOPDIR=$(pwd)
			exec 5>COMPILETEST
			echo >&5
			for i in $AUTOBUILDS; do
				pushd $(dirname $i)

				echo "config............: `basename \`pwd\``" >&5
				echo "date..............: `date`" >&5
				echo "user..............: ${USER}@${HOSTNAME}" >&5
				PTX_STARTTIME=`date +"%s"`

				./$(basename $i)

				PTX_RETVAL=$?
				PTX_STOPTIME=`date +"%s"`
				let "PTX_TIME=$PTX_STOPTIME-$PTX_STARTTIME"
				let "PTX_TIME_H=$PTX_TIME/3600"
				let "PTX_TIME_M=($PTX_TIME-$PTX_TIME_H*3600)/60"
				let "PTX_TIME_S=($PTX_TIME-$PTX_TIME_H*3600-$PTX_TIME_M*60)/60"
				echo "buildtime.........: ${PTX_TIME_H}h${PTX_TIME_M}m${PTX_TIME_S}s" >&5
				echo "result............: ${PTX_RETVAL}" >&5
				echo >&5

				[ -e "logfile" ] && mv logfile "${AUTOBUILD_TOPDIR}/`basename \`pwd\``.log"
				[ "${PTX_RETVAL}" = "0" ] && ${PTXDIST} distclean

				popd
			done
			echo
			echo "${PROMPT}done"
			echo
			exit 0
			;;
	boardsetup)	shift
			check_ptxconfig
			boardsetup
			;;
	compile)	shift
			check_ptxconfig
			check_if_selected $1
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_compile 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	clean)		shift
			check_ptxconfig
			check_deps
			clean $1
			exit 0
			;;
	clone)		shift;
			clone $1 $2
			exit 0
			;;
	-d|--debug)	shift
			export PTXDIST_MAKE_DBG="--debug=make"
			;;
	distclean)	shift
			clean
			echo "${PROMPT}removing toolchain link..."
			rm -f .toolchain
			echo "${PROMPT}removing logs dir..."
			rm -fr logfile
			if [ -h "${PTXCONFIG}" ]; then
				echo "${PROMPT}removing ptxconfig link..."
				rm ${PTXCONFIG}
			fi
			echo
			;;
	drop)		shift
			check_ptxconfig
			drop $1 $2
			;;
	export)		shift
			if [ ! -d $1 ]; then
				echo
				echo "${PROMPT}error: directory '$1' does not exist!"
				echo
				exit 1
			fi
			export EXPORTDIR=$1
			check_ptxconfig
			check_native
			check_deps
			ptxd_make export $1 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	extract)	shift
			check_ptxconfig
			check_if_selected $1
			check_native
			check_deps
			ptxd_make $1_extract 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	get)		shift
			check_ptxconfig
			check_native
			check_deps
			if [ $# -eq 0 ]; then
				ptxd_make get 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			else
				check_if_selected $1
				ptxd_make $1_get 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			fi
			;;
	go)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make world 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	help|--help)	shift; usage; exit 0; ;;
	images)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make images 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	install)	shift
			check_ptxconfig
			check_if_selected $1
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_install 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	kernelconfig)	shift
			check_ptxconfig
			check_native
			check_deps
			ptxd_make kernel_menuconfig
			check_pipe_status
			exit 0
			;;
	u_boot_config)	shift
			check_ptxconfig
			check_native
			check_deps
			ptxd_make u-boot-v2_menuconfig
			check_pipe_status
			exit 0
			;;
	maintainer)	shift
			if [ "$#" = "0" ]; then
				echo
				echo "${PROMPT} commands:"
				echo
				echo "${PROMPT} configversionbump"
				echo "${PROMPT} alloldconfig"
				echo
				exit 0
			fi
			case $1 in
			configversionbump)
				echo
				echo "${PROMPT} configversionbump:"
				echo
				for i in $(find . -name "ptxconfig*" | grep -v .svn); do
					echo "${PROMPT} version fixup in $i..."
					sed -i -e \
						"s/PTXCONF_CONFIGFILE_VERSION=\".*\"/PTXCONF_CONFIGFILE_VERSION=\"${FULLVERSION}\"/g" \
						$i
				done
				;;
			alloldconfig)
				echo
				echo "${PROMPT} alloldconfig:"
				echo
				for i in $(find . -name "autobuild" | grep -v .svn); do
					i_dir=$(dirname $i)
					echo i=$i i_dir=$i_dir
					pushd $i_dir
					ptxdist oldconfig
					popd
				done
				;;
			*)
				echo
				echo "${PROMPT} error: unknown command: $1"
				echo
				exit 1
				;;
			esac
			exit 0
			;;
	make)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	menuconfig)	shift
			check_ptxconfig
			if test $# -eq 0; then
				ptxd_kconfig true menuconfig_action
			else
				check_native
				check_deps
				ptxd_make $1_menuconfig
			fi
			check_pipe_status
			exit 0
			;;
	--native)	shift
			export NATIVE=1
			;;
	newpacket)	# test if we are in a rules dir
			if [ "`basename \`pwd\``" != "rules" ]; then
				echo
				echo "${PROMPT}error: newpacket command only allowed in a rules dir"
				echo
				exit 1
			fi
			shift
			newpacket "$1"
			exit $?
			;;
	oldconfig)	shift
			check_ptxconfig
			if test $# -eq 0; then
				ptxd_kconfig true oldconfig_action
			else
				check_native
				check_deps
				ptxd_make $1_oldconfig
			fi
			exit $?
			;;
	platform)	shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "${PLATFORMCONFIG}" ]; then
				echo
				echo -n "${PROMPT}warning: overwrite existing platformconfig [y/n]? "
				read answer
				if [ "$answer" != "y" ]; then
					echo "interrupting"
					echo
					exit 1
				fi
			fi
			echo
			echo "${PROMPT}selecting platformconfig \"$1\""
			ln -sf $1 ${PLATFORMCONFIG}
			echo "${PROMPT}done."
			echo
			exit 0
			;;
	platformconfig)	shift
			platformconfig
			;;
	prepare)	shift
			check_ptxconfig
			check_if_selected $1
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_prepare 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	print)		shift
			check_ptxconfig
			check_deps
			ptxd_make print-$1 2>&1 | tee -a logfile
			check_pipe_status
			shift
			;;
	projects)	shift
			projects
			;;
	run)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make world 2>&1 | tee -a logfile
			check_pipe_status
			RUN_ROOTMETHOD=$(. ${PTXCONFIG} && echo ${PTXCONF_KERNEL_NATIVE_ROOT_HOSTFS})
			RUN_CMDLINE=$(. ${PTXCONFIG} && echo ${PTXCONF_KERNEL_NATIVE_CMDLINE})
			if [ -n "${RUN_ROOTMETHOD}" ]; then
				RUN_CMDLINE="${RUN_CMDLINE} root=/dev/root rootflags=`pwd`/root rootfstype=hostfs"
			fi
			${PTXDIST_WORKSPACE}/images/linuximage ${RUN_CMDLINE}
			exit 0
			;;
	select)		shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "${PTXCONFIG}" -a ! -L "${PTXCONFIG}" ]; then
				echo
				echo "${PROMPT}error: There already is a ptxconfig file."
				echo "${PROMPT}error: If you really want to select another configuration,"
				echo "${PROMPT}error: please move away the ptxconfig file first."
				echo
				exit 1
			fi
			echo
			echo "${PROMPT}linking $1 to ptxconfig"
			ln -sf $1 ${PTXCONFIG}
			echo "${PROMPT}done."
			echo
			exit 0
			;;
	setup)		shift; setup;;
	targetinstall)	shift
			check_ptxconfig
			check_if_selected $1
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_targetinstall 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	test)		shift
			if [ -z "$1" ]; then
				echo "No test given. try ptxdist test help for a list of available tests"
				exit 0
			fi
			if [ "$1" = help ]; then
				echo "available tests:"
				find $PTXDIST_WORKSPACE/tests -maxdepth 1 -type f -exec basename {} \;
				exit 0
			fi
			if [ -x "$PTXDIST_WORKSPACE/tests/$1" ]; then
				echo
				"$PTXDIST_WORKSPACE/tests/$1" > ${PTXDIST_WORKSPACE}/test.log
				echo
			else if [ -x "$PTXDIST_TOPDIR/tests/$1" ]; then
				echo
				"$PTXDIST_TOPDIR/tests/$1" > ${PTXDIST_WORKSPACE}/test.log
				echo
			else
				echo
				echo "${PROMPT}error: test '$1' not found in PTXDIST_TOPDIR and PTXDIST_WORKSPACE"
				echo
			fi
			fi
			exit 0
			;;
	toolchain)	shift
			echo
			if [ ! -d "$1" ]; then
				echo
				echo "${PROMPT}error: path $1 does not exist"
				echo
				exit 1
			fi
			echo "${PROMPT}using toolchain in $1"
			test -h ".toolchain" && rm -f .toolchain
			if [ -e ".toolchain" ]; then
				echo
				echo "${PROMPT}error: There is a .toolchain in this directory which is no link."
				echo "${PROMPT}error: This should never happen, please contact the"
				echo "${PROMPT}error: Pengutronix Department of Illegal File Removement."
				echo
				exit 1
			fi
			ln -sf $1 .toolchain
			echo
			exit 0
			;;
	--version)	echo ${FULLVERSION}
			exit 0
			;;
	*)		shift
			usage
			exit 0
			;;
	esac

done

exit 0

