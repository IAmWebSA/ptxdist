#!/bin/bash

#
# TODO
#
# - split images out of Makefile; we should have a command "image jffs2"
#   which starts a corresponding script in scripts/
#
#

PROMPT="ptxdist: "
PTXDIST_WORKSPACE=$(pwd)
DEBUG=

# export this, so that children can call the master script, for example
# to find out the version number
PTXDIST=$0

if [ -L "$PTXDIST" ]; then
	PTXDIST_TOPDIR=$(cd $(dirname $(readlink $PTXDIST))/.. && pwd)
else
	PTXDIST_TOPDIR=$(cd $(dirname $PTXDIST)/.. && pwd)
fi

export PTXDIST PTXDIST_WORKSPACE PTXDIST_TOPDIR


#
# sanity check: is PTXdist already configured?
#

if [ ! -e ${PTXDIST_TOPDIR}/.done ]; then
	echo
	echo "${PROMPT}error: PTXdist in ${PTXDIST_TOPDIR} is not built."
	echo
	exit 1
fi

#
# we need the version definitions
#
for file in \
	scripts/libptxdist.sh \
	scripts/ptxdist_version.sh \
	scripts/ptxdist_vars.sh \
; do
	if test -e ${PTXDIST_TOPDIR}/$file; then
		. ${PTXDIST_TOPDIR}/$file
	else
		echo "${PROMPT}didn't find \$(PTXDIST_TOPDIR)/$file"
		exit 1
	fi
done

# source the user's .ptxdistrc
[ -e "$HOME/.ptxdistrc.${FULLVERSION}" ] && . $HOME/.ptxdistrc.${FULLVERSION}

# use linked toolchain if available
[ -d ".toolchain" ] && export PATH=${PTXDIST_WORKSPACE}/.toolchain:$PATH

#
# board setup
#
boardsetup() {
	local tmpdir

	echo
	echo "${PROMPT}boardsetup..."

	if [ ! -e "${PTXDIST_WORKSPACE}/boardsetup/boardsetup" ] ||
	   [ ! -e "${PTXDIST_WORKSPACE}/boardsetup/Kconfig" ]; then
		echo "error: boardsetup/boardsetup or boardsetup/Kconfig missing"
		echo
		exit 1
	fi

	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see it's original environment
	ln -sf ${PTXDIST_TOPDIR}/scripts
	cp ${PTXDIST_WORKSPACE}/boardsetup/boardsetup .config

	# store boardsetup
	${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_WORKSPACE}/boardsetup/Kconfig
	echo "${PROMPT}saving \$PTXDIST_WORKSPACE/boardsetup/boardsetup"
	cp .config ${PTXDIST_WORKSPACE}/boardsetup/boardsetup

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}

#
# Check for existence of a ptxconfig file
# check_ptxconfig()

check_ptxconfig() {
	if [ ! -e "ptxconfig" ]; then
		echo
		echo "${PROMPT}error: ptxconfig file is missing. Did you setup your project yet?"
		echo "${PROMPT}error: To get a ptxconfig file clone a template project or (if"
		echo "${PROMPT}error: there are more than one configurations like ptxconfig.*)"
		echo "${PROMPT}error: select one of these with 'ptxdist select ptxconfig.<yourselection>'"
		echo "${PROMPT}error: first."
		echo
		exit 1
	fi

	# sanity check: we process only files which have been built with the
	# same PTXdist version!

	PTXCONF_CONFIGFILE_VERSION=$(. ptxconfig && echo ${PTXCONF_CONFIGFILE_VERSION})
	if [ "${PTXCONF_CONFIGFILE_VERSION}" != "${FULLVERSION}" ]; then
		echo
		echo "${PROMPT}error: Your ptxconfig file was built with another PTXdist version."
		echo "${PROMPT}error: As this may result in a broken configuration it is recommended"
		echo "${PROMPT}error: that you carefully review the config differences and change"
		echo "${PROMPT}error: the variable PTXCONF_CONFIGFILE_VERSION=\"${FULLVERSION}\" manually"
		echo "${PROMPT}error: then, or change it first, run 'ptxdist oldconfig' and check"
		echo "${PROMPT}error: if the result is what you expected."
		echo
		echo "${PROMPT}error: config file wants PTXCONF_CONFIGFILE_VERSION \"${PTXCONF_CONFIGFILE_VERSION}\""
		echo "${PROMPT}error: ptxdist version is \"${FULLVERSION}\""
		echo
		exit 1
	fi
}

check_kernelconfig() {
	local kernelconfig

	if [ "$NATIVE" = "1" ]; then
		kernelconfig="kernelconfig.native"
	else
		kernelconfig="kernelconfig.target"
	fi
	if [ ! -e "$kernelconfig" ]; then
		echo
		echo "${PROMPT}error: You don't have a $kernelconfig file"
		echo
		exit 1
	fi
}

#
# Check for defined compiler
# This only should be done when we build userland (chicken egg problem)
#
check_compiler() {
	local build_userland compiler compiler_should_be compiler_is

	build_userland=$(. ptxconfig && echo ${PTXCONF_BUILD_USERLAND})
	[ "$build_userland" != "y" -o "$NATIVE" != "" ] && return

	compiler=$(. ptxconfig && echo ${PTXCONF_COMPILER_PREFIX})gcc
	compiler_should_be=$(. ptxconfig && echo ${PTXCONF_CROSSCHAIN_CHECK})
	compiler_is=$($compiler -dumpversion 2> /dev/null)

	if [ -z "$compiler_is" ]; then
		echo
		echo "${PROMPT}error: Compiler '$compiler' not found.  Check PATH or"
		echo "${PROMPT}error: use 'ptxdist toolchain <path/to/toolchain>'."
		echo
		exit 1
	fi
	if [ "$compiler_is" != "$compiler_should_be" ]; then
		echo
		echo "${PROMPT}error: Compiler version $compiler_should_be expected,"
		echo "${PROMPT}error: but $compiler_is found."
		echo
		exit 1
	fi
}

#
# Most install stages think that some standard directories are there, so
# they are created here. 
#
check_dirs() {
	local ptxconf_prefix ptxconf_gnu_target

	if [ -z "$PREFIX" ]; then
		ptxconf_prefix=$(. ptxconfig && echo ${PTXCONF_PREFIX})
	else 
		ptxconf_prefix=$PREFIX
	fi
	ptxconf_gnu_target=$(. ptxconfig && echo ${PTXCONF_GNU_TARGET})

	# And now we learn something new about shell: brace expansion.
	# It saves 16 characters compared to what NORMAL people would write 
	# here... unfortunately it discovers a bug in vim's syntax high-
	# lighting :) Thanks to Martin Neitzel who inspired this...(rsc)
	# it's even possible to do it shorter (mkl)
	for i in {,usr/}{lib,{,s}bin,include,{,share/}man/man{1,2,3,4,5,6,7,8,9}}; do
		mkdir -p ${ptxconf_prefix}/{,${ptxconf_gnu_target}/}${i}
	done
}

check_native() {
	[ -n "$NATIVE" ] && touch .build.native
	[ -z "$NATIVE" ] && touch .build.cross
	if [ -f ".build.native" ] && [ -f ".build.cross" ]; then
		if [ -z "$NATIVE" ]; then
			echo
			echo "error: trying to crosscompile in a native tree"
			echo
			rm -f .build.cross
			exit 1
		else
			echo
			echo "error: trying to compile natively in a cross tree"
			echo
			rm -f .build.native
			exit 1
		fi
	fi
}

#
# usage()
#
usage() {
cat << EOF

PTXdist `printf "%-24s" ${FULLVERSION}` Build System for Embedded Linux Systems

  ptxdist <action [args]> [options]

Setup and Project Actions:

  setup                          setup per-user preferences
  boardsetup                     setup per-board preferences

  projects                       show available projects
  clone <from> <to>              create a new project, cloned from <from>. 

  menuconfig                     configure the root filesystem
  oldconfig                      run 'make oldconfig' on ptxconfig file
  kernelconfig                   configure the kernel

  toolchain <path>               select this toolchain (path to binaries)
  select <config>                if there is no ptxconfig file you can
                                 select one of several configs to be used
Build Actions:

  go                             start building the current project

  get <package>                  get packet sources
  extract <package>              extract packet
  prepare <package>              run configure stages for packet
  compile <package>              compile the sources
  install <package>              install host side components into sysroot/
  targetinstall <package>        install files for target into root/
  clean <package>                cleanup packet
  autobuild                      search for "autobuild" scripts and run them
  drop <package>.<stage>         mark a stage of a packet as unbuilt

  images                         build images for target system

Clean Actions:

  clean                          cleanup build-host and build-cross dirs
  distclean                      cleanup everything
  (clean images)                 cleanup images directory
  clean root                     cleanup root directory for target
  (clean project)                cleanup project specific packages
  (clean maintainer)             maintainerclean

Misc

  run                            start a previously built native image

  --native                       build with native compiler instead of cross
  --version                      print out ptxdist version

  (svn up)                       run "svn update" in topdir and project dir
  (svn stat)                     run "svn stat" in topdir and project dir

  test <testname>                run tests

  newpacket <type>               create a new packet Makefile in a rules dir
                                 type can be one of host, target, cross

Environment:

  PREFIX=<path>                  build into this directory, instead of
			         building into PTXCONF_PREFIX from config

EOF
}

clean() {

	if [ "$1" = "root" ]; then
		echo
		echo "${PROMPT}cleaning root directory..."
		rm -fr root
		rm -fr root-debug
		echo "${PROMPT}cleaning targetinstall stages..."
		rm -f state/*.targetinstall
		echo "${PROMPT}done."
		echo
		return
	fi

	if [ -n "$1" ]; then
		make $PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make $1_clean PTXDIST_TOPDIR=${PTXDIST_TOPDIR}
		return
	fi

	echo
	echo "${PROMPT}removing build directories..."
	rm -fr build-cross
	rm -fr build-host
	rm -fr build-target
	echo "${PROMPT}removing deps..."
	rm -f depend.out deptree-a4.ps deptree.ps
	echo "${PROMPT}removing imagedir..."
	rm -fr images
	echo "${PROMPT}removing sysroot directory (local)..."
	rm -fr local
	echo "${PROMPT}removing sysroot..."
	rm -fr sysroot
	echo "${PROMPT}removing root..."
	rm -fr root
	rm -fr root-debug
	echo "${PROMPT}removing state..."
	rm -fr state
	echo "${PROMPT}removing logfile..."
	rm -f logfile
	echo "${PROMPT}removing test logfile..."
	rm -f test.log
	echo "${PROMPT}removing cross/native marker..."
	rm -f .build.cross .build.native
	echo "${PROMPT}done."
	echo
}

drop() {
	local statefile
	if [ "$2" = "" ]; then
		statefile="$1"
	else
		statefile="$1.$2"
	fi

	echo
	if [ -e ${STATEDIR}/${statefile} ]; then
		rm -f ${STATEDIR}/${statefile}
		echo "droping ${statefile}"
		echo
		exit 0
	else
		echo "stage ${statefile} isn't built, so we cannot drop it"
		echo
		exit 1
	fi
}

menuconfig() {
	echo

	# check if this is a PTXdist project dir
	if [ -z "$(find . -maxdepth 1 -name "ptxconfig" | grep -v .svn)" ]; then
		echo "${PROMPT}error: no ptxconfig file found."
		echo "${PROMPT}error: check if this is a PTXdist project directory"
		echo
		exit 1
	fi

	echo "${PROMPT}menuconfig..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`

	pushd $tmpdir > /dev/null
	ln -sf ${PTXDIST_TOPDIR}/scripts
	ln -sf ${PTXDIST_TOPDIR}/rules
	ln -sf ${PTXDIST_TOPDIR}/config
	ln -sf ${PTXDIST_WORKSPACE} workspace
	cp ${PTXDIST_WORKSPACE}/ptxconfig .config
	if [ -e "${PTXDIST_WORKSPACE}/Kconfig" ]; then
		${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_WORKSPACE}/Kconfig
		echo "${PROMPT}silentoldconfig..."
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s ${PTXDIST_WORKSPACE}/Kconfig
	else
		${PTXDIST_TOPDIR}/scripts/kconfig/mconf config/Kconfig
		echo "${PROMPT}silentoldconfig..."
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s config/Kconfig
	fi

	echo "${PROMPT}saving ptxconfig"
	cp .config ${PTXDIST_WORKSPACE}/ptxconfig

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
	echo
}

kernelconfig () {
	echo
	make \
		$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
		kernel_menuconfig PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 
}

newpacket () {
	local template
	
	case $1 in 
	host)	template=template-host ;;
	target)	template=template ;;
	cross)	template=template-cross ;;
	*)	echo
		echo "${PROMPT}error: illegal packet type: $1"
		echo "must be one of host, target, cross"
		echo
		exit 1 ;;
	esac

	echo
	echo "${PROMPT}creating a new packet from ${template}:"
	echo
	echo -n "${PROMPT}enter packet name.......: "
	read PACKET_NAME
	echo -n "${PROMPT}enter version number....: "
	read VERSION
	echo -n "${PROMPT}enter URL of basedir....: "
	read URL
	echo -n "${PROMPT}enter packet author.....: "
	read AUTHOR
	echo -n "${PROMPT}enter suffix............: "
	read SUFFIX
	YEAR=`date +%Y`
	packet=`echo $PACKET_NAME | tr "[A-Z]" "[a-z]"`
	PACKET=`echo $PACKET_NAME | tr "[a-z]" "[A-Z]"`

	if [ -f "${packet}.make" ]; then
		echo
		echo -n "${PROMPT}warning: ${packet}.make does already exist, overwrite? "
		read overwrite
		if [ "$overwrite" != "y" ]; then
			echo "${PROMPT}aborted."
			echo
			exit 0
		fi
	fi
	
	sed \
		-e "s~\@PACKET@~${PACKET}~g" \
		-e "s~\@packet@~${packet}~g" \
		-e "s~\@VERSION@~${VERSION}~g" \
		-e "s~\@URL@~${URL}~g" \
		-e "s~\@YEAR@~${YEAR}~g" \
		-e "s~\@AUTHOR@~${AUTHOR}~g" \
		-e "s~\@SUFFIX@~${SUFFIX}~g" \
		${PTXDIST_TOPDIR}/rules/${template} \
		> ${packet}.make
	
}

oldconfig() {
	echo

	# check if this is a PTXdist project dir
	if [ -z "$(find . -maxdepth 1 -name "ptxconfig" | grep -v .svn)" ]; then
		echo "${PROMPT}error: no ptxconfig file found."
		echo "${PROMPT}error: check if this is a PTXdist project directory"
		echo
		exit 1
	fi

	echo "${PROMPT}silentoldconfig..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`

	pushd $tmpdir > /dev/null
	ln -sf ${PTXDIST_TOPDIR}/scripts
	ln -sf ${PTXDIST_TOPDIR}/rules
	ln -sf ${PTXDIST_TOPDIR}/config
	ln -sf ${PTXDIST_WORKSPACE} workspace
	cp ${PTXDIST_WORKSPACE}/ptxconfig .config
	if [ -e "${PTXDIST_WORKSPACE}/Kconfig" ]; then
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s ${PTXDIST_WORKSPACE}/Kconfig
	else
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s config/Kconfig
	fi
	echo "${PROMPT}saving ptxconfig"
	cp .config ${PTXDIST_WORKSPACE}/ptxconfig

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
	echo
}

projects() {
	echo
	echo "${PROMPT}searching for projects:"
	echo "${PROMPT}scanning ${PTXDIST_TOPDIR}/projects..."
	projects=`cd ${PTXDIST_TOPDIR}/projects-example && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	projects="$projects `cd ${PTXDIST_TOPDIR}/projects-toolchains && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`"
	echo -n "${PROMPT}scanning \${PTXCONF_SETUP_PROJECTDIR}..."
	if [ -d "${PTXCONF_SETUP_PROJECTDIR}" ]; then
	lprojects=`cd ${PTXCONF_SETUP_PROJECTDIR} && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	echo
	else
	echo "not found"
	fi
	projects=`(for i in $projects $lprojects; do echo $i; done) | sort -u`
	echo
	echo "---------------------- Available PTXdist Projects: ----------------------------"
	for i in $projects; do echo $i; done
	echo "-------------------------------------------------------------------------------"
	echo
}

setup() {
	local tmpdir

	echo
	echo "${PROMPT}setup..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see it's original environment
	ln -sf ${PTXDIST_TOPDIR}/scripts
	cp ${PTXDIST_TOPDIR}/config/setup/ptxdistrc.default .config
	if [ -f "$HOME/.ptxdistrc.${FULLVERSION}" ]; then
		echo "using \$HOME/.ptxdistrc.${FULLVERSION}"
		cp $HOME/.ptxdistrc.${FULLVERSION} .config
	fi

	# store ~/.ptxdistrc
	${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_TOPDIR}/config/setup/Kconfig
	echo "${PROMPT}saving \$HOME/.ptxdistrc.${FULLVERSION}"
	cp .config $HOME/.ptxdistrc.${FULLVERSION}

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}

clone() {
	local projects lprojects

	if [ -z "$1" ]; then usage; exit 1; fi
	if [ -z "$2" ]; then usage; exit 1; fi

	if [ -d "$2" ]; then
		echo
		echo "${PROMPT}error: directory $2 does already exist"
		echo
		exit 1
	fi

	echo
	echo "${PROMPT}searching for projects:"
	echo "${PROMPT}scanning ${PTXDIST_TOPDIR}/projects-example..."
	projects=`cd ${PTXDIST_TOPDIR}/projects-example && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	echo "${PROMPT}scanning ${PTXDIST_TOPDIR}/projects-toolchains..."
	projects="$projects `cd ${PTXDIST_TOPDIR}/projects-toolchains && find .  -maxdepth 1 -type d ! -name .svn ! -name .  -exec basename {} \;`"
	echo -n "${PROMPT}scanning \${PTXCONF_SETUP_PROJECTDIR}..."
	if [ -d "${PTXCONF_SETUP_PROJECTDIR}" ]; then
	lprojects=`cd ${PTXCONF_SETUP_PROJECTDIR} && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	echo
	else
	echo "not found"
	fi
	projects=`(for i in $projects $lprojects; do echo $i; done) | sort -u`
	echo

	for i in $projects; do
		if [ "$1" = "$i" ]; then
			echo "${PROMPT}cloning project $1 to $2"

			if [ -d "${PTXCONF_SETUP_PROJECTDIR}" ] && [ -d "${PTXCONF_SETUP_PROJECTDIR}/$1" ] ; then

				mkdir -p $2
				tar -C ${PTXCONF_SETUP_PROJECTDIR}/$1 -cf - \
				    --exclude .svn --exclude state --exclude debian . | \
				    tar -C $2 -xvf -

				echo "${PROMPT}done."
				echo
				return 0

			elif [ -d "${PTXDIST_TOPDIR}/projects-example/$1" ]; then

				mkdir -p $2
				tar -C ${PTXDIST_TOPDIR}/projects-example/$1 -cf - \
				    --exclude .svn --exclude state --exclude debian . | \
				    tar -C $2 -xvf -

				echo "${PROMPT}done."
				echo
				return 0

			elif [ -d "${PTXDIST_TOPDIR}/projects-toolchains/$1" ]; then

				mkdir -p $2
				tar -C ${PTXDIST_TOPDIR}/projects-toolchains/$1 -cf - \
				    --exclude .svn --exclude state --exclude debian . | \
				    tar -C $2 -xvf -

				echo "${PROMPT}done."
				echo
				return 0
			fi
		fi
	done

	echo "${PROMPT}project $1 is to be cloned, but could not be found"
	echo
}


#
# main()
#
if [ "$#" = "0" ]; then
	usage
	exit 0
fi

while [ "$#" != "0" ]; do

	case $1 in
	autobuild)	echo
			echo "${PROMPT}running autobuild"
			echo
			AUTOBUILDS=$(find . -name "autobuild")
			AUTOBUILD_TOPDIR=$(pwd)
			exec 5>COMPILETEST
			echo >&5
			for i in $AUTOBUILDS; do
				pushd $(dirname $i)

				echo "config............: `basename \`pwd\``" >&5
				echo "date..............: `date`" >&5
				echo "user..............: ${USER}@${HOSTNAME}" >&5
				PTX_STARTTIME=`date +"%s"`

				./autobuild

				PTX_RETVAL=$?
				PTX_STOPTIME=`date +"%s"`
				let "PTX_TIME=$PTX_STOPTIME-$PTX_STARTTIME"
				let "PTX_TIME_H=$PTX_TIME/3600"
				let "PTX_TIME_M=($PTX_TIME-$PTX_TIME_H*3600)/60"
				let "PTX_TIME_S=($PTX_TIME-$PTX_TIME_H*3600-$PTX_TIME_M*60)/60"
				echo "buildtime.........: ${PTX_TIME_H}h${PTX_TIME_M}m${PTX_TIME_S}s" >&5
				echo "result............: ${PTX_RETVAL}" >&5
				echo >&5

				[ -e "logfile" ] && mv logfile "${AUTOBUILD_TOPDIR}/`basename \`pwd\``.log"
				[ "${PTX_RETVAL}" = "0" ] && ${PTXDIST} distclean

				popd
			done
			echo
			echo "${PROMPT}done"
			echo
			exit 0
			;;
	boardsetup)	shift; boardsetup
			;;
	compile)	shift
			if [ "$#" = "0" ]; then
				echo "${PROMPT}error: add target you want to compile"
				exit 1
			fi
			check_ptxconfig
			check_native
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_compile PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	clean)		shift
			check_ptxconfig
			clean $1
			exit 0
			;;
	clone)		shift; clone $1 $2; exit 0;;
	-d|--debug)	shift
			export PTXDIST_MAKE_DBG="--debug=make"
			;;
	distclean)	shift
			check_ptxconfig
			clean
			echo "${PROMPT}removing toolchain link..."
			rm -f .toolchain
			echo "${PROMPT}removing logs dir..."
			rm -fr logs
			if [ -h "ptxconfig" ]; then
				echo "${PROMPT}removing ptxconfig link..."
				rm ptxconfig
			fi
			echo
			;;
	drop)		shift
			check_ptxconfig
			drop $1 $2
			;;
	extract)	shift
			check_ptxconfig
			check_native
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_extract PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	get)		shift
			check_ptxconfig
			check_native
			if [ "$#" = "0" ]; then
				make \
					$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
					get PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			else
				make \
					$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
					$1_get PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			fi
			;;
	go)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				world PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	help|--help)	shift; usage; exit 0; ;;
	images)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				images PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	install)	shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_install PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	kernelconfig)	shift
			check_ptxconfig
			check_native
			check_kernelconfig
			kernelconfig
			;;
	maintainer)	shift
			if [ "$#" = "0" ]; then
				echo
				echo "${PROMPT} commands:"
				echo
				echo "${PROMPT} configversionbump"
				echo
				exit 0
			fi
			case $1 in
			configversionbump)
				echo
				echo "${PROMPT} configversionbump:"
				echo
				for i in $(find . -name "ptxconfig*" | grep -v .svn); do
					echo "${PROMPT} version fixup in $i..."
					sed -i -e \
						"s/PTXCONF_CONFIGFILE_VERSION=\".*\"/PTXCONF_CONFIGFILE_VERSION=\"${FULLVERSION}\"/g" \
						$i
				done
				;;
			*)
				echo
				echo "${PROMPT} error: unknown command: $1"
				echo
				exit 1
				;;
			esac
			exit 0
			;;
	make)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1 PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	menuconfig)	shift
			check_ptxconfig
			check_native
			menuconfig
			;;
	--native)	shift
			export NATIVE=1
			;;
	newpacket)	# test if we are in a rules dir
			if [ "`basename \`pwd\``" != "rules" ]; then
				echo
				echo "${PROMPT}error: newpacket command only allowed in a rules dir"
				echo
				exit 1
			fi
			shift
			newpacket "$1"
			exit $?
			;;
	oldconfig)	shift
			check_ptxconfig
			oldconfig
			;;
	prepare)	shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_prepare PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	print)		shift
			check_ptxconfig
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				print-$1 PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			shift
			;;
	projects)	shift
			projects
			;;
	run)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				world PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			RUN_ROOTMETHOD=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_ROOT_HOSTFS})
			RUN_CMDLINE=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_CMDLINE})
			if [ -n "${RUN_ROOTMETHOD}" ]; then
				RUN_CMDLINE="${RUN_CMDLINE} root=/dev/root rootflags=`pwd`/root rootfstype=hostfs"
			fi
			root/boot/vmlinux ${RUN_CMDLINE}
			exit 0	
			;;	
	select)		shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "ptxconfig" ]; then
				echo
				echo "${PROMPT}error: There already is a ptxconfig file."
				echo "${PROMPT}error: If you really want to select another configuration,"
				echo "${PROMPT}error: please move away the ptxconfig file first."
				echo
				exit 1
			fi
			echo
			echo "${PROMPT}linking $1 to ptxconfig"
			rm -f ptxconfig
			ln -sf $1 ptxconfig
			echo "${PROMPT}done."
			echo
			exit 0
			;;
	setup)		shift; setup;;
	targetinstall)	shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_targetinstall PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	test)		shift
			if [ -x "$PTXDIST_WORKSPACE/tests/$1" ]; then
				echo
				$PTXDIST_WORKSPACE/tests/$1 > ${PTXDIST_WORKSPACE}/test.log
				echo
			else if [ -x "$PTXDIST_TOPDIR/tests/$1" ]; then
				echo
				$PTXDIST_TOPDIR/tests/$1 > ${PTXDIST_WORKSPACE}/test.log
				echo
			else
				echo
				echo "${PROMPT}error: test $i not found in PTXDIST_TOPDIR and PTXDIST_WORKSPACE"
				echo
			fi
			fi
			exit 0
			;;
	toolchain)	shift
			echo
			if [ ! -d "$1" ]; then
				echo
				echo "${PROMPT}error: path $1 does not exist"
				echo
				exit 1
			fi
			echo "${PROMPT}using toolchain in $1"
			test -h ".toolchain" && rm -f .toolchain
			if [ -e ".toolchain" ]; then
				echo
				echo "${PROMPT}error: There is a .toolchain in this directory which is no link."
				echo "${PROMPT}error: This should never happen, please contact the"
				echo "${PROMPT}error: Pengutronix Department of Illegal File Removement."
				echo
				exit 1
			fi
			ln -sf $1 .toolchain
			echo
			exit 0
			;;
	--version)	echo ${FULLVERSION}
			exit 0
			;;
	*)		shift
			usage
			exit 0
			;;
	esac

done

exit 0

