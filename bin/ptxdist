#!/bin/bash

#
# TODO
#
# - split images out of Makefile; we should have a command "image jffs2"
#   which starts a corresponding script in scripts/
#
#

PROMPT="ptxdist: "
PTXDIST_WORKSPACE=`pwd`
DEBUG=

# export this, so that children can call the master script, for example
# to find out the version number
PTXDIST=$0

if [ -L "$PTXDIST" ]; then
	PTXDIST_TOPDIR=$(cd $(dirname $(readlink -f $PTXDIST))/.. && pwd)
else
	PTXDIST_TOPDIR=$(cd $(dirname $PTXDIST)/.. && pwd)
fi

export PTXDIST PTXDIST_WORKSPACE PTXDIST_TOPDIR


#
# sanity check: is PTXdist already configured?
#

if [ ! -e ${PTXDIST_TOPDIR}/.done ]; then
	echo
	echo "${PROMPT}error: PTXdist in ${PTXDIST_TOPDIR} is not built."
	echo
	exit 1
fi

#
# we need the PTXdist shell library
# we need the version definitions
# we need the static variable definitions
#
for file in \
	scripts/libptxdist.sh \
	scripts/ptxdist_version.sh \
	scripts/ptxdist_vars.sh \
; do
	if test -e ${PTXDIST_TOPDIR}/$file; then
		. ${PTXDIST_TOPDIR}/$file
	else
		echo "${PROMPT}didn't find \$(PTXDIST_TOPDIR)/$file"
		exit 1
	fi
done

# source the user's .ptxdistrc
[ -e "$HOME/.ptxdistrc.${FULLVERSION}" ] && . $HOME/.ptxdistrc.${FULLVERSION}

# use linked toolchain if available
[ -d ".toolchain" ] && export PATH=${PTXDIST_WORKSPACE}/.toolchain:$PATH

#
# board setup
#
boardsetup() {
	local tmpdir

	echo
	echo "${PROMPT}boardsetup..."

	if [ ! -e "${PTXDIST_WORKSPACE}/boardsetup/Kconfig" ]; then
		echo "error: boardsetup/boardsetup or boardsetup/Kconfig missing"
		echo
		exit 1
	fi

	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see it's original environment
	ln -sf ${PTXDIST_TOPDIR}/scripts
	cp ${PTXDIST_WORKSPACE}/boardsetup/boardsetup .config

	# store boardsetup
	${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_WORKSPACE}/boardsetup/Kconfig
	echo "${PROMPT}saving \$PTXDIST_WORKSPACE/boardsetup/boardsetup"
	cp .config ${PTXDIST_WORKSPACE}/boardsetup/boardsetup

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}

#
# Check for existence of a ptxconfig file
# check_ptxconfig()
#
check_ptxconfig() {
	if [ ! -e "ptxconfig" ]; then
		echo
		echo "${PROMPT}error: ptxconfig file is missing"
		echo
		exit 1
	fi

	# sanity check: we process only files which have been built with the
	# same PTXdist version!

	PTXCONF_CONFIGFILE_VERSION=$(. ptxconfig && echo ${PTXCONF_CONFIGFILE_VERSION})
	if [ "${PTXCONF_CONFIGFILE_VERSION}" != "${FULLVERSION}" ]; then
		echo
		echo "${PROMPT}error: trying to build ptxdist \"${PTXCONF_CONFIGFILE_VERSION}\" project with \"${FULLVERSION}\""
		echo
		exit 1
	fi
}

check_kernelconfig() {
	local kernelconfig

	if [ "$NATIVE" = "1" ]; then
		kernelconfig=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_CONFIG})
	else
		kernelconfig=$(. ptxconfig && echo ${PTXCONF_KERNEL_TARGET_CONFIG})
	fi
	if [ ! -e "$kernelconfig" ]; then
		echo
		echo "${PROMPT}error: You don't have a $kernelconfig file"
		echo
		exit 1
	fi
}

#
# abort if ptxdist is run as root
#
check_uid() {
	if [ ${UID} -eq 0 ]; then
		echo
		echo "${PROMPT}refusing to run PTXdist as root"
		echo
		exit 1
	fi
}

#
#
#
check_path() {
	case "${PATH}" in
		.*)
			echo
			echo "${PROMPT}\".\" in your \$PATH detected, please remove it!"
			echo
			exit 1
			;;
		*)
			;;
	esac
}


#
# Check for defined compiler
# This only should be done when we build userland (chicken egg problem)
#
check_compiler() {
	local build_userland compiler compiler_should_be compiler_is

	build_userland=$(. ptxconfig && echo ${PTXCONF_BUILD_USERLAND})
	[ "$build_userland" != "y" -o "$NATIVE" != "" ] && return

	compiler=$(. ptxconfig && echo ${PTXCONF_COMPILER_PREFIX})gcc
	compiler_should_be=$(. ptxconfig && echo ${PTXCONF_CROSSCHAIN_CHECK})
	compiler_is=$($compiler -dumpversion 2> /dev/null)

	if [ -z "$compiler_is" ]; then
		echo
		echo "${PROMPT}error: Compiler '$compiler' not found.  Check PATH or"
		echo "${PROMPT}error: use 'ptxdist toolchain <path/to/toolchain>'."
		echo
		exit 1
	fi
	if [ "$compiler_is" != "$compiler_should_be" ]; then
		echo
		echo "${PROMPT}error: Compiler version $compiler_should_be expected,"
		echo "${PROMPT}error: but $compiler_is found."
		echo
		exit 1
	fi
}


#
# checks if the dependencies are allright (make for the poor)
#
check_deps() {
	${DGENDIR}/dgen.sh
}


#
# Most install stages think that some standard directories are there, so
# they are created here.
#
check_dirs() {
	local ptxconf_prefix ptxconf_gnu_target testfile testfile_upper testfile_lower i

	if [ -z "$PREFIX" ]; then
		ptxconf_prefix=$(. ptxconfig && echo ${PTXCONF_PREFIX})
	else
		ptxconf_prefix=$PREFIX
	fi

	if test -d ${ptxconf_prefix}; then
	    	testfile=${ptxconf_prefix}/.secret-world-domination-project
		touch ${testfile} 2> /dev/null
		if test $? -ne 0; then
			echo
			echo "error: \"${ptxconf_prefix}\""
			echo "       does exist, but is not writeable."
			echo "       Change the permissions and try again."
			echo
			read -t 5 -p "press enter to let sudo do the job!"
			if test $? -ne 0; then
				echo
				exit 1
			fi
			echo
			echo sudo chown $UID ${ptxconf_prefix}
			sudo chown $UID ${ptxconf_prefix}
		fi
		rm ${testfile}
	else
		mkdir -p ${ptxconf_prefix} 2> /dev/null
		if test $? -ne 0; then
			echo
			echo "error: \"${ptxconf_prefix}\""
			echo "       does not exist and cannot be created!"
			echo "       Please create that dir with write permissions for you."
			echo
			read -t 5 -p "press enter to let sudo do that job!"
			if test $? -ne 0; then
				echo
				exit 1
			fi
			echo
			echo sudo mkdir -p ${ptxconf_prefix}
			sudo mkdir -p ${ptxconf_prefix}
			echo
			echo sudo chown $UID ${ptxconf_prefix}
			sudo chown $UID ${ptxconf_prefix}
		fi
	fi

	ptxconf_gnu_target=$(. ptxconfig && echo ${PTXCONF_GNU_TARGET})

	# And now we learn something new about shell: brace expansion.
	# It saves 16 characters compared to what NORMAL people would write
	# here... unfortunately it discovers a bug in vim's syntax high-
	# lighting :) Thanks to Martin Neitzel who inspired this...(rsc)
	# it's even possible to do it shorter (mkl)
	for i in {,usr/}{lib,{,s}bin,include,{,share/}man/man{1,2,3,4,5,6,7,8,9}}; do
		mkdir -p ${ptxconf_prefix}/{,${ptxconf_gnu_target}/}${i}
	done

	for i in ${BUILDDIR} ${CROSS_BUILDDIR} ${HOST_BUILDDIR} \
		${STATEDIR} ${IMAGEDIR} ${ROOTDIR} ${ROOTDIR_DEBUG}; do
		mkdir -p ${i}
	done

	for i in ${BUILDDIR} ${CROSS_BUILDDIR} ${HOST_BUILDDIR}; do
		testfile_lower=${i}/.secret-world-domination-project
		testfile_upper=${i}/.Secret-World-Domination-Project

		echo lower > ${testfile_lower}
		echo upper > ${testfile_upper}

		if test "`cat ${testfile_lower}`" != "lower" -o \
		    "`cat ${testfile_upper}`" != "upper"; then
			echo
			echo "error: \"${i}\""
			echo "       is not a case sensitive filesystem."
			echo "       Please move your project to a case sensitive one"
			echo
			exit 1
		fi

		rm ${testfile_lower} ${testfile_upper}
	done
}

check_native() {
	[ -n "$NATIVE" ] && touch .build.native
	[ -z "$NATIVE" ] && touch .build.cross
	if [ -f ".build.native" ] && [ -f ".build.cross" ]; then
		if [ -z "$NATIVE" ]; then
			echo
			echo "error: trying to crosscompile in a native tree"
			echo
			rm -f .build.cross
			exit 1
		else
			echo
			echo "error: trying to compile natively in a cross tree"
			echo
			rm -f .build.native
			exit 1
		fi
	fi
}

#
# usage()
#
usage() {
cat << EOF

PTXdist `printf "%-24s" ${FULLVERSION}` Build System for Embedded Linux Systems

  ptxdist <action [args]> [options]

Setup and Project Actions:

  setup                          setup per-user preferences
  boardsetup                     setup per-board preferences

  projects                       show available projects
  clone <from> <to>              create a new project, cloned from <from>.

  menuconfig                     configure the root filesystem
  oldconfig                      run 'make oldconfig' on ptxconfig file
  kernelconfig                   configure the kernel

  toolchain <path>               select this toolchain (path to binaries)
  select <config>                if there is no ptxconfig file you can
                                 select one of several configs to be used
Build Actions:

  go                             start building the current project

  get <package>                  get packet sources
  extract <package>              extract packet
  prepare <package>              run configure stages for packet
  compile <package>              compile the sources
  install <package>              install host side components into sysroot/
  targetinstall <package>        install files for target into root/
  clean <package>                cleanup packet
  autobuild                      search for "autobuild" scripts and run them
  drop <package>.<stage>         mark a stage of a packet as unbuilt

  images                         build images for target system

Clean Actions:

  clean                          cleanup build-host and build-cross dirs
  distclean                      cleanup everything
  (clean images)                 cleanup images directory
  clean root                     cleanup root directory for target
  (clean project)                cleanup project specific packages
  (clean maintainer)             maintainerclean

Misc

  run                            start a previously built native image

  --native                       build with native compiler instead of cross
  --version                      print out ptxdist version

  (svn up)                       run "svn update" in topdir and project dir
  (svn stat)                     run "svn stat" in topdir and project dir

  test <testname>                run tests

  newpacket <type>               create a new packet Makefile in a rules dir
                                 type can be one of host, target, cross

Environment:

  PREFIX=<path>                  build into this directory, instead of
			         building into PTXCONF_PREFIX from config

EOF
}

clean() {
	if [ "$1" = "root" ]; then
		echo
		echo "${PROMPT}cleaning root directory..."
		rm -fr ${ROOTDIR}
		rm -fr ${ROOTDIR_DEBUG}
		echo "${PROMPT}cleaning targetinstall stages..."
		rm -f ${STATEDIR}/*.targetinstall
		echo "${PROMPT}done."
		echo
		return
	fi

	if [ -n "$1" ]; then
		ptxd_make $1_clean
		return
	fi

	echo
	echo "${PROMPT}removing build directories..."
	rm -fr ${BUILDDIR}
	rm -fr ${CROSS_BUILDDIR}
	rm -fr ${HOST_BUILDDIR}
	echo "${PROMPT}removing deps..."
	rm -f depend.out deptree-a4.ps deptree.ps
	echo "${PROMPT}removing imagedir..."
	rm -fr ${IMAGEDIR}
	echo "${PROMPT}removing sysroot directory (local)..."
	rm -fr local
	echo "${PROMPT}removing sysroot..."
	rm -fr sysroot
	echo "${PROMPT}removing root..."
	rm -fr ${ROOTDIR}
	rm -fr ${ROOTDIR_DEBUG}
	echo "${PROMPT}removing state..."
	rm -fr ${STATEDIR}
	echo "${PROMPT}removing logfile..."
	rm -f logfile
	echo "${PROMPT}removing test logfile..."
	rm -f test.log
	echo "${PROMPT}removing cross/native marker..."
	rm -f .build.cross .build.native
	echo "${PROMPT}done."
	echo
}

drop() {
	local statefile
	if [ "$2" = "" ]; then
		statefile="$1"
	else
		statefile="$1.$2"
	fi

	echo
	if [ -e ${STATEDIR}/${statefile} ]; then
		rm -f ${STATEDIR}/${statefile}
		echo "dropping ${statefile}"
		echo
		exit 0
	else
		echo "stage ${statefile} isn't built, so we cannot drop it"
		echo
		exit 1
	fi
}

menuconfig_action() {
	echo "${PROMPT}menuconfig..."
	${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_KCONFIG}
}

newpacket () {
	local packet_name version url author year suffix overwrite \
	    template prefix packet_filename packet_name packet PACKET filename

	case $1 in
	    host|target|cross|source|kernel_driver)
		;;
	    *)	echo
		echo "${PROMPT}error: illegal packet type: $1"
		echo "must be one of host, target, cross, source, kernel_driver"
		echo
		exit 1 ;;
	esac

	echo
	echo "${PROMPT}creating a new packet:"
	echo
	echo -n "${PROMPT}enter packet name.......: "
	read packet_name
	echo -n "${PROMPT}enter version number....: "
	read version
	echo -n "${PROMPT}enter URL of basedir....: "
	read url
	echo -n "${PROMPT}enter packet author.....: "
	read author
	echo -n "${PROMPT}enter suffix............: "
	read suffix


	case $1 in
	    target)
		template=template
		prefix=
		;;
	    host)
		template=template-host
		prefix=host-
		;;
	    cross)
		template=template-cross
		prefix=cross-
		;;
	    source)
		template=template-src
		prefix=
		;;
	    kernel_driver)
		template=template-driver
		prefix=
		;;
	esac

	packet_filename="${packet_name}"
	packet_name="`echo ${packet_name} | tr - _`"

	packet="`echo ${packet_name} | tr \"[A-Z]\" \"[a-z]\"`"
	packet="${prefix}${packet}"
	PACKET="`echo ${packet_name} | tr \"[a-z]\" \"[A-Z]\"`"
	PACKET="`echo ${prefix} | tr \"[a-z-]\" \"[A-Z_]\"`${PACKET}"

	year=`date +%Y`

	filename="${prefix}${packet_filename}.make"

	if [ -f "${filename}" ]; then
		echo
		echo -n "${PROMPT}warning: ${filename} does already exist, overwrite? [y/n]"
		read overwrite
		if [ "$overwrite" != "y" ]; then
			echo "${PROMPT}aborted."
			echo
			exit 0
		fi
	fi

	sed \
		-e "s,\@packet_filename@,${packet_filename},g" \
		-e "s,\@PACKET@,${PACKET},g" \
		-e "s,\@packet@,${packet},g" \
		-e "s,\@VERSION@,${version},g" \
		-e "s,\@URL@,${url},g" \
		-e "s,\@YEAR@,${year},g" \
		-e "s,\@AUTHOR@,${author},g" \
		-e "s,\@SUFFIX@,${suffix},g" \
		${RULESDIR}/${template} \
		> ${filename}

}

oldconfig_action() {
	${PTXDIST_TOPDIR}/scripts/kconfig/conf -s ${PTXDIST_KCONFIG}
}

projects() {
	local ifs_old projects projectdir
	echo
	echo "${PROMPT}searching for projects:"
	ifs_old=$IFS
	IFS=:
	projects=
	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do
		echo "${PROMPT}scanning ${projectdir}..."
		projects="$projects $(cd ${projectdir} && find .  -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;)"
	done
	IFS=$ifs_old
	projects=$(echo $projects | sort -u)
	echo
	echo "---------------------- Available PTXdist Projects: ----------------------------"
	for i in $projects; do echo $i; done
	echo "-------------------------------------------------------------------------------"
	echo
}

setup() {
	local tmpdir

	echo
	echo "${PROMPT}setup..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see it's original environment
	ln -sf ${PTXDIST_TOPDIR}/scripts
	cp ${PTXDIST_TOPDIR}/config/setup/ptxdistrc.default .config
	if [ -f "$HOME/.ptxdistrc.${FULLVERSION}" ]; then
		echo "using \$HOME/.ptxdistrc.${FULLVERSION}"
		cp $HOME/.ptxdistrc.${FULLVERSION} .config
	fi

	# store ~/.ptxdistrc
	${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_TOPDIR}/config/setup/Kconfig
	echo "${PROMPT}saving \$HOME/.ptxdistrc.${FULLVERSION}"
	cp .config $HOME/.ptxdistrc.${FULLVERSION}

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}


clone() {
	local ifs_old projectdir

	if [ -z "$1" ]; then usage; exit 1; fi
	if [ -z "$2" ]; then usage; exit 1; fi

	if [ -d "$2" ]; then
		echo
		echo "${PROMPT}error: directory $2 does already exist"
		echo
		exit 1
	fi

	ifs_old=$IFS
	IFS=:

	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do

		echo "${PROMPT}scanning $projectdir..."

		if [ -d "${projectdir}/$1" ] ; then

			mkdir -p $2
			tar -C ${projectdir}/$1 -cf - \
			    --exclude .svn --exclude state --exclude debian . | \
			    tar -C $2 -xvf -

			echo "${PROMPT}done."
			echo
			return 0
		fi
	done
	IFS=$ifs_old

	echo "${PROMPT}project $1 is to be cloned, but could not be found"
	echo
}


#
# main()
#
if [ "$#" = "0" ]; then
	usage
	exit 0
fi

check_uid
check_path

while [ "$#" != "0" ]; do

	case $1 in
	autobuild)	echo
			echo "${PROMPT}running autobuild"
			echo
			AUTOBUILDS=$(find . -name "autobuild*" | grep -v .svn)
			AUTOBUILD_TOPDIR=$(pwd)
			exec 5>COMPILETEST
			echo >&5
			for i in $AUTOBUILDS; do
				pushd $(dirname $i)

				echo "config............: `basename \`pwd\``" >&5
				echo "date..............: `date`" >&5
				echo "user..............: ${USER}@${HOSTNAME}" >&5
				PTX_STARTTIME=`date +"%s"`

				./$(basename $i)

				PTX_RETVAL=$?
				PTX_STOPTIME=`date +"%s"`
				let "PTX_TIME=$PTX_STOPTIME-$PTX_STARTTIME"
				let "PTX_TIME_H=$PTX_TIME/3600"
				let "PTX_TIME_M=($PTX_TIME-$PTX_TIME_H*3600)/60"
				let "PTX_TIME_S=($PTX_TIME-$PTX_TIME_H*3600-$PTX_TIME_M*60)/60"
				echo "buildtime.........: ${PTX_TIME_H}h${PTX_TIME_M}m${PTX_TIME_S}s" >&5
				echo "result............: ${PTX_RETVAL}" >&5
				echo >&5

				[ -e "logfile" ] && mv logfile "${AUTOBUILD_TOPDIR}/`basename \`pwd\``.log"
				[ "${PTX_RETVAL}" = "0" ] && ${PTXDIST} distclean

				popd
			done
			echo
			echo "${PROMPT}done"
			echo
			exit 0
			;;
	boardsetup)	shift
			check_ptxconfig
			boardsetup
			;;
	compile)	shift
			if [ $# -eq 0 ]; then
				echo "${PROMPT}error: add target you want to compile"
				exit 1
			fi
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_compile 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	clean)		shift
			check_ptxconfig
			check_deps
			clean $1
			exit 0
			;;
	clone)		shift; clone $1 $2; exit 0;;
	-d|--debug)	shift
			export PTXDIST_MAKE_DBG="--debug=make"
			;;
	distclean)	shift
			clean
			echo "${PROMPT}removing toolchain link..."
			rm -f .toolchain
			echo "${PROMPT}removing logs dir..."
			rm -fr logs
			if [ -h "ptxconfig" ]; then
				echo "${PROMPT}removing ptxconfig link..."
				rm ptxconfig
			fi
			echo
			;;
	drop)		shift
			check_ptxconfig
			drop $1 $2
			;;
	extract)	shift
			check_ptxconfig
			check_native
			check_deps
			ptxd_make $1_extract 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	get)		shift
			check_ptxconfig
			check_native
			check_deps
			if [ $# -eq 0 ]; then
				ptxd_make get 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			else
				ptxd_make $1_get 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			fi
			;;
	go)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make world 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	help|--help)	shift; usage; exit 0; ;;
	images)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make images 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	install)	shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_install 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	kernelconfig)	shift
			check_ptxconfig
			check_native
			check_kernelconfig
			check_deps
			ptxd_make kernel_menuconfig
			;;
	maintainer)	shift
			if [ "$#" = "0" ]; then
				echo
				echo "${PROMPT} commands:"
				echo
				echo "${PROMPT} configversionbump"
				echo "${PROMPT} alloldconfig"
				echo
				exit 0
			fi
			case $1 in
			configversionbump)
				echo
				echo "${PROMPT} configversionbump:"
				echo
				for i in $(find . -name "ptxconfig*" | grep -v .svn); do
					echo "${PROMPT} version fixup in $i..."
					sed -i -e \
						"s/PTXCONF_CONFIGFILE_VERSION=\".*\"/PTXCONF_CONFIGFILE_VERSION=\"${FULLVERSION}\"/g" \
						$i
				done
				;;
			alloldconfig)
				echo
				echo "${PROMPT} alloldconfig:"
				echo
				for i in $(find . -name "autobuild" | grep -v .svn); do
					i_dir=$(dirname $i)
					echo i=$i i_dir=$i_dir
					pushd $i_dir
					ptxdist oldconfig
					popd
				done
				;;
			*)
				echo
				echo "${PROMPT} error: unknown command: $1"
				echo
				exit 1
				;;
			esac
			exit 0
			;;
	make)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	menuconfig)	shift
			check_ptxconfig
			ptxd_kconfig true menuconfig_action
			;;
	--native)	shift
			export NATIVE=1
			;;
	newpacket)	# test if we are in a rules dir
			if [ "`basename \`pwd\``" != "rules" ]; then
				echo
				echo "${PROMPT}error: newpacket command only allowed in a rules dir"
				echo
				exit 1
			fi
			shift
			newpacket "$1"
			exit $?
			;;
	oldconfig)	shift
			check_ptxconfig
			ptxd_kconfig true oldconfig_action
			;;
	prepare)	shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_prepare 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	print)		shift
			check_ptxconfig
			check_deps
			ptxd_make print-$1 2>&1 | tee -a logfile
			check_pipe_status
			shift
			;;
	projects)	shift
			projects
			;;
	run)		shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make world 2>&1 | tee -a logfile
			check_pipe_status
			RUN_ROOTMETHOD=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_ROOT_HOSTFS})
			RUN_CMDLINE=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_CMDLINE})
			if [ -n "${RUN_ROOTMETHOD}" ]; then
				RUN_CMDLINE="${RUN_CMDLINE} root=/dev/root rootflags=`pwd`/root rootfstype=hostfs"
			fi
			${PTXDIST_WORKSPACE}/images/linuximage ${RUN_CMDLINE}
			exit 0
			;;
	select)		shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "ptxconfig" ]; then
				echo
				echo "${PROMPT}error: There already is a ptxconfig file."
				echo "${PROMPT}error: If you really want to select another configuration,"
				echo "${PROMPT}error: please move away the ptxconfig file first."
				echo
				exit 1
			fi
			echo
			echo "${PROMPT}linking $1 to ptxconfig"
			rm -f ptxconfig
			ln -sf $1 ptxconfig
			echo "${PROMPT}done."
			echo
			exit 0
			;;
	setup)		shift; setup;;
	targetinstall)	shift
			check_ptxconfig
			check_native
			check_compiler
			check_dirs
			check_deps
			ptxd_make $1_targetinstall 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	test)		shift
			if [ -x "$PTXDIST_WORKSPACE/tests/$1" ]; then
				echo
				$PTXDIST_WORKSPACE/tests/$1 > ${PTXDIST_WORKSPACE}/test.log
				echo
			else if [ -x "$PTXDIST_TOPDIR/tests/$1" ]; then
				echo
				$PTXDIST_TOPDIR/tests/$1 > ${PTXDIST_WORKSPACE}/test.log
				echo
			else
				echo
				echo "${PROMPT}error: test $i not found in PTXDIST_TOPDIR and PTXDIST_WORKSPACE"
				echo
			fi
			fi
			exit 0
			;;
	toolchain)	shift
			echo
			if [ ! -d "$1" ]; then
				echo
				echo "${PROMPT}error: path $1 does not exist"
				echo
				exit 1
			fi
			echo "${PROMPT}using toolchain in $1"
			test -h ".toolchain" && rm -f .toolchain
			if [ -e ".toolchain" ]; then
				echo
				echo "${PROMPT}error: There is a .toolchain in this directory which is no link."
				echo "${PROMPT}error: This should never happen, please contact the"
				echo "${PROMPT}error: Pengutronix Department of Illegal File Removement."
				echo
				exit 1
			fi
			ln -sf $1 .toolchain
			echo
			exit 0
			;;
	--version)	echo ${FULLVERSION}
			exit 0
			;;
	*)		shift
			usage
			exit 0
			;;
	esac

done

exit 0

