#!/bin/bash

export LANG=C
export LC_ALL=POSIX
export LC_CTYPE=POSIX
export CDPATH=

PTXDIST_ARGS_FULL=("${@}")
PROMPT="ptxdist: "

#
# defaults
#
PTXDIST_PTXCONFIG_DEFAULT='${PTXDIST_WORKSPACE}/selected_ptxconfig'
PTXDIST_PLATFORMCONFIG_DEFAULT='${PTXDIST_WORKSPACE}/selected_platformconfig'
PTXDIST_TOOLCHAIN_DEFAULT='${PTXDIST_WORKSPACE}/selected_toolchain'
PTXDIST_PTXRC_DEFAULT='${HOME}/.ptxdistrc.${PTXDIST_VERSION_FULL}'
PTXDIST_PACKAGES_COLLECTION_DEFAULT="ALL"

PTXDIST_KGEN_DIR='${PTXDIST_TEMPDIR}/kgen'


#
# menu_select
#
# start file chooser and actual "select function"
#
# ${1}	specifies what to select {ptxconfig,platformconfig}
#
menu_select() {
	local config="${1}"
	local "${config}"

	check_nonstandard "${config}" || return
	ptxd_dialog_fselect "${config}" || return

	do_select "${config}" "${!config}"
}


#
# le menu
#
menu() {
	local kernel_version="$(ptxd_get_ptxconf PTXCONF_KERNEL_VERSION)"
	local u_boot_v2_version="$(ptxd_get_ptxconf PTXCONF_U_BOOT_V2_VERSION)"
	local platform="$(ptxd_get_ptxconf PTXCONF_PLATFORM)"
	local ptxconfig cmd

	kernel_version="${kernel_version:-none}"
	u_boot_v2_version="${u_boot_v2_version:-none}"

	ptxconfig="$(readlink -e "${PTXDIST_PTXCONFIG}")"
	ptxconfig="${ptxconfig#${PTXDIST_WORKSPACE}/}"

	if [ -z "${platform}" -a -e "${PTXDIST_PLATFORMCONFIG}" ]; then
		platform="$(readlink -e "${PTXDIST_PLATFORMCONFIG}")"
		platform="${platform#${PTXDIST_WORKSPACE}/}"
	fi

	exec 3>&1
	exec 4>&1
	cmd="$(${PTX_DIALOG} \
		--clear \
		--title "PTXdist Main Menu" \
		--output-fd 3 \
		--default-item "${_ptxdist_menu_cmd}" \
		--cancel-label "Exit" \
		--menu "" 0 0 0 \
		-- \
		"menuconfig"		"Configure Software Platform" \
		"platformconfig"	"Configure Hardware Platform" \
		"kernel"		"Configure Kernel (${kernel_version})" \
		"u-boot-v2"		"Configure U-Boot-v2 (${u_boot_v2_version})" \
		"--------------"	"--------------------------------------------" \
		"select"		"Select Software Platform (${ptxconfig})" \
		"platform"		"Select Hardware Platform (${platform})" \
		"--------------"	"--------------------------------------------" \
		"boardsetup"		"Configure Board Properties" \
		"setup"			"Configure User Properties" \
		3>&1 1>&4 \
		)" || return
	exec 4>&-
	exec 3>&-
	_ptxdist_menu_cmd="${cmd}"

	case "${cmd}" in
	menuconfig)	cmd=ptx ;;
	platformconfig)	cmd=platform ;;
	select)		cmd=ptxconfig ;;
	platform)	cmd=platformconfig ;;
	boardsetup)	cmd=board ;;
	setup)		cmd=user ;;
	esac

	case "${cmd}" in
	platformconfig|ptxconfig)
		menu_select "${cmd}"
		;;

	ptx|platform|kernel|u-boot-v2|board|user)
		do_config menuconfig "${cmd}"
		# FIXME: reread user config file
		;;
	-*)
		# ignore the "--------------"
		;;
	*)
		echo "${cmd}"
		read
		;;
	esac

	return 0
}



#
# check a ptxdist version against a configfile version.
#
# - The ptxdist major version has to be equal to the configfile major version
# - The ptxdist minor version has to be equal to the configfile minor version
# - The ptxdist micro version has to greater than or equal to the configfile
#   micro version
# - If the configfile has no micro version stop here and assume
#   everything is ok (this means '1.0' 'can build with 1.0.x').
#
check_version() {
	local ifs_old="${IFS}"
	IFS=.
	set -- ${1}
	IFS="${ifs_old}"

	local config_major="${1}"
	local config_minor="${2}"
	local config_micro="${3}"

	if   [ "${PTXDIST_VERSION_MAJOR}" != "${config_major}" ]; then
		return 1
	elif [ "${PTXDIST_VERSION_MINOR}" != "${config_minor}" ]; then
		return 1
	elif [                            -z "${config_micro}" -o \
	       "${PTXDIST_VERSION_MICRO}"  = "${config_micro}" ]; then
		return 0
	elif [ ${PTXDIST_VERSION_MICRO}  -ge  ${config_micro} ] >/dev/null 2>&1; then
		return 0	# fails if one is "svn"
	fi

	return 1
}



#
# check if user has used --toolchain, --ptxconfig, --platformconfig
#
check_nonstandard() {
	local nonstandard_set="PTX_${1}_SET"

	if [ "${!nonstandard_set}" = "true" ]; then
		ptxd_dialog_msgbox "error: cannot select ${1} when using the '--${1}' feature"
		return 1
	elif [ -z "${!nonstandard_set}" ]; then
		echo
		echo "${PROMPT}error: invalid use of '${FUNCNAME} ${@}'"
		echo
		exit 1
	fi
}


#
# Check for existence of a ptxconfig file
# check_ptxconfig()
#
check_ptxconfig() {
	if [ ! -e "${PTXDIST_PTXCONFIG}" ]; then
		ptxd_dialog_msgbox \
			"error: '${PTXDIST_PTXCONFIG#${PTXDIST_WORKSPACE}/}' file is missing\n" \
			"	try 'ptxdist select <ptxconfig>' or\n" \
			"	'ptxdist clone <project>' to clone an existing project"
		return 1
	fi

	if [ ! -e "${PTXDIST_PLATFORMCONFIG}" ]; then
		ptxd_dialog_msgbox \
			"error: '${PTXDIST_PLATFORMCONFIG#${PTXDIST_WORKSPACE}/}' is missing\n" \
			"	try 'ptxdist platform <platformconfig>'"
		return 1
	fi

	local configfile_version="$(ptxd_get_ptxconf PTXCONF_CONFIGFILE_VERSION)"

	check_version "${configfile_version}"
	if [ ${?} -ne 0 -a -z "${PTX_FORCE}" ]; then
		ptxd_dialog_msgbox \
			"error: The configfile version and ptxdist version do not match:\n" \
			"\n" \
			"	configfile version: ${configfile_version}\n" \
			"	ptxdist version:    ${PTXDIST_VERSION_FULL}\n" \
			"\n" \
			"	If you are absolutely sure, please add '--force'\n" \
			"	to ptxdist's parameters, e.g.:\n" \
			"\n" \
			"	'ptxdist --force ${PTXDIST_ARGS_FULL[*]}'"
		return 1
	fi
}



#
# abort if ptxdist is run as root
#
check_uid() {
	if [ ${UID} -eq 0 ]; then
		echo
		echo "${PROMPT}error: refusing to run PTXdist as root"
		echo
		exit 1
	fi
}



#
# check if "." is in the PATH
#
check_path() {
	case "${PATH}" in
	.:*)
		echo
		echo "${PROMPT}error: '.' in your \$PATH detected, please remove it!"
		echo
		exit 1
		;;
	*)
		;;
	esac
}



#
# Check for defined compiler
# This only should be done when we build userland (chicken egg problem)
#
check_compiler() {
	local build_toolchain="$(ptxd_get_ptxconf PTXCONF_BUILD_TOOLCHAIN)"

	[ -n "$build_toolchain" ] && return

	#
	# Three things should be checked
	# 1) Correct compiler name
	# 2) Correct vendor if the vendor string is given
	# 3) Correct compiler version if a specific compiler version is given
	#

	local compiler="$(ptxd_get_ptxconf PTXCONF_COMPILER_PREFIX)gcc"
	local vendor_should="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_VENDOR)"

	if [ -n "${vendor_should}" ]; then
		# yea! A toolchain vendor was specified in the ptxconfig file.
		# So we check for a 'ptxconfig' file in the toolchain directory
		# and test the PTXCONF_PROJECT string therein.

		if [ ! -d "${PTXDIST_TOOLCHAIN}" ]; then
			echo
			echo "${PROMPT}error: specify '${PTXDIST_TOOLCHAIN#${PTXDIST_WORKSPACE}/}' with 'ptxdist toolchain [<path>]'"
			echo "${PROMPT}error: or leave PTXCONF_CROSSCHAIN_VENDOR empty to disable toolchain check"
			echo
			exit 1
		fi

		local vendor_def="$(readlink -f "${PTXDIST_TOOLCHAIN}/ptxconfig")"
		if [ -z "${vendor_def}" -o \! -e "${vendor_def}" ]; then
			echo
			echo "${PROMPT}error: toolchain doesn't point to an OSELAS.Toolchain"
			echo "${PROMPT}error: set PTXCONF_CROSSCHAIN_VENDOR to disable toolchain version check"
			echo
			exit 1
		else
			# both vendor strings are present. Check them
			local vendor_is="$(. ${vendor_def} && echo ${PTXCONF_PROJECT})"
			if [ "$vendor_is" != "$vendor_should" ]; then
				echo
				echo "${PROMPT}error: wrong toolchain vendor: Cannot continue! Vendor is '${vendor_is}',"
				echo "${PROMPT}error: specified: ${vendor_should}"
				echo "${PROMPT}error: found:	 ${vendor_is}"
				echo
				exit 1
			fi
		fi
	fi

	local compiler_should="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_CHECK)"
	local compiler_is="$(${compiler} -dumpversion 2> /dev/null || true)"

	if [ -z "${compiler_is}" ]; then
		echo
		echo "${PROMPT}error: Compiler '${compiler}' not found. Check PATH or"
		echo "${PROMPT}error: use 'ptxdist toolchain [</path/to/toolchain>]'."
		echo
		exit 1
	fi

	if [ "${compiler_is}" != "${compiler_should}" ]; then
		echo
		echo "${PROMPT}error: Compiler version ${compiler_should} expected,"
		echo "${PROMPT}error: but ${compiler_is} found."
		echo
		exit 1
	fi
}



#
# checks if the dependencies are allright (make for the poor)
#
check_deps() {
	ptxd_kgen || ptxd_bailout "error in kgen"
	"${SCRIPTSDIR}/dgen.sh" || ptxd_bailout "error in dgen.sh"
#	ptxd_create_autoconf_cache "${STATEDIR}/autoconf.cache" || ptxd_bailout "error in create_config_cache.sh"
	touch "${STATEDIR}/autoconf.cache"
}



check_dirs_prefix() {
	local testfile

	local prefix="${1}"

	if [ -z "${prefix}" ]; then
		echo
		echo
		echo "${PROMPT}check_dirs_prefix(): error prefix is not defined"
		echo
		echo
		exit 1
	fi

	if echo "${prefix}" | grep -q " "; then
		echo
		echo "error: some important dir ('${prefix}')"
		echo "	     contains spaces, this will probably not work, sorry"
		echo
		exit 1
	fi

	if [ ! -d "${prefix}" ]; then
		mkdir -p "${prefix}" 2> /dev/null
		if [ ${?} -ne 0 ]; then
			echo
			echo "error: '${prefix}'"
			echo "	     does not exist and cannot be created!"
			echo "	     Please create that dir with write permissions for you."
			echo
			read -t 5 -p "press enter to let sudo do that job!"
			if [ ${?} -ne 0 ]; then
				echo
				exit 1
			fi
			echo
			echo sudo mkdir -p "${prefix}"
			sudo mkdir -p "${prefix}"
			echo
			echo sudo chown $UID "${prefix}"
			sudo chown $UID "${prefix}"
		fi
	fi

	testfile="${prefix}/.secret-world-domination-project"
	touch "${testfile}" 2> /dev/null
	if [ ${?} -ne 0 ]; then
		echo
		echo "error: '${prefix}'"
		echo "	     does exist, but is not writeable."
		echo "	     Change the permissions and try again."
		echo
		read -t 5 -p "press enter to let sudo do the job!"
		if [ ${?} -ne 0 ]; then
			echo
			exit 1
		fi
		echo
		echo sudo chown $UID "${prefix}"
		sudo chown $UID "${prefix}"
		echo sudo chmod u+w "${prefix}"
		sudo chmod u+w "${prefix}"

		touch "${testfile}" 2> /dev/null
		if [ ${?} -ne 0 ]; then
			echo
			echo "error: cannot make '${prefix}' writeable, giving up"
			echo
			exit 1
		fi
	fi

	rm "${testfile}"

	mkdir -p "${prefix}"/{etc,lib,{,s}bin,include,{,share/}man/man{1,2,3,4,5,6,7,8,9}}
}


#
# Most install stages think that some standard directories are there, so
# they are created here.
#
check_dirs() {
	local ptxconf_sysroot_target ptxconf_sysroot_host ptxconf_sysroot_cross
	local dir testfile_upper testfile_lower

	ptxconf_sysroot_host="$(ptxd_get_ptxconf PTXCONF_SYSROOT_HOST)"
	ptxconf_sysroot_cross="$(ptxd_get_ptxconf PTXCONF_SYSROOT_CROSS)"
	ptxconf_sysroot_target="$(ptxd_get_ptxconf PTXCONF_SYSROOT_TARGET)"

	# check for r/w and create standard directory layout
	for dir in \
		"${ptxconf_sysroot_host}" \
		"${ptxconf_sysroot_cross}" \
		"${ptxconf_sysroot_target}" \
		"${ptxconf_sysroot_target}/usr" \
		; do
		check_dirs_prefix "${dir}"
	done

	# create build and output dirs
	for dir in \
		"${BUILDDIR}" \
		"${CROSS_BUILDDIR}" \
		"${HOST_BUILDDIR}" \
		"${STATEDIR}" \
		"${IMAGEDIR}" \
		"${ROOTDIR}" \
		"${ROOTDIR_DEBUG}" \
		"${PTXDIST_SRCDIR}" \
		; do
		if [ \! -d "${dir}" ]; then
			mkdir -p "${dir}" || ptxd_bailout "cannot create dir: ${dir}"
		fi
	done

	# check for case sensitive file system
	for dir in \
		"${BUILDDIR}" \
		"${CROSS_BUILDDIR}" \
		"${HOST_BUILDDIR}" \
		; do
		testfile_lower="${dir}/.secret-world-domination-project"
		testfile_upper="${dir}/.Secret-World-Domination-Project"

		echo lower > "${testfile_lower}"
		echo upper > "${testfile_upper}"

		if [ "$(cat "${testfile_lower}")" != "lower" -o \
		    "$(cat "${testfile_upper}")" != "upper" ]; then
			echo
			echo "error: '${dir}'"
			echo "	     is not a case sensitive filesystem."
			echo "	     Please move your project to a case sensitive one"
			echo
			exit 1
		fi

		rm "${testfile_lower}" "${testfile_upper}"
	done
}



check_if_selected() {
	if [ -z "${1}" ]; then
		echo
		echo "${PROMPT}error: please specify a target"
		echo
		exit 1
	fi

	local configvar="PTXCONF_$(ptxd_name_to_NAME "${1}")"
	local ptxconfig_configvar="$(ptxd_get_ptxconf "${configvar}")"

	if [ -z "${ptxconfig_configvar}" ]; then
		ptxd_dialog_msgbox \
			"${PROMPT}error: '${1}' is not selected in\n" \
			"	${PTXDIST_PTXCONFIG}"
		return 1
	fi
}


clone() {
	local projectdir

	if [ -d "$2" ]; then
		echo
		echo "${PROMPT}error: directory $2 does already exist"
		echo
		exit 1
	fi

	local ifs_old="${IFS}"
	IFS=:

	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do

		echo "${PROMPT}scanning $projectdir..."

		if [ -d "${projectdir}/$1" ] ; then

			mkdir -p "${2}"
			tar -C "${projectdir}/${1}" -cf - \
			    --exclude .svn --exclude state --exclude debian . | \
			    tar -C "${2}" -xvf -

			echo "${PROMPT}done."
			echo
			IFS="${ifs_old}"
			return 0
		fi
	done
	IFS="${ifs_old}"

	echo "${PROMPT}project $1 is to be cloned, but could not be found"
	echo
}


#
# usage()
#
usage() {
cat << EOF

PTXdist $(printf "%-24s" ${PTXDIST_VERSION_FULL}) Build System for Embedded Linux Systems

  ptxdist <action [args]> [options]

Setup and Project Actions:

  menu				enter main control menu

  setup				setup per-user preferences
  boardsetup			setup per-board preferences

  projects			show available projects
  clone <from> <to>		create a new project, cloned from <from>.

  menuconfig			configure the project's filesystem

  menuconfig kernel
  kernelconfig			configure the kernel

  menuconfig platform
  platformconfig		configure the platform

  oldconfig			run 'make oldconfig' on ptxconfig file

  menuconfig u-boot-v2		configure U-Boot (U-Boot V2 only)
  u_boot_config

  toolchain [<path>]		if path is omitted the toolchain is guessed,
				    (guessing works only if platformconfig is
				    already selected)
				otherwise select this toolchain
				    (<path> to binaries)
  select <config>		if there is no selected_ptxconfig file you can
				select one of several project configs to be used
  platform <config>		if there is no selected_platform file you can
				select one of several platform configs to be used
Build Actions:

  go				start building the current project

  get <package>			get packet sources
  extract <package>		extract packet
  prepare <package>		run configure stages for packet
  compile <package>		compile the sources
  install <package>		install host side components into sysroot/
  targetinstall <package>	install files for target into root/
  clean <package>		cleanup packet
  autobuild			search for "autobuild" scripts and run them
  drop <package>.<stage>	mark a stage of a packet as unbuilt
  tags <package>		try to build tags of the packet

  images			build images for target system

Clean Actions:

  clean				cleanup build-host and build-cross dirs
  clean root			cleanup root directory for target
  distclean			cleanup everything

Overwrite:

  --ptxconfig			use specified ptxconfig
  --platformconfig		use specified platformconfig
  --toolchain			use specified toolchain
  --force			select config even if MOJO is missing
				or versions do not match
Misc:

  --version			print out ptxdist version

  test <testname>		run tests

  newpacket <type>		create a new packet Makefile in a rules dir
				<type> can be one of:
				target, host, host-existing-target,
				cross, cross-existing-target, source,
				kernel_driver, font, simple
  print <var>			print the contents of a variable, in the way
				it is known by "make"
Options:

  -d				print out make decisions (debug)
  --quiet, -q			suppress output, show only stderr

  --j-intern=<n>, -ji<n>	set number of parallel builds in packages
				(default = 2*CPUs)
  --j-extern=<n>, -je<n>	set number of packages built in parallel
				(default = 1)

EOF
}

clean() {
	local dir bdir
	local ptxconf_sysroot_target ptxconf_sysroot_host ptxconf_sysroot_cross

	# we want to clean the root dir
	if [ "${1}" = "root" ]; then
		echo
		echo "${PROMPT}cleaning root directory..."
		rm -fr "${ROOTDIR}"
		rm -fr "${ROOTDIR_DEBUG}"
		echo "${PROMPT}cleaning targetinstall stages..."
		rm -f "${STATEDIR}"/*.targetinstall*
		echo "${PROMPT}done."
		echo
		return
	fi

	# we want to clean a single package
	if [ -n "${1}" ]; then
		check_if_selected "${1}" || return
		ptxd_make_log "${1}_clean"
		return
	fi

	echo
	echo "${PROMPT}removing build directories..."
	for dir in "${BUILDDIR}" "${CROSS_BUILDDIR}" "${HOST_BUILDDIR}"; do
		if [ ! -d "${dir}" ]; then
			continue
		fi
		for bdir in $(find "${dir}" -maxdepth 1 -mindepth 1 -type l); do
			# run 'make clean' for linked source directories
			pushd "${bdir}" > /dev/null
			echo -n "${PROMPT}running 'make clean' in '${bdir#${dir}/}'... "
			make clean 1> /dev/null 2>&1
			echo "done"
			popd > /dev/null
		done
		rm -fr "${dir}"
	done

	if [ -f "${PTXDIST_PTXCONFIG}" ]; then
		echo "${PROMPT}removing sysroot directories..."
		ptxconf_sysroot_target="$(ptxd_get_ptxconf PTXCONF_SYSROOT_TARGET)"
		ptxconf_sysroot_host="$(ptxd_get_ptxconf PTXCONF_SYSROOT_HOST)"
		ptxconf_sysroot_cross="$(ptxd_get_ptxconf PTXCONF_SYSROOT_CROSS)"

		for dir in "${ptxconf_sysroot_target}" "${ptxconf_sysroot_host}" "${ptxconf_sysroot_cross}"; do
			if [ ! -d "${dir}" ]; then
				continue
			fi
			#
			# remove the dir only if it is inside the workspace; if we for
			# example build toolchains or production builds to /opt/...,
			# we don't want to clean them here!
			#
			case "${dir}" in
			(${PTXDIST_WORKSPACE}/*)
				rm -fr "${dir}"
				;;
			(*)
				;;
			esac
		done
	fi

	echo "${PROMPT}removing deps..."
	rm -f "${PTXDIST_PLATFORMDIR}/"{deptree-a4.ps,deptree.ps}
	rm -f "${STATEDIR}/depend.out"
	echo "${PROMPT}removing imagedir..."
	rm -fr "${IMAGEDIR}"
	echo "${PROMPT}removing root..."
	rm -fr "${ROOTDIR}"
	rm -fr "${ROOTDIR_DEBUG}"
	echo "${PROMPT}removing state..."
	rm -fr "${STATEDIR}"
	echo "${PROMPT}removing logfile..."
	rm -f "${PTX_LOGFILE}"
	echo "${PROMPT}removing test logfile..."
	rm -f "${PTXDIST_PLATFORMDIR}/test.log"
	echo "${PROMPT}removing packages dir..."
	rm -fr "${PKGDIR}"

	# remove the remaining PTXDIST_PLATFORMDIR (if empty)
	rmdir "${PTXDIST_PLATFORMDIR}" > /dev/null 2>&1

	echo "${PROMPT}done."
	echo
}

drop() {
	local statefile

	if [ -z "$2" ]; then
		statefile="${1}"
	else
		statefile="${1}.${2}"
	fi

	echo
	if [ -e "${STATEDIR}/${statefile}" ]; then
		rm -f "${STATEDIR}/${statefile}"
		echo "dropping ${statefile}"
		echo
		exit
	else
		echo "stage ${statefile} isn't built, so we cannot drop it"
		echo
		exit 1
	fi
}


newpacket() {
	local packet_name version url author year suffix overwrite \
	    template template_file template_suffix packet_filename packet_name packet PACKET packetdash filename \
	    class CLASS autoconf_class

	case "$1" in
	target)
		template=template
		class=
		autoconf_class=
		;;
	host)
		template=template-class
		class=host-
		autoconf_class=HOST_
		;;
	cross)
		template=template-class
		class=cross-
		autoconf_class=HOST_CROSS_
		;;
	host-existing-target)
		template=template-class-existing-target
		class=host-
		autoconf_class=HOST_
		;;
	cross-existing-target)
		template=template-class-existing-target
		class=cross-
		autoconf_class=HOST_CROSS_
		;;
	source)
		template=template-src
		class=
		autoconf_class=
		;;
	kernel_driver)
		template=template-driver
		class=
		autoconf_class=
		;;
	font)
		template=template-font
		class=
		autoconf_class=
		;;
	simple)
		template=template-file
		class=
		autoconf_class=
		;;
	*)
		echo
		echo "${PROMPT}error: illegal packet type: $1"
		echo "must be one of host, host-existing-target, target,"
		echo "cross, cross-existing-target, source, kernel_driver, font, simple"
		echo
		exit 1
		;;
	esac

	echo
	echo "${PROMPT}creating a new packet:"
	echo
	echo -n "${PROMPT}enter packet name.......: "
	read packet_name
	echo -n "${PROMPT}enter version number....: "
	read version
	echo -n "${PROMPT}enter URL of basedir....: "
	read url
	echo -n "${PROMPT}enter packet author.....: "
	read author
	echo -n "${PROMPT}enter suffix............: "
	read suffix

	packet_filename="${packet_name}"

	packet="$(echo ${packet_name} | tr "[A-Z]" "[a-z]")"
	packetdash="$(echo ${packet} | tr "[_]" "[\-]")"
	PACKET="$(echo ${packet_name} | tr "[a-z-]" "[A-Z_]")"
	CLASS="$(echo ${class} | tr "[a-z-]" "[A-Z_]")"

	year="$(date +%Y)"

	for template_suffix in "make" "in"; do
		template_file="${TEMPLATESDIR}/${template}-${template_suffix}"
		filename="${class}${packet_filename}.${template_suffix}"

		if [ ! -f "${template_file}" ]; then
			echo
			echo "${PROMPT}warning: template '${template_file}' does not exist"
			echo
			continue
		fi

		if [ -f "${filename}" ]; then
			echo
			echo -n "${PROMPT}warning: ${filename} does already exist, overwrite? [y/n]"
			read overwrite
			if [ "$overwrite" != "y" ]; then
				echo "${PROMPT}aborted."
				echo
				exit
			fi
		fi

	    sed \
		-e "s#\@packet_filename@#${packet_filename}#g" \
		-e "s#\@PACKET@#${PACKET}#g" \
		-e "s#\@packet@#${packet}#g" \
		-e "s#\@packetdash@#${packetdash}#g" \
		-e "s#\@class@#${class}#g" \
		-e "s#\@CLASS@#${CLASS}#g" \
		-e "s#\@AUTOCONF_CLASS@#${autoconf_class}#g" \
		-e "s#\@VERSION@#${version}#g" \
		-e "s#\@URL@#${url}#g" \
		-e "s#\@YEAR@#${year}#g" \
		-e "s#\@AUTHOR@#${author}#g" \
		-e "s#\@SUFFIX@#${suffix}#g" \
		"${template_file}" \
		> "${filename}"
	done
}


projects() {
	local ifs_old projects projectdir
	echo
	echo "${PROMPT}searching for projects:"
	ifs_old="$IFS"
	IFS=:
	projects=
	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do
		echo "${PROMPT}scanning ${projectdir}..."
		if [ ! -d ${projectdir} ]; then
			echo
			echo "${PROMPT}error: directory does not exist"
			echo "${PROMPT}please check PTXCONF_SETUP_PROJECTPATH in 'ptxdist setup'"
			exit 1
		fi
		projects="$projects $(cd ${projectdir} && find .  -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;)"
	done
	IFS=$ifs_old
	projects=$(echo $projects | sort -u)
	echo
	echo "---------------------- Available PTXdist Projects: ----------------------------"
	for i in $projects; do echo $i; done
	echo "-------------------------------------------------------------------------------"
	echo
}



##################################################################
################ "minusminus" option parser ######################
##################################################################

parse_first()
{
	local arg

	#
	# sane defaults
	#
	PTXDIST_TOOLCHAIN="${PTXDIST_TOOLCHAIN_DEFAULT}"
	PTXDIST_PLATFORMCONFIG="${PTXDIST_PLATFORMCONFIG_DEFAULT}"
	PTXDIST_PTXCONFIG="${PTXDIST_PTXCONFIG_DEFAULT}"
	PTXDIST_PACKAGES_COLLECTION="${PTXDIST_PACKAGES_COLLECTION_DEFAULT}"

	#
	# init these ones
	#
	PTX_ptxconfig_SET="false"
	PTX_platformconfig_SET="false"
	PTX_toolchain_SET="false"

	set -- "${PTXDIST_ARGS_FULL[@]}"
	while [ ${#} -ne 0 ]; do
		arg="${1}"
		shift

		case "${arg}" in
		-d|--debug)
			PTX_MAKE_DBG="--debug=make"
			;;
		-f|--force)
			PTX_FORCE=true
			;;
		--ptxconfig=*)
			PTXDIST_PTXCONFIG="$(ptxd_abspath "${arg#*=}")"
			PTX_ptxconfig_SET=true
			;;
		--platformconfig=*)
			PTXDIST_PLATFORMCONFIG="$(ptxd_abspath "${arg#*=}")"
			PTX_platformconfig_SET=true
			;;
		--toolchain=*)
			PTXDIST_TOOLCHAIN="$(ptxd_abspath "${arg#*=}")"
			PTX_toolchain_SET=true
			;;
		--packages=all)
			PTXDIST_PACKAGES_COLLECTION="ALL"
			;;
		--packages=base)
			PTXDIST_PACKAGES_COLLECTION="BASE"
			;;
		--j-intern=*)
			PTXDIST_PARALLELMFLAGS_INTERN="-j${arg#*=}"
			;;
		-ji*)
			PTXDIST_PARALLELMFLAGS_INTERN="-j${arg#*i}"
			;;
		--j-extern=*)
			PTXDIST_PARALLELMFLAGS_EXTERN="-j${arg#*=}"
			;;
		-je*)
			PTXDIST_PARALLELMFLAGS_EXTERN="-j${arg#*e}"
			;;
		-q|--quiet)
			PTXDIST_QUIET=1
			;;
		*)
			PTXDIST_ARGS_SECOND[${#PTXDIST_ARGS_SECOND[@]}]="${arg}"
			;;
		esac
	done
}


##################################################################
################ do_* ############################################
##################################################################

#
# calls menu/old config on several components
#
# $1	what kind of config ("menuconfig", "oldconfig")
# $2	what to "config"
#
do_config()
{
	local config="${1}"
	local part="${2}"

	if [ "${part}" != "user" ]; then
		check_ptxconfig || return
	fi

	case "${config}" in
	"menuconfig"|"oldconfig")
		;;
	*)
		echo
		echo "${PROMPT}error: invalid use of '${FUNCNAME} ${@}'"
		echo
		exit 1
		;;
	esac

	case "${part}" in
	"ptx"|"ptxdist"|"")
		ptxd_kconfig "${config}" "ptx"
		;;

	"platform"|"board"|"user")
		ptxd_kconfig "${config}" "${part}"
		;;

	*)
		check_if_selected "${part}" || return

		ptxd_dialog_infobox "${PROMPT}Checking dependencies. This may take some seconds."
		check_deps

		ptxd_make "${part}_${config}"
	esac


	if [ $? -ne 0 -a -n "${PTX_MENU}" ]; then
		echo
		echo "${PROMPT}'${part} ${config}' returned with an error"
		echo
		read
	fi

}


#
# do_select:
#
# select a configfile, do sanity checks, etc
#
# ${1}: type of config file {ptxconfig,platformconfig}
# ${2}: the actual config file
#
do_select()
{
	local type="${1}"
	local file="${2}"
	local dest_ptr="PTXDIST_$(echo "${type}" | tr 'a-z' 'A-Z')"
	local dest_file="$(readlink -e ${!dest_ptr})"
	local magic="PTXCONF__${type}_MAGIC__=y"

	check_nonstandard "${type}" || return

	# check if magic is present in config file
	if ! egrep -q "^${magic}$" "${file}" && [ -z "${PTX_FORCE}" ]; then
		ptxd_dialog_msgbox \
			"error: Couldn't verify(1) that\n" \
			"	'${file}'\n" \
			"	is a valid ${type} file.\n" \
			"	If you are absolutely sure, please add '--force'\n" \
			"	to ptxdist's parameters, e.g.:\n" \
			"\n" \
			"	'ptxdist --force ${PTXDIST_ARGS_FULL[*]}'\n" \
			"\n" \
			"	(1) it appears not to have the right MOJO."
		return 1
	fi

	if [ ! -f "${file}" ]; then
		ptxd_dialog_msgbox \
			"error: cannot select\n" \
			"	'${file}'\n" \
			"	file does not exist"
		return 1
	elif [ -e "${!dest_ptr}" -a \! -L "${!dest_ptr}" ]; then
		ptxd_dialog_msgbox \
			"error: '${!dest_ptr}'\n" \
			"	is not a link thus ${type} is not selectable!"
		return 1
	fi

	ln -sf "${file}" "${!dest_ptr}"
	ptxd_dialog_msgbox \
		"info: selected ${type}:\n" \
		"      '${file}'"

	#
	# try to guess toolchain
	#
	case "${type}" in
	platformconfig)
		if [ "${PTX_toolchain_SET}" != "true" ]; then
			do_select_toolchain
		fi
		;;
	*)
		;;
	esac

	#
	# re-read config files and
	# export changed variables
	#
	setup_platform
	setup_path
	setup_logfile
	setup_export
}



do_select_toolchain() {
	local toolchain="${1}"

	check_nonstandard "toolchain" || return

	#
	# guess the toolchain if path is omitted
	#
	if [ -z "${toolchain}" ]; then
		if [ ! -e "${PTXDIST_PLATFORMCONFIG}" ]; then
			ptxd_dialog_msgbox \
				"error: cannot guess toolchain, no platform selected.\n" \
				"	try 'ptxdist platform <platformconfig>' first\n" \
				"	or use 'ptxdist toolchain </path/to/toolchain>'"
			return 1
		fi

		local vendor="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_VENDOR)"
		local target="$(ptxd_get_ptxconf PTXCONF_GNU_TARGET)"
		local version="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_CHECK)"

		local hint="/opt/${vendor}/${target}/gcc-${version}-*/bin"

		if [ -z "${vendor}" -o \
		    -z "${target}" -o \
		    -z "${version}" ]; then
			ptxd_dialog_msgbox \
				"info: insufficient information in your ptxconfig file\n" \
				"      please use 'ptxdist toolchain </path/to/toolchain>' to select your toolchain"
			return 1
		fi
		# let the shell expand the "*" in the hint, put it into an array
		toolchain=($(echo ${hint}))

		# number of items in array == number of found toolchains
		local num="${#toolchain[@]}"

		if [ ${num} -eq 0 ]; then
			ptxd_dialog_msgbox \
				"error: sorry, no toolchain found, matching\n" \
				"	${hint}"
			return 1
		elif [ ${num} -ne 1 ]; then
			local old_ifs="${IFS}"
			IFS="
"
			toolchain="${toolchain[*]}"
			IFS="${old_ifs}"

			ptxd_dialog_msgbox \
				"error: more than one toolchain found, matching\n" \
				"	'${hint}':\n\n" \
				"${toolchain}"
			return 1
		fi
	fi

	if [ ! -d "${toolchain}" ]; then
		ptxd_dialog_msgbox "error: path ${toolchain} does not exist!"
		return 1
	fi

	ptxd_dialog_msgbox \
		"found and using toolchain:\n" \
		"'${toolchain}'"

	if [ -L "${PTXDIST_TOOLCHAIN_DEFAULT}" ]; then
		rm -f "${PTXDIST_TOOLCHAIN_DEFAULT}"
	elif [ -e "${PTXDIST_TOOLCHAIN_DEFAULT}" ]; then
		ptxd_dialog_msgbox \
			"error: There is a '${PTXDIST_TOOLCHAIN#${PTXDIST_WORKSPACE}/}' in this directory which is no link.\n" \
			"	This should never happen, please contact the\n" \
			"	Pengutronix Department of Illegal File Removement."
		exit 1
	fi

	ln -sf "${toolchain}" "${PTXDIST_TOOLCHAIN_DEFAULT}"
}


##################################################################
################ normal option parser ############################
##################################################################

parse_second()
{
	#
	# use args from first stage parser, prepared for us
	#
	set --	"${PTXDIST_ARGS_SECOND[@]}"

	if [ $# -eq 0 ]; then
		usage
		exit 0
	fi

	local kernellink=${PTXDIST_WORKSPACE}/.kernel

	while [ $# -ne 0 ]; do
		local cmd="${1}"
		shift

		case "${cmd}" in
######## --*
		--version)
			echo "${PTXDIST_VERSION_FULL}"
			exit 0
			;;

		--help|help)
			usage
			exit 0
			;;

######## standard target, directly into make

		extract|prepare|compile|install|targetinstall|tags)
			check_ptxconfig || return
			check_if_selected "${1}" || return
			check_compiler
			check_dirs
			check_deps

			if [ "${cmd}" = "targetinstall" ]; then
				local cmd_post=".post"
			fi
			ptxd_make_log "${STATEDIR}/${1}.${cmd}${cmd_post}"
			exit 0
			;;

######## *config, *setup, toolchain

		menuconfig|oldconfig)
			do_config "${cmd}" "${@}"
			exit ${?}
			;;

		platformconfig)
			[ -L ${kernellink} ] && rm -f ${kernellink}

			do_config menuconfig platform
			local retval=${?}

			if [ -n "$(ptxd_get_ptxconf PTXCONF_KERNEL_SYMLINK_IN_PROJECTDIR)" ]; then
				ln -sf ${BUILDDIR}/linux-$(ptxd_get_ptxconf PTXCONF_KERNEL_VERSION) ${kernellink}
			fi
			exit ${retval}
			;;

		kernelconfig)
			do_config menuconfig kernel
			exit ${?}
			;;

		u_boot_config)
			do_config menuconfig u-boot-v2
			exit ${?}
			;;

		boardsetup)
			check_ptxconfig
			[ -d ${HOME}/.ptxdist ] || mkdir ${HOME}/.ptxdist
			do_config menuconfig board
			exit ${?}
			;;

		setup)
			do_config menuconfig user
			exit ${?}
			;;


		select)
			do_select ptxconfig "${1}"
			exit ${?}
			;;

		platform)
			[ -L ${kernellink} ] && rm -f ${kernellink}

			do_select platformconfig "${1}"
			local retval=${?}

			if [ -n "$(ptxd_get_ptxconf PTXCONF_KERNEL_SYMLINK_IN_PROJECTDIR)" ]; then
				ln -sf ${BUILDDIR}/linux-$(ptxd_get_ptxconf PTXCONF_KERNEL_VERSION) ${kernellink}
			fi
			exit ${retval}
			;;

		toolchain)
			do_select_toolchain "${1}"
			exit ${?}
			;;

######## the rest of it

		clean)
			check_ptxconfig || return
			check_deps
			clean "${1}"
			exit 0
				;;
		clone)
			if [ $# -ne 2 ]; then
				usage
				exit 1
			fi

			clone "${1}" "${2}"
			exit 0
			;;
		distclean)
			clean

			if [ -L "${PTXDIST_TOOLCHAIN}" ]; then
				echo "${PROMPT}removing toolchain link..."
				rm -f "${PTXDIST_TOOLCHAIN}"
			fi

			if [ -L "${PTXDIST_PTXCONFIG}" ]; then
				echo "${PROMPT}removing ptxconfig link..."
				rm "${PTXDIST_PTXCONFIG}"

			fi
			if [ -L "${PTXDIST_PLATFORMCONFIG}" ]; then
				echo "${PROMPT}removing platformconfig link..."
				rm "${PTXDIST_PLATFORMCONFIG}"
			fi

			echo "${PROMPT}removing logs..."
			rm -fr "${PTX_LOGFILE}"

			echo
			exit 0
			;;
		drop)
			check_ptxconfig || return
			drop "${1}" "${2}"
			exit 0
			;;
		export)
			if [ ! -d "${1}" ]; then
				echo
				echo "${PROMPT}error: directory '$1' does not exist!"
				echo
				exit 1
			fi
			check_ptxconfig || return
			check_deps
			ptxd_make_log export EXPORTDIR="${1}"
			exit 0
			;;
		get)
			check_ptxconfig || return
			check_deps
			if [ $# -eq 0 ]; then
				ptxd_make_log get
			else
				check_if_selected "${1}" || return
				ptxd_make_log "${STATEDIR}/${1}.get"
			fi
			exit 0
			;;
		go)
			check_ptxconfig || return
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log world
			exit 0
			;;
		images)
			check_ptxconfig || return
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log world
			ptxd_make_log images
			exit 0
			;;

		make)
			check_ptxconfig || return
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log "${1}"
			exit 0
			;;
		menu)
			if [ \! -x "$(which dialog)" ]; then
				echo
				echo "${PROMPT}info: Sorry, no menu for you, please install 'dialog'"
				echo
				exit 1
			fi
			PTX_MENU=true
			while menu; do true; done
			exit 0
			;;

		newpacket)
			# test if we are in a rules dir
			if [ "$(basename $(pwd))" != "rules" ]; then
				echo
				echo "${PROMPT}error: newpacket command only allowed in a rules dir"
				echo
				exit 1
			fi
			newpacket "${1}"
			exit ${?}
			;;
		print)
			check_ptxconfig || return
			check_deps
			ptxd_make_log "print-${1}"
			shift
			;;
		projects)
			projects
			exit 0
			;;
		test)
			check_ptxconfig || return

			if [ -z "$1" ]; then
			#	echo "No test given. try ptxdist test help for a list of available tests"
				echo "No test given."
				exit 1
			fi
			#if [ "$1" = help ]; then
			#	# FIXME
			#	echo "available tests:"
			#	find $PTXDIST_WORKSPACE/tests -maxdepth 1 -type f -exec basename {} \;
			#	exit 0
			#fi

			for tst in \
				"${PTXDIST_WORKSPACE}/tests/${1}${PTXDIST_PLATFORMSUFFIX}" \
				"${PTXDIST_WORKSPACE}/tests/${1}" \
				"${PTXDIST_PLATFORMCONFIGDIR}/tests/${1}${PTXDIST_PLATFORMSUFFIX}" \
				"${PTXDIST_PLATFORMCONFIGDIR}/tests/${1}" \
				"${PTXDIST_TOPDIR}/tests/${1}${PTXDIST_PLATFORMSUFFIX}" \
				"${PTXDIST_TOPDIR}/tests/${1}" \
				; do \
				if [ -x "${tst}" ]; then
					"${tst}" > "${PTXDIST_PLATFORMDIR}/test.log"
					exit ${?}
				fi
			done

			echo
			echo "${PROMPT}error: test '$1' not found in PTXDIST_TOPDIR and PTXDIST_WORKSPACE"
			echo
			exit 1
			;;
		*)
			usage
			exit 1
			;;
		esac

	done
}



##################################################################
################ setup stuff only ################################
##################################################################


#
# figure out PTXDIST_TOPDIR
# this is where the ptxdist installation lives
#
# out: PTXDIST
#      PTXDIST_TOPDIR
#      PTXDIST_WORKSPACE
#      PTXDIST_TOOLCHAIN_DEFAULT
#      PTXDIST_PLATFORMCONFIG_DEFAULT
#      PTXDIST_PTXCONFIG_DEFAULT
#
setup_topdir() {
	local ptxdist topdir

	ptxdist="$(readlink -f "${0}")"
	topdir="$(cd "$(dirname "${ptxdist}")"/.. && pwd)"

	#
	# sanity check: is PTXdist already configured?
	#
	if [ ! -e "${topdir}/.done" ]; then
		echo
		echo "${PROMPT}error: PTXdist in ${topdir} is not built."
		echo
		exit 1
	fi

	PTXDIST="${ptxdist}"
	PTXDIST_TOPDIR="${topdir}"
	PTXDIST_WORKSPACE="$(pwd)"

	eval PTXDIST_PTXCONFIG_DEFAULT="${PTXDIST_PTXCONFIG_DEFAULT}"
	eval PTXDIST_PLATFORMCONFIG_DEFAULT="${PTXDIST_PLATFORMCONFIG_DEFAULT}"
	eval PTXDIST_TOOLCHAIN_DEFAULT="${PTXDIST_TOOLCHAIN_DEFAULT}"
}


#
# deletes ptxdist's temporary storage
# closes logfile
#
# in: PTXDIST_TEMPDIR
# in: PTX_LOGFILE
#
ptxdist_trap_exit_handler() {
	local retval="${?}"

	if [ -n "${PTXDIST_TEMPDIR}" -a -d "${PTXDIST_TEMPDIR}" ]; then
		rm -fr "${PTXDIST_TEMPDIR}"
	fi

	if [ -e "${PTX_LOGFILE}" ]; then
		#
		# use these quotes to keep Enrik's editor happy
		#	   \\
		#	    VV
		echo -e "\n}""}} $(date '+%FT%T%z') ${PTXDIST} ${PTXDIST_ARGS_FULL[@]}; (exit value: ${retval})\n\n\n" >> "${PTX_LOGFILE}"
	fi
}


#
# setups trap, to delete temporary storage
#
setup_traps() {
	trap 'ptxdist_trap_exit_handler' 0 1 15
}


#
# source the scripts we need
#
# we need the PTXdist shell library
# we need the version definitions
# we need the static variable definitions
#
# out: "ptxd_*"		library calls
#      "*"		ptxdist version variables
#      "*DIR"		directory definitions (some not correct, due to missing PTXDIST_PLATFORMDIR)
#      PTXDIST_TEMPDIR	generic ptxdist temp dir
#
setup_libs() {
	local file abs_file

	for file in \
		scripts/ptxdist_vars.sh \
		scripts/ptxdist_version.sh \
		scripts/libptxdist.sh \
	; do
		abs_file="${PTXDIST_TOPDIR}/${file}"
		if [ -e "${abs_file}" ]; then
			. "${abs_file}"
		else
			echo "${PROMPT}FATAL didn't find ${abs_file}"
			exit 1
		fi
	done

	for lib in "${SCRIPTSDIR}/lib/ptxd_lib_"*.sh; do
		source "${lib}" || ptxd_bailout "failed to source lib: ${lib}"
	done

	PTXDIST_TEMPDIR="$(mktemp -d /tmp/ptxdist.XXXXXX)"
	if [ ${?} -ne 0 ]; then
		echo
		echo "${PROMPT}error: unable to create tempdir"
		echo
		exit 1
	fi

	#
	# eval those who live in the tempdir
	#
	eval PTXDIST_KGEN_DIR="${PTXDIST_KGEN_DIR}"
}


#
# setup PTXDIST_PLATFORMDIR properly
#
# out: PTXDIST_PLATFORMDIR
#      PTXDIST_PLATFORMSUFFIX
#      PTXDIST_PLATFORMCONFIGDIR
#      "*DIR"	correct directory definitions
#
setup_platform() {
	local cfg_dir
	local platform="$(ptxd_get_ptxconf PTXCONF_PLATFORM)"
	local project="$(ptxd_get_ptxconf PTXCONF_PROJECT)"
	local project_version="$(ptxd_get_ptxconf PTXCONF_PROJECT_VERSION)"

	if [ -n "${platform}" ]; then
		PTXDIST_PLATFORMDIR="${PTXDIST_WORKSPACE}/platform-${platform}"
		PTXDIST_PLATFORMSUFFIX=".${platform}"
	else
		PTXDIST_PLATFORMDIR="${PTXDIST_WORKSPACE}"
		PTXDIST_PLATFORMSUFFIX=""
	fi

	# reread vars with correct PTXDIST_PLATFORMDIR
	. "${SCRIPTSDIR}/ptxdist_vars.sh"

	if [ -e "${PTXDIST_PLATFORMCONFIG}" ]; then
		cfg_dir="$(dirname "$(readlink -f "${PTXDIST_PLATFORMCONFIG}")")"
	else
		unset cfg_dir
	fi

	PTXDIST_PLATFORMCONFIGDIR="${cfg_dir}"
	PTXDIST_BOARDSETUP="${HOME}/.ptxdist/boardsetup.${project}${project_version}.${platform}"
}


#
# source the user's .ptxdistrc
# or default one
# setup PTXDIST_SRCDIR
#
# out: PTXCONF_*	user preferences
#      PTXDIST_SRCDIR
#      PTXDIST_PARALLELMFLAGS_INTERN
#      PTXDIST_PARALLELMFLAGS_EXTERN
#      PTXDIST_PTXRC
#
setup_config() {
	local cpus pmf_intern

	eval PTXDIST_PTXRC_DEFAULT="${PTXDIST_PTXRC_DEFAULT}"
	PTXDIST_PTXRC="${PTXDIST_PTXRC_DEFAULT}"

	local rc_user="${PTXDIST_PTXRC}"
	local rc_default="${PTXDIST_TOPDIR}/config/setup/ptxdistrc.default"

	if [ \! -e "${rc_user}" ]; then
		cp "${rc_default}" "${rc_user}"
	fi

	ptxd_source_kconfig "${rc_user}"


	#
	# enable or disable errexit
	#
	if [ -n "${PTXCONF_SETUP_CHECK_EXIT_ON_ERROR}" ]; then
		set -e
	else
		set +e
	fi


	#
	# setup SRCDIR
	#
	if [ -z "${PTXCONF_SETUP_SRCDIR}" ]; then
		PTXDIST_SRCDIR="${PTXDIST_WORKSPACE}/src"
	else
		eval PTXDIST_SRCDIR="${PTXCONF_SETUP_SRCDIR}"
	fi


	#
	# setup proxy
	#
	if [ -n "${PTXCONF_SETUP_HTTP_PROXY}" ]; then
		export http_proxy="${PTXCONF_SETUP_HTTP_PROXY}"
	fi

	if [ -n "${PTXCONF_SETUP_FTP_PROXY}" ]; then
		export ftp_proxy="${PTXCONF_SETUP_FTP_PROXY}"
	fi


	#
	# setup PARALLELMFLAGS
	#

	# default no parallel for now
	local pmf_extern="-j1"

	#
	# user may override PARALLELMFLAGS
	#
	if [ -n "${PARALLELMFLAGS}" ]; then
		pmf_intern="${PARALLELMFLAGS}"
		unset PARALLELMFLAGS
	else
		if [ -r /proc/cpuinfo ]; then
			cpus="$(egrep '^(processor|cpu	)' /proc/cpuinfo | wc -l)"
			if [ $cpus -eq 0 ]; then
				cpus=1
			fi
		else
			cpus=1
		fi

		pmf_intern="-j$(( $cpus * 2 ))"
	fi

	#
	# user may override these, too
	#
	PTXDIST_PARALLELMFLAGS_INTERN="${PTXDIST_PARALLELMFLAGS_INTERN:-${pmf_intern}}"
	PTXDIST_PARALLELMFLAGS_EXTERN="${PTXDIST_PARALLELMFLAGS_EXTERN:-${pmf_extern}}"
}


#
# add PTXDIST_TOOLCHAIN and sysroots to path
#
# out: PATH
#
setup_path() {
	# save PATH and reuse it later on
	PATH="${_ptxdist_setup_path:=${PATH}}"

	if [ -d "${PTXDIST_TOOLCHAIN}" ]; then
		PATH="${PTXDIST_TOOLCHAIN}:${PATH}"
	fi

	# dir might not be available yet, but will be created later
	local sysroot_host="$(ptxd_get_ptxconf PTXCONF_SYSROOT_HOST)"

	if [ -n "${sysroot_host}" ]; then
		PATH="${sysroot_host}/bin:${sysroot_host}/sbin:${PATH}"
	fi
}


#
# starts logfile
#
setup_logfile()
{
	local logdir="${PTX_LOGFILE%/*}"

	if [ ! -d "${logdir}" ]; then
		mkdir -p ${logdir} || ptxd_bailout "cannot create dir: ${logdir}"
	fi

	if [ ! -e "${PTX_LOGFILE}" ]; then
		# let emacs outline mode be compatible to vi's fold mode
		echo -e "# -*- mode:outline; outline-regexp:\"{""{{\" -*-\n" > "${PTX_LOGFILE}"
	fi

	#
	# use these quotes to keep Enrik's editor happy
	#      ||
	#      VV
	echo "{""{{ $(date '+%FT%T%z') ${PTXDIST} ${PTXDIST_ARGS_FULL[@]}" >> "${PTX_LOGFILE}"
}



#
# export some important vars
# so that they can be used in make
#
setup_export() {
	export PROJECT FULLVERSION VERSION PATCHLEVEL SUBLEVEL EXTRAVERSION		# FIXME: review these
	export \
		PATH \
		\
		PTXDIST \
		PTXDIST_TOPDIR \
		PTXDIST_SRCDIR \
		PTXDIST_TEMPDIR \
		PTXDIST_PTXCONFIG \
		PTXDIST_PLATFORMCONFIG \
		PTXDIST_BOARDSETUP \
		\
		PTXDIST_VERSION_FULL \
		PTXDIST_VERSION_MAJOR \
		PTXDIST_VERSION_MINOR \
		PTXDIST_VERSION_MICRO \
		\
		PTXDIST_WORKSPACE \
		\
		PTXDIST_PLATFORMDIR \
		PTXDIST_PLATFORMSUFFIX \
		PTXDIST_PLATFORMCONFIGDIR \
		\
		PTXDIST_KGEN_DIR \
		\
		PTXDIST_PARALLELMFLAGS_INTERN \
		PTXDIST_PACKAGES_COLLECTION \
		\
		PTXDIST_QUIET
}


########################################################################
# main()
########################################################################

setup_topdir
setup_traps
setup_libs
# ---  libs are available from here ---
setup_config
# --- errexit feature may be active ---
parse_first
# --- vars to config files are setup ---
setup_platform
# --- platformdir and other *dirs are available from here ---
# --- all variables are defined now ---
setup_path
# --- path is now set ---
setup_logfile
# -- logfile is ready
setup_export
# -- all improtant vars are exported

check_uid
check_path

parse_second

exit 1
