#!/bin/bash

#
# TODO
#
# - split images out of Makefile; we should have a command "image jffs2"
#   which starts a corresponding script in scripts/
#
#

PROMPT="ptxdist: "
PTXDIST_WORKSPACE=$(pwd)
DEBUG=

# export this, so that children can call the master script, for example
# to find out the version number
export PTXDIST=$0

if [ -L "$0" ]; then
	PTXDIST_TOPDIR=$(cd $(dirname $(readlink $0))/.. && pwd)
else
	PTXDIST_TOPDIR=$(cd $(dirname $0)/.. && pwd)
fi

export PTXDIST_WORKSPACE PTXDIST_TOPDIR


#
# sanity check: is PTXdist already configured?
#

if [ ! -e ${PTXDIST_TOPDIR}/.done ]; then
	echo
	echo "${PROMPT}error: PTXdist in ${PTXDIST_TOPDIR} is not built."
	echo
	exit 1
fi


#
# we need the PTXdist shell library
#

libptxdist=${PTXDIST_TOPDIR}/scripts/libptxdist.sh

if [ -e "$libptxdist" ]; then
	. $libptxdist
else
	echo "${PROMPT}didn't find \$(PTXDIST_TOPDIR)/scripts/libptxdist.sh"
	exit 1
fi


#
# we need the static variable definitions
#

ptxdistvars=${PTXDIST_TOPDIR}/scripts/ptxdistvars.sh

if [ -e "$ptxdistvars" ]; then
	. $ptxdistvars
else
	echo "${PROMPT}didn't find \$(PTXDIST_TOPDIR)/scripts/ptxdistvars.sh"
	exit 1
fi


# source the user's .ptxdistrc
[ -e "$HOME/.ptxdistrc.${FULLVERSION}" ] && .  $HOME/.ptxdistrc.${FULLVERSION}

# use linked toolchain if available
[ -d ".toolchain" ] && export PATH=`pwd`/.toolchain:$PATH

#
# Check for existence of a ptxconfig file
# check_ptxconfig()

check_ptxconfig() {
	if [ ! -e "ptxconfig" ]; then
		echo
		echo "${PROMPT}error: ptxconfig file is missing. Did you setup your project yet?"
		echo "${PROMPT}error: To get a ptxconfig file clone a template project or (if"
		echo "${PROMPT}error: there are more than one configurations like ptxconfig.*)"
		echo "${PROMPT}error: select one of these with 'ptxdist select ptxconfig.<yourselection>'"
		echo "${PROMPT}error: first."
		echo
		exit 1
	fi

	# sanity check: we process only files which have been built with the
	# same PTXdist version!

	PTXCONF_CONFIGFILE_VERSION=$(. ptxconfig && echo ${PTXCONF_CONFIGFILE_VERSION})
	if [ "${PTXCONF_CONFIGFILE_VERSION}" != "${FULLVERSION}" ]; then

		echo
		echo "${PROMPT}error: Your ptxconfig file was built with another PTXdist version."
		echo "${PROMPT}error: As this may result in a broken configuration it is recommended"
		echo "${PROMPT}error: that you carefully review the config differences and change"
		echo "${PROMPT}error: the variable PTXCONF_CONFIGFILE_VERSION=\"${FULLVERSION}\" manually"
		echo "${PROMPT}error: then, or change it first, run 'ptxdist oldconfig' and check"
		echo "${PROMPT}error: if the result is what you expected."
		echo
		echo "${PROMPT}error: config file wants PTXCONF_CONFIGFILE_VERSION \"${PTXCONF_CONFIGFILE_VERSION}\""
		echo "${PROMPT}error: ptxdist version is \"${FULLVERSION}\""
		echo
		exit 1
	fi
}

#
# Check for defined compiler
# This only should be done when we build userland (chicken egg problem)
#
check_compiler() {

	BUILD_USERLAND=$(. ptxconfig && echo ${PTXCONF_BUILD_USERLAND})
	[ "$BUILD_USERLAND" != "y" ] && return
	[ "$NATIVE" != "" ] && return

	C_COMPILER=$(. ptxconfig && echo ${PTXCONF_GNU_TARGET})-gcc
	COMPILER_SHOULD_BE=$(. ptxconfig && echo ${PTXCONF_CROSSCHAIN_CHECK})
	if [ -d ".toolchain" ]; then
		COMPILER_PATH=`pwd`/.toolchain/$C_COMPILER
	else
		COMPILER_PATH=$C_COMPILER
	fi

	COMPILER_IS=$($COMPILER_PATH -dumpversion 2> /dev/null)

	if [ -z "$COMPILER_IS" ]; then
		echo
		echo "${PROMPT}error: Compiler '$C_COMPILER' not found. Check PATH or"
		echo "${PROMPT}error: use 'ptxdist toolchain <path/to/toolchain>'."
		echo
		exit 1
	fi
	if [ "$COMPILER_IS" != "$COMPILER_SHOULD_BE" ]; then
		echo
		echo "${PROMPT}error: Compiler version $COMPILER_SHOULD_BE expected,"
		echo "${PROMPT}error: but $COMPILER_IS found."
		echo
		exit 1
	fi
}

#
# usage()
#

usage() {
cat << EOF

PTXdist `printf "%-24s" ${FULLVERSION}` Build System for Embedded Linux Systems

  ptxdist <action [args]> [options]

Setup and Project Actions:

  setup                          setup per-user preferences

  projects                       show available projects
  clone <from> <to>              create a new project, cloned from <from>. 

  menuconfig                     configure the root filesystem
  oldconfig                      run 'make oldconfig' on ptxconfig file

  toolchain <path>               select this toolchain (path to binaries)
  select <config>                if there is no ptxconfig file you can
                                 select one of several configs to be used
Build Actions:

  go                             start building the current project

  get <package>                  get packet sources
  extract <package>              extract packet
  prepare <package>              run configure stages for packet
  compile <package>              compile the sources
  install <package>              install host side components into sysroot/
  targetinstall <package>        install files for target into root/
  clean <package>                cleanup packet
  autobuild                      search for "autobuild" scripts and run them

  images                         build images for target system

Clean Actions:

  clean                          cleanup build-host and build-cross dirs
  distclean                      cleanup everything
  (clean images)                 cleanup images directory
  clean root                     cleanup root directory for target
  (clean project)                cleanup project specific packages
  (clean maintainer)             maintainerclean

Misc

  run                            start a previously built native image

  --native                       build with native compiler instead of cross
  --version                      print out ptxdist version

  (svn up)                       run "svn update" in topdir and project dir
  (svn stat)                     run "svn stat" in topdir and project dir

  test <testname>                run tests

Environment:

  PREFIX=<path>                  build into this directory, instead of
			         building into PTXCONF_PREFIX from config

EOF
}

clean() {

	if [ "$1" = "root" ]; then
		echo
		echo "${PROMPT}cleaning root directory..."
		rm -fr root
		echo "${PROMPT}cleaning targetinstall stages..."
		rm -f state/*.targetinstall
		echo "${PROMPT}done."
		echo
		return
	fi

	if [ -n "$1" ]; then
		make $PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make $1_clean PTXDIST_TOPDIR=${PTXDIST_TOPDIR}
		return
	fi

	echo
	echo "${PROMPT}removing build directories..."
	rm -fr build-cross
	rm -fr build-host
	rm -fr build-target
	echo "${PROMPT}removing deps..."
	rm -f depend.out deptree-a4.ps deptree.ps
	echo "${PROMPT}removing imagedir..."
	rm -fr images
	echo "${PROMPT}removing sysroot directory (local)..."
	rm -fr local
	echo "${PROMPT}removing sysroot..."
	rm -fr sysroot
	echo "${PROMPT}removing root..."
	rm -fr root
	echo "${PROMPT}removing state..."
	rm -fr state
	echo "${PROMPT}removing logfile..."
	rm -f logfile
	if [ -h "ptxconfig" ]; then
		echo "${PROMPT}removing ptxconfig link..."
		rm ptxconfig
	fi
	echo "${PROMPT}done."
	echo
}

menuconfig() {
	echo

	# check if this is a PTXdist project dir
	if [ -z "$(find . -maxdepth 1 -name "ptxconfig" | grep -v .svn)" ]; then
		echo "${PROMPT}error: no ptxconfig file found."
		echo "${PROMPT}error: check if this is a PTXdist project directory"
		echo
		exit 1
	fi

	echo "${PROMPT}menuconfig..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`

	pushd $tmpdir > /dev/null
	ln -sf ${PTXDIST_TOPDIR}/scripts
	ln -sf ${PTXDIST_TOPDIR}/rules
	ln -sf ${PTXDIST_TOPDIR}/config
	ln -sf ${PTXDIST_WORKSPACE} workspace
	cp ${PTXDIST_WORKSPACE}/ptxconfig .config
	if [ -e "${PTXDIST_WORKSPACE}/Kconfig" ]; then
		${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_WORKSPACE}/Kconfig
		echo "${PROMPT}silentoldconfig..."
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s ${PTXDIST_WORKSPACE}/Kconfig
	else
		${PTXDIST_TOPDIR}/scripts/kconfig/mconf config/Kconfig
		echo "${PROMPT}silentoldconfig..."
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s config/Kconfig
	fi

	echo "${PROMPT}saving ptxconfig"
	cp .config ${PTXDIST_WORKSPACE}/ptxconfig

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
	echo
}

newpacket () {
	
	case $1 in 
	host)	TEMPLATE=template-host ;;
	target)	TEMPLATE=template ;;
	cross)	TEMPLATE=template-cross ;;
	*)	echo; echo "${PROMPT}error: illegal argument"; echo; exit 1 ;;
	esac

	echo
	echo "${PROMPT}creating a new packet from ${TEMPLATE}:"
	echo
	echo -n "${PROMPT}enter packet name.......: "
	read PACKET_NAME
	echo -n "${PROMPT}enter version number....: "
	read VERSION
	echo -n "${PROMPT}enter URL of basedir....: "
	read URL
	echo -n "${PROMPT}enter packet author.....: "
	read AUTHOR
	echo -n "${PROMPT}enter suffix............: "
	read SUFFIX
	YEAR=`date +%Y`
	packet=`echo $PACKET_NAME | tr "[A-Z]" "[a-z]"`
	PACKET=`echo $PACKET_NAME | tr "[a-z]" "[A-Z]"`

	if [ -f "${packet}.make" ]; then
		echo
		echo -n "${PROMPT}warning: ${packet}.make does already exist, overwrite? "
		read overwrite
		if [ "$overwrite" != "y" ]; then
			echo "${PROMPT}aborted."
			echo
			exit 0
		fi
	fi
	
	sed \
		-e "s~\@PACKET@~${PACKET}~g" \
		-e "s~\@packet@~${packet}~g" \
		-e "s~\@VERSION@~${VERSION}~g" \
		-e "s~\@URL@~${URL}~g" \
		-e "s~\@YEAR@~${YEAR}~g" \
		-e "s~\@AUTHOR@~${AUTHOR}~g" \
		-e "s~\@SUFFIX@~${SUFFIX}~g" \
		${PTXDIST_TOPDIR}/rules/${TEMPLATE} \
		> ${packet}.make
	
}

oldconfig() {
	echo

	# check if this is a PTXdist project dir
	if [ -z "$(find . -maxdepth 1 -name "ptxconfig" | grep -v .svn)" ]; then
		echo "${PROMPT}error: no ptxconfig file found."
		echo "${PROMPT}error: check if this is a PTXdist project directory"
		echo
		exit 1
	fi

	echo "${PROMPT}silentoldconfig..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`

	pushd $tmpdir > /dev/null
	ln -sf ${PTXDIST_TOPDIR}/scripts
	ln -sf ${PTXDIST_TOPDIR}/rules
	ln -sf ${PTXDIST_TOPDIR}/config
	ln -sf ${PTXDIST_WORKSPACE} workspace
	cp ${PTXDIST_WORKSPACE}/ptxconfig .config
	if [ -e "${PTXDIST_WORKSPACE}/Kconfig" ]; then
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s ${PTXDIST_WORKSPACE}/Kconfig
	else
		${PTXDIST_TOPDIR}/scripts/kconfig/conf -s config/Kconfig
	fi
	echo "${PROMPT}saving ptxconfig"
	cp .config ${PTXDIST_WORKSPACE}/ptxconfig

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
	echo
}

projects() {
	echo
	echo "${PROMPT}searching for projects:"
	echo "${PROMPT}scanning ${PTXDIST_TOPDIR}/projects..."
	projects=`cd ${PTXDIST_TOPDIR}/projects-example && find . -maxdepth 1 -type d ! -name .svn ! -name .  -exec basename {} \;`
	projects="$projects `cd ${PTXDIST_TOPDIR}/projects-toolchains && find . -maxdepth 1 -type d ! -name .svn ! -name .  -exec basename {} \;`"
	echo -n "${PROMPT}scanning \${PTXCONF_SETUP_PROJECTDIR}..."
	if [ -d "${PTXCONF_SETUP_PROJECTDIR}" ]; then
	lprojects=`cd ${PTXCONF_SETUP_PROJECTDIR} && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	echo
	else
	echo "not found"
	fi
	projects=`(for i in $projects $lprojects; do echo $i; done) | sort -u`
	echo
	echo "---------------------- Available PTXdist Projects: ----------------------------"
	for i in $projects; do echo $i; done
	echo "-------------------------------------------------------------------------------"
	echo
}

setup() {
	echo
	echo "${PROMPT}setup..."
	tmpdir=`mktemp -d /tmp/ptxdist.XXXXXX`
	pushd $tmpdir > /dev/null

	# prepare everything to make kconfig see it's original environment
	ln -sf ${PTXDIST_TOPDIR}/scripts
	cp ${PTXDIST_TOPDIR}/config/setup/ptxdistrc.default .config
	if [ -f "$HOME/.ptxdistrc.${FULLVERSION}" ]; then
		echo "using \$HOME/.ptxdistrc.${FULLVERSION}"
		cp $HOME/.ptxdistrc.${FULLVERSION} .config
	fi

	# store ~/.ptxdistrc
	${PTXDIST_TOPDIR}/scripts/kconfig/mconf ${PTXDIST_TOPDIR}/config/setup/Kconfig
	echo "${PROMPT}saving \$HOME/.ptxdistrc.${FULLVERSION}"
	cp .config $HOME/.ptxdistrc.${FULLVERSION}

	popd > /dev/null
	echo "${PROMPT}cleanup..."
	rm -fr $tmpdir
}

clone() {

	if [ -z "$1" ]; then usage; exit 1; fi
	if [ -z "$2" ]; then usage; exit 1; fi

	if [ -d "$2" ]; then
		echo
		echo "${PROMPT}error: directory $2 does already exist"
		echo
		exit 1
	fi

	echo
	echo "${PROMPT}searching for projects:"
	echo "${PROMPT}scanning ${PTXDIST_TOPDIR}/projects-example..."
	projects=`cd ${PTXDIST_TOPDIR}/projects-example && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	echo "${PROMPT}scanning ${PTXDIST_TOPDIR}/projects-toolchains..."
	projects="$projects `cd ${PTXDIST_TOPDIR}/projects-toolchains && find .  -maxdepth 1 -type d ! -name .svn ! -name .  -exec basename {} \;`"
	echo -n "${PROMPT}scanning \${PTXCONF_SETUP_PROJECTDIR}..."
	if [ -d "${PTXCONF_SETUP_PROJECTDIR}" ]; then
	lprojects=`cd ${PTXCONF_SETUP_PROJECTDIR} && find . -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;`
	echo
	else
	echo "not found"
	fi
	projects=`(for i in $projects $lprojects; do echo $i; done) | sort -u`
	echo

	for i in $projects; do
		if [ "$1" = "$i" ]; then
			echo "${PROMPT}cloning project $1 to $2"
			if [ -d "${PTXCONF_SETUP_PROJECTDIR}" ] && [ -d "${PTXCONF_SETUP_PROJECTDIR}/$1" ] ; then
				cp -a ${PTXCONF_SETUP_PROJECTDIR}/$1 $2
				echo "${PROMPT}done."
				echo
				return 0
			elif [ -d "${PTXDIST_TOPDIR}/projects-example/$1" ]; then
				cp -a ${PTXDIST_TOPDIR}/projects-example/$1 $2
				echo "${PROMPT}done."
				echo
				return 0
			elif [ -d "${PTXDIST_TOPDIR}/projects-toolchains/$1" ]; then
				cp -a ${PTXDIST_TOPDIR}/projects-toolchains/$1 $2
				echo "${PROMPT}done."
				echo
				return 0
			fi
		fi
	done

	echo "${PROMPT}project $1 is to be cloned, but could not be found"
	echo
}


#
# main()
#
if [ "$#" = "0" ]; then
	usage
	exit 0
fi

while [ "$#" != "0" ]; do

	case $1 in
	autobuild)	echo
			echo "${PROMPT}running autobuild"
			echo
			AUTOBUILDS=$(find . -name "autobuild")
			AUTOBUILD_TOPDIR=$(pwd)
			exec 5>COMPILETEST
			echo >&5
			for i in $AUTOBUILDS; do
				pushd $(dirname $i)

				echo "config............: `basename \`pwd\``" >&5
				echo "date..............: `date`" >&5
				echo "user..............: ${USER}@${HOSTNAME}" >&5
				PTX_STARTTIME=`date +"%s"`

				./autobuild

				PTX_RETVAL=$?
				PTX_STOPTIME=`date +"%s"`
				let "PTX_TIME=$PTX_STOPTIME-$PTX_STARTTIME"
				let "PTX_TIME_H=$PTX_TIME/3600"
				let "PTX_TIME_M=($PTX_TIME-$PTX_TIME_H*3600)/60"
				let "PTX_TIME_S=($PTX_TIME-$PTX_TIME_H*3600-$PTX_TIME_M*60)/60"
				echo "buildtime.........: ${PTX_TIME_H}h${PTX_TIME_M}m${PTX_TIME_S}s" >&5
				echo "result............: ${PTX_RETVAL}" >&5
				echo >&5

				[ -e "logfile" ] && mv logfile "${AUTOBUILD_TOPDIR}/`basename \`pwd\``.log"
				[ "${PTX_RETVAL}" = "0" ] && ${PTXDIST} clean

				popd
			done
			echo
			echo "${PROMPT}done"
			echo
			exit 0
			;;
	compile)	shift
			if [ "$#" = "0" ]; then
				echo "${PROMPT}error: add target you want to compile"
				exit 1
			fi
			check_ptxconfig
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_compile PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	clean)		shift
			clean $1
			exit 0
			;;
	clone)		shift; clone $1 $2; exit 0;;
	-d|--debug)	shift
			export PTXDIST_MAKE_DBG="--debug=make"
			;;
	distclean)	shift
			clean
			echo "${PROMPT}removing toolchain link..."
			rm -f .toolchain
			echo "${PROMPT}removing logs dir..."
			rm -fr logs
			echo
			;;
	extract)	shift
			check_ptxconfig
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_extract PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	get)		shift
			check_ptxconfig
			if [ "$#" = "0" ]; then
				make \
					$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
					get PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			else
				make \
					$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
					$1_get PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
				check_pipe_status
				exit 0
			fi
			;;
	go)		shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				world PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	help|--help)	shift; usage; exit 0; ;;
	images)		shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				images PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	install)	shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_install PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	make)		shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1 PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	menuconfig)	shift
			check_ptxconfig
			menuconfig
			;;
	--native)	shift
			export NATIVE=1
			;;
	newpacket)	# test if we are in a rules dir
			if [ "`basename \`pwd\``" != "rules" ]; then
				echo
				echo "${PROMPT}error: newpacket command only allowed in a rules dir"
				echo
				exit 1
			fi
			shift
			case $1 in
			--target) newpacket target ;;
			--host)   newpacket host   ;;
			--cross)  newpacket cross  ;;
			esac
			exit $?
			;;
	oldconfig)	shift
			check_ptxconfig
			oldconfig
			;;
	prepare)	shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_prepare PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	print)		shift
			check_ptxconfig
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				print-$1 PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			shift
			;;

	projects)	shift; projects;;
	run)		shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				world PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			RUN_ROOTMETHOD=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_ROOT_HOSTFS})
			RUN_CMDLINE=$(. ptxconfig && echo ${PTXCONF_KERNEL_NATIVE_CMDLINE})
			if [ -n "${RUN_ROOTMETHOD}" ]; then
				RUN_CMDLINE="${RUN_CMDLINE} root=/dev/root rootflags=`pwd`/root rootfstype=hostfs"
			fi
			root/boot/vmlinux ${RUN_CMDLINE}
			exit 0	
			;;	
	select)		shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "ptxconfig" ]; then
				echo
				echo "${PROMPT}error: There already is a ptxconfig file."
				echo "${PROMPT}error: If you really want to select another configuration,"
				echo "${PROMPT}error: please move away the ptxconfig file first."
				echo
				exit 1
			fi
			echo
			echo "${PROMPT}linking $1 to ptxconfig"
			rm -f ptxconfig
			ln -sf $1 ptxconfig
			echo "${PROMPT}done."
			echo
			exit 0
			;;
	setup)		shift; setup;;
	targetinstall)	shift
			check_ptxconfig
			check_compiler
			make \
				$PTXDIST_MAKE_DBG -f ${PTXDIST_TOPDIR}/rules/Toplevel.make \
				$1_targetinstall PTXDIST_TOPDIR=${PTXDIST_TOPDIR} 2>&1 | tee -a logfile
			check_pipe_status
			exit 0
			;;
	test)		shift
			if [ -x "$PTXDIST_WORKSPACE/tests/$1" ]; then
				echo
				echo "${PROMPT}starting test $1"
				$PTXDIST_WORKSPACE/tests/$1
				echo "${PROMPT}test $1 finished"
				echo
			else if [ -x "$PTXDIST_TOPDIR/tests/$1" ]; then
				echo
				echo "${PROMPT}starting test $1"
				$PTXDIST_TOPDIR/tests/$1
				echo "${PROMPT}test $1 finished"
				echo
			else
				echo
				echo "${PROMPT}error: test $i not found in PTXDIST_TOPDIR and PTXDIST_WORKSPACE"
				echo
			fi
			fi
			exit 0
			;;
	toolchain)	shift
			echo
			if [ ! -d "$1" ]; then
				echo
				echo "${PROMPT}error: path $1 does not exist"
				echo
				exit 1
			fi
			echo "${PROMPT}using toolchain in $1"
			test -h ".toolchain" && rm -f .toolchain
			if [ -e ".toolchain" ]; then
				echo
				echo "${PROMPT}error: There is a .toolchain in this directory which is no link."
				echo "${PROMPT}error: This should never happen, please contact the"
				echo "${PROMPT}error: Pengutronix Department of Illegal File Removement."
				echo
				exit 1
			fi
			ln -sf $1 .toolchain
			echo
			exit 0
			;;
	--version)	echo ${FULLVERSION}
			exit 0
			;;
	*)		shift
			usage
			exit 0
			;;
	esac

done

exit 0

