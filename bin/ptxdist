#!/bin/bash

export LANG=C
export LC_ALL=POSIX
export LC_CTYPE=POSIX

PTXDIST_FULLARGS=("${@}")
PROMPT="ptxdist: "
DEBUG=


boardsetup_action() {
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${PTXDIST_WORKSPACE}/boardsetup/Kconfig"
}

#
# board setup
#
boardsetup() {
	echo
	echo "${PROMPT}boardsetup..."

	if [ ! -e "${PTXDIST_WORKSPACE}/boardsetup/Kconfig" ]; then
		echo "${PROMPT}error: boardsetup/boardsetup or boardsetup/Kconfig missing"
		echo
		exit 1
	fi

	ptxd_kconfig "${PTXDIST_WORKSPACE}/boardsetup/boardsetup" boardsetup_action true
}

# check a ptxdist version against a configfile version.
#
# - The ptxdist major version has to be equal to the configfile major version
# - The ptxdist minor version has to be equal to the configfile minor version
# - The ptxdist micro version has to greater than or equal to the configfile
#   micro version
# - If the configfile has no minor or micro version stop here and assume
#   everything is ok (this means 'can build with 0.10.x or 0.x').
# - If the ptxdist minor or micro version is "svn" then no further checks are
#   done. You know what you are doing when you use svn, don't you?
#
check_version() {
	ptxdist="$1"
	config="$2"

	ptxdist_major=$(echo $ptxdist | awk -F. '{print $1}')
	config_major=$(echo $config | awk -F. '{print $1}')
	[ "$ptxdist_major" != "$config_major" ] && return 1

	ptxdist_minor=$(echo $ptxdist | awk -F. '{print $2}')
	config_minor=$(echo $config | awk -F. '{print $2}')
	[ -z "$config_minor" ] && return 0
	[ "$ptxdist_minor" = "svn" ] && return 0
	[ "$ptxdist_minor" != "$config_minor" ] && return 1

	ptxdist_micro=$(echo $ptxdist | awk -F. '{print $3}')
	config_micro=$(echo $config | awk -F. '{print $3}')
	[ -z "$config_micro" ] && return 0
	[ "$ptxdist_micro" = "svn" ] && return 0
	[ "$ptxdist_micro" -lt "$config_micro" ] && return 1

	return 0
}

#
# Check for existence of a ptxconfig file
# check_ptxconfig()
#
check_ptxconfig() {
	local configfile_version

	if [ ! -e "${PTXCONFIG}" ]; then
		echo
		echo "${PROMPT}error: ptxconfig file is missing"
		echo "${PROMPT}error: please 'ptxdist clone' an existing project"
		echo
		exit 1
	fi

	if [ ! -e "${PLATFORMCONFIG}" ]; then
		echo
		echo "${PROMPT}error: '${PLATFORMCONFIG#${PTXDIST_WORKSPACE}/}' is missing"
		echo
		exit 1
	fi

	configfile_version="$(ptxd_get_ptxconf PTXCONF_CONFIGFILE_VERSION)"

	check_version "${FULLVERSION}" "${configfile_version}"
	if [ $? -ne 0 ]; then
		echo
		echo "${PROMPT}error: The configfile version and ptxdist version do not match:"
		echo
		echo "	configfile version: ${configfile_version}"
		echo "	ptxdist version:    ${FULLVERSION}"
		echo
		exit 1
	fi
}

check_kernelconfig() {
	local kernelconfig

	kernelconfig="$(ptxd_get_ptxconf PTXCONF_KERNEL_CONFIG)"
	if [ ! -e "$kernelconfig" ]; then
		echo
		echo "${PROMPT}error: You don't have a $kernelconfig file"
		echo
		exit 1
	fi
}

#
# abort if ptxdist is run as root
#
check_uid() {
	if [ ${UID} -eq 0 ]; then
		echo
		echo "${PROMPT}error: refusing to run PTXdist as root"
		echo
		exit 1
	fi
}

#
#
#
check_path() {
	case "${PATH}" in
		.:*)
			echo
			echo "${PROMPT}error: \".\" in your \$PATH detected, please remove it!"
			echo
			exit 1
			;;
		*)
			;;
	esac
}


#
# Check for defined compiler
# This only should be done when we build userland (chicken egg problem)
#
check_compiler() {
	local build_toolchain compiler toolchain_ptxconfig
	local vendor_should vendor_is compiler_should compiler_is

	build_toolchain="$(ptxd_get_ptxconf PTXCONF_BUILD_TOOLCHAIN)"

	[ -n "$build_toolchain" ] && return

	#
	# Three things should be checked
	# 1) Correct compiler name
	# 2) Correct vendor if the vendor string is given
	# 3) Correct compiler version if a specific compiler version is given
	#

	compiler="$(ptxd_get_ptxconf PTXCONF_COMPILER_PREFIX)gcc"
	vendor_should="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_VENDOR)"

	if [ -n "${vendor_should}" ]; then
		# yea! A toolchain vendor was specified in the ptxconfig file.
		# So we check for a 'ptxconfig' file in the toolchain directory
		# and test the PTXCONF_PROJECT string therein.

		if [ ! -d "${PTXDIST_TOOLCHAIN}" ]; then
			echo
			echo "${PROMPT}error: specify .toolchain with 'ptxdist toolchain [<path>]'"
			echo "${PROMPT}error: or leave PTXCONF_CROSSCHAIN_VENDOR empty to disable toolchain check"
			echo
			exit 1
		fi

		vendor_def="$(readlink -f ${PTXDIST_TOOLCHAIN}/ptxconfig)"
		if [ -z "${vendor_def}" -o \! -e "${vendor_def}" ]; then
			echo
			echo "${PROMPT}error: toolchain doesn't point to an OSELAS.Toolchain"
			echo "${PROMPT}error: set PTXCONF_CROSSCHAIN_VENDOR to disable toolchain version check"
			echo
			exit 1
		else
			# both vendor strings are present. Check them
			vendor_is="$(. ${vendor_def} && echo ${PTXCONF_PROJECT})"
			if [ "$vendor_is" != "$vendor_should" ]; then
				echo
				echo "${PROMPT}error: wrong toolchain vendor: Cannot continue! Vendor is <${vendor_is}>,"
				echo "${PROMPT}error: specified: ${vendor_should}"
				echo "${PROMPT}error: found:     ${vendor_is}"
				echo
				exit 1
			fi
		fi
	fi

	compiler_should="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_CHECK)"
	compiler_is="$(${compiler} -dumpversion 2> /dev/null)"

	if [ -z "${compiler_is}" ]; then
		echo
		echo "${PROMPT}error: Compiler '${compiler}' not found. Check PATH or"
		echo "${PROMPT}error: use 'ptxdist toolchain [</path/to/toolchain>]'."
		echo
		exit 1
	fi
	if [ "${compiler_is}" != "${compiler_should}" ]; then
		echo
		echo "${PROMPT}error: Compiler version ${compiler_should} expected,"
		echo "${PROMPT}error: but ${compiler_is} found."
		echo
		exit 1
	fi
}


#
# checks if the dependencies are allright (make for the poor)
#
check_deps() {
	"${DGENDIR}/dgen.sh"
}


check_dirs_prefix() {
	local prefix testfile

	prefix="${1}"

	if [ -z "${prefix}" ]; then
		return
	fi

	if [ ! -d "${prefix}" ]; then
		mkdir -p "${prefix}" 2> /dev/null
		if [ $? -ne 0 ]; then
			echo
			echo "error: \"${prefix}\""
			echo "       does not exist and cannot be created!"
			echo "       Please create that dir with write permissions for you."
			echo
			read -t 5 -p "press enter to let sudo do that job!"
			if [ $? -ne 0 ]; then
				echo
				exit 1
			fi
			echo
			echo sudo mkdir -p "${prefix}"
			sudo mkdir -p "${prefix}"
			echo
			echo sudo chown $UID "${prefix}"
			sudo chown $UID "${prefix}"
		fi
	fi

    	testfile="${prefix}/.secret-world-domination-project"
	touch "${testfile}" 2> /dev/null
	if [ $? -ne 0 ]; then
		echo
		echo "error: \"${prefix}\""
		echo "       does exist, but is not writeable."
		echo "       Change the permissions and try again."
		echo
		read -t 5 -p "press enter to let sudo do the job!"
		if [ $? -ne 0 ]; then
			echo
			exit 1
		fi
		echo
		echo sudo chown $UID "${prefix}"
		sudo chown $UID "${prefix}"
		echo sudo chmod u+w "${prefix}"
		sudo chmod u+w "${prefix}"

		touch "${testfile}" 2> /dev/null
		if [ $? -ne 0 ]; then
			echo
			echo "error: cannot make \"${prefix}\" writeable, giving up"
			echo
			exit 1
		fi
	fi

	rm "${testfile}"

	mkdir -p "${prefix}"/{etc,lib,{,s}bin,include,{,share/}man/man{1,2,3,4,5,6,7,8,9}}
}


#
# Most install stages think that some standard directories are there, so
# they are created here.
#
check_dirs() {
	local ptxconf_sysroot_target ptxconf_sysroot_host ptxconf_sysroot_cross
	local dir testfile_upper testfile_lower

	ptxconf_sysroot_target="$(ptxd_get_ptxconf PTXCONF_SYSROOT_TARGET)"
	ptxconf_sysroot_host="$(ptxd_get_ptxconf PTXCONF_SYSROOT_HOST)"
	ptxconf_sysroot_cross="$(ptxd_get_ptxconf PTXCONF_SYSROOT_CROSS)"

	# check for r/w and create standard directory layout
	for dir in \
		"${ptxconf_sysroot_target}" \
		"${ptxconf_sysroot_target}/usr" \
		"${ptxconf_sysroot_host}" \
		"${ptxconf_sysroot_cross}" \
		; do
		check_dirs_prefix "${dir}"
	done

	# create build and output dirs
	for dir in \
		"${BUILDDIR}" \
		"${CROSS_BUILDDIR}" \
		"${HOST_BUILDDIR}" \
		"${STATEDIR}" \
		"${IMAGEDIR}" \
		"${ROOTDIR}" \
		"${ROOTDIR_DEBUG}" \
		; do
		mkdir -p "${dir}"
	done

	# check for case sensitive file system
	for dir in \
		"${BUILDDIR}" \
		"${CROSS_BUILDDIR}" \
		"${HOST_BUILDDIR}" \
		; do
		testfile_lower=${dir}/.secret-world-domination-project
		testfile_upper=${dir}/.Secret-World-Domination-Project

		echo lower > "${testfile_lower}"
		echo upper > "${testfile_upper}"

		if [ "$(cat "${testfile_lower}")" != "lower" -o \
		    "$(cat "${testfile_upper}")" != "upper" ]; then
			echo
			echo "error: \"${dir}\""
			echo "       is not a case sensitive filesystem."
			echo "       Please move your project to a case sensitive one"
			echo
			exit 1
		fi

		rm "${testfile_lower}" "${testfile_upper}"
	done
}

check_if_selected() {
	if [ -z ${1} ]; then
		echo
		echo "${PROMPT}error: please specify a target"
		echo
		exit 1
	fi
	local configvar="PTXCONF_$(ptxd_name_to_NAME ${1})"
	local ptxconfig_configvar="$(ptxd_get_ptxconf $configvar)"

	if [ -z ${ptxconfig_configvar} ]; then
		echo
		echo "${PROMPT}error: $1 is not selected in ${PTXCONFIG}"
		echo
		exit 1
	fi
}


clone() {
	local ifs_old projectdir

	if [ -z "$1" ]; then usage; exit 1; fi
	if [ -z "$2" ]; then usage; exit 1; fi

	if [ -d "$2" ]; then
		echo
		echo "${PROMPT}error: directory $2 does already exist"
		echo
		exit 1
	fi

	ifs_old=$IFS
	IFS=:

	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do

		echo "${PROMPT}scanning $projectdir..."

		if [ -d "${projectdir}/$1" ] ; then

			mkdir -p $2
			tar -C ${projectdir}/$1 -cf - \
			    --exclude .svn --exclude state --exclude debian . | \
			    tar -C $2 -xvf -

			echo "${PROMPT}done."
			echo
			return 0
		fi
	done
	IFS=$ifs_old

	echo "${PROMPT}project $1 is to be cloned, but could not be found"
	echo
}


#
# usage()
#
usage() {
cat << EOF

PTXdist $(printf "%-24s" ${FULLVERSION}) Build System for Embedded Linux Systems

  ptxdist <action [args]> [options]

Setup and Project Actions:

  setup				setup per-user preferences
  boardsetup			setup per-board preferences

  projects			show available projects
  clone <from> <to>		create a new project, cloned from <from>.

  menuconfig			configure the root filesystem
  oldconfig			run 'make oldconfig' on ptxconfig file
  kernelconfig			configure the kernel

  u_boot_config			configure U-Boot (U-Boot V2 only)

  toolchain [<path>]		if path is omitted the toolchain is guessed,
				    (guessing works only platformconfig is
				    already selected)
				othewise select this toolchain
				    (<path> to binaries)
  select <config>		if there is no ptxconfig file you can
				select one of several configs to be used
Build Actions:

  go				start building the current project

  get <package>			get packet sources
  extract <package>		extract packet
  prepare <package>		run configure stages for packet
  compile <package>		compile the sources
  install <package>		install host side components into sysroot/
  targetinstall <package>	install files for target into root/
  clean <package>		cleanup packet
  autobuild			search for "autobuild" scripts and run them
  drop <package>.<stage>	mark a stage of a packet as unbuilt

  images			build images for target system

Clean Actions:

  clean				cleanup build-host and build-cross dirs
  distclean			cleanup everything
  (clean images)		cleanup images directory
  clean root			cleanup root directory for target
  (clean project)		cleanup project specific packages
  (clean maintainer)		maintainerclean

Misc

  --version			print out ptxdist version

  (svn up)			run "svn update" in topdir and project dir
  (svn stat)			run "svn stat" in topdir and project dir

  test <testname>		run tests

  newpacket <type>		create a new packet Makefile in a rules dir
				type can be one of:
				target, host, host-existing-target,
				cross, cross-existing-target, source,
				kernel_driver, font, simple

EOF
}

clean() {
	local dir bdir
	local ptxconf_sysroot_target ptxconf_sysroot_host ptxconf_sysroot_cross

	# we want to clean the root dir
	if [ "$1" = "root" ]; then
		echo
		echo "${PROMPT}cleaning root directory..."
		rm -fr "${ROOTDIR}"
		rm -fr "${ROOTDIR_DEBUG}"
		echo "${PROMPT}cleaning targetinstall stages..."
		rm -f "${STATEDIR}"/*.targetinstall*
		echo "${PROMPT}done."
		echo
		return
	fi

	# we want to clean a single package
	if [ -n "$1" ]; then
		check_if_selected "${1}"
		ptxd_make_log "${1}_clean"
		return
	fi

	echo
	echo "${PROMPT}removing build directories..."
	for dir in "${BUILDDIR}" "${CROSS_BUILDDIR}" "${HOST_BUILDDIR}"; do
		if [ ! -d "${dir}" ]; then
			continue
		fi
		for bdir in $(find "${dir}" -maxdepth 1 -mindepth 1 -type l); do
		    # run 'make clean' for linked source directories
		    pushd "${bdir}" > /dev/null
		    echo -n "${PROMPT}running \"make clean\" in \"${bdir#${dir}/}\"... "
		    make clean 1> /dev/null 2>&1
		    echo "done"
		    popd > /dev/null
		done
		rm -rf "${dir}"
	done

	if [ -f "${PTXCONFIG}" ]; then
		echo "${PROMPT}removing sysroot directories..."
		ptxconf_sysroot_target="$(ptxd_get_ptxconf PTXCONF_SYSROOT_TARGET)"
		ptxconf_sysroot_host="$(ptxd_get_ptxconf PTXCONF_SYSROOT_HOST)"
		ptxconf_sysroot_cross="$(ptxd_get_ptxconf PTXCONF_SYSROOT_CROSS)"

		for dir in "${ptxconf_sysroot_target}" "${ptxconf_sysroot_host}" "${ptxconf_sysroot_cross}"; do
			if [ ! -d "${dir}" ]; then
				continue
			fi
			#
			# remove the dir only if it is inside the workspace; if we for
			# example build toolchains or production builds to /opt/...,
			# we don't want to clean them here!
			#
			case "${dir}" in
			    (${PTXDIST_WORKSPACE}/*)
				rm -rf "${dir}"
				;;
			    (*)
				;;
			esac
		done
	fi

	echo "${PROMPT}removing deps..."
	rm -f "${PTXDIST_PLATFORMDIR}/"{deptree-a4.ps,deptree.ps}
	rm -f "${STATEDIR}/depend.out"
	echo "${PROMPT}removing imagedir..."
	rm -fr "${IMAGEDIR}"
	echo "${PROMPT}removing root..."
	rm -fr "${ROOTDIR}"
	rm -fr "${ROOTDIR_DEBUG}"
	echo "${PROMPT}removing state..."
	rm -fr "${STATEDIR}"
	echo "${PROMPT}removing logfile..."
	rm -f "${PTX_LOGFILE}"
	echo "${PROMPT}removing test logfile..."
	rm -f "${PTXDIST_PLATFORMDIR}/test.log"
	echo "${PROMPT}removing packages dir..."
	rm -fr "${PKGDIR}"

	# remove the remaining PTXDIST_PLATFORMDIR (if empty)
	rmdir "${PTXDIST_PLATFORMDIR}" > /dev/null 2>&1

	echo "${PROMPT}done."
	echo
}

drop() {
	local statefile
	if [ -z "$2" ]; then
		statefile="$1"
	else
		statefile="$1.$2"
	fi

	echo
	if [ -e "${STATEDIR}/${statefile}" ]; then
		rm -f "${STATEDIR}/${statefile}"
		echo "dropping ${statefile}"
		echo
		exit
	else
		echo "stage ${statefile} isn't built, so we cannot drop it"
		echo
		exit 1
	fi
}

menuconfig_action() {
	echo "${PROMPT}menuconfig..."
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${kconfig}"
}

newpacket() {
	local packet_name version url author year suffix overwrite \
	    template template_file template_suffix packet_filename packet_name packet PACKET packetdash filename \
	    class CLASS autoconf_class

	case $1 in
	    target|host|host-existing-target|cross|cross-existing-target|source|kernel_driver|font|simple)
		;;
	    *)	echo
		echo "${PROMPT}error: illegal packet type: $1"
		echo "must be one of host, host-existing-target, target,"
		echo "cross, cross-existing-target, source, kernel_driver, font, simple"
		echo
		exit 1
		;;
	esac

	echo
	echo "${PROMPT}creating a new packet:"
	echo
	echo -n "${PROMPT}enter packet name.......: "
	read packet_name
	echo -n "${PROMPT}enter version number....: "
	read version
	echo -n "${PROMPT}enter URL of basedir....: "
	read url
	echo -n "${PROMPT}enter packet author.....: "
	read author
	echo -n "${PROMPT}enter suffix............: "
	read suffix

	case $1 in
	    target)
		template=template
		class=
		autoconf_class=
		;;
	    host)
		template=template-class
		class=host-
		autoconf_class=HOST_
		;;
	    cross)
		template=template-class
		class=cross-
		autoconf_class=HOST_CROSS_
		;;
	    host-existing-target)
		template=template-class-existing-target
		class=host-
		autoconf_class=HOST_
		;;
	    cross-existing-target)
		template=template-class-existing-target
		class=cross-
		autoconf_class=HOST_CROSS_
		;;
	    source)
		template=template-src
		class=
		autoconf_class=
		;;
	    kernel_driver)
		template=template-driver
		class=
		autoconf_class=
		;;
	    font)
		template=template-font
		class=
		autoconf_class=
		;;
	    simple)
		template=template-file
		class=
		autoconf_class=
		;;
	esac

	packet_filename="${packet_name}"

	packet="$(echo ${packet_name} | tr "[A-Z]" "[a-z]")"
	packetdash="$(echo ${packet} | tr "[_]" "[\-]")"
	PACKET="$(echo ${packet_name} | tr "[a-z-]" "[A-Z_]")"
	CLASS="$(echo ${class} | tr "[a-z-]" "[A-Z_]")"

	year=$(date +%Y)

	for template_suffix in "make" "in"; do
	    template_file="${RULESDIR}/${template}-${template_suffix}"
	    filename="${class}${packet_filename}.${template_suffix}"

	    if [ ! -f "${template_file}" ]; then
		echo
		echo "${PROMPT}warning: template \"${template_file}\" does not exist"
		echo
		continue
	    fi

	    if [ -f "${filename}" ]; then
		echo
		echo -n "${PROMPT}warning: ${filename} does already exist, overwrite? [y/n]"
		read overwrite
		if [ "$overwrite" != "y" ]; then
		    echo "${PROMPT}aborted."
		    echo
		    exit
		fi
	    fi

	    sed \
		-e "s#\@packet_filename@#${packet_filename}#g" \
		-e "s#\@PACKET@#${PACKET}#g" \
		-e "s#\@packet@#${packet}#g" \
		-e "s#\@packetdash@#${packetdash}#g" \
		-e "s#\@class@#${class}#g" \
		-e "s#\@CLASS@#${CLASS}#g" \
		-e "s#\@AUTOCONF_CLASS@#${autoconf_class}#g" \
		-e "s#\@VERSION@#${version}#g" \
		-e "s#\@URL@#${url}#g" \
		-e "s#\@YEAR@#${year}#g" \
		-e "s#\@AUTHOR@#${author}#g" \
		-e "s#\@SUFFIX@#${suffix}#g" \
		"${template_file}" \
		> "${filename}"
	done
}

oldconfig_action() {
	"${PTXDIST_TOPDIR}/scripts/kconfig/conf" -s "${kconfig}"
}


platformconfig_action() {
	echo "${PROMPT}platformconfig..."
	echo
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${kconfig_platform}"
}


projects() {
	local ifs_old projects projectdir
	echo
	echo "${PROMPT}searching for projects:"
	ifs_old=$IFS
	IFS=:
	projects=
	for projectdir in ${PTXCONF_SETUP_PROJECTPATH}; do
		echo "${PROMPT}scanning ${projectdir}..."
		if [ ! -d ${projectdir} ]; then
			echo
			echo "${PROMPT}error: directory does not exist"
			echo "${PROMPT}please check PTXCONF_SETUP_PROJECTPATH in 'ptxdist setup'"
			exit 1
		fi
		projects="$projects $(cd ${projectdir} && find .  -maxdepth 1 -type d ! -name .svn ! -name . -exec basename {} \;)"
	done
	IFS=$ifs_old
	projects=$(echo $projects | sort -u)
	echo
	echo "---------------------- Available PTXdist Projects: ----------------------------"
	for i in $projects; do echo $i; done
	echo "-------------------------------------------------------------------------------"
	echo
}


setup_action() {
	"${PTXDIST_TOPDIR}/scripts/kconfig/mconf" "${PTXDIST_TOPDIR}/config/setup/Kconfig"
}


toolchain() {
	local toolchain
	local vendor target version hint num

	toolchain="${1}"

	#
	# guess the toolchain if path is omitted
	#
	if [ -z "${toolchain}" ]; then
		if [ ! -e "${PLATFORMCONFIG}" ]; then
			echo
			echo "${PROMPT}error: cannot guess toolchain, no ${PLATFORMCONFIG#${PTXDIST_WORKSPACE}/} found"
			echo
			exit 1
		fi

		vendor="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_VENDOR)"
		target="$(ptxd_get_ptxconf PTXCONF_GNU_TARGET)"
		version="$(ptxd_get_ptxconf PTXCONF_CROSSCHAIN_CHECK)"

		hint="/opt/${vendor}/${target}/gcc-${version}-*/bin"

		if [ -z "${vendor}" -o \
		    -z "${target}" -o \
		    -z "${version}" ]; then
			echo
			echo "${PROMPT}error: insufficient information in your ptxconfig file"
			echo "${PROMPT}       please use 'ptxdist toolchain <path>"
			echo
			exit 1
		else
			echo
			echo "${PROMPT}CROSSCHAIN_VENDOR : ${vendor}"
			echo "${PROMPT}CROSSCHAIN_CHECK  : ${version}"
			echo "${PROMPT}GNU_TARGET        : ${target}"
			echo "${PROMPT}"
			echo "${PROMPT}looking for       : ${hint}"
			echo "${PROMPT}"
		fi
		# let the shell expand the "*" in the hint, put it into an array
		toolchain=($(echo ${hint}))

		# number of items in array == number of found toolchains
		num="${#toolchain[@]}"

		if [ ${num} -eq 0 ]; then
			echo "${PROMPT}"
			echo "${PROMPT}"
			echo "${PROMPT}error: sorry, no toolchain found, matching"
			echo "${PROMPT}       ${hint}"
			echo
			exit 1
		elif [ ${num} -ne 1 ]; then
			echo "${PROMPT}"
			echo "${PROMPT}"
			echo "${PROMPT}error: more than one toolchain found, matching"
			echo "${PROMPT}       ${hint}"
			echo "${PROMPT}       ${toolchain}"
			echo
			exit 1
		fi
	fi

	if [ ! -d "${toolchain}" ]; then
		echo
		echo "${PROMPT}error: path ${toolchain} does not exist"
		echo
		exit 1
	fi
	echo "${PROMPT}using toolchain in \"${toolchain}\""
	test -L ".toolchain" && rm -f .toolchain
	if [ -e ".toolchain" ]; then
		echo
		echo "${PROMPT}error: There is a .toolchain in this directory which is no link."
		echo "${PROMPT}error: This should never happen, please contact the"
		echo "${PROMPT}error: Pengutronix Department of Illegal File Removement."
		echo
		exit 1
	fi
	ln -sf "${toolchain}" .toolchain
	echo
}




################ setup stuff only ################################


#
# figure out PTXDIST_TOPDIR
# this is where the ptxdist installation lives
#
# out: PTXDIST
#      PTXDIST_TOPDIR
#      PTXDIST_WORKSPACE
#
setup_topdir() {
	local ptxdist topdir

	ptxdist="$(readlink -f "${0}")"
	topdir="$(cd "$(dirname "${ptxdist}")"/.. && pwd)"

	#
	# sanity check: is PTXdist already configured?
	#
	if [ ! -e "${topdir}/.done" ]; then
		echo
		echo "${PROMPT}error: PTXdist in ${topdir} is not built."
		echo
		exit 1
	fi

	PTXDIST="${ptxdist}"
	PTXDIST_TOPDIR="${topdir}"
	PTXDIST_WORKSPACE="$(pwd)"
}


#
# deletes ptxdist's temporary storage
# closes logfile
#
# in: PTXDIST_TEMPDIR
# in: PTX_LOGFILE
#
ptxdist_trap_handler() {
	if [ -n "${PTXDIST_TEMPDIR}" -a -d "${PTXDIST_TEMPDIR}" ]; then
		rm -rf "${PTXDIST_TEMPDIR}"
	fi
	if [ -e "${PTX_LOGFILE}" ]; then
		#
	    	# use these quotes to keep Enrik's editor happy
		#        \\
		#         VV
		echo -e "}""}} $(date '+%FT%T%z') ${PTXDIST} ${PTXDIST_FULLARGS[@]}\n\n\n" >> "${PTX_LOGFILE}"
	fi
}


#
# setups trap, to delete temporary storage
#
setup_traps() {
	trap 'ptxdist_trap_handler' 0 1 15
}


#
# source the scripts we need
#
# we need the PTXdist shell library
# we need the version definitions
# we need the static variable definitions
#
# out: "ptxd_*"		library calls
#      "*"		ptxdist version variables
#      "*DIR"		directory definitions (some not correct, due to missing PTXDIST_PLATFORMDIR)
#      PTXDIST_TEMPDIR	generic ptxdist temp dir
#
setup_libs() {
	local file abs_file

	for file in \
		scripts/ptxdist_vars.sh \
		scripts/ptxdist_version.sh \
		scripts/libptxdist.sh \
	; do
		abs_file="${PTXDIST_TOPDIR}/${file}"
		if [ -e "${abs_file}" ]; then
			. "${abs_file}"
		else
			echo "${PROMPT}FATAL didn't find ${abs_file}"
			exit 1
		fi
	done

	PTXDIST_TEMPDIR="$(mktemp -d /tmp/ptxdist.XXXXXX)"
	if [ ${?} -ne 0 ]; then
		echo
		echo "${PROMPT}error: unable to create tempdir"
		echo
		exit 1
	fi
}


#
# setup PTXDIST_PLATFORMDIR properly
#
# out: PTXDIST_PLATFORMDIR
#      PTXDIST_PLATFORMSUFFIX
#      PTXDIST_PLATFORMCONFIGDIR
#      "*DIR"	correct directory definitions
#
setup_platform() {
	local platform cfg_dir

	platform="$(ptxd_get_ptxconf PTXCONF_PLATFORM)"

	if [ -n "${platform}" ]; then
		PTXDIST_PLATFORMDIR="${PTXDIST_WORKSPACE}/platform-${platform}"
		PTXDIST_PLATFORMSUFFIX=".${platform}"
	else
		PTXDIST_PLATFORMDIR="${PTXDIST_WORKSPACE}"
		PTXDIST_PLATFORMSUFFIX=""
	fi

	# reread vars with correct PTXDIST_PLATFORMDIR
	. "${SCRIPTSDIR}/ptxdist_vars.sh"

	if [ -e "${PLATFORMCONFIG}" ]; then
		cfg_dir="$(dirname "$(readlink -f "${PLATFORMCONFIG}")")"
	else
		unset cfg_dir
	fi

	PTXDIST_PLATFORMCONFIGDIR="${cfg_dir}"
}


#
# source the user's .ptxdistrc
# or default one
# setup PTXDIST_SRCDIR
#
# out: PTXCONF_*	user preferences
#      PTXDIST_SRCDIR
#      PTXDIST_PARALLELMFLAGS_INTERN
#      PTXDIST_PARALLELMFLAGS_EXTERN
#
setup_config() {
	local rc_user rc_default cpus pmf_intern pmf_extern

	rc_user="${HOME}/.ptxdistrc.${FULLVERSION}"
	rc_default="${PTXDIST_TOPDIR}/config/setup/ptxdistrc.default"

	if [ \! -e "${rc_user}" ]; then
		cp "${rc_default}" "${rc_user}"
	fi

	ptxd_source_kconfig "${rc_user}"

	#
	# setup SRCDIR
	#
	if [ -z "${PTXCONF_SETUP_SRCDIR}" ]; then
		PTXDIST_SRCDIR="${PTXDIST_WORKSPACE}/src"
	else
		PTXDIST_SRCDIR="${PTXCONF_SETUP_SRCDIR}"
	fi

	#
	# setup PARALLELMFLAGS
	#

	# default no parallel for now
	pmf_extern=-j1

	#
	# user may override PARALLELMFLAGS
	#
	if [ -n "${PARALLELMFLAGS}" ]; then
		pmf_intern="${PARALLELMFLAGS}"
		unset PARALLELMFLAGS
	else
		if [ -r /proc/cpuinfo ]; then
			cpus="$(egrep '^(processor|cpu  )' /proc/cpuinfo | wc -l)"
			if [ $cpus -eq 0 ]; then
				cpus=1
			fi
		else
			cpus=1
		fi

		pmf_intern=-j$(( $cpus * 2 ))
	fi

	#
	# user may overwrite these, too
	#
	PTXDIST_PARALLELMFLAGS_INTERN="${PTXDIST_PARALLELMFLAGS_INTERN:-${pmf_intern}}"
	PTXDIST_PARALLELMFLAGS_EXTERN="${PTXDIST_PARALLELMFLAGS_EXTERN:-${pmf_extern}}"
}


#
# add .toolchain and sysroots to path
#
# out: PATH
#      PTXDIST_TOOLCHAIN
#
setup_path() {
	local sysroot_host
	#
	# use linked toolchain if available
	#
	if [ -d ".toolchain" ]; then
		PTXDIST_TOOLCHAIN="${PTXDIST_WORKSPACE}/.toolchain"
		PATH="${PTXDIST_TOOLCHAIN}:$PATH"
	fi

	# dir might not be available yet, but will be created later
	sysroot_host="$(ptxd_get_ptxconf PTXCONF_SYSROOT_HOST)"

	if [ -n "${sysroot_host}" ]; then
		PATH="${sysroot_host}/bin:${sysroot_host}/sbin:$PATH"
	fi
}


#
# starts logfile
#
setup_logfile()
{
	local logdir

	logdir="${PTX_LOGFILE%/*}"

	if [ ! -d "${logdir}" ]; then
		mkdir -p ${logdir} || ptxd_bailout "cannot create dir ${logdir}"
	fi
	# use these quotes to keep Enrik's editor happy
	#      ||
	#      VV
	echo "{""{{ $(date '+%FT%T%z') ${PTXDIST} ${PTXDIST_FULLARGS[@]}" >> "${PTX_LOGFILE}"
}

########################################################################
# main()
########################################################################

setup_topdir
setup_traps
setup_libs
# ---  libs are available from here ---
setup_platform
# --- platformdir and other *dirs are available from here ---
setup_config
# --- all variables are defined now ---
setup_path
# --- path is now set ---
setup_logfile

export PROJECT FULLVERSION VERSION PATCHLEVEL SUBLEVEL EXTRAVERSION		# FIXME: review these
export \
	PATH \
	\
	PTXDIST \
	PTXDIST_TOPDIR \
	PTXDIST_SRCDIR \
	PTXDIST_TEMPDIR \
	\
	PTXDIST_WORKSPACE \
	\
	PTXDIST_PLATFORMDIR \
	PTXDIST_PLATFORMSUFFIX \
	PTXDIST_PLATFORMCONFIGDIR \
	\
	PTXDIST_PARALLELMFLAGS_INTERN

check_uid
check_path

if [ "$#" = "0" ]; then
	usage
	exit 0
fi

while [ "$#" != "0" ]; do

	case "${1}" in
	autobuild)	echo
			echo "${PROMPT}running autobuild"
			echo
			AUTOBUILDS=$(find . -name "autobuild*" | grep -v .svn)
			AUTOBUILD_TOPDIR=$(pwd)
			exec 5>COMPILETEST
			echo >&5
			for i in $AUTOBUILDS; do
				pushd $(dirname $i)

				echo "config............: $(basename $(pwd))" >&5
				echo "date..............: $(date)" >&5
				echo "user..............: ${USER}@${HOSTNAME}" >&5
				PTX_STARTTIME=$(date +"%s")

				./$(basename $i)

				PTX_RETVAL=$?
				PTX_STOPTIME=$(date +"%s")
				let "PTX_TIME=$PTX_STOPTIME-$PTX_STARTTIME"
				let "PTX_TIME_H=$PTX_TIME/3600"
				let "PTX_TIME_M=($PTX_TIME-$PTX_TIME_H*3600)/60"
				let "PTX_TIME_S=($PTX_TIME-$PTX_TIME_H*3600-$PTX_TIME_M*60)/60"
				echo "buildtime.........: ${PTX_TIME_H}h${PTX_TIME_M}m${PTX_TIME_S}s" >&5
				echo "result............: ${PTX_RETVAL}" >&5
				echo >&5

				[ -e "logfile" ] && mv logfile "${AUTOBUILD_TOPDIR}/$(basename $(pwd)).log"
				[ "${PTX_RETVAL}" = "0" ] && ${PTXDIST} distclean

				popd
			done
			echo
			echo "${PROMPT}done"
			echo
			exit
			;;
	boardsetup)	shift
			check_ptxconfig
			boardsetup
			;;
	compile)	shift
			check_ptxconfig
			check_if_selected $1
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log "${STATEDIR}/${1}.compile"
			check_pipe_status
			exit
			;;
	clean)		shift
			check_ptxconfig
			check_deps
			clean $1
			exit
			;;
	clone)		shift;
			clone $1 $2
			exit
			;;
	-d|--debug)	shift
			export PTXDIST_MAKE_DBG="--debug=make"
			;;
	distclean)	shift
			clean
			echo "${PROMPT}removing toolchain link..."
			rm -f .toolchain
			echo "${PROMPT}removing logs dir..."
			rm -fr ${PTXDIST_PLATFORMDIR}/logfile
			if [ -L "${PTXCONFIG}" ]; then
				echo "${PROMPT}removing ptxconfig link..."
				rm "${PTXCONFIG}"
			fi
			if [ -L "${PLATFORMCONFIG}" ]; then
				echo "${PROMPT}removing platformconfig link..."
				rm "${PLATFORMCONFIG}"
			fi
			echo
			;;
	drop)		shift
			check_ptxconfig
			drop $1 $2
			;;
	export)		shift
			if [ ! -d "${1}" ]; then
				echo
				echo "${PROMPT}error: directory '$1' does not exist!"
				echo
				exit 1
			fi
			export EXPORTDIR="${1}"
			check_ptxconfig
			check_deps
			ptxd_make_log export
			check_pipe_status
			exit
			;;
	extract)	shift
			check_ptxconfig
			check_if_selected $1
			check_deps
			ptxd_make_log "${STATEDIR}/${1}.extract"
			check_pipe_status
			exit
			;;
	get)		shift
			check_ptxconfig
			check_deps
			if [ $# -eq 0 ]; then
				ptxd_make_log get
				check_pipe_status
				exit
			else
				check_if_selected $1
				ptxd_make_log "${STATEDIR}/${1}.get"
				check_pipe_status
				exit
			fi
			;;
	go)		shift
			check_ptxconfig
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log world
			check_pipe_status
			exit
			;;
	help|--help)	shift
			usage
			exit
			;;
	images)		shift
			check_ptxconfig
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log world
			check_pipe_status
			ptxd_make_log images
			check_pipe_status
			exit
			;;
	install)	shift
			check_ptxconfig
			check_if_selected $1
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log "${STATEDIR}/${1}.install"
			check_pipe_status
			exit
			;;
	kernelconfig)	shift
			check_ptxconfig
			check_deps
			ptxd_make kernel_menuconfig
			check_pipe_status
			exit
			;;
	u_boot_config)	shift
			check_ptxconfig
			check_deps
			ptxd_make u-boot-v2_menuconfig
			check_pipe_status
			exit
			;;
	maintainer)	shift
			if [ "$#" = "0" ]; then
				echo
				echo "${PROMPT} commands:"
				echo
				echo "${PROMPT} configversionbump"
				echo "${PROMPT} alloldconfig"
				echo
				exit
			fi
			case $1 in
			configversionbump)
				echo
				echo "${PROMPT} configversionbump:"
				echo
				for i in $(find . -name "ptxconfig*" | grep -v .svn); do
					echo "${PROMPT} version fixup in $i..."
					sed -i -e \
						"s/PTXCONF_CONFIGFILE_VERSION=\".*\"/PTXCONF_CONFIGFILE_VERSION=\"${FULLVERSION}\"/g" \
						$i
				done
				;;
			alloldconfig)
				echo
				echo "${PROMPT} alloldconfig:"
				echo
				for i in $(find . -name "autobuild" | grep -v .svn); do
					i_dir=$(dirname $i)
					echo i=$i i_dir=$i_dir
					pushd $i_dir
					ptxdist oldconfig
					popd
				done
				;;
			*)
				echo
				echo "${PROMPT} error: unknown command: $1"
				echo
				exit 1
				;;
			esac
			exit
			;;
	make)		shift
			check_ptxconfig
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log "${1}"
			check_pipe_status
			exit
			;;
	menuconfig)	shift
			check_ptxconfig
			if [ ${#} -eq 0 ]; then
				ptxd_kconfig "${PTXCONFIG}" menuconfig_action true
			else
				check_deps
				ptxd_make "${1}_menuconfig"
			fi
			check_pipe_status
			exit
			;;
	newpacket)	# test if we are in a rules dir
			if [ "$(basename $(pwd))" != "rules" ]; then
				echo
				echo "${PROMPT}error: newpacket command only allowed in a rules dir"
				echo
				exit 1
			fi
			shift
			newpacket "$1"
			exit $?
			;;
	oldconfig)	shift
			check_ptxconfig
			if [ ${#} -eq 0 ]; then
				ptxd_kconfig "${PTXCONFIG}" oldconfig_action true
			else
				check_deps
				ptxd_make "${1}_oldconfig"
			fi
			exit $?
			;;
	platform)	shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "${PLATFORMCONFIG}" ]; then
				echo
				echo -n "${PROMPT}warning: overwrite existing platformconfig [Y/n]? "
				read answer
				if [ "$answer" != "y" -a "$answer" != "" ]; then
					echo "interrupting"
					echo
					exit 1
				fi
			fi
			echo
			echo "${PROMPT}selecting platformconfig \"$1\""
			ln -sf "${1}" "${PLATFORMCONFIG}"
			echo "${PROMPT}done."
			echo
			exit
			;;
	platformconfig)	shift
			ptxd_kconfig "${PLATFORMCONFIG}" platformconfig_action true
			;;
	prepare)	shift
			check_ptxconfig
			check_if_selected "${1}"
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log "${STATEDIR}/${1}.prepare"
			check_pipe_status
			exit
			;;
	print)		shift
			check_ptxconfig
			check_deps
			ptxd_make_log "print-${1}"
			check_pipe_status
			shift
			;;
	projects)	shift
			projects
			;;
	select)		shift
			if [ ! -f "$1" ]; then
				echo
				echo "${PROMPT}error: couldn't select \"$1\", file does not exist"
				echo
				exit 1
			fi
			if [ -f "${PTXCONFIG}" -a ! -L "${PTXCONFIG}" ]; then
				echo
				echo "${PROMPT}error: There already is a ptxconfig file."
				echo "${PROMPT}error: If you really want to select another configuration,"
				echo "${PROMPT}error: please move away the ptxconfig file first."
				echo
				exit 1
			fi
			echo
			echo "${PROMPT}linking $1 to ptxconfig"
			ln -sf "${1}" "${PTXCONFIG}"
			echo "${PROMPT}done."
			echo
			exit
			;;
	setup)		shift
			ptxd_kconfig "${PTXDISTRC}" setup_action true
			;;
	targetinstall)	shift
			check_ptxconfig
			check_if_selected $1
			check_compiler
			check_dirs
			check_deps
			ptxd_make_log "${STATEDIR}/${1}.targetinstall.post"
			check_pipe_status
			exit
			;;
	test)		shift
			if [ -z "$1" ]; then
				echo "No test given. try ptxdist test help for a list of available tests"
				exit 1
			fi
			if [ "$1" = help ]; then
				echo "available tests:"
				find $PTXDIST_WORKSPACE/tests -maxdepth 1 -type f -exec basename {} \;
				exit
			fi
			if [ -x "$PTXDIST_WORKSPACE/tests/$1" ]; then
				echo
				"$PTXDIST_WORKSPACE/tests/$1" > ${PTXDIST_WORKSPACE}/test.log
				echo
			elif [ -x "$PTXDIST_TOPDIR/tests/$1" ]; then
				echo
				"$PTXDIST_TOPDIR/tests/$1" > ${PTXDIST_WORKSPACE}/test.log
				echo
			else
				echo
				echo "${PROMPT}error: test '$1' not found in PTXDIST_TOPDIR and PTXDIST_WORKSPACE"
				echo
			fi
			exit
			;;
	toolchain)	shift
			toolchain "${1}"
			exit
			;;
	--toolchain)	shift
			echo
			PTXDIST_TOOLCHAIN="${1}"
			if [ ! -d "${PTXDIST_TOOLCHAIN}" ]; then
				echo
				echo "${PROMPT}error: path ${PTXDIST_TOOLCHAIN} does not exist"
				echo
				exit 1
			fi
			echo "${PROMPT}using toolchain in ${PTXDIST_TOOLCHAIN}"
			export PATH="${PTXDIST_TOOLCHAIN}:$PATH"
			shift
			echo
			;;
	--version)	echo ${FULLVERSION}
			exit 0
			;;
	*)		shift
			usage
			exit 1
			;;
	esac

done

exit 0
