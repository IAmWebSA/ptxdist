diff -iEbwBuNau kdrive_alt/linux/Imakefile xc/programs/Xserver/hw/kdrive/linux/Imakefile
--- kdrive_alt/linux/Imakefile	2002-11-01 23:27:49.000000000 +0100
+++ xc/programs/Xserver/hw/kdrive/linux/Imakefile	2004-02-13 10:19:43.000000000 +0100
@@ -13,9 +13,9 @@
 #endif
 #endif
 
-SRCS = keyboard.c linux.c mouse.c ps2.c bus.c ms.c agp.c $(TSSRCS)
+SRCS = keyboard.c linux.c input.c mouse.c ps2.c bus.c ms.c agp.c $(TSSRCS)
 
-OBJS = keyboard.o linux.o mouse.o ps2.o bus.o ms.o agp.o $(TSOBJS)
+OBJS = keyboard.o linux.o input.o mouse.o ps2.o bus.o ms.o agp.o $(TSOBJS)
 
 INCLUDES = -I. $(KDINCS)
 
diff -iEbwBuNau kdrive_alt/linux/input.c xc/programs/Xserver/hw/kdrive/linux/input.c
--- kdrive_alt/linux/input.c	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/kdrive/linux/input.c	2004-02-13 15:41:18.000000000 +0100
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2004 Juergen Beisert
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * This driver supports the input subsystem of the linux kernel to drive the cursor
+ * of this X server. If you use this driver you don't need to know which device
+ * you connect to your system. Because the input subsystem generalize any input device
+ * (keyboard, mouse, pad, tablet, joystick, touch) this driver runs for every device.
+ * Attention: The tablet support is not tested yet (report of absolut coordinates does
+ * not work).
+ */
+
+/**********************************************************************************
+ * $Log: kdrive_linux_input.c,v $
+ * Revision 1.1  2004/02/13 14:41:18  jb
+ * first time working
+ *
+ **********************************************************************************/
+
+#define NEED_EVENTS
+#include "X.h"
+#include "Xproto.h"
+#include "inputstr.h"
+#include "scrnintstr.h"
+#include "kdrive.h"
+#include "Xpoll.h"
+#include <linux/input.h>
+
+/**********************************************************************************
+ * Some local stuff
+ **********************************************************************************/
+
+static int linuxInputType;
+static int eventPort;
+
+/*
+ * missing when include "linux/input.h" from userland
+ * FIXME: How to get BITS_PER_LONG in userland?
+ */
+#define BITS_PER_LONG 32
+#define BIT(x) (1UL<<((x)%BITS_PER_LONG))
+#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)
+#define LONG(x) ((x)/BITS_PER_LONG)
+
+/* #################################################################################### */
+
+/**
+ * linuxEventRead - Read the next event and feed it into the X system
+ * @fh: Filehandle for port to read
+ * @closure: Decription of this device (given with KdRegisterFd() )
+ *
+ * Other drivers do this in two steps. First step is read, second is parsing
+ * the protocoll. We do it here in one step.
+ */
+
+static void linuxEventRead(int fh, void *closure)
+{
+struct input_event event;
+static unsigned long flags=0UL;
+static signed int dx=0,dy=0,dz=0;
+unsigned long repeatFlags;
+KdMouseInfo	*mi=closure;
+
+	if (read(fh,&event,sizeof(struct input_event)) == sizeof(struct input_event)) {
+		switch(event.type) {
+		case EV_KEY:		/* key changed */
+			switch (event.code) {
+			case BTN_0:
+			case BTN_FORWARD:
+			case BTN_LEFT:
+				if (event.value)
+					flags |= KD_BUTTON_1;
+				else
+					flags &= ~KD_BUTTON_1;
+				break;
+
+			case BTN_4:
+			case BTN_EXTRA:
+				if (event.value)
+					flags |= KD_BUTTON_5;
+				else
+					flags &= ~KD_BUTTON_5;
+				break;
+
+			case BTN_STYLUS:
+			case BTN_1:
+			case BTN_RIGHT:
+				if (event.value)
+					flags |= KD_BUTTON_2;
+				else
+					flags &= ~KD_BUTTON_2;
+				break;
+
+			case BTN_3:
+			case BTN_BACK:
+			case BTN_SIDE:
+				if (event.value)
+					flags |= KD_BUTTON_4;
+				else
+					flags &= ~KD_BUTTON_4;
+				break;
+
+			case BTN_2:
+			case BTN_STYLUS2:
+			case BTN_MIDDLE:
+				if (event.value)
+					flags |= KD_BUTTON_3;
+				else
+					flags &= ~KD_BUTTON_3;
+				break;
+			}
+			break;	/* EV_KEY */
+
+		case EV_REL:	/* movement */
+			switch(event.code) {
+				case REL_X:
+					dx += event.value;
+					break;
+
+				case REL_Y:
+					dy += event.value;
+					break;
+
+				case REL_WHEEL:
+					dz = event.value;
+					if (dz > 0)
+						flags |= KD_BUTTON_4;
+					else {
+						flags |= KD_BUTTON_5;
+						dz = -dz;
+					}
+					break;
+			}
+			break;	/* EV_REL */
+
+		case EV_ABS:	/* FIXME: Add support for tablet or joystick data */
+		case EV_MSC:
+		case EV_LED:
+		case EV_SND:
+		case EV_REP:
+		case EV_FF:
+		case EV_PWR:
+		case EV_FF_STATUS:
+		case EV_MAX:
+			break;
+
+		case EV_SYN:	/* event complete --> add KD_MOUSE_DELTA because dx and dy is relative! */
+			KdEnqueueMouseEvent(mi, flags | KD_MOUSE_DELTA , dx, dy);
+			dx=dy=0;
+
+			if (dz != 0) {
+				repeatFlags=flags & ~(KD_BUTTON_4 | KD_BUTTON_5);
+				KdEnqueueMouseEvent(mi,repeatFlags | KD_MOUSE_DELTA,0,0);
+				while(--dz) {
+					KdEnqueueMouseEvent(mi,flags | KD_MOUSE_DELTA, 0,0);
+					KdEnqueueMouseEvent(mi,repeatFlags | KD_MOUSE_DELTA,0,0);
+				}
+				flags=repeatFlags;	/* clean button 4 and 5 */
+			}
+			break;
+		}
+	}
+}
+
+/* #################################################################################### */
+
+/**
+ * checkForPointerDevice - Check if the given device is a pointing device
+ * @fh: Filehandle of opened device
+ * @mi: Decription of this device
+ *
+ * Returns:
+ * 0 on success -> this device is a pointing device
+ * else don't use this device, it's not a pointing device
+ */
+
+static int checkForPointerDevice(int fh,KdMouseInfo *mi)
+{
+unsigned long features[NBITS(KEY_MAX)];
+
+/* How to test?
+ * - We need a pointing device. Mouse devices delivers relative movements -> we test for EV_REL bits
+ *   At least REL_X and REL_Y should be set
+ */
+	if (ioctl(fh,EVIOCGBIT(EV_REL,sizeof(unsigned long)),features) == -1)
+		return(1);
+
+	if (features[0] & (BIT(REL_X) | BIT(REL_Y))) {
+	/*
+	 * ok, this seems to be a pointing device.
+	 * But how man buttons it have?
+	 * Three buttons are the default. But in the case of a wheel, we need five.
+	 * But if the user doesn't give "-mouse <device>,5" it will not work, because
+	 * something in KdEnqueueMouseEvent() will eat all button 4 and 5 events...
+	 *
+	 */
+		if (features[0] & (BIT(REL_WHEEL))) {
+			if (mi->nbutton != 5)
+				ErrorF(stderr,"Missing option -mouse <device>,5!\n");
+		}
+	#if 0
+		/* nothing changes in this server if I change nbutton here! Seems too late... */
+		else {
+			mi->nbutton=1;	/* only a fall back */
+			if (ioctl(fh,EVIOCGBIT(EV_KEY,sizeof(unsigned long)*NBITS(KEY_MAX)),features) == -1)
+				return(0);
+			if (features[LONG(BTN_MOUSE)] & (BIT(BTN_RIGHT))) {
+				mi->nbutton=2;
+				mi->emulateMiddleButton=1;
+			}
+			if (features[LONG(BTN_MOUSE)] & (BIT(BTN_MIDDLE))) {
+				mi->nbutton=3;
+				mi->emulateMiddleButton=0;
+			}
+		}
+	#endif
+		return(0);	/* return happy */
+	}
+
+/* FIXME: Test for absolute pointing devices */
+
+	return(1);
+}
+
+/* #################################################################################### */
+
+/**
+ * linuxInputInit - Open pointer device
+ *
+ * Tries to open a given device or, if no is given, tries to find a useable pointing device
+ *
+ * Returns:
+ * 0 if now pointer input device is found
+ * else count of pointer input devices found
+ */
+
+static int linuxInputInit(void)
+{
+int		i,devicesFound=0;
+int		n;
+char		deviceName[128];
+KdMouseInfo	*mi;
+
+	if (!linuxInputType)
+		linuxInputType = KdAllocInputType();
+/*
+ * Two possibilities hier:
+ * - the user has given a device (with option -mouse <path/to/device>), then we use it (in mi->name)
+ * - the user has not given a device, so we have to search for one
+ */
+	for (n=0,mi=kdMouseInfo; mi; mi = mi->next) {	/* walk through given devices */
+
+		if (mi->inputType)
+			continue;
+
+		mi->driver = 0;
+
+		if (mi->name != NULL) {	/* device given? */
+			eventPort=open(mi->name,2);
+			if (eventPort >= 0) {
+				if (checkForPointerDevice(eventPort,mi)) {
+					fprintf(stderr,"Given <%s> is not a pointing device! Trying default...\n",mi->name);
+					close(eventPort);
+				}
+				else {
+					fprintf(stderr,"Using given input device <%s>\n",mi->name);
+					mi->inputType=linuxInputType;
+					if (KdRegisterFd(linuxInputType,eventPort,linuxEventRead, (void *)mi)) {
+						devicesFound++;
+						continue;
+					}
+					else
+						close(eventPort);
+				}
+			}
+		}
+	/*
+	 * no device given or the given not found/not usable. We try at our own
+	 */
+		for (i=n;i<15;i++) {	/* FIXME: 15 enough? */
+			sprintf(deviceName,"/dev/input/event%d",i);
+			fprintf(stderr,"Trying device <%s>...",deviceName);
+			eventPort=open(deviceName,2);
+			if (eventPort >= 0) {								/* device present? */
+				if (checkForPointerDevice(eventPort,mi)) {	/* pointing device? */
+					fprintf(stderr,"not a pointing device.\n");
+					close(eventPort);
+					continue;										/* no pointing device, try next */
+				}
+				fprintf(stderr,"successful.\n");
+				mi->name=KdSaveString(deviceName);
+				mi->inputType=linuxInputType;
+				if (KdRegisterFd(linuxInputType,eventPort,linuxEventRead, (void *)mi)) {
+					n=i+1;
+					devicesFound++;
+					break;
+				}
+				else
+					close(eventPort);
+			}
+			else
+				break;	/* no more input devices */
+		}
+	}
+
+	return(devicesFound);
+}
+
+/* #################################################################################### */
+
+/**
+ * linuxInputFini -
+ *
+ */
+
+static void linuxInputFini(void)
+{
+KdMouseInfo	*mi;
+
+	KdUnregisterFds(linuxInputType, TRUE);
+	for (mi = kdMouseInfo; mi; mi = mi->next) {
+		if (mi->inputType == linuxInputType)
+			mi->inputType = 0;
+	}
+
+	close(eventPort);
+}
+
+/* #################################################################################### */
+
+/**
+ * To use this structure instead of the one in mouse.c insert this file into the
+ * Imakefile at the top of the list.
+ * So change:
+ * SRCS = keyboard.c linux.c mouse.c ps2.c bus.c ms.c agp.c $(TSSRCS)
+ * OBJS = keyboard.o linux.o mouse.o ps2.o bus.o ms.o agp.o $(TSOBJS)
+ *
+ * into:
+ * SRCS = keyboard.c linux.c input.c mouse.c ps2.c bus.c ms.c agp.c $(TSSRCS)
+ * OBJS = keyboard.o linux.o input.o mouse.o ps2.o bus.o ms.o agp.o $(TSOBJS)
+ *
+ * Thats all.
+ */
+
+KdMouseFuncs LinuxMouseFuncs = {
+    linuxInputInit,
+    linuxInputFini
+};
+
+/* end of file input.c */
