% ----------------------------------------------------------------------------
\chapter{Running Make}				\label{chap:running-make}
% ----------------------------------------------------------------------------

After having completed the first PTXdist example we now want to have a
more detailed look at the different Makefile targets. A brief overview
of the possibilities is printed out when just running \texttt{make}
without any further options: 

\begin{code}
robert@himalia:~/work/cvs-rsc/ptxdist> make

PTXdist - Pengutronix Distribution Build System

Syntax:

  make menuconfig              Configure the whole system

  make get                     Download (most) of the needed packets
  make extract                 Extract all needed archives
  make prepare                 Prepare the configured system 
                               for compilation
  make compile                 Compile the packages
  make install                 Install to rootdirectory
  make clean                   Remove everything but local/
  make rootclean               Remove root directory contents
  make distclean               Clean everything

  make world                   Make-everything-and-be-happy

Some 'helpful' targets:

  make virtual-xchain_install  build the toolchain only
  make archive-toolchain       dito, but do also create a tarball
  make configs                 show predefined configs

[...]
 
\end{code}

To understand how these targets work, let's do a short excursion to the
mechanism of Makefiles. As Makefiles may be a little bit unfamiliar for
you when you have not been writing Unix programs before we will explain
how they work in a short example. 

Makefiles are a generic way to define what to do to define a certain
\emph{target}: a target is something --~usually a file~-- being built by
executing a rule which consists of some commands.  Targets can not only
have rules, they also have \emph{dependencies}. A dependency defines
that, before the current target can be built, first the dependency has
to be fulfilled. 

Let's for example have a look at this little Makefile: 
\begin{code}
all: baz

foo: foo.src
	generate foo from foo.src

bar: bar.src
	generate bar from bar.src 
	
baz: foo bar
	link foo and bar together to create baz
\end{code}

It defines three "real" targets: \texttt{foo}, \texttt{bar} and
\texttt{baz}. \texttt{foo} is created from \texttt{foo.src} by using the
rule \texttt{generate foo from foo.src}, the same for \texttt{bar}.
\texttt{foo} depends on \texttt{foo.src} and \texttt{bar} on
\texttt{bar.src}, so the target is recreated by the rule whenever the
dependency is newer than the target itself, which is usually the case
when somebody has changed the dependend file. \texttt{baz} depends on
\texttt{foo} and \texttt{bar}. The last target, \texttt{all}, is just
used as an alias. When somebody types \texttt{make} in the directory
containing this Makefile, the first target is executed, which means in
our case that \texttt{make} tries to create target \texttt{baz}.

Think about what happens when somebody has changed \texttt{foo.src} and
\texttt{bar.src}: \texttt{make} wants to build \texttt{baz}, which needs
\texttt{foo}. \texttt{make} notices that \texttt{foo.src} was modified
and recreates \texttt{foo} from \texttt{foo.src}, using the appropriate
rule. Now \texttt{foo} is there, so the first dependency for
\texttt{baz} is fulfilled and \texttt{make} wants to have the dependency
\texttt{bar}. \texttt{bar.src} was modified, so \texttt{bar} is
recreated with it's rule. This means that all dependencies for
\texttt{baz} have been fulfilled, so \texttt{make} runs the rule to link
\texttt{foo} and \texttt{bar} together into \texttt{baz}. 

As you may notice, it is possible to split complicated inter-target
dependencies into easy-to-read target/dependency/rule sets. Makefiles
make it possible to reduce all the complicated what-happens-when cases
to simple targets. That's why the Makefile mechanism was chosen as a
base for PTXdist. 

The most important targets listed above are these: 

\paragraph{make menuconfig:} Configure the whole system. This starts the
text based Kconfig frontend (more on this in chapter~\ref{}). 

\paragraph{make world:} Build the whole system. This is normally what
you do to build a preconfigured configuration. 

\paragraph{clean:} Clean up all build stuff; each packet which is being
compiled extracts it's source code and sometimes also a separate build
directory in PTXdist's \texttt{build/} directory. During the
\texttt{clean} stage this is removed. 

\paragraph{rootclean:} Remove the contents of the target's root
directory, rediding in \texttt{root/}. The sequence \texttt{make
rootclean \&\& make world} can often be used if you have somehow
corrupted your target root directory and want to have it recreated from
the already compiled sources. 

\paragraph{distclean:} Brings the whole tree back into it's state after
it was freshly extracted from the PTXdist archive. Helpful when you want
to start from the beginning or if you want to make patches against a
cleaned up tree. 

\paragraph{configs:} Show which default configurations are available. 

