% ----------------------------------------------------------------------------
\chapter{Subtargets} 				\label{chap:subtargets}
% ----------------------------------------------------------------------------

Compiling a whole configuration in one step is usually what is done
when, for example, a board support package for an embedded PC is rolled
out. In this case, \texttt{make world} should simply work and spit out a
ready to run root filesystem for the embedded target. But most of the
time working with PTXdist you won't build complete runs but work on the
integration of a single software packet or on your special target
integration. In theses situations, running the whole \texttt{make clean
\&\& make world} sequence is time consuming and boring. 

Let's have a more in-detail look at the single targets each PTXdist
ruleset for a software packet consists of. This hopefully brings more
light into the darkness of what happens behind the scenes and what has
to be done to recompile single stages. 

Each packet's rule file, living in \texttt{rules/somepacket.make}, is
just a simple Makefile. There are several rules which targets this
Makefile must contain: 
%
\begin{itemize}
\setlength{\itemsep}{0pt}
\item \textbf{get:} Get the source archives for a packet. 
\item \textbf{extract:} Extract the archive and, if necessary, apply
      some patches. 
\item \textbf{prepare:} Run the configure part of the software package.
\item \textbf{compile:} Compile or cross-compile. 
\item \textbf{install:} Install host-side tools build by \emph{compile}
      into the PTXDIST\_PREFIX directory. 
\item \textbf{targetinstall:} Install the target-side programs into the 
      \texttt{root/} directory. 
\end{itemize}
%
For each target there is a corresponding so called \emph{statefile} in
\texttt{state/} which is touched by the framework when the target was
called. \emph{Touching} means that the file gets the current time as
it's time stamp. The state files are used as dependencies for other
packages.  

Assume we have a packet called \texttt{gargelpu}. It will have it's
rules in \texttt{rules/gargelpu.make}, which is a Makefile containing
targets to create 
%
\begin{itemize}
\setlength{\itemsep}{0pt}
\item \texttt{state/gargelpu.get},
\item \texttt{state/gargelpu.extract},
\item \texttt{state/gargelpu.prepare},
\item \texttt{state/gargelpu.compile}, 
\item \texttt{state/gargelpu.install} and 
\item \texttt{state/gargelpu.targetinstall}.
\end{itemize}
%
To force recreation of a target and all targets which depend on it you
can remove the state file and run \texttt{make world} again. Also, to
force recreation of a single sub-target you can delete the statefile,
for example \texttt{state/gargelpu.compile}, and run \texttt{make
state/gargelpu.compile} again. 

As these target names are a little bit longish to type there are
convenience targets which define abbreviated names. Normally these ones
are used during the work on PTXdist when you want to recreate certain
sub-targets: 
%
\begin{itemize}
\setlength{\itemsep}{0pt}
\item \texttt{gargelpu\_get}
\item \texttt{gargelpu\_extract}
\item \texttt{gargelpu\_prepare}
\item \texttt{gargelpu\_compile}
\item \texttt{gargelpu\_install} and 
\item \texttt{gargelpu\_targetinstall}
\end{itemize}

Like above, invalidating a sub-target is done by just removing the state
file, e.g. \texttt{state/gargelpu.compile}, and running \texttt{make
gargelpu\_compile}. Note the underscore in place of the dot --
\texttt{make} is unable to accept dots here. 

