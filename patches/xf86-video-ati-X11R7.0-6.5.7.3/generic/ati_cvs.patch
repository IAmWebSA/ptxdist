#
# Submitted-By: Erwin Rol, 2006-03-26
# Committed-By: Erwin Rol
#
# Error:
# The ATI driver has some serious bugs that cause problems with serveral cards.
#
# Description:
# This patch pulls in bug fixes from Xorg CVS.
#
# State:
# These patches will be in the next Xorg release, no action  needed.
#
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/ChangeLog xf86-video-ati-X11R7.0-6.5.7.3/ChangeLog
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/ChangeLog	2005-12-21 03:29:59.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/ChangeLog	2006-03-23 19:07:10.000000000 +0100
@@ -1,3 +1,303 @@
+2006-03-23  Roland Scheidegger  <rscheidegger_lists@hispeed.ch>
+	* src/radeon_reg.h:
+	* src/radeon_video.c: (RADEONResetVideo), (RADEONDisplayVideo),
+	(RADEONPutImage): Use programmable tap coefficients for (hopefully)
+	better video image quality when downscaling. Remove unnecessary code
+	programming the tap coefficients twice. Disable some code which is
+	supposed to improve filtering quality but causes very visible image
+	quality problems at least with rv250 when upscaling. Fix potentially
+	broken FOURCC_RGB16T format (untested if it was broken, untested if it
+	works now...). Change some magic numbers to (new) macro defines.
+
+2006-03-23  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONRestoreMode),
+	(RADEONInitCrtcRegisters), (RADEONInitCrtc2Registers):
+	Call RADEONRestoreCommonRegisters() before
+	RADEONRestoreCrtc2Registers() instead of after. I can't find any good
+	reason why we did it backward until now and it definitely causes
+	problems as the workaround for VT switch in
+	RADEONRestoreCommonRegisters() will break output to the secondary head
+	in various situations. Also does an unrelated minor update to a
+	comment.
+
+2006-03-18  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONRestoreMemMapRegisters),
+	(RADEONRestoreCrtcRegisters), (RADEONRestoreCrtc2Registers):
+	* src/radeon_reg.h:
+	Clear the offsets when updating the memory map instead of when
+	enabling the CRTCs and try to make that code more reliable. Doesn't
+	disable the CRTCs beforehand.
+
+2006-03-18  Roland Scheidegger  <rscheidegger_lists@hispeed.ch>
+	* src/radeon_dri.c: (RADEONDRIGetVersion)
+	* src/radeon_driver.c: (RADEONGetAccessibleVRAM):
+	* man/radeon_reg.h:
+	* src/radeon_video.c:
+	Fix various small cosmetic issues. Change a driver message, get the order
+	right for requesting drm versions, replace the use of some numbers with
+	the respective macro defines in radeon_video.c, and add some more macro
+	defines. None of that really matters.
+
+2006-03-17  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONGetAccessibleVRAM),
+	(RADEONPreInitVRAM):
+	Add missing return statement (the driver would not start randomly),
+	add RV410 to the list of new generation cards for the memory map
+	setup and fix a bogus message.
+
+2006-03-16  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONInitCrtcRegisters),
+	(RADEONInitCrtc2Registers), (RADEONDoAdjustFrame):
+	Fix incorrect CRTC2_OFFSET values when using old-style dual head (not
+	MergedFB). Fixes Xinerama for me.
+
+2006-03-16  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONWaitForVerticalSync),
+	(RADEONWaitForVerticalSync2), (RADEONLoadPalette),
+	(RADEONScreenInit), (RADEONRestoreMemMapRegisters),
+	(RADEONRestoreCrtcRegisters), (RADEONRestoreCrtc2Registers),
+	(RADEONDoAdjustFrame), (RADEONCloseScreen):
+	* src/radeon_reg.h:
+	Add various workarounds that seem to fix some remaning lockup
+	scenarios I'm experiencing with the driver when setting the memory
+	map. Some of the magic delays are a bit dodgy but they seem to work, I
+	suppose I can't do better now without help from ATI. Also removed some
+	really too noisy debug messages.
+
+2006-03-15  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon.h:
+	* src/radeon_dri.c: (RADEONDRIScreenInit),
+	(RADEONDRIDoCloseScreen), (RADEONDRIFinishScreenInit),
+	(RADEONDRIStop), (RADEONDRICloseScreen):
+	* src/radeon_driver.c: (RADEONCloseScreen):
+	Fix various issues with DRI & server recycle by putting DRICloseSreen
+	in the normal CloseScreen callback chain at a spot that matches the
+	call to DRIFinishScreenInit in order to unwrap at the right time.
+
+2006-03-13  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_video.c: (RADEONSetTransform):
+	Fix typo in the function setting the color space transformation
+	factors for old radeon
+
+2006-03-13  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONPreInitVRAM),
+	(RADEONPreInitChipType), (RADEONPreInit):
+	Earliest fix introduced a bug due to another chicken & egg problem in
+	card detection. Now split PreInitConfig into PreInitChipType and
+	PreInitVRAM so that PreInitDRI can be done just in between. Restores
+	proper AGPx4 functionality (when enabled)
+
+2006-03-12  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/ati.h:
+	* src/r128_dri.c:
+	* src/r128_driver.c:
+	* src/r128_probe.c:
+	* src/radeon_driver.c:
+	* src/radeon_mm_i2c.c:
+	* src/radeon_probe.c:
+	* src/radeon_video.c:
+	* src/radeon_vip.c:
+	* src/atipciids.h:
+	Stop using xf86PciInfo.h, instead use a local copy of the PCI IDs
+	we need in atipciids.h so we can update the ATI driver independently
+	of the server when new chips are added
+
+2006-03-10  Alan Coopersmith  <alan.coopersmith@sun.com>
+
+	* src/radeon_driver.c: 
+	Add #ifdef XF86DRI guards around references to info->allowPageFlip
+	and info->depthMoves, since they are only defined if building with
+	DRI.
+
+2006-03-10  Roland Scheidegger  <rscheidegger_lists@hispeed.ch>
+	* man/radeon.man:
+	* src/radeon_driver.c: (RADEONSetupMemXAA_DRI), (RADEONScreenInit):
+	Use "FBTexPercent" option for XAA too (only for increasing
+	memory reserved for textures).
+
+2006-03-10  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon.h:
+	* src/radeon_dri.c: (RADEONDRIGartHeapInit), (RADEONDRIGetVersion),
+	(RADEONDRIScreenInit), (RADEONDRIInitPageFlip), (RADEONDRIResume),
+	(RADEONDRIAllocatePCIGARTTable):
+	* src/radeon_driver.c: (RADEONInitMemoryMap),
+	(RADEONGetAccessibleVRAM), (RADEONPreInitConfig),
+	(RADEONPreInitDRI), (RADEONPreInitColorTiling), (RADEONPreInit),
+	(RADEONScreenInit), (RADEONRestoreMode):
+	More memory map fixes !!! This time, we add a way to get the DRM
+	kernel module version early, in order to properly limit the
+	framebuffer size when a module that doesn't support the new map is
+	loaded. That will improve backward compatibility. I also made the
+	minimum required kernel module version 1.3 which hopefully shouldn't
+	be a problem for anybody, and cleaned up the ordering in which we test
+	for DRM version to enable features
+
+2006-03-09  Michel Dänzer  <michel@daenzer.net>
+
+	* src/radeon_driver.c: (RADEONGetClockInfo), (RADEONGetVRamType),
+	(RADEONPreInitConfig):
+	Bugzilla #5766 <https://bugs.freedesktop.org/show_bug.cgi?id=5766>
+	Patch #4636  <https://bugs.freedesktop.org/attachment.cgi?id=4636>
+	- Acknowledge that RN50 only has one CRTC, and use this to distinguish
+	  it from RV100.
+	- Fix detection of RN50 memory type and bus width.
+	- Model RN50 memory bandwidth limits by capping the pixel clock range
+	  based on memory clock, bpp and memory bus width.
+	(ATI Technologies Inc.)
+
+2006-03-03  Michel Dänzer  <michel@daenzer.net>
+
+	* man/radeon.man:
+	* src/radeon_driver.c: (RADEONScreenInit):
+	* src/radeon_exa.c: (RADEONSetupMemEXA):
+	Add Option "FBTexPercent" to override the amount of video RAM reserved
+	for OpenGL textures with EXA.
+
+2006-03-02  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONPreInitConfig):
+	Fix the fix ... I didn't interpret PciInfo->size properly and forgot
+	that the function works in Kb not bytes... Ooops.
+
+2006-03-02  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONInitMemoryMap),
+	(RADEONPreInitConfig):
+	Extend the alignement workaround to post-rv280 chips as well (thanks
+	Hui) and also limit the CPU accessible memory to the size of the PCI
+	BAR size (yeah, it was passed to the driver, I just got blind for a
+	while it seems)
+
+2006-03-01  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_driver.c: (RADEONInitMemoryMap),
+	(RADEONPreInitConfig):
+	Workaround for rv280 bug which needs the framebuffer memory mapping
+	to be aligned to its own size. Also add back limit of 128Mb of mapped
+	fb space for now until I fully sort out what's up with dual function
+	cards. I would really need to access the PCI BAR sizes here but that
+	information seem to be missing from the PCI info passed to the driver.
+
+2006-02-27  Roland Scheidegger  <rscheidegger_lists@hispeed.ch>
+	* src/atichip.h:
+	* src/atichip.c:
+	* src/radeon_chipset.h:
+	Add the newly added (and tons of previously forgotten ones) pci ids
+	to the ati wrapper too (probably not required for it to work as
+	everything should default to radeon anyway there).
+
+2006-02-26  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon.h:
+	* src/radeon_dri.c: (RADEONDRIFinishScreenInit),
+	(RADEONDRIInitPageFlip):
+	* src/radeon_driver.c: (RADEONScreenInit):
+	Fix page flipping with XAA. The new code ended up calling
+	ShadowFBInit() before XAAInit(), which breaks ShadowFB.
+
+2006-02-24  Roland Scheidegger  <rscheidegger_lists@hispeed.ch>
+	* src/radeon.h:
+	* src/radeon_chipset.h:
+	* src/radeon_driver.c:
+	* src/radeon_probe.c:
+	Add pci ids known to exist (see #4284 for instance). There are still
+	entries which probably don't really exist (cancelled cards and such),
+	leave them as-is. Fix the name of some entries, mostly based on the
+	.inf file of the newest catalyst driver. Use own family id for rv410
+	and rs400, though there is no different code (yet?).
+
+2006-02-17  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon.h:
+	* src/radeon_common.h:
+	* src/radeon_commonfuncs.c: (RADEONWaitForIdle):
+	* src/radeon_cursor.c: (RADEONCursorAllocEXA),
+	(RADEONSetCursorColors), (RADEONSetCursorPosition),
+	(RADEONLoadCursorImage), (RADEONHideCursor), (RADEONShowCursor),
+	(RADEONLoadCursorARGB), (RADEONCursorInit):
+	* src/radeon_dri.c: (RADEONDRIScreenInit),
+	(RADEONDRIFinishScreenInit), (RADEONDRICloseScreen),
+	(RADEONDRIRefreshArea):
+	* src/radeon_driver.c: (RADEONMapFB), (RADEONInitMemMapRegisters),
+	(RADEONInitMemoryMap), (RADEONGetAccessibleVRAM),
+	(RADEONPreInitConfig), (RADEONLoadPalette), (RADEONBlockHandler),
+	(RADEONScreenInit), (RADEONRestoreMemMapRegisters),
+	(RADEONAdjustMemMapRegisters), (RADEONRestoreSurfaces),
+	(RADEONSaveSurfaces), (RADEONChangeSurfaces), (RADEONRestoreMode),
+	(RADEONSaveMemMapRegisters), (RADEONSaveMode), (RADEONSave),
+	(RADEONInitDispBandwidth), (RADEONInitPLLRegisters),
+	(RADEONInitPLL2Registers), (RADEONInit), (RADEONModeInit),
+	(RADEONSaveScreen), (RADEONSwitchMode), (RADEONDoAdjustFrame),
+	(RADEONAdjustFrame), (RADEONEnterVT), (RADEONLeaveVT),
+	(RADEONCloseScreen), (RADEONDisplayPowerManagementSet):
+	* src/radeon_reg.h:
+	* src/radeon_render.c: (RADEONSetupRenderByteswap):
+	Memory map and misc fixes. This completely reworks the way the driver
+	detects available & accessible video memory and initializes the card
+	internal memory map. Along the way, I re-ordered some of the stuffs
+	in pre-init in order to remove some dodgy codepath, fixed various
+	init, exit and vt switch issues, and overall made the driver more
+	robust. The full memory map fix requires an updated DRM. The X driver
+	no longer tries to position the AGP aperture, this becomes entirely
+	DRM responsibility.
+
+2006-02-16  Benjamin Herrenschmidt  <benh@kernel.crashing.org>
+
+	* src/radeon_accel.c: (RADEONEngineRestore):
+	The engine setup would trigger a bogus line write before the proper
+	addresses are setup, thus causing the card to try to bus master over
+	the system bus to some stale location (usually 0 but could depend on
+	whatever was used before X). Remove that useless init bit, and always
+	setup some good enough engine source & destination pointers in case we
+	have some other spurrious engine activity going on.
+
+2006-02-13  Benjamin Herrenschmidt <benh@kernel.crashing.org>
+
+	* src/radeon_exa_render.c: (R100TextureSetup), (R200TextureSetup):
+	Fix EXA acceleration of textures with byteswap or tiling
+	From John Clemens <john@deater.net>
+
+2006-02-06  Eric Anholt  <anholt@FreeBSD.org>
+
+	* src/radeon_exa_render.c:
+	Fix a copy'n'paste-o in the EXA render implementation that resulted in
+	[ax]8b8g8r8 pict formats not being supported on r200, but no other
+	issues.
+
+2006-01-19  Daniel Stone  <daniel@freedesktop.org>
+
+	* src/radeon_driver.c:
+	Bug #5656: Set all Radeon XPRESS 200 R[CS]4xx-based chips to
+	have IsIGP = 1, fixing modesetting issues.
+
+2006-01-12  Alan Coopersmith  <alan.coopersmith@sun.com>
+
+	* src/theatre200_module.c (theatre200VersRec): 
+	* src/theatre_detect_module.c (theatre_detectVersRec): 
+	XF86_VERSION_CURRENT -> XORG_VERSION_CURRENT
+
+2006-01-12  Alan Coopersmith  <alan.coopersmith@sun.com>	
+
+	* src/radeon_driver.c (RADEONPreInitModes): 
+	When failing to parse MetaModes, reset CRT2pScrn to NULL after 
+	free'ing it so we don't crash when trying to use it later 
+	(such as in RADEONFreeRec).
+
+2006-01-08  Adam Jackson  <ajax@freedesktop.org>
+
+	* src/radeon.h:
+	Bug #5523: Make radeon compile without USE_XAA.  (Tilman Sauerbeck)
+
 2005-12-20  Kevin E. Martin  <kem-at-freedesktop-dot-org>
 
 	* configure.ac:
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/man/Makefile.am xf86-video-ati-X11R7.0-6.5.7.3/man/Makefile.am
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/man/Makefile.am	2005-12-06 23:48:33.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/man/Makefile.am	2005-12-06 23:48:33.000000000 +0100
@@ -1,4 +1,4 @@
-# $Id: Makefile.am,v 1.7 2005/12/06 22:48:33 kem Exp $
+# $Id: Makefile.am,v 1.6 2005/11/28 22:04:08 alanc Exp $
 #
 # Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 # 
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/man/radeon.man xf86-video-ati-X11R7.0-6.5.7.3/man/radeon.man
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/man/radeon.man	2005-12-19 10:07:50.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/man/radeon.man	2006-03-12 06:01:21.000000000 +0100
@@ -512,6 +512,18 @@
 possibly unstable.  The default is
 .B XAA.
 .TP
+.BI "Option \*qFBTexPercent\*q \*q" integer \*q
+Amount of video RAM to reserve for OpenGL textures, in percent. With EXA, the
+remainder of video RAM is reserved for EXA offscreen management. Specifying 0
+results in all offscreen video RAM being reserved for EXA and only GART memory
+being available for OpenGL textures. This may improve EXA performance, but
+beware that it may cause problems with OpenGL drivers from Mesa versions older
+than 6.4. With XAA, specifiying lower percentage than what gets reserved without
+this option has no effect, but the driver tries to increase the video RAM
+reserved for textures to the amount specified roughly.
+Default:
+.B 50.
+.TP
 .BI "Option \*qDMAForXv\*q \*q" boolean \*q
 Try or don't try to use DMA for Xv image transfers. This will reduce CPU
 usage when playing big videos like DVDs, but may cause instabilities.
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/README.ati xf86-video-ati-X11R7.0-6.5.7.3/README.ati
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/README.ati	2005-12-21 08:58:45.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/README.ati	2005-10-04 22:01:03.000000000 +0200
@@ -1,7 +1,6 @@
-  $Id: README.ati.sgml,v 1.3 2005/12/19 09:07:50 alanc Exp $
-  Based on XFree86:
-  xc/programs/Xserver/hw/xfree86/doc/sgml/ati.sgml,v 3.42
-  2003/01/20 03:43:07 dawes Exp ATI Adapters README file
+  $Id: ati.sgml,v 1.2 2004/04/23 19:23:59 eich Exp $ Based on
+  XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/ati.sgml,v
+  3.42 2003/01/20 03:43:07 dawes Exp ATI Adapters README file
   Marc Aurele La France
   2002 February 12
 
@@ -48,47 +47,43 @@
 
   ______________________________________________________________________
 
-  11..  SSttaatteemmeenntt ooff iinntteenntt
-
-  Generally speaking, the driver is intended for all ATI video adapters
-  based on the Mach64 series or older chipsets, providing maximum video
-  function within hardware limitations.  The driver is also intended to
-  optionally provide the same level of support for generic VGA or 8514/A
-  adapters.  The newer Rage 128 and Radeon chips are not yet supported
-  by this driver.  Rage 128's and Radeon's are, however, supported by
-  separate drivers, and owners of such adapters should consult the
-  documentation provided with these drivers.  This driver will also
-  invoke the appropriate driver if it finds Rage 128 and/or Radeon
-  adapter(s) in the system.  This driver is still being actively
-  developed, meaning that it currently does not yet fully meet these
-  goals.
+  [1m1.  Statement of intent[0m
 
+  Generally speaking, the driver is intended for all ATI video adapters,
+  providing maximum video function within hardware limitations.  The
+  driver is also intended to optionally provide the same level of
+  support for generic VGA or 8514/A adapters.  This driver is still
+  being actively developed, meaning that it currently does not yet fully
+  meet these goals.
 
   The driver will provide
 
-  +o  accelerated support if an ATI accelerator is detected _a_n_d the user
+  +o  accelerated support if an ATI accelerator is detected [4mand[24m the user
      has not requested that this support be disabled;  otherwise
 
   +o  accelerated support if a non-ATI 8514/A-capable adapter is detected
-     _a_n_d the user has requested such support;  otherwise
+     [4mand[24m the user has requested such support;  otherwise
 
   +o  unaccelerated SuperVGA support if an ATI VGA-capable adapter is
      detected; otherwise
 
   +o  generic VGA support if a non-ATI VGA-capable adapter is detected
-     _a_n_d the user has requested such support.
+     [4mand[24m the user has requested such support.
 
      Thus, the level of support provided not only depends on what the
      driver detects in the system, but also, on what the user specifies
-     in the xorg.conf file.  See the ````xxoorrgg..ccoonnff ssppeecciiffiiccaattiioonnss''''
+     in the xorg.conf file.  See the [1m``xorg.conf specifications''[0m
      section below for details.
 
   If none of the above conditions are met, the ATI driver will
   essentially disable itself to allow other drivers to examine the
   system.
 
+  Note that I am currently considering removing the driver's support for
+  generic VGA.  If you have any concerns about this, please contact me
+  at <tsi@xfree86.org>.
 
-  22..  AA nnoottee oonn aacccceelleerraattiioonn
+  [1m2.  A note on acceleration[0m
 
   The meaning of ``acceleration'', as used in this document, needs to be
   clarified.  Two of the many components in an accelerator are the CRT
@@ -113,7 +108,7 @@
   implies the use of the accelerator's CRTC.
 
 
-  33..  CCuurrrreenntt iimmpplleemmeennttaattiioonn ffoorr AATTII aaddaapptteerrss
+  [1m3.  Current implementation for ATI adapters[0m
 
   The driver currently supports the SuperVGA capabilities of all ATI
   adapters except some early Mach8 and Mach32 adapters that do not
@@ -134,6 +129,7 @@
   and 3D Rage series of adapters using the accelerator CRTC (but not the
   VGA CRTC).
 
+
   The newer Rage 128 and Radeon chips are not yet supported by this
   driver.  Rage 128's and Radeon's are, however, supported by separate
   drivers, and owners of such adapters should consult the documentation
@@ -185,7 +181,7 @@
   and SuperVGA functionality, but the driver currently only uses the
   VGA.
 
-  The driver _d_o_e_s however support the accelerator CRTC present in all
+  The driver [4mdoes[24m however support the accelerator CRTC present in all
   ATI Mach64 adapters.  For 256-colour, and higher depth modes, this
   support will be used by default, although an xorg.conf option can be
   specified to use the SuperVGA CRTC instead.  A linear video memory
@@ -195,7 +191,6 @@
   are available to disable this aperture, or (for non-PCI adapters)
   enable it or move it to some other address.
 
-
   By default, the driver provides some acceleration for Mach64 if the
   accelerator CRTC is used, and modes whose colour depth greater than or
   equal to 8 are to be used.  This support is as yet incomplete and can
@@ -205,7 +200,7 @@
   Mach64 adapters.
 
 
-  44..  CCuurrrreenntt iimmpplleemmeennttaattiioonn ooff ggeenneerriicc VVGGAA ssuuppppoorrtt ffoorr nnoonn--AATTII aaddaapptteerrss
+  [1m4.  Current implementation of generic VGA support for non-ATI adapters[0m
 
   Support for generic VGA with non-ATI adapters is also implemented, but
   has undergone only limited testing.  The driver will intentionally
@@ -233,7 +228,7 @@
 
   +o  Colour depths higher than 8 are not available.
 
-  55..  xxoorrgg..ccoonnff ssppeecciiffiiccaattiioonnss
+  [1m5.  xorg.conf specifications[0m
 
   The driver recognises a number of xorg.conf options.  In general, all
   such options should be specified in a ``Device'' section, and affect
@@ -252,7 +247,7 @@
   assigned to the ``Device'' section which contains them.
 
 
-  55..11..  DDrriivveerr ````aattii''''
+  [1m5.1.  Driver ``ati''[0m
 
   The use of this specification is highly recommended if the ``Device''
   section is to be recognised by the driver.  In fact, it is almost (but
@@ -261,26 +256,25 @@
   ``Device'' section.
 
 
+  [1m5.2.  ChipSet ``name''[0m
 
-  55..22..  CChhiippSSeett ````nnaammee''''
-
-  The default ChipSet name for this driver is ``_a_t_i''.  In this case,
+  The default ChipSet name for this driver is ``[4mati[24m''.  In this case,
   any ATI adapter can be associated with the ``Device'' section.  If an
   ATI accelerator is detected and the driver supports it, the
   accelerator's CRTC will be used to drive the screen.  Otherwise, the
   driver will programme the adapter's SuperVGA CRTC.
 
-  If ``_a_t_i_v_g_a'' is specified instead, the driver will ignore any ATI
-  accelerator it detects, but otherwise operate as if ``_a_t_i'' had been
+  If ``[4mativga[24m'' is specified instead, the driver will ignore any ATI
+  accelerator it detects, but otherwise operate as if ``[4mati[24m'' had been
   specified.  This specification ensures the VGA CRTC is used.
 
-  A ChipSet name of ``_i_b_m_v_g_a'' causes any VGA-capable adapter in the
+  A ChipSet name of ``[4mibmvga[24m'' causes any VGA-capable adapter in the
   system to be associated with the ``Device'' section.  It enables the
   driver's generic VGA support, but only for non-ATI adapters.  If an
   ATI adapter is associated with the ``Device'' section, the driver will
-  operate as if ``_a_t_i_v_g_a'' had been specified instead.
+  operate as if ``[4mativga[24m'' had been specified instead.
 
-  A ChipSet name of ``_v_g_a_w_o_n_d_e_r'' is equivalent to ``_a_t_i_v_g_a'', except
+  A ChipSet name of ``[4mvgawonder[24m'' is equivalent to ``[4mativga[24m'', except
   that only VGAWonder-capable adapters can be assigned to the ``Device''
   section.  This specifically excludes the newer integrated Mach64
   controllers.
@@ -292,16 +286,16 @@
   lockup would occur, it will skip the probe.  In some situations, this
   determination cannot be accurate, and the driver will err on the side
   of caution, skipping the probe.  Specifying a ChipSet name of
-  ``_m_a_c_h_3_2'' or ``_m_a_c_h_6_4'', as appropriate, will force the driver to
+  ``[4mmach32[24m'' or ``[4mmach64[24m'', as appropriate, will force the driver to
   probe for the non-PCI adapter.  These ChipSet names should, therefore,
   only be used when there is in fact such an adapter in the system.
-  They are otherwise equivalent to ``_a_t_i''.
+  They are otherwise equivalent to ``[4mati[24m''.
 
-  On non-Intel platforms, only ``_a_t_i'' and ``_m_a_c_h_6_4'' ChipSet values are
+  On non-Intel platforms, only ``[4mati[24m'' and ``[4mmach64[24m'' ChipSet values are
   operative.
 
 
-  55..33..  CChhiippIIDD && CChhiippRReevv ssppeecciiffiiccaattiioonnss
+  [1m5.3.  ChipID & ChipRev specifications[0m
 
   These specifications will cause the driver to associate the ``Device''
   section only with an adapter having the same attributes, or an adapter
@@ -314,7 +308,7 @@
   specified in the same ``Device'' section.
 
 
-  55..44..  IIOOBBaassee
+  [1m5.4.  IOBase[0m
 
   This option limits the adapters that can be associated with the
   ``Device'' section to the one with the specified I/O base.  This
@@ -322,27 +316,28 @@
   adapters.
 
 
-  55..55..  BBuussIIDD
+  [1m5.5.  BusID[0m
 
   This option limits the adapters that can be associated with the
   ``Device'' section to the one with the specified PCI Bus ID.  This
   specification excludes non-PCI adapters.
 
-  55..66..  CClloocckkss
+
+  [1m5.6.  Clocks[0m
 
   For the purpose of specifying a clock line in your xorg.conf, one of
   four different situations can occur, as follows.
 
   Those configuring the driver's generic VGA support for a non-ATI
-  adapter, can skip ahead to the ````CClloocckkss ffoorr nnoonn--AATTII aaddaapptteerrss'''' section
-  below.  Those _n_o_t trying to configure the driver for a Mach64 adapter,
-  can skip ahead to the ````CClloocckkss ffoorr ffiixxeedd cclloocckk ggeenneerraattoorrss oonn AATTII
-  aaddaapptteerrss'''' section below.
+  adapter, can skip ahead to the [1m``Clocks for non-ATI adapters'' [22msection
+  below.  Those [4mnot[24m trying to configure the driver for a Mach64 adapter,
+  can skip ahead to the [1m``Clocks for fixed clock generators on ATI[0m
+  [1madapters'' [22msection below.
 
   The very earliest Mach64 adapters use fixed (i.e. non-programmable)
   clock generators.  Very few of these (mostly prototypes) are known to
   exist, but if you have one of these, you can also skip ahead to the
-  ````CClloocckkss ffoorr ffiixxeedd cclloocckk ggeenneerraattoorrss oonn AATTII aaddaapptteerrss'''' section below.
+  [1m``Clocks for fixed clock generators on ATI adapters'' [22msection below.
 
   The two cases that are left deal with programmable clock generators,
   which are used on the great majority of Mach64 adapters.
@@ -351,7 +346,7 @@
   run a clock probe with the command ``X -probeonly''.
 
 
-  55..66..11..  CClloocckkss ffoorr ssuuppppoorrtteedd pprrooggrraammmmaabbllee cclloocckk ggeenneerraattoorrss
+  [1m5.6.1.  Clocks for supported programmable clock generators[0m
 
   At bootup, video BIOS initialisation programmes an initial set of
   frequencies.  Two of these are reserved to allow the setting of modes
@@ -367,7 +362,7 @@
   generator as needed by the modes used during the X session.
 
 
-  55..66..22..  CClloocckkss ffoorr uunnssuuppppoorrtteedd pprrooggrraammmmaabbllee cclloocckk ggeenneerraattoorrss
+  [1m5.6.2.  Clocks for unsupported programmable clock generators[0m
 
   This case is unlikely to occur, but is documented for the sake of
   completeness.
@@ -394,6 +389,7 @@
              0.000  40.000  37.500  32.500  20.000  22.450  24.750  25.000
 
 
+
   BIOS setting 3:
 
     Clocks   0.000   0.000   0.000   0.000  25.180  28.320   0.000   0.000
@@ -403,10 +399,10 @@
 
 
   If the driver matches the clocks to the third setting above, function-
-  ality will be _e_x_t_r_e_m_e_l_y limited (assuming the driver works at all).
+  ality will be [4mextremely[24m limited (assuming the driver works at all).
 
 
-  55..66..33..  CClloocckkss ffoorr ffiixxeedd cclloocckk ggeenneerraattoorrss oonn AATTII aaddaapptteerrss
+  [1m5.6.3.  Clocks for fixed clock generators on ATI adapters[0m
 
   This section applies to all VGAWonder and Mach32 adapters, and to
   early Mach64 prototypes.
@@ -482,13 +478,13 @@
   all be said to be clones of one of the above) might generate non-zero
   frequencies for those that are zero above, or vice-versa.
 
-  The order of the clocks _i_s very important, although the driver will
+  The order of the clocks [4mis[24m very important, although the driver will
   reorder the specified clocks if it deems it appropriate to do so.
   Mach32 and Mach64 owners should note that this order is different than
   what they would use for previous accelerated servers.
 
 
-  55..66..44..  CClloocckkss ffoorr nnoonn--AATTII aaddaapptteerrss
+  [1m5.6.4.  Clocks for non-ATI adapters[0m
 
   If no clocks are specified in the xorg.conf, the driver will probe for
   four clocks, the second of which will be assumed to be 28.322 MHz.
@@ -498,7 +494,7 @@
   will be ignored.
 
 
-  55..77..  OOppttiioonn ````nnooppaanneell__ddiissppllaayy''''
+  [1m5.7.  Option ``nopanel_display''[0m
 
   This specification is only effective when the driver detects that the
   adapter's BIOS has initialised both the digital flat panel and CRT
@@ -509,14 +505,14 @@
   than the panel can handle.
 
 
-  55..88..  OOppttiioonn ````ccrrtt__ddiissppllaayy''''
+  [1m5.8.  Option ``crt_display''[0m
 
   This specification is only effective when the driver detects that the
   adapter's BIOS has initialised the digital flat panel interface, but
   has disabled the CRT interface.  In such a situation the driver will
   normally drive only the panel.  This specification causes the driver
   to instead display the same image on both the panel and the CRT.
-  55..99..  OOppttiioonn ````nnooaacccceell''''
+  [1m5.9.  Option ``noaccel''[0m
 
   By default, the driver will accelerate draw operations if a Mach64
   CRTC is used to drive the display.  As implemented in this driver,
@@ -524,7 +520,7 @@
   option disables this acceleration.
 
 
-  55..1100..  OOppttiioonn ````nnoolliinneeaarr''''
+  [1m5.10.  Option ``nolinear''[0m
 
   By default, the driver will enable a linear video memory aperture for
   256-colour and higher depth modes if it is also using a Mach64
@@ -535,20 +531,20 @@
   this option is ignored.
 
 
-  55..1111..  OOppttiioonn ````HHWWCCuurrssoorr''''  aanndd OOppttiioonn ````SSWWCCuurrssoorr''''
+  [1m5.11.  Option ``HWCursor''  and Option ``SWCursor''[0m
 
-  Option _`_`_H_W_C_u_r_s_o_r_'_', which is the default, specifies that hardware
+  Option [4m``HWCursor''[24m, which is the default, specifies that hardware
   facilities are to be used to paint the mouse pointer on the screen.
-  Option _`_`_S_W_C_u_r_s_o_r_'_' specifies that the mouse pointer is to be drawn by
+  Option [4m``SWCursor''[24m specifies that the mouse pointer is to be drawn by
   software, which is much slower.  If both options are specified, option
-  _`_`_S_W_C_u_r_s_o_r_'_' prevails.  Currently, these options are only acted upon
+  [4m``SWCursor''[24m prevails.  Currently, these options are only acted upon
   for 256-colour or higher depth modes, if a Mach64 accelerator CRTC, or
   a Mach64 integrated controller is being used.  In all other
   situations, a software cursor will be used, regardless of what these
   options specify.
 
 
-  55..1122..  OOppttiioonn ````SSiillkkeennMMoouussee''''
+  [1m5.12.  Option ``SilkenMouse''[0m
 
   This option is only acted upon when a hardware cursor is being used.
   It specifies that the cursor's position on the screen is to be updated
@@ -557,7 +553,7 @@
   when the X server is very busy.
 
 
-  55..1133..  OOppttiioonn ````sshhaaddoowwffbb''''
+  [1m5.13.  Option ``shadowfb''[0m
 
   If this option is enabled, the driver will cause the CPU to do each
   drawing operation first into a shadow frame buffer in system virtual
@@ -574,14 +570,14 @@
   frame buffer depth is less than 8, or when acceleration is used.
 
 
-  55..1144..  OOppttiioonn ````ddppmmss''''
+  [1m5.14.  Option ``dpms''[0m
 
   This option enables the driver's support for VESA's Display Power
   Management Specification.
 
 
 
-  55..1155..  OOppttiioonn ````bbaacckkiinnggssttoorree''''
+  [1m5.15.  Option ``backingstore''[0m
 
   This is not specifically a driver option.  It is used to enable the
   server's support for backing store, a mechanism by which pixel data
@@ -590,7 +586,7 @@
   needs to be redisplayed.
 
 
-  55..1166..  MMeemmBBaassee aaddddrreessss
+  [1m5.16.  MemBase address[0m
 
   This specification is only effective for non-PCI Mach64 adapters, and
   is used to override the CPU address at which the adapter will map its
@@ -605,7 +601,7 @@
   driver can not easily change the linear aperture address.
 
 
-  55..1177..  OOppttiioonn ````RReeffeerreenncceeCClloocckk''''  ````ffrreeqquueennccyy''''
+  [1m5.17.  Option ``ReferenceClock''  ``frequency''[0m
 
   This option is only applicable to non-Intel platforms, where an
   adapter BIOS is not available to the driver.  The option specifies the
@@ -614,23 +610,23 @@
   MHz.
 
 
-  55..1188..  CClloocckkCChhiipp ````nnaammee''''
+  [1m5.18.  ClockChip ``name''[0m
 
   This option is only applicable to non-Intel platforms, where an
   adapter BIOS is not available to the driver, and the driver cannot
   reliably determine whether the clock generator the adapter uses is a
   variant of an ATI 18818 (a.k.a.  ICS 2595) or an unsupported clock
-  generator.  The only values that are acted upon are _`_`_A_T_I _1_8_8_1_8_-_0_'_' or
-  _`_`_A_T_I _1_8_8_1_8_-_1_'_'.  From this specification, the driver derives a
+  generator.  The only values that are acted upon are [4m``ATI[24m [4m18818-0''[24m or
+  [4m``ATI[24m [4m18818-1''[24m.  From this specification, the driver derives a
   reference divider of 43 or 46 (respectively) for use in clock
   programming calculations.  The driver's default behaviour, in this
   case, is to assume an unsupported clock generator, which means it will
   treat it as a fixed-frequency clock generator, as described under the
-  heading ````CClloocckkss ffoorr uunnssuuppppoorrtteedd pprrooggrraammmmaabbllee cclloocckk ggeenneerraattoorrss''''
+  heading [1m``Clocks for unsupported programmable clock generators''[0m
   above.
 
 
-  66..  VViiddeeoo mmooddeess
+  [1m6.  Video modes[0m
 
   Mode timings can be derived from the information in X's doc
   subdirectory.  However, it is no longer required to specify such
@@ -650,11 +646,11 @@
   For a digital flat panel, any sync tolerances should be removed from
   the corresponding ``Monitor'' section.  The driver will automatically
   calculate these from the mode that is active on server entry.  The
-  driver also inserts timings for a mode called _"_N_a_t_i_v_e _p_a_n_e_l _m_o_d_e_" that
+  driver also inserts timings for a mode called [4m"Native[24m [4mpanel[24m [4mmode"[24m that
   represents the panel's native resolution.
 
 
-  77..  KKnnoowwnn pprroobblleemmss aanndd lliimmiittaattiioonnss
+  [1m7.  Known problems and limitations[0m
 
   There are several known problems or limitations related to the ATI
   driver.  They include:
@@ -753,11 +749,11 @@
 
   +o  3D operations.
 
-  88..  RReeppoorrttiinngg pprroobblleemmss
+  [1m8.  Reporting problems[0m
 
   If you are experiencing problems that are not already recorded in this
   document, first ensure that you have the latest current release of
-  this driver and the Xorg X server.  Check the server's log (usually
+  this driver and the Xorg X server..  Check the server's log (usually
   found in /var/log/Xorg.0.log) and ftp://ftp.freedesktop.org/pub/Xorg
   if you are uncertain.
 
@@ -765,23 +761,20 @@
   information.
 
   Thirdly, a scan through the comp.windows.x.i386unix and
-  comp.os.linux.x newsgroups, the xorg mailing list archives at
-  http://lists.freedesktop.org/mailman/listinfo/xorg, and the Xorg bug
-  database at https://bugs.freedesktop.org/enter_bug.cgi?product=xorg
-  can also prove useful in resolving problems.
+  comp.os.linux.x newsgroups and the xorg mailing list using your
+  favourite archiving service can also prove useful in resolving
+  problems.
 
-  If you are still experiencing problems, you can send _n_o_n_-_H_T_M_L_i_s_e_d e-
-  mail to  <xorg@lists.fredesktop.org>.  Please be as specific as
-  possible when describing the problem(s), and include an _u_n_e_d_i_t_e_d copy
-  of the server's log and the xorg.conf file used.
+  If you are still experiencing problems, you can send me [4mnon-HTMLised[0m
+  e-mail at  <tsi@xfree86.org>.  Please be as specific as possible when
+  describing the problem(s), and include an [4munedited[24m copy of the
+  server's log and the xorg.conf file used.
 
 
-
-  99..  DDrriivveerr hhiissttoorryy
+  [1m9.  Driver history[0m
 
   The complete history of the driver is rather cloudy.  The following is
   more than likely to be incomplete and inaccurate.
-
   Apparently, Per Lindqvist first got a driver working with an early ATI
   adapter under X386 1.1a.  This original driver might have actually
   been based on a non-functional ATI driver written by Thomas Roell
@@ -795,12 +788,12 @@
   1992 and ported the code to the X386 part of X11R5.  This subsequently
   became part of XFree86.
 
-  Marc Aurele La France took over development and maintenance of the
+  I (Marc Aurele La France) took over development and maintenance of the
   driver in the fall of 1993 after Rik got rid of his VGA Wonder
   adapter.
 
 
-  1100..  DDrriivveerr vveerrssiioonnss
+  [1m10.  Driver versions[0m
 
   Due to the introduction of loadable drivers in XFree86 4.0, it has
   become necessary to track driver versions separately.  Driver releases
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/README.ati.sgml xf86-video-ati-X11R7.0-6.5.7.3/README.ati.sgml
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/README.ati.sgml	2005-12-19 10:07:50.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/README.ati.sgml	2005-12-19 10:07:50.000000000 +0100
@@ -15,7 +15,7 @@
 
 
 <ident>
-$Id: README.ati.sgml,v 1.3 2005/12/19 09:07:50 alanc Exp $ 
+$Id: ati.sgml,v 1.3 2005/12/19 07:56:55 alanc Exp $ 
 Based on XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/ati.sgml,v 3.42 2003/01/20 03:43:07 dawes Exp 
 </ident>
 
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atichip.c xf86-video-ati-X11R7.0-6.5.7.3/src/atichip.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atichip.c	2005-07-11 04:29:44.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/atichip.c	2006-02-28 01:52:53.000000000 +0100
@@ -104,13 +104,18 @@
     "ATI Radeon 9200",
     "ATI Radeon Mobility M9+",
     "ATI Radeon 9700/9500",
-    "ATI Radeon 9600",
+    "ATI Radeon 9600/9550",
     "ATI Radeon 9800",
     "ATI Radeon 9800XT",
-    "ATI Radeon X300/M22",
-    "ATI Radeon X600/M24",
-    "ATI Radeon X800/M18",
-    "ATI Radeon X800 PCIE",
+    "ATI Radeon X300/X550/M22",
+    "ATI Radeon X600/X550/M24",
+    "ATI Radeon X800/M18 AGP",
+    "ATI Radeon X800/M28 PCIE",
+    "ATI Radeon X800XL PCIE",
+    "ATI Radeon X850 PCIE",
+    "ATI Radeon X850 AGP",
+    "ATI Radeon X700",
+    "ATI Xpress 200"
     "ATI unknown Radeon",
     "ATI Rage HDTV"
 };
@@ -642,6 +647,7 @@
 
         case NewChipID('Q', 'Y'):
         case NewChipID('Q', 'Z'):
+        case NewChipID('Q', '^'):
             return ATI_CHIP_RADEONVE;
 
         case NewChipID('L', 'Y'):
@@ -705,6 +711,7 @@
         case NewChipID('Y', 'a'):
         case NewChipID('Y', 'b'):
         case NewChipID('Y', 'd'):
+        case NewChipID('Y', 'e'):
             return ATI_CHIP_RV280;
 
         case NewChipID('\\', 'a'):
@@ -735,6 +742,7 @@
         case NewChipID('A', 'R'):
         case NewChipID('A', 'S'):
         case NewChipID('A', 'T'):
+        case NewChipID('A', 'U'):
         case NewChipID('A', 'V'):
         case NewChipID('N', 'P'):
         case NewChipID('N', 'Q'):
@@ -749,15 +757,18 @@
 
         case NewChipID('[', '\''):
         case NewChipID('[', 'b'):
+        case NewChipID('[', 'c'):
         case NewChipID('[', 'd'):
         case NewChipID('[', 'e'):
         case NewChipID('T', '\''):
+        case NewChipID('T', 'b'):
         case NewChipID('T', 'd'):
 	    return ATI_CHIP_RV370;
 
         case NewChipID('>', 'P'):
         case NewChipID('>', 'T'):
         case NewChipID('1', 'P'):
+        case NewChipID('1', 'R'):
         case NewChipID('1', 'T'):
 	    return ATI_CHIP_RV380;
 
@@ -768,19 +779,70 @@
         case NewChipID('J', 'L'):
         case NewChipID('J', 'M'):
         case NewChipID('J', 'N'):
+        case NewChipID('J', 'O'):
         case NewChipID('J', 'P'):
+        case NewChipID('J', 'T'):
 	    return ATI_CHIP_R420;
 
         case NewChipID('U', 'H'):
         case NewChipID('U', 'I'):
         case NewChipID('U', 'J'):
         case NewChipID('U', 'K'):
+        case NewChipID('U', 'P'):
         case NewChipID('U', 'Q'):
         case NewChipID('U', 'R'):
         case NewChipID('U', 'T'):
         case NewChipID(']', 'W'):
+        /* those are m28, not 100% certain they are r423 could
+	   be r480 but not r430 as their pci id names indicate... */
+        case NewChipID(']', 'H'):
+        case NewChipID(']', 'I'):
+        case NewChipID(']', 'J'):
 	    return ATI_CHIP_R423;
 
+        case NewChipID('U', 'L'):
+        case NewChipID('U', 'M'):
+        case NewChipID('U', 'N'):
+        case NewChipID('U', 'O'):
+	    return ATI_CHIP_R430;
+
+        case NewChipID(']', 'L'):
+        case NewChipID(']', 'M'):
+        case NewChipID(']', 'N'):
+        case NewChipID(']', 'O'):
+        case NewChipID(']', 'P'):
+        case NewChipID(']', 'R'):
+	    return ATI_CHIP_R480;
+
+        case NewChipID('K', 'I'):
+        case NewChipID('K', 'J'):
+        case NewChipID('K', 'K'):
+        case NewChipID('K', 'L'):
+	    return ATI_CHIP_R481;
+
+        case NewChipID('^', 'H'):
+        case NewChipID('^', 'J'):
+        case NewChipID('^', 'K'):
+        case NewChipID('^', 'L'):
+        case NewChipID('^', 'M'):
+        case NewChipID('^', 'O'):
+        case NewChipID('V', 'J'):
+        case NewChipID('V', 'K'):
+        case NewChipID('V', 'O'):
+        case NewChipID('V', 'R'):
+        case NewChipID('V', 'S'):
+	    return ATI_CHIP_RV410;
+
+        case NewChipID('Z', 'A'):
+        case NewChipID('Z', 'B'):
+        case NewChipID('Z', 'a'):
+        case NewChipID('Z', 'b'):
+        case NewChipID('Y', 'T'):
+        case NewChipID('Y', 'U'):
+        case NewChipID('Y', 't'):
+        case NewChipID('Y', 'u'):
+	    return ATI_CHIP_RS400;
+
         case NewChipID('H', 'D'):
             return ATI_CHIP_HDTV;
 
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atichip.h xf86-video-ati-X11R7.0-6.5.7.3/src/atichip.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atichip.h	2005-04-20 14:25:22.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/atichip.h	2006-02-28 01:52:53.000000000 +0100
@@ -108,7 +108,12 @@
     ATI_CHIP_RV370,             /* RV370/M22 */
     ATI_CHIP_RV380,             /* RV380/M24 */
     ATI_CHIP_R420,              /* R420/M18 */
-    ATI_CHIP_R423,              /* R423 */
+    ATI_CHIP_R423,              /* R423/M28? */
+    ATI_CHIP_R430,              /* R430 */
+    ATI_CHIP_R480,              /* R480/M28? */
+    ATI_CHIP_R481,              /* R481 */
+    ATI_CHIP_RV410,             /* RV410, M26 */
+    ATI_CHIP_RS400,             /* RS400, RS410, RS480, RS482, ... */
     ATI_CHIP_Radeon,            /* Last among Radeon's */
     ATI_CHIP_HDTV               /* HDTV */
 } ATIChipType;
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/ati.h xf86-video-ati-X11R7.0-6.5.7.3/src/ati.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/ati.h	2004-04-23 21:26:46.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/ati.h	2006-03-12 07:57:12.000000000 +0100
@@ -25,7 +25,7 @@
 #define ___ATI_H___ 1
 
 #include "xf86Pci.h"
-#include "xf86PciInfo.h"
+#include "atipciids.h"
 
 #include "xf86.h"
 
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atipciids.h xf86-video-ati-X11R7.0-6.5.7.3/src/atipciids.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atipciids.h	2006-03-26 16:50:21.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/atipciids.h	2006-03-12 07:57:12.000000000 +0100
@@ -0,0 +1,294 @@
+/* $XdotOrg: driver/xf86-video-ati/src/atipciids.h,v 1.1.2.1 2006-03-12 06:57:12 benh Exp $ */
+
+/*
+ * Copyright (c) 1995-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file is a replacement for xf86PciInfo.h moving ATI related PCI IDs
+ * locally to the driver module
+ */
+
+#ifndef _ATIPCIIDS_H
+#define _ATIPCIIDS_H
+
+/* PCI Vendor */
+#define PCI_VENDOR_ATI			0x1002
+#define PCI_VENDOR_AMD			0x1022
+#define PCI_VENDOR_DELL			0x1028
+
+/* ATI */
+#define PCI_CHIP_RV380_3150             0x3150
+#define PCI_CHIP_RV380_3151             0x3151
+#define PCI_CHIP_RV380_3152             0x3152
+#define PCI_CHIP_RV380_3153             0x3153
+#define PCI_CHIP_RV380_3154             0x3154
+#define PCI_CHIP_RV380_3156             0x3156
+#define PCI_CHIP_RV380_3E50             0x3E50
+#define PCI_CHIP_RV380_3E51             0x3E51
+#define PCI_CHIP_RV380_3E52             0x3E52
+#define PCI_CHIP_RV380_3E53             0x3E53
+#define PCI_CHIP_RV380_3E54             0x3E54
+#define PCI_CHIP_RV380_3E56             0x3E56
+#define PCI_CHIP_RS100_4136		0x4136
+#define PCI_CHIP_RS200_4137		0x4137
+#define PCI_CHIP_R300_AD		0x4144
+#define PCI_CHIP_R300_AE		0x4145
+#define PCI_CHIP_R300_AF		0x4146
+#define PCI_CHIP_R300_AG		0x4147
+#define PCI_CHIP_R350_AH                0x4148
+#define PCI_CHIP_R350_AI                0x4149
+#define PCI_CHIP_R350_AJ                0x414A
+#define PCI_CHIP_R350_AK                0x414B
+#define PCI_CHIP_RV350_AP               0x4150
+#define PCI_CHIP_RV350_AQ               0x4151
+#define PCI_CHIP_RV360_AR               0x4152
+#define PCI_CHIP_RV350_AS               0x4153
+#define PCI_CHIP_RV350_AT               0x4154
+#define PCI_CHIP_RV350_4155             0x4155
+#define PCI_CHIP_RV350_AV               0x4156
+#define PCI_CHIP_MACH32			0x4158
+#define PCI_CHIP_RS250_4237		0x4237
+#define PCI_CHIP_R200_BB		0x4242
+#define PCI_CHIP_R200_BC		0x4243
+#define PCI_CHIP_RS100_4336		0x4336
+#define PCI_CHIP_RS200_4337		0x4337
+#define PCI_CHIP_MACH64CT		0x4354
+#define PCI_CHIP_MACH64CX		0x4358
+#define PCI_CHIP_RS250_4437		0x4437
+#define PCI_CHIP_MACH64ET		0x4554
+#define PCI_CHIP_MACH64GB		0x4742
+#define PCI_CHIP_MACH64GD		0x4744
+#define PCI_CHIP_MACH64GI		0x4749
+#define PCI_CHIP_MACH64GL		0x474C
+#define PCI_CHIP_MACH64GM		0x474D
+#define PCI_CHIP_MACH64GN		0x474E
+#define PCI_CHIP_MACH64GO		0x474F
+#define PCI_CHIP_MACH64GP		0x4750
+#define PCI_CHIP_MACH64GQ		0x4751
+#define PCI_CHIP_MACH64GR		0x4752
+#define PCI_CHIP_MACH64GS		0x4753
+#define PCI_CHIP_MACH64GT		0x4754
+#define PCI_CHIP_MACH64GU		0x4755
+#define PCI_CHIP_MACH64GV		0x4756
+#define PCI_CHIP_MACH64GW		0x4757
+#define PCI_CHIP_MACH64GX		0x4758
+#define PCI_CHIP_MACH64GY		0x4759
+#define PCI_CHIP_MACH64GZ		0x475A
+#define PCI_CHIP_RV250_Id		0x4964
+#define PCI_CHIP_RV250_Ie		0x4965
+#define PCI_CHIP_RV250_If		0x4966
+#define PCI_CHIP_RV250_Ig		0x4967
+#define PCI_CHIP_R420_JH                0x4A48
+#define PCI_CHIP_R420_JI                0x4A49
+#define PCI_CHIP_R420_JJ                0x4A4A
+#define PCI_CHIP_R420_JK                0x4A4B
+#define PCI_CHIP_R420_JL                0x4A4C
+#define PCI_CHIP_R420_JM                0x4A4D
+#define PCI_CHIP_R420_JN                0x4A4E
+#define PCI_CHIP_R420_4A4F              0x4A4F
+#define PCI_CHIP_R420_JP                0x4A50
+#define PCI_CHIP_R420_4A54              0x4A54
+#define PCI_CHIP_R481_4B49              0x4B49
+#define PCI_CHIP_R481_4B4A              0x4B4A
+#define PCI_CHIP_R481_4B4B              0x4B4B
+#define PCI_CHIP_R481_4B4C              0x4B4C
+#define PCI_CHIP_MACH64LB		0x4C42
+#define PCI_CHIP_MACH64LD		0x4C44
+#define PCI_CHIP_RAGE128LE		0x4C45
+#define PCI_CHIP_RAGE128LF		0x4C46
+#define PCI_CHIP_MACH64LG		0x4C47
+#define PCI_CHIP_MACH64LI		0x4C49
+#define PCI_CHIP_MACH64LM		0x4C4D
+#define PCI_CHIP_MACH64LN		0x4C4E
+#define PCI_CHIP_MACH64LP		0x4C50
+#define PCI_CHIP_MACH64LQ		0x4C51
+#define PCI_CHIP_MACH64LR		0x4C52
+#define PCI_CHIP_MACH64LS		0x4C53
+#define PCI_CHIP_RADEON_LW		0x4C57
+#define PCI_CHIP_RADEON_LX		0x4C58
+#define PCI_CHIP_RADEON_LY		0x4C59
+#define PCI_CHIP_RADEON_LZ		0x4C5A
+#define PCI_CHIP_RV250_Ld		0x4C64
+#define PCI_CHIP_RV250_Le		0x4C65
+#define PCI_CHIP_RV250_Lf		0x4C66
+#define PCI_CHIP_RV250_Lg		0x4C67
+#define PCI_CHIP_RV250_Ln		0x4C6E
+#define PCI_CHIP_RAGE128MF		0x4D46
+#define PCI_CHIP_RAGE128ML		0x4D4C
+#define PCI_CHIP_R300_ND		0x4E44
+#define PCI_CHIP_R300_NE		0x4E45
+#define PCI_CHIP_R300_NF		0x4E46
+#define PCI_CHIP_R300_NG		0x4E47
+#define PCI_CHIP_R350_NH                0x4E48  
+#define PCI_CHIP_R350_NI                0x4E49  
+#define PCI_CHIP_R360_NJ                0x4E4A  
+#define PCI_CHIP_R350_NK                0x4E4B  
+#define PCI_CHIP_RV350_NP               0x4E50
+#define PCI_CHIP_RV350_NQ               0x4E51
+#define PCI_CHIP_RV350_NR               0x4E52
+#define PCI_CHIP_RV350_NS               0x4E53
+#define PCI_CHIP_RV350_NT               0x4E54
+#define PCI_CHIP_RV350_NV               0x4E56
+#define PCI_CHIP_RAGE128PA		0x5041
+#define PCI_CHIP_RAGE128PB		0x5042
+#define PCI_CHIP_RAGE128PC		0x5043
+#define PCI_CHIP_RAGE128PD		0x5044
+#define PCI_CHIP_RAGE128PE		0x5045
+#define PCI_CHIP_RAGE128PF		0x5046
+#define PCI_CHIP_RAGE128PG		0x5047
+#define PCI_CHIP_RAGE128PH		0x5048
+#define PCI_CHIP_RAGE128PI		0x5049
+#define PCI_CHIP_RAGE128PJ		0x504A
+#define PCI_CHIP_RAGE128PK		0x504B
+#define PCI_CHIP_RAGE128PL		0x504C
+#define PCI_CHIP_RAGE128PM		0x504D
+#define PCI_CHIP_RAGE128PN		0x504E
+#define PCI_CHIP_RAGE128PO		0x504F
+#define PCI_CHIP_RAGE128PP		0x5050
+#define PCI_CHIP_RAGE128PQ		0x5051
+#define PCI_CHIP_RAGE128PR		0x5052
+#define PCI_CHIP_RAGE128PS		0x5053
+#define PCI_CHIP_RAGE128PT		0x5054
+#define PCI_CHIP_RAGE128PU		0x5055
+#define PCI_CHIP_RAGE128PV		0x5056
+#define PCI_CHIP_RAGE128PW		0x5057
+#define PCI_CHIP_RAGE128PX		0x5058
+#define PCI_CHIP_RADEON_QD		0x5144
+#define PCI_CHIP_RADEON_QE		0x5145
+#define PCI_CHIP_RADEON_QF		0x5146
+#define PCI_CHIP_RADEON_QG		0x5147
+#define PCI_CHIP_R200_QH		0x5148
+#define PCI_CHIP_R200_QI		0x5149
+#define PCI_CHIP_R200_QJ		0x514A
+#define PCI_CHIP_R200_QK		0x514B
+#define PCI_CHIP_R200_QL		0x514C
+#define PCI_CHIP_R200_QM		0x514D
+#define PCI_CHIP_R200_QN		0x514E
+#define PCI_CHIP_R200_QO		0x514F
+#define PCI_CHIP_RV200_QW		0x5157
+#define PCI_CHIP_RV200_QX		0x5158
+#define PCI_CHIP_RV100_QY		0x5159
+#define PCI_CHIP_RV100_QZ		0x515A
+#define PCI_CHIP_RN50_515E		0x515E
+#define PCI_CHIP_RAGE128RE		0x5245
+#define PCI_CHIP_RAGE128RF		0x5246
+#define PCI_CHIP_RAGE128RG		0x5247
+#define PCI_CHIP_RAGE128RK		0x524B
+#define PCI_CHIP_RAGE128RL		0x524C
+#define PCI_CHIP_RAGE128SE		0x5345
+#define PCI_CHIP_RAGE128SF		0x5346
+#define PCI_CHIP_RAGE128SG		0x5347
+#define PCI_CHIP_RAGE128SH		0x5348
+#define PCI_CHIP_RAGE128SK		0x534B
+#define PCI_CHIP_RAGE128SL		0x534C
+#define PCI_CHIP_RAGE128SM		0x534D
+#define PCI_CHIP_RAGE128SN		0x534E
+#define PCI_CHIP_RAGE128TF		0x5446
+#define PCI_CHIP_RAGE128TL		0x544C
+#define PCI_CHIP_RAGE128TR		0x5452
+#define PCI_CHIP_RAGE128TS		0x5453
+#define PCI_CHIP_RAGE128TT		0x5454
+#define PCI_CHIP_RAGE128TU		0x5455
+#define PCI_CHIP_RV370_5460             0x5460
+#define PCI_CHIP_RV370_5461             0x5461
+#define PCI_CHIP_RV370_5462             0x5462
+#define PCI_CHIP_RV370_5463             0x5463
+#define PCI_CHIP_RV370_5464             0x5464
+#define PCI_CHIP_RV370_5465             0x5465
+#define PCI_CHIP_RV370_5466             0x5466
+#define PCI_CHIP_RV370_5467             0x5467
+#define PCI_CHIP_R423_UH                0x5548
+#define PCI_CHIP_R423_UI                0x5549
+#define PCI_CHIP_R423_UJ                0x554A
+#define PCI_CHIP_R423_UK                0x554B
+#define PCI_CHIP_R430_554C              0x554C
+#define PCI_CHIP_R430_554D              0x554D
+#define PCI_CHIP_R430_554E              0x554E
+#define PCI_CHIP_R430_554F              0x554F
+#define PCI_CHIP_R423_5550              0x5550
+#define PCI_CHIP_R423_UQ                0x5551
+#define PCI_CHIP_R423_UR                0x5552
+#define PCI_CHIP_R423_UT                0x5554
+#define PCI_CHIP_RV410_564A             0x564A
+#define PCI_CHIP_RV410_564B             0x564B
+#define PCI_CHIP_RV410_564F             0x564F
+#define PCI_CHIP_RV410_5652             0x5652
+#define PCI_CHIP_RV410_5653             0x5653
+#define PCI_CHIP_MACH64VT		0x5654
+#define PCI_CHIP_MACH64VU		0x5655
+#define PCI_CHIP_MACH64VV		0x5656
+#define PCI_CHIP_RS300_5834		0x5834
+#define PCI_CHIP_RS300_5835		0x5835
+#define PCI_CHIP_RS300_5836		0x5836
+#define PCI_CHIP_RS300_5837		0x5837
+#define PCI_CHIP_RS480_5954             0x5954
+#define PCI_CHIP_RS480_5955             0x5955
+#define PCI_CHIP_RV280_5960		0x5960
+#define PCI_CHIP_RV280_5961		0x5961
+#define PCI_CHIP_RV280_5962		0x5962
+#define PCI_CHIP_RV280_5964		0x5964
+#define PCI_CHIP_RV280_5965 		0x5965
+#define PCI_CHIP_RN50_5969		0x5969
+#define PCI_CHIP_RS482_5974             0x5974
+#define PCI_CHIP_RS482_5975             0x5975
+#define PCI_CHIP_RS400_5A41             0x5A41
+#define PCI_CHIP_RS400_5A42             0x5A42
+#define PCI_CHIP_RC410_5A61             0x5A61
+#define PCI_CHIP_RC410_5A62             0x5A62
+#define PCI_CHIP_RV370_5B60             0x5B60
+#define PCI_CHIP_RV370_5B61             0x5B61
+#define PCI_CHIP_RV370_5B62             0x5B62
+#define PCI_CHIP_RV370_5B63             0x5B63
+#define PCI_CHIP_RV370_5B64             0x5B64
+#define PCI_CHIP_RV370_5B65             0x5B65
+#define PCI_CHIP_RV370_5B66             0x5B66
+#define PCI_CHIP_RV370_5B67             0x5B67
+#define PCI_CHIP_RV280_5C61		0x5C61
+#define PCI_CHIP_RV280_5C63		0x5C63
+#define PCI_CHIP_R430_5D48              0x5D48
+#define PCI_CHIP_R430_5D49              0x5D49
+#define PCI_CHIP_R430_5D4A              0x5D4A
+#define PCI_CHIP_R480_5D4C              0x5D4C
+#define PCI_CHIP_R480_5D4D              0x5D4D
+#define PCI_CHIP_R480_5D4E              0x5D4E
+#define PCI_CHIP_R480_5D4F              0x5D4F
+#define PCI_CHIP_R480_5D50              0x5D50
+#define PCI_CHIP_R480_5D52              0x5D52
+#define PCI_CHIP_R423_5D57              0x5D57
+#define PCI_CHIP_RV410_5E48             0x5E48
+#define PCI_CHIP_RV410_5E4A             0x5E4A
+#define PCI_CHIP_RV410_5E4B             0x5E4B
+#define PCI_CHIP_RV410_5E4C             0x5E4C
+#define PCI_CHIP_RV410_5E4D             0x5E4D
+#define PCI_CHIP_RV410_5E4F             0x5E4F
+#define PCI_CHIP_RS350_7834             0x7834
+#define PCI_CHIP_RS350_7835             0x7835
+
+/* Misc */
+#define PCI_CHIP_AMD761			0x700E
+
+#endif /* _ATIPCIIDS_H */
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atipreinit.c xf86-video-ati-X11R7.0-6.5.7.3/src/atipreinit.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/atipreinit.c	2005-08-28 20:10:34.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/atipreinit.c	2005-08-28 20:10:34.000000000 +0200
@@ -1,5 +1,5 @@
 /* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atipreinit.c,v 1.74 2003/12/22 17:48:09 tsi Exp $ */
-/* $XdotOrg: xc/programs/Xserver/hw/xfree86/drivers/ati/atipreinit.c,v 1.6 2005/06/26 04:38:12 ajax Exp $ */
+/* $XdotOrg: driver/xf86-video-ati/src/atipreinit.c,v 1.9 2005-08-28 18:10:34 ajax Exp $ */
 /*
  * Copyright 1999 through 2004 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
  *
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/ativga.c xf86-video-ati-X11R7.0-6.5.7.3/src/ativga.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/ativga.c	2005-07-11 04:29:45.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/ativga.c	2005-07-11 04:29:45.000000000 +0200
@@ -1,5 +1,5 @@
 /* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/ativga.c,v 1.20 2003/04/23 21:51:31 tsi Exp $ */
-/* $XdotOrg: xc/programs/Xserver/hw/xfree86/drivers/ati/ativga.c,v 1.4 2005/06/04 20:26:28 alanc Exp $ */
+/* $XdotOrg: driver/xf86-video-ati/src/ativga.c,v 1.6 2005-07-11 02:29:45 ajax Exp $ */
 /*
  * Copyright 1997 through 2004 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
  *
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/r128_dri.c xf86-video-ati-X11R7.0-6.5.7.3/src/r128_dri.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/r128_dri.c	2005-11-11 12:05:42.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/r128_dri.c	2006-03-12 07:57:12.000000000 +0100
@@ -52,7 +52,7 @@
 				/* X and server generic header files */
 #include "xf86.h"
 #include "windowstr.h"
-#include "xf86PciInfo.h"
+#include "atipciids.h"
 
 #include "shadowfb.h"
 				/* GLX/DRI/DRM definitions */
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/r128_driver.c xf86-video-ati-X11R7.0-6.5.7.3/src/r128_driver.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/r128_driver.c	2005-12-14 20:41:28.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/r128_driver.c	2006-03-12 07:57:12.000000000 +0100
@@ -85,7 +85,6 @@
 				/* X and server generic header files */
 #include "xf86.h"
 #include "xf86_OSproc.h"
-#include "xf86PciInfo.h"
 #include "xf86RAC.h"
 #include "xf86Resources.h"
 #include "xf86cmap.h"
@@ -103,6 +102,7 @@
 #define DPMS_SERVER
 #include <X11/extensions/dpms.h>
 
+#include "atipciids.h"
 #include "r128_chipset.h"
 
 #ifndef MAX
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/r128_probe.c xf86-video-ati-X11R7.0-6.5.7.3/src/r128_probe.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/r128_probe.c	2005-07-11 04:29:45.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/r128_probe.c	2006-03-12 07:57:12.000000000 +0100
@@ -45,8 +45,7 @@
 
 #include "r128_probe.h"
 #include "r128_version.h"
-
-#include "xf86PciInfo.h"
+#include "atipciids.h"
 
 #include "xf86.h"
 #include "xf86_ansic.h"
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_accel.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_accel.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_accel.c	2005-11-08 17:30:48.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_accel.c	2006-02-16 00:36:55.000000000 +0100
@@ -292,19 +292,19 @@
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
-    int            pitch64;
 
     RADEONTRACE(("EngineRestore (%d/%d)\n",
 		 info->CurrentLayout.pixel_code,
 		 info->CurrentLayout.bitsPerPixel));
 
-    RADEONWaitForFifo(pScrn, 1);
-
-    pitch64 = ((pScrn->displayWidth * (pScrn->bitsPerPixel / 8) + 0x3f)) >> 6;
-
-/*    RADEONWaitForFifo(pScrn, 2);
+    /* Setup engine location. This shouldn't be necessary since we
+     * set them appropriately before any accel ops, but let's avoid
+     * random bogus DMA in case we inadvertently trigger the engine
+     * in the wrong place (happened).
+     */
+    RADEONWaitForFifo(pScrn, 2);
     OUTREG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset);
-    OUTREG(RADEON_SRC_PITCH_OFFSET, info->dst_pitch_offset);*/
+    OUTREG(RADEON_SRC_PITCH_OFFSET, info->dst_pitch_offset);
 
     RADEONWaitForFifo(pScrn, 1);
 #if X_BYTE_ORDER == X_BIG_ENDIAN
@@ -326,9 +326,7 @@
 				       | RADEON_GMC_BRUSH_SOLID_COLOR
 				       | RADEON_GMC_SRC_DATATYPE_COLOR));
 
-    RADEONWaitForFifo(pScrn, 7);
-    OUTREG(RADEON_DST_LINE_START,    0);
-    OUTREG(RADEON_DST_LINE_END,      0);
+    RADEONWaitForFifo(pScrn, 5);
     OUTREG(RADEON_DP_BRUSH_FRGD_CLR, 0xffffffff);
     OUTREG(RADEON_DP_BRUSH_BKGD_CLR, 0x00000000);
     OUTREG(RADEON_DP_SRC_FRGD_CLR,   0xffffffff);
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_chipset.h xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_chipset.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_chipset.h	2005-04-01 01:18:10.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_chipset.h	2006-02-28 01:52:53.000000000 +0100
@@ -33,7 +33,7 @@
     { PCI_CHIP_RS300_5835, "ATI Radeon Mobility 9100 IGP (U3) 5835" },
     { PCI_CHIP_RS350_7834, "ATI Radeon 9100 PRO IGP 7834" },
     { PCI_CHIP_RS350_7835, "ATI Radeon Mobility 9200 IGP 7835" },
-    { PCI_CHIP_RV280_5960, "ATI Radeon 9200PRO 5960 (AGP)" },
+    { PCI_CHIP_RV280_5960, "ATI Radeon 9250 5960 (AGP)" },
     { PCI_CHIP_RV280_5961, "ATI Radeon 9200 5961 (AGP)" },
     { PCI_CHIP_RV280_5962, "ATI Radeon 9200 5962 (AGP)" },
     { PCI_CHIP_RV280_5964, "ATI Radeon 9200SE 5964 (AGP)" },
@@ -46,7 +46,7 @@
     { PCI_CHIP_R300_AG, "ATI FireGL Z1 AG (AGP)" },
     { PCI_CHIP_R300_ND, "ATI Radeon 9700 Pro ND (AGP)" },
     { PCI_CHIP_R300_NE, "ATI Radeon 9700/9500Pro NE (AGP)" },
-    { PCI_CHIP_R300_NF, "ATI Radeon 9700 NF (AGP)" },
+    { PCI_CHIP_R300_NF, "ATI Radeon 9600TX NF (AGP)" },
     { PCI_CHIP_R300_NG, "ATI FireGL X1 NG (AGP)" },
     { PCI_CHIP_RV350_AP, "ATI Radeon 9600 AP (AGP)" },
     { PCI_CHIP_RV350_AQ, "ATI Radeon 9600SE AQ (AGP)" },
@@ -72,12 +72,15 @@
     { PCI_CHIP_RV380_3E50, "ATI Radeon X600 (RV380) 3E50 (PCIE)" },
     { PCI_CHIP_RV380_3E54, "ATI FireGL V3200 (RV380) 3E54 (PCIE)" },
     { PCI_CHIP_RV380_3150, "ATI Radeon Mobility X600 (M24) 3150 (PCIE)" },
+    { PCI_CHIP_RV380_3152, "ATI Radeon Mobility X300 (M24) 3152 (PCIE)" },
     { PCI_CHIP_RV380_3154, "ATI FireGL M24 GL 3154 (PCIE)" },
     { PCI_CHIP_RV370_5B60, "ATI Radeon X300 (RV370) 5B60 (PCIE)" },
     { PCI_CHIP_RV370_5B62, "ATI Radeon X600 (RV370) 5B62 (PCIE)" },
+    { PCI_CHIP_RV370_5B63, "ATI Radeon X550 (RV370) 5B63 (PCIE)" },
     { PCI_CHIP_RV370_5B64, "ATI FireGL V3100 (RV370) 5B64 (PCIE)" },
-    { PCI_CHIP_RV370_5B65, "ATI FireGL D1100 (RV370) 5B65 (PCIE)" },
-    { PCI_CHIP_RV370_5460, "ATI Radeon Mobility M300 (M22) 5460 (PCIE)" },
+    { PCI_CHIP_RV370_5B65, "ATI FireMV 2200 PCIE (RV370) 5B65 (PCIE)" },
+    { PCI_CHIP_RV370_5460, "ATI Radeon Mobility X300 (M22) 5460 (PCIE)" },
+    { PCI_CHIP_RV370_5462, "ATI Radeon Mobility X600 SE (M24C) 5462 (PCIE)" },
     { PCI_CHIP_RV370_5464, "ATI FireGL M22 GL 5464 (PCIE)" },
     { PCI_CHIP_RS400_5A41, "ATI Radeon XPRESS 200 5A41 (PCIE)" },
     { PCI_CHIP_RS400_5A42, "ATI Radeon XPRESS 200M 5A42 (PCIE)" },
@@ -90,6 +93,7 @@
     { PCI_CHIP_RV410_5E48, "ATI FireGL V5000 (RV410) (PCIE)" },
     { PCI_CHIP_RV410_564A, "ATI Mobility FireGL V5000 (M26) (PCIE)" },
     { PCI_CHIP_RV410_564B, "ATI Mobility FireGL V5000 (M26) (PCIE)" },
+    { PCI_CHIP_RV410_564F, "ATI Mobility Radeon X700 XL (M26) (PCIE)" },
     { PCI_CHIP_RV410_5652, "ATI Mobility Radeon X700 (M26) (PCIE)" },
     { PCI_CHIP_RV410_5653, "ATI Mobility Radeon X700 (M26) (PCIE)" },
     { PCI_CHIP_RV410_5E4B, "ATI Radeon X700 PRO (RV410) (PCIE)" },
@@ -106,13 +110,14 @@
     { PCI_CHIP_R420_JN, "ATI Radeon Mobility 9800 (M18) JN (AGP)" },
     { PCI_CHIP_R420_JP, "ATI Radeon X800XT (R420) JP (AGP)" },
     { PCI_CHIP_R420_4A4F, "ATI Radeon X800 SE (R420) (AGP)" },
+    { PCI_CHIP_R420_4A54, "ATI Radeon AIW X800 VE (R420) JT (AGP)" },
     { PCI_CHIP_R423_UH, "ATI Radeon X800 (R423) UH (PCIE)" },
     { PCI_CHIP_R423_UI, "ATI Radeon X800PRO (R423) UI (PCIE)" },
     { PCI_CHIP_R423_UJ, "ATI Radeon X800LE (R423) UJ (PCIE)" },
     { PCI_CHIP_R423_UK, "ATI Radeon X800SE (R423) UK (PCIE)" },
-    { PCI_CHIP_R423_UQ, "ATI FireGL V7200 (R423) UQ (PCIE)" },
-    { PCI_CHIP_R423_UR, "ATI FireGL V5100 (R423) UR (PCIE)" },
-    { PCI_CHIP_R423_UT, "ATI FireGL V7100 (R423) UT (PCIE)" },
+    { PCI_CHIP_R423_UQ, "ATI FireGL V5100 (R423) UQ (PCIE)" },
+    { PCI_CHIP_R423_UR, "ATI FireGL unknown (R423) UR (PCIE)" },
+    { PCI_CHIP_R423_UT, "ATI FireGL unknown (R423) UT (PCIE)" },
     { PCI_CHIP_R423_5D57, "ATI Radeon X800XT (R423) 5D57 (PCIE)" },
     { PCI_CHIP_R423_5550, "ATI FireGL V7100 (R423) (PCIE)" },
     { PCI_CHIP_R430_5D49, "ATI Mobility FireGL V5100 (M28) (PCIE)" },
@@ -123,7 +128,7 @@
     { PCI_CHIP_R430_554E, "ATI Radeon X800 SE (R430) (PCIE)" },
     { PCI_CHIP_R430_554C, "ATI Radeon X800 XTP (R430) (PCIE)" },
     { PCI_CHIP_R480_5D4C, "ATI Radeon X850 5D4C (PCIE)" },
-    { PCI_CHIP_R480_5D50, "ATI Radeon FireGL (R480) GL 5D50 (PCIE)" },
+    { PCI_CHIP_R480_5D50, "ATI unknown Radeon / FireGL (R480) 5D50 (PCIE)" },
     { PCI_CHIP_R480_5D4E, "ATI Radeon X850 SE (R480) (PCIE)" },
     { PCI_CHIP_R480_5D4F, "ATI Radeon X850 PRO (R480) (PCIE)" },
     { PCI_CHIP_R480_5D52, "ATI Radeon X850 XT (R480) (PCIE)" },
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_commonfuncs.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_commonfuncs.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_commonfuncs.c	2005-09-11 22:58:53.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_commonfuncs.c	2006-02-17 00:27:44.000000000 +0100
@@ -155,9 +155,11 @@
     }
 #endif
 
+#if 0
     RADEONTRACE(("WaitForIdle (entering): %d entries, stat=0x%08x\n",
 		     INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK,
 		     INREG(RADEON_RBBM_STATUS)));
+#endif
 
     /* Wait for the engine to go idle */
     RADEONWaitForFifoFunction(pScrn, 64);
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_common.h xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_common.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_common.h	2005-09-11 10:51:38.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_common.h	2006-02-17 00:27:44.000000000 +0100
@@ -31,7 +31,7 @@
  * Converted to common header format:
  *   Jens Owen <jens@tungstengraphics.com>
  *
- * $XdotOrg: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_common.h,v 1.5 2005/01/26 18:23:40 sroland Exp $
+ * $XdotOrg: driver/xf86-video-ati/src/radeon_common.h,v 1.8 2006-02-16 23:27:44 benh Exp $
  * $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_common.h,v 1.8tsi Exp $
  *
  */
@@ -474,6 +474,7 @@
 #define RADEON_SETPARAM_FB_LOCATION     1
 #define RADEON_SETPARAM_SWITCH_TILING   2
 #define RADEON_SETPARAM_PCIGART_LOCATION 3
+#define RADEON_SETPARAM_NEW_MEMMAP 4
 
 /* 1.14: Clients can allocate/free a surface
  */
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_cursor.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_cursor.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_cursor.c	2005-11-08 10:44:41.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_cursor.c	2006-02-17 00:27:44.000000000 +0100
@@ -31,6 +31,9 @@
 #include "config.h"
 #endif
 
+#define RADEONCTRACE(x)
+/* #define RADEONCTRACE(x) RADEONTRACE(x)  */
+
 /*
  * Authors:
  *   Kevin E. Martin <martin@xfree86.org>
@@ -50,6 +53,7 @@
 
 				/* Driver data structures */
 #include "radeon.h"
+#include "radeon_version.h"
 #include "radeon_reg.h"
 #include "radeon_macros.h"
 #include "radeon_mergedfb.h"
@@ -81,11 +85,11 @@
 #define CURSOR_SWAPPING_DECL_MMIO   unsigned char *RADEONMMIO = info->MMIO;
 #define CURSOR_SWAPPING_START() \
   do { \
+    COMMON_CURSOR_SWAPPING_START(); \
     OUTREG(RADEON_SURFACE_CNTL, \
 	   (info->ModeReg.surface_cntl | \
-	    RADEON_NONSURF_AP0_SWP_32BPP) & \
-	   ~RADEON_NONSURF_AP0_SWP_16BPP); \
-    COMMON_CURSOR_SWAPPING_START(); \
+	     RADEON_NONSURF_AP0_SWP_32BPP | RADEON_NONSURF_AP1_SWP_32BPP) & \
+	   ~(RADEON_NONSURF_AP0_SWP_16BPP | RADEON_NONSURF_AP1_SWP_16BPP)); \
   } while (0)
 #define CURSOR_SWAPPING_END()	(OUTREG(RADEON_SURFACE_CNTL, \
 					info->ModeReg.surface_cntl))
@@ -133,9 +137,9 @@
 		   "Using hardware cursor\n",
 		   info->cursor_offset = info->cursorArea->offset);
 
-	RADEONTRACE(("%s (0x%08x-0x%08x)\n", __func__,
-		     info->cursor_offset,
-		     info->cursor_offset + info->cursorArea->size));
+	RADEONCTRACE(("%s (0x%08x-0x%08x)\n", __func__,
+		      info->cursor_offset,
+		      info->cursor_offset + info->cursorArea->size));
     }
 }
 #endif
@@ -149,6 +153,11 @@
     int            pixel, i;
     CURSOR_SWAPPING_DECL_MMIO
 
+    RADEONCTRACE(("RADEONSetCursorColors\n"));
+
+    if (info->cursor_offset == 0)
+	return;
+
 #ifdef ARGB_CURSOR
     /* Don't recolour cursors set with SetCursorARGB. */
     if (info->cursor_argb)
@@ -191,11 +200,17 @@
     int                total_y    = pScrn->frameY1 - pScrn->frameY0;
     int		       stride     = 256;
 
+    if (info->cursor_offset == 0)
+	return;
+
     if(info->MergedFB) {
+       RADEONCTRACE(("RADEONSetCursorPositionMerged\n"));
        RADEONSetCursorPositionMerged(pScrn, x, y);
        return;
     }
 
+    RADEONCTRACE(("RADEONSetCursorPosition\n"));
+
     if (x < 0)                        xorigin = -x+1;
     if (y < 0)                        yorigin = -y+1;
     if (y > total_y)                  y       = total_y;
@@ -210,6 +225,8 @@
 	OUTREG(RADEON_CUR_HORZ_VERT_POSN, (RADEON_CUR_LOCK
 					   | ((xorigin ? 0 : x) << 16)
 					   | (yorigin ? 0 : y)));
+	RADEONCTRACE(("cursor_offset: 0x%x, yorigin: %d, stride: %d\n",
+		     info->cursor_offset, yorigin, stride));
 	OUTREG(RADEON_CUR_OFFSET, info->cursor_offset + yorigin * stride);
     } else {
 	OUTREG(RADEON_CUR2_HORZ_VERT_OFF,  (RADEON_CUR2_LOCK
@@ -238,6 +255,11 @@
     CARD8	   chunk;
     CARD32         i, j;
 
+    if (info->cursor_offset == 0)
+	return;
+
+    RADEONCTRACE(("RADEONLoadCursorImage (at %x)\n", info->cursor_offset));
+
     if (!info->IsSecondary) {
 	save1 = INREG(RADEON_CRTC_GEN_CNTL) & ~(CARD32) (3 << 20);
 	save1 |= (CARD32) (2 << 20);
@@ -264,7 +286,7 @@
      */
     CURSOR_SWAPPING_START();
 #define ARGB_PER_CHUNK	(8 * sizeof (chunk) / 2)
-    for (i = 0; i < CURSOR_WIDTH * CURSOR_HEIGHT / ARGB_PER_CHUNK; i++) {
+    for (i = 0; i < (CURSOR_WIDTH * CURSOR_HEIGHT / ARGB_PER_CHUNK); i++) {
         chunk = *s++;
 	for (j = 0; j < ARGB_PER_CHUNK; j++, chunk >>= 2)
 	    *d++ = mono_cursor_color[chunk & 3];
@@ -288,6 +310,8 @@
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
 
+    RADEONCTRACE(("RADEONHideCursor\n"));
+
     if (info->IsSecondary || info->MergedFB)
 	OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~RADEON_CRTC2_CUR_EN);
 
@@ -301,6 +325,8 @@
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
 
+    RADEONCTRACE(("RADEONShowCursor\n"));
+
     if (info->IsSecondary || info->MergedFB)
 	OUTREGP(RADEON_CRTC2_GEN_CNTL, RADEON_CRTC2_CUR_EN,
 		~RADEON_CRTC2_CUR_EN);
@@ -351,8 +377,10 @@
     CARD32	  *image = pCurs->bits->argb;
     CARD32	  *i;
 
-    if (!image)
-	return;	/* XXX can't happen */
+    RADEONCTRACE(("RADEONLoadCursorARGB\n"));
+
+    if (info->cursor_offset == 0)
+	return;
 
     if (!info->IsSecondary) {
 	save1 = INREG(RADEON_CRTC_GEN_CNTL) & ~(CARD32) (3 << 20);
@@ -473,7 +501,7 @@
 						256);
 	    info->cursor_end = info->cursor_offset + size_bytes;
 	}
-	RADEONTRACE(("RADEONCursorInit (0x%08x-0x%08x)\n",
+	RADEONCTRACE(("RADEONCursorInit (0x%08x-0x%08x)\n",
 		    info->cursor_offset, info->cursor_end));
     }
 #endif
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_dri.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_dri.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_dri.c	2005-10-21 20:40:18.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_dri.c	2006-03-17 04:03:59.000000000 +0100
@@ -1092,7 +1092,7 @@
     drmRadeonMemInitHeap drmHeap;
 
     /* Start up the simple memory manager for GART space */
-    if (info->drmMinor >= 6) {
+    if (info->pKernelDRMVersion->version_minor >= 6) {
 	drmHeap.region = RADEON_MEM_REGION_GART;
 	drmHeap.start  = 0;
 	drmHeap.size   = info->gartTexMapSize;
@@ -1109,7 +1109,7 @@
     } else {
 	xf86DrvMsg(pScreen->myNum, X_INFO,
 		   "[drm] Kernel module too old (1.%d) for GART heap manager\n",
-		   info->drmMinor);
+		   info->pKernelDRMVersion->version_minor);
     }
 }
 
@@ -1193,19 +1193,14 @@
 }
 
 
-/* Initialize the screen-specific data structures for the DRI and the
- * Radeon.  This is the main entry point to the device-specific
- * initialization code.  It calls device-independent DRI functions to
- * create the DRI data structures and initialize the DRI state.
- */
-Bool RADEONDRIScreenInit(ScreenPtr pScreen)
+/* Get the DRM version and do some basic useability checks of DRI */
+Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
 {
-    ScrnInfoPtr    pScrn   = xf86Screens[pScreen->myNum];
     RADEONInfoPtr  info    = RADEONPTR(pScrn);
-    DRIInfoPtr     pDRIInfo;
-    RADEONDRIPtr   pRADEONDRI;
-    int            major, minor, patch;
-    drmVersionPtr  version;
+    int            major, minor, patch, fd;
+    int		   req_minor, req_patch;
+    char           *busId;
+    drmVersionPtr  libVersion;
 
     /* Check that the GLX, DRI, and DRM modules have been loaded by testing
      * for known symbols in each module.
@@ -1213,16 +1208,17 @@
     if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) return FALSE;
     if (!xf86LoaderCheckSymbol("drmAvailable"))        return FALSE;
     if (!xf86LoaderCheckSymbol("DRIQueryVersion")) {
-      xf86DrvMsg(pScreen->myNum, X_ERROR,
-		 "[dri] RADEONDRIScreenInit failed (libdri.a too old)\n");
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		 "[dri] RADEONDRIGetVersion failed (libdri.a too old)\n"
+		 "[dri] Disabling DRI.\n");
       return FALSE;
     }
 
     /* Check the DRI version */
     DRIQueryVersion(&major, &minor, &patch);
     if (major != DRIINFO_MAJOR_VERSION || minor < DRIINFO_MINOR_VERSION) {
-	xf86DrvMsg(pScreen->myNum, X_ERROR,
-		   "[dri] RADEONDRIScreenInit failed because of a version "
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[dri] RADEONDRIGetVersion failed because of a version "
 		   "mismatch.\n"
 		   "[dri] libdri version is %d.%d.%d but version %d.%d.x is "
 		   "needed.\n"
@@ -1232,6 +1228,120 @@
 	return FALSE;
     }
 
+    /* Check the lib version */
+    if (xf86LoaderCheckSymbol("drmGetLibVersion"))
+	info->pLibDRMVersion = drmGetLibVersion(info->drmFD);
+    if (info->pLibDRMVersion == NULL) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[dri] RADEONDRIGetVersion failed because libDRM is really "
+		   "way to old to even get a version number out of it.\n"
+		   "[dri] Disabling DRI.\n");
+	return FALSE;
+    }
+    if (info->pLibDRMVersion->version_major != 1 ||
+	info->pLibDRMVersion->version_minor < 2) {
+	    /* incompatible drm library version */
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[dri] RADEONDRIGetVersion failed because of a "
+		   "version mismatch.\n"
+		   "[dri] libdrm.a module version is %d.%d.%d but "
+		   "version 1.2.x is needed.\n"
+		   "[dri] Disabling DRI.\n",
+		   info->pLibDRMVersion->version_major,
+		   info->pLibDRMVersion->version_minor,
+		   info->pLibDRMVersion->version_patchlevel);
+	drmFreeVersion(info->pLibDRMVersion);
+	info->pLibDRMVersion = NULL;
+	return FALSE;
+    }
+
+    /* Create a bus Id */
+    if (xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
+	busId = DRICreatePCIBusID(info->PciInfo);
+    } else {
+	busId = xalloc(64);
+	sprintf(busId,
+		"PCI:%d:%d:%d",
+		info->PciInfo->bus,
+		info->PciInfo->device,
+		info->PciInfo->func);
+    }
+
+    /* Low level DRM open */
+    fd = drmOpen(RADEON_DRIVER_NAME, busId);
+    xfree(busId);
+    if (fd < 0) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[dri] RADEONDRIGetVersion failed to open the DRM\n"
+		   "[dri] Disabling DRI.\n");
+	return FALSE;
+    }
+
+    /* Get DRM version & close DRM */
+    info->pKernelDRMVersion = drmGetVersion(fd);
+    drmClose(fd);
+    if (info->pKernelDRMVersion == NULL) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[dri] RADEONDRIGetVersion failed to get the DRM version\n"
+		   "[dri] Disabling DRI.\n");
+	return FALSE;
+    }
+
+    /* Now check if we qualify */
+    if (info->ChipFamily >= CHIP_FAMILY_R300) {
+        req_minor = 17;
+        req_patch = 0;
+    } else if (info->IsIGP) {
+        req_minor = 10;
+	req_patch = 0;
+    } else if (info->ChipFamily >= CHIP_FAMILY_R200) {
+	req_minor = 5;
+	req_patch = 0;
+    } else {
+	req_minor = 3;
+	req_patch = 0;
+    }
+
+    /* We don't, bummer ! */
+    if (info->pKernelDRMVersion->version_major != 1 ||
+	info->pKernelDRMVersion->version_minor < req_minor ||
+	(info->pKernelDRMVersion->version_minor == req_minor &&
+	 info->pKernelDRMVersion->version_patchlevel < req_patch)) {
+        /* Incompatible drm version */
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[dri] RADEONDRIGetVersion failed because of a version "
+		   "mismatch.\n"
+		   "[dri] radeon.o kernel module version is %d.%d.%d "
+		   "but version 1.%d.%d or newer is needed.\n"
+		   "[dri] Disabling DRI.\n",
+		   info->pKernelDRMVersion->version_major,
+		   info->pKernelDRMVersion->version_minor,
+		   info->pKernelDRMVersion->version_patchlevel,
+		   req_minor,
+		   req_patch);
+	drmFreeVersion(info->pKernelDRMVersion);
+	info->pKernelDRMVersion = NULL;
+	return FALSE;
+    }
+
+    return TRUE;
+}
+
+/* Initialize the screen-specific data structures for the DRI and the
+ * Radeon.  This is the main entry point to the device-specific
+ * initialization code.  It calls device-independent DRI functions to
+ * create the DRI data structures and initialize the DRI state.
+ */
+Bool RADEONDRIScreenInit(ScreenPtr pScreen)
+{
+    ScrnInfoPtr    pScrn   = xf86Screens[pScreen->myNum];
+    RADEONInfoPtr  info    = RADEONPTR(pScrn);
+    DRIInfoPtr     pDRIInfo;
+    RADEONDRIPtr   pRADEONDRI;
+    drmVersionPtr  version;
+
+    info->DRICloseScreen = NULL;
+
     switch (info->CurrentLayout.pixel_code) {
     case 8:
     case 15:
@@ -1350,121 +1460,6 @@
 	pDRIInfo = NULL;
 	return FALSE;
     }
-
-    /* Check the DRM lib version.
-     * drmGetLibVersion was not supported in version 1.0, so check for
-     * symbol first to avoid possible crash or hang.
-     */
-    if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
-	version = drmGetLibVersion(info->drmFD);
-    } else {
-	/* drmlib version 1.0.0 didn't have the drmGetLibVersion
-	 * entry point.  Fake it by allocating a version record
-	 * via drmGetVersion and changing it to version 1.0.0.
-	 */
-	version = drmGetVersion(info->drmFD);
-	version->version_major      = 1;
-	version->version_minor      = 0;
-	version->version_patchlevel = 0;
-    }
-
-    if (version) {
-	if (version->version_major != 1 ||
-	    version->version_minor < 1) {
-	    /* incompatible drm library version */
-	    xf86DrvMsg(pScreen->myNum, X_ERROR,
-		       "[dri] RADEONDRIScreenInit failed because of a "
-		       "version mismatch.\n"
-		       "[dri] libdrm.a module version is %d.%d.%d but "
-		       "version 1.1.x is needed.\n"
-		       "[dri] Disabling DRI.\n",
-		       version->version_major,
-		       version->version_minor,
-		       version->version_patchlevel);
-	    drmFreeVersion(version);
-	    RADEONDRICloseScreen(pScreen);
-	    return FALSE;
-	}
-	drmFreeVersion(version);
-    }
-
-    /* Check the radeon DRM version */
-    version = drmGetVersion(info->drmFD);
-    if (version) {
-	int req_minor, req_patch;
-
-	if (info->IsIGP) {
-	    req_minor = 10;
-	    req_patch = 0;
-       	} else if (info->ChipFamily >= CHIP_FAMILY_R300) {
-           req_minor = 17;
-           req_patch = 0;
-	} else if (info->ChipFamily >= CHIP_FAMILY_R200) {
-	    req_minor = 5;
-	    req_patch = 0;
-	} else {
-#if X_BYTE_ORDER == X_LITTLE_ENDIAN
-	    req_minor = 1;
-	    req_patch = 0;
-#else
-	    req_minor = 2;
-	    req_patch = 1;
-#endif
-	}
-
-	if (version->version_major != 1 ||
-	    version->version_minor < req_minor ||
-	    (version->version_minor == req_minor &&
-	     version->version_patchlevel < req_patch)) {
-	    /* Incompatible drm version */
-	    xf86DrvMsg(pScreen->myNum, X_ERROR,
-		       "[dri] RADEONDRIScreenInit failed because of a version "
-		       "mismatch.\n"
-		       "[dri] radeon.o kernel module version is %d.%d.%d "
-		       "but version 1.%d.%d or newer is needed.\n"
-		       "[dri] Disabling DRI.\n",
-		       version->version_major,
-		       version->version_minor,
-		       version->version_patchlevel,
-		       req_minor,
-		       req_patch);
-	    drmFreeVersion(version);
-	    RADEONDRICloseScreen(pScreen);
-	    return FALSE;
-	}
-
-	if (version->version_minor < 3) {
-	    xf86DrvMsg(pScreen->myNum, X_WARNING,
-		       "[dri] Some DRI features disabled because of version "
-		       "mismatch.\n"
-		       "[dri] radeon.o kernel module version is %d.%d.%d but "
-		       "1.3.1 or later is preferred.\n",
-		       version->version_major,
-		       version->version_minor,
-		       version->version_patchlevel);
-	}
-	info->drmMinor = version->version_minor;
-
-	if (info->allowColorTiling && version->version_minor < 14) {
-	    xf86DrvMsg(pScreen->myNum, X_WARNING,
-		       "[dri] color tiling disabled because of version "
-		       "mismatch.\n"
-		       "[dri] radeon.o kernel module version is %d.%d.%d but "
-		       "1.14.0 or later is required for color tiling.\n",
-		       version->version_major,
-		       version->version_minor,
-		       version->version_patchlevel);
-	   info->allowColorTiling = FALSE;
-	   info->tilingEnabled = FALSE;
-	   /* try to fix up already set mode, crt pitch, ddx major (hope that's ok to do here) */
-	   /* is this correct scrnIndex? flags? */
-	   RADEONSwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0);
-	   pScrn->AdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
-	   pDRIInfo->ddxDriverMajorVersion = RADEON_VERSION_MAJOR;
-	}
-	drmFreeVersion(version);
-    }
-
 				/* Initialize AGP */
     if (info->cardType==CARD_AGP && !RADEONDRIAgpInit(info, pScreen)) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
@@ -1516,6 +1511,17 @@
     return TRUE;
 }
 
+static Bool RADEONDRIDoCloseScreen(int scrnIndex, ScreenPtr pScreen)
+{
+    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
+    RADEONInfoPtr  info  = RADEONPTR(pScrn);
+
+    RADEONDRICloseScreen(pScreen);
+
+    pScreen->CloseScreen = info->DRICloseScreen;
+    return (*pScreen->CloseScreen)(scrnIndex, pScreen);
+}
+
 /* Finish initializing the device-dependent DRI state, and call
  * DRIFinishScreenInit() to complete the device-independent DRI
  * initialization.
@@ -1604,14 +1610,34 @@
     pRADEONDRI->perctx_sarea_size = info->perctx_sarea_size;
 #endif
 
-    /* Have shadowfb run only while there is 3d active. */
-    if (!info->useEXA && info->allowPageFlip /* && info->drmMinor >= 3 */) {
-	ShadowFBInit( pScreen, RADEONDRIRefreshArea );
+    info->directRenderingInited = TRUE;
+
+    /* Wrap CloseScreen */
+    info->DRICloseScreen = pScreen->CloseScreen;
+    pScreen->CloseScreen = RADEONDRIDoCloseScreen;
+
+    return TRUE;
+}
+
+void RADEONDRIInitPageFlip(ScreenPtr pScreen)
+{
+    ScrnInfoPtr         pScrn = xf86Screens[pScreen->myNum];
+    RADEONInfoPtr       info  = RADEONPTR(pScrn);
+
+   /* Have shadowfb run only while there is 3d active. This must happen late,
+     * after XAAInit has been called 
+     */
+    if (!info->useEXA) {
+	if (!ShadowFBInit( pScreen, RADEONDRIRefreshArea )) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		       "ShadowFB init failed, Page Flipping disabled\n");
+	    info->allowPageFlip = 0;
+	} else
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       "ShadowFB initialized for Page Flipping\n");
     } else {
        info->allowPageFlip = 0;
     }
-
-    return TRUE;
 }
 
 /**
@@ -1626,7 +1652,7 @@
     ScrnInfoPtr   pScrn   = xf86Screens[pScreen->myNum];
     RADEONInfoPtr info    = RADEONPTR(pScrn);
 
-    if (info->drmMinor >= 9) {
+    if (info->pKernelDRMVersion->version_minor >= 9) {
 	xf86DrvMsg(pScreen->myNum, X_INFO,
 		   "[RESUME] Attempting to re-init Radeon hardware.\n");
     } else {
@@ -1655,18 +1681,16 @@
     RADEONDRICPInit(pScrn);
 }
 
-/* The screen is being closed, so clean up any state and free any
- * resources used by the DRI.
- */
-void RADEONDRICloseScreen(ScreenPtr pScreen)
+void RADEONDRIStop(ScreenPtr pScreen)
 {
     ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
-    drmRadeonInit  drmInfo;
     RING_LOCALS;
 
-				/* Stop the CP */
-    if (info->directRenderingEnabled) {
+    RADEONTRACE(("RADEONDRIStop\n"));
+
+    /* Stop the CP */
+    if (info->directRenderingInited) {
 	/* If we've generated any CP commands, we must flush them to the
 	 * kernel module now.
 	 */
@@ -1679,26 +1703,39 @@
 	}
 	RADEONCP_STOP(pScrn, info);
     }
+    info->directRenderingInited = FALSE;
+}
+
+/* The screen is being closed, so clean up any state and free any
+ * resources used by the DRI.
+ */
+void RADEONDRICloseScreen(ScreenPtr pScreen)
+{
+    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
+    RADEONInfoPtr  info  = RADEONPTR(pScrn);
+    drmRadeonInit  drmInfo;
 
-    if (info->irq) {
+     RADEONTRACE(("RADEONDRICloseScreen\n"));
+    
+     if (info->irq) {
 	drmCtlUninstHandler(info->drmFD);
 	info->irq = 0;
 	info->ModeReg.gen_int_cntl = 0;
     }
 
-				/* De-allocate vertex buffers */
+    /* De-allocate vertex buffers */
     if (info->buffers) {
 	drmUnmapBufs(info->buffers);
 	info->buffers = NULL;
     }
 
-				/* De-allocate all kernel resources */
+    /* De-allocate all kernel resources */
     memset(&drmInfo, 0, sizeof(drmRadeonInit));
     drmInfo.func = DRM_RADEON_CLEANUP_CP;
     drmCommandWrite(info->drmFD, DRM_RADEON_CP_INIT,
 		    &drmInfo, sizeof(drmRadeonInit));
 
-				/* De-allocate all GART resources */
+    /* De-allocate all GART resources */
     if (info->gartTex) {
 	drmUnmap(info->gartTex, info->gartTexMapSize);
 	info->gartTex = NULL;
@@ -1726,10 +1763,10 @@
 	info->pciMemHandle = 0;
     }
 
-				/* De-allocate all DRI resources */
+    /* De-allocate all DRI resources */
     DRICloseScreen(pScreen);
 
-				/* De-allocate all DRI data structures */
+    /* De-allocate all DRI data structures */
     if (info->pDRIInfo) {
 	if (info->pDRIInfo->devPrivate) {
 	    xfree(info->pDRIInfo->devPrivate);
@@ -1748,7 +1785,6 @@
     }
 }
 
-
 /* Use callbacks from dri.c to support pageflipping mode for a single
  * 3d context without need for any specific full-screen extension.
  *
@@ -1775,6 +1811,9 @@
     int                 i;
     RADEONSAREAPrivPtr  pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
 
+    if (!info->directRenderingInited)
+	return;
+
     /* Don't want to do this when no 3d is active and pages are
      * right-way-round
      */
@@ -1784,6 +1823,10 @@
 #ifdef USE_XAA
     /* XXX: implement for EXA */
     /* pretty much a hack. */
+
+    /* Make sure accel has been properly inited */
+    if (info->accel == NULL || info->accel->SetupForScreenToScreenCopy == NULL)
+	return;
     if (info->tilingEnabled)
        info->dst_pitch_offset |= RADEON_DST_TILE_MACRO;
     (*info->accel->SetupForScreenToScreenCopy)(pScrn,
@@ -1987,7 +2030,8 @@
     ScrnInfoPtr        pScrn   = xf86Screens[pScreen->myNum];
     RADEONInfoPtr      info    = RADEONPTR(pScrn);
 
-    if (info->cardType!=CARD_PCIE || info->drmMinor<19)
+    if (info->cardType != CARD_PCIE ||
+	info->pKernelDRMVersion->version_minor < 19)
       return;
 
     if (info->FbSecureSize==0)
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_driver.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_driver.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_driver.c	2005-12-14 20:41:28.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_driver.c	2006-03-23 02:39:07.000000000 +0100
@@ -1,4 +1,5 @@
 /* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.117 2004/02/19 22:38:12 tsi Exp $ */
+/* $XdotOrg: driver/xf86-video-ati/src/radeon_driver.c,v 1.92.2.13 2006-03-23 01:39:07 benh Exp $ */
 /*
  * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
  *                VA Linux Systems Inc., Fremont, California.
@@ -90,7 +91,6 @@
 				/* X and server generic header files */
 #include "xf86.h"
 #include "xf86_OSproc.h"
-#include "xf86PciInfo.h"
 #include "xf86RAC.h"
 #include "xf86Resources.h"
 #include "xf86cmap.h"
@@ -105,6 +105,7 @@
 #define DPMS_SERVER
 #include <X11/extensions/dpms.h>
 
+#include "atipciids.h"
 #include "radeon_chipset.h"
 
 #ifndef MAX
@@ -129,6 +130,8 @@
 static int RADEONValidateMergeModes(ScrnInfoPtr pScrn);
 static void RADEONSetDynamicClock(ScrnInfoPtr pScrn, int mode);
 static void RADEONUpdatePanelSize(ScrnInfoPtr pScrn);
+static void RADEONSaveMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
+static void RADEONAdjustMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
 
 /* psuedo xinerama support */
 
@@ -153,6 +156,7 @@
     OPTION_PAGE_FLIP,
     OPTION_NO_BACKBUFFER,
     OPTION_XV_DMA,
+    OPTION_FBTEX_PERCENT,
 #endif
     OPTION_PANEL_OFF,
     OPTION_DDC_MODE,
@@ -215,6 +219,7 @@
     { OPTION_PAGE_FLIP,      "EnablePageFlip",   OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_NO_BACKBUFFER,  "NoBackBuffer",     OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_XV_DMA,         "DMAForXv",         OPTV_BOOLEAN, {0}, FALSE },
+    { OPTION_FBTEX_PERCENT,  "FBTexPercent",     OPTV_INTEGER, {0}, FALSE },
 #endif
     { OPTION_PANEL_OFF,      "PanelOff",         OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_DDC_MODE,       "DDCMode",          OPTV_BOOLEAN, {0}, FALSE },
@@ -519,6 +524,8 @@
     {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV350*/
     {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV380*/
     {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R420*/
+    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_RV410*/ /* FIXME: just values from r420 used... */
+    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS400*/ /* FIXME: just values from rv380 used... */
 };
 
 #ifdef XFree86LOADER
@@ -732,6 +739,7 @@
     if (info->FBDev) {
 	info->FB = fbdevHWMapVidmem(pScrn);
     } else {
+	RADEONTRACE(("Map: 0x%08x, 0x%08x\n", info->LinearAddr, info->FbMapSize));
 	info->FB = xf86MapPciMem(pScrn->scrnIndex,
 				 VIDMEM_FRAMEBUFFER,
 				 info->PciTag,
@@ -862,8 +870,14 @@
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
+    CARD32         crtc_gen_cntl;
     int            i;
 
+    crtc_gen_cntl = INREG(RADEON_CRTC_GEN_CNTL);
+    if ((crtc_gen_cntl & RADEON_CRTC_DISP_REQ_EN_B) ||
+	!(crtc_gen_cntl & RADEON_CRTC_EN))
+	return;
+
     /* Clear the CRTC_VBLANK_SAVE bit */
     OUTREG(RADEON_CRTC_STATUS, RADEON_CRTC_VBLANK_SAVE_CLEAR);
 
@@ -879,7 +893,13 @@
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
+    CARD32         crtc2_gen_cntl;
     int            i;
+ 
+    crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL);
+    if ((crtc2_gen_cntl & RADEON_CRTC2_DISP_REQ_EN_B) ||
+	!(crtc2_gen_cntl & RADEON_CRTC2_EN))
+	return;
 
     /* Clear the CRTC2_VBLANK_SAVE bit */
     OUTREG(RADEON_CRTC2_STATUS, RADEON_CRTC2_VBLANK_SAVE_CLEAR);
@@ -1697,7 +1717,7 @@
 		    "Video BIOS not detected, using default clock settings!\n");
 
        /* Default min/max PLL values */
-       if (info->ChipFamily == CHIP_FAMILY_R420) {
+       if (info->ChipFamily == CHIP_FAMILY_R420 || info->ChipFamily == CHIP_FAMILY_RV410) {
            pll->min_pll_freq = 20000;
            pll->max_pll_freq = 50000;
        } else {
@@ -1720,6 +1740,15 @@
         info->mclk = 200.00;
     }
 
+    if (info->ChipFamily == CHIP_FAMILY_RV100 && !info->HasCRTC2) {
+        /* Avoid RN50 corruption due to memory bandwidth starvation.
+         * 18 is an empirical value based on the databook and Windows driver.
+        */
+        pll->max_pll_freq = min(pll->max_pll_freq,
+                               18 * info->mclk * 100 / pScrn->bitsPerPixel *
+                               info->RamWidth / 16);
+    }
+
     xf86DrvMsg (pScrn->scrnIndex, X_INFO,
 		"PLL parameters: rf=%d rd=%d min=%ld max=%ld; xclk=%d\n",
 		pll->reference_freq,
@@ -2252,83 +2281,89 @@
     return TRUE;
 }
 
-/* Set up MC_FB_LOCATION and related registers */
-static void
-RADEONSetFBLocation(ScrnInfoPtr pScrn)
+static void RADEONInitMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
+				      RADEONInfoPtr info)
 {
-    RADEONInfoPtr  info = RADEONPTR(pScrn);
-    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
-    unsigned char *RADEONMMIO = info->MMIO;
-    CARD32 mc_fb_location;
-    CARD32 mc_agp_location = INREG(RADEON_MC_AGP_LOCATION);
-    CARD32 bus_cntl = INREG(RADEON_BUS_CNTL);
-    
-    OUTREG (RADEON_BUS_CNTL, bus_cntl | RADEON_BUS_MASTER_DIS);
-    RADEONWaitForIdleMMIO(pScrn);
-
-    /* This function has many problems with newer cards.
-     * Even with older cards, all registers changed here are not
-     * restored properly when X quits, this will also cause 
-     * various problems, especially with radeonfb.
-     * Since we don't have DRI support for R300 and above cards, 
-     * we just hardcode these values for now.
-     * Need to revisit this whole function!!!
-     */
+    save->mc_fb_location = info->mc_fb_location;
+    save->mc_agp_location = info->mc_agp_location;
+    save->display_base_addr = info->fbLocation;
+    save->display2_base_addr = info->fbLocation;
+    save->ov0_base_addr = info->fbLocation;
+}
 
-    if (info->IsIGP) {
-	mc_fb_location = INREG(RADEON_NB_TOM);
+static void RADEONInitMemoryMap(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr  info   = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+    unsigned long agp_size, agp_base, mem_size;
 
-	OUTREG(RADEON_GRPH2_BUFFER_CNTL,
-	       INREG(RADEON_GRPH2_BUFFER_CNTL) & ~0x7f0000);
+    /* Default to existing values */
+    info->mc_fb_location = INREG(RADEON_MC_FB_LOCATION);
+    info->mc_agp_location = INREG(RADEON_MC_AGP_LOCATION);
+
+    /* We shouldn't use info->videoRam here which might have been clipped
+     * but the real video RAM instead
+     */
+    mem_size = INREG(RADEON_CONFIG_MEMSIZE);
+    if (mem_size == 0)
+	    mem_size = 0x800000;
 
-    } else
 #ifdef XF86DRI
-    if ( info->directRenderingEnabled && info->drmMinor < 10 ) {
-	mc_fb_location = (INREG(RADEON_CONFIG_APER_SIZE) - 1) & 0xffff0000U;
-    } else
-#endif
-    {
-	CARD32 aper0_base = INREG(RADEON_CONFIG_APER_0_BASE);
-
-	mc_fb_location = (aper0_base >> 16)
-		       | ((aper0_base + (INREG(RADEON_CONFIG_APER_SIZE) - 1)
-			   ) & 0xffff0000U);
+    /* Apply memory map limitation if using an old DRI */
+    if (info->directRenderingEnabled && !info->newMemoryMap) {
+	    CARD32 aper_size = INREG(RADEON_CONFIG_APER_SIZE);
+	    if (aper_size < mem_size)
+		mem_size = aper_size;
     }
+#endif
 
-    info->fbLocation = (mc_fb_location & 0xffff) << 16;
-
-    if (((mc_agp_location & 0xffff) << 16) !=
-	((mc_fb_location & 0xffff0000U) + 0x10000)) {
-	mc_agp_location = mc_fb_location & 0xffff0000U;
-	mc_agp_location |= (mc_agp_location + 0x10000) >> 16;
-    }
-
-    RADEONWaitForIdleMMIO(pScrn);
-
-    OUTREG(RADEON_MC_FB_LOCATION, mc_fb_location);
-    OUTREG(RADEON_MC_AGP_LOCATION, mc_agp_location);
-    OUTREG(RADEON_DISPLAY_BASE_ADDR, info->fbLocation);
-    if (info->HasCRTC2)
-	OUTREG(RADEON_DISPLAY2_BASE_ADDR, info->fbLocation);
-    OUTREG(RADEON_OV0_BASE_ADDR, info->fbLocation);
-
-    OUTREG (RADEON_BUS_CNTL, bus_cntl);
-    RADEONWaitForIdleMMIO(pScrn);
-
-    /* Set display0/1 priority up on r3/4xx in the memory controller for 
-     * high res modes if the user specifies HIGH for displaypriority 
-     * option.
-     */
-    if ((info->DispPriority == 2) && IS_R300_VARIANT) {
-        CARD32 mc_init_misc_lat_timer = INREG(R300_MC_INIT_MISC_LAT_TIMER);
-	if (info->MergedFB || pRADEONEnt->HasSecondary) {
-	    mc_init_misc_lat_timer |= 0x1100; /* display 0 and 1 */
-	} else {
-	    mc_init_misc_lat_timer |= 0x0100; /* display 0 only */
-	}
-	OUTREG(R300_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
-    }
+    /* We won't try to change MC_FB_LOCATION when using fbdev */
+    if (!info->FBDev) {
+	if (info->IsIGP)
+	    info->mc_fb_location = INREG(RADEON_NB_TOM);
+	else
+#ifdef XF86DRI
+	/* Old DRI has restrictions on the memory map */
+	if ( info->directRenderingEnabled &&
+	     info->pKernelDRMVersion->version_minor < 10 )
+	    info->mc_fb_location = (mem_size - 1) & 0xffff0000U;
+	else
+#endif
+	{
+	    CARD32 aper0_base = INREG(RADEON_CONFIG_APER_0_BASE);
 
+	    /* Recent chips have an "issue" with the memory controller, the
+	     * location must be aligned to the size. We just align it down,
+	     * too bad if we walk over the top of system memory, we don't
+	     * use DMA without a remapped anyway.
+	     * Affected chips are rv280, all r3xx, and all r4xx, but not IGP
+	     */
+	    if (info->ChipFamily == CHIP_FAMILY_RV280 ||
+		info->ChipFamily == CHIP_FAMILY_R300 ||
+		info->ChipFamily == CHIP_FAMILY_R350 ||
+		info->ChipFamily == CHIP_FAMILY_RV350 ||
+		info->ChipFamily == CHIP_FAMILY_RV380 ||
+		info->ChipFamily == CHIP_FAMILY_R420 ||
+		info->ChipFamily == CHIP_FAMILY_RV410)
+		    aper0_base &= ~(mem_size - 1);
+
+	    info->mc_fb_location = (aper0_base >> 16) |
+		    ((aper0_base + mem_size - 1) & 0xffff0000U);
+	}
+    }
+    info->fbLocation = (info->mc_fb_location & 0xffff) << 16;
+   
+    /* Just disable the damn AGP apertures for now, it may be
+     * re-enabled later by the DRM
+     */
+    info->mc_agp_location = 0xffffffc0;
+
+    RADEONTRACE(("RADEONInitMemoryMap() : \n"));
+    RADEONTRACE(("  mem_size         : 0x%08lx\n", mem_size));
+    RADEONTRACE(("  agp_size         : 0x%08lx\n", agp_size));
+    RADEONTRACE(("  agp_base         : 0x%08lx\n", agp_base));
+    RADEONTRACE(("  MC_FB_LOCATION   : 0x%08lx\n", info->mc_fb_location));
+    RADEONTRACE(("  MC_AGP_LOCATION  : 0x%08lx\n", info->mc_agp_location));
 }
 
 static void RADEONGetVRamType(ScrnInfoPtr pScrn)
@@ -2357,6 +2392,10 @@
 	       (info->ChipFamily == CHIP_FAMILY_RS200)){
 	if (tmp & RV100_HALF_MODE) info->RamWidth = 32;
 	else info->RamWidth = 64;
+       if (!info->HasCRTC2) {
+           info->RamWidth /= 4;
+           info->IsDDR = TRUE;
+       }
     } else {
 	if (tmp & RADEON_MEM_NUM_CHANNELS_MASK) info->RamWidth = 128;
 	else info->RamWidth = 64;
@@ -2367,23 +2406,193 @@
      */
 }
 
+/*
+ * Depending on card genertation, chipset bugs, etc... the amount of vram
+ * accessible to the CPU can vary. This function is our best shot at figuring
+ * it out. Returns a value in KB.
+ */
+static CARD32 RADEONGetAccessibleVRAM(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr  info   = RADEONPTR(pScrn);
+    EntityInfoPtr  pEnt   = info->pEnt;
+    GDevPtr        dev    = pEnt->device;
+    MessageType    from;
+    unsigned char *RADEONMMIO = info->MMIO;
+    CARD32	   aper_size = INREG(RADEON_CONFIG_APER_SIZE) / 1024;
+
+#ifdef XF86DRI
+    /* If we use the DRI, we need to check if it's a version that has the
+     * bug of always cropping MC_FB_LOCATION to one aperture, in which case
+     * we need to limit the amount of accessible video memory
+     */
+    if (info->directRenderingEnabled &&
+	info->pKernelDRMVersion->version_minor < 23) {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "[dri] limiting video memory to one aperture of %dK\n",
+		   aper_size);
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "[dri] detected radeon kernel module version 1.%d but"
+		   " 1.23 or newer is required for full memory mapping.\n",
+		   info->pKernelDRMVersion->version_minor);
+	info->newMemoryMap = FALSE;
+	return aper_size;
+    }
+    info->newMemoryMap = TRUE;
+#endif /* XF86DRI */
+
+    /* Set HDP_APER_CNTL only on cards that are known not to be broken,
+     * that is has the 2nd generation multifunction PCI interface
+     */
+    if (info->ChipFamily == CHIP_FAMILY_RV280 ||
+	info->ChipFamily == CHIP_FAMILY_RV350 ||
+	info->ChipFamily == CHIP_FAMILY_RV380 ||
+	info->ChipFamily == CHIP_FAMILY_R420 ||
+	info->ChipFamily == CHIP_FAMILY_RV410) {
+	    OUTREGP (RADEON_HOST_PATH_CNTL, RADEON_HDP_APER_CNTL,
+		     ~RADEON_HDP_APER_CNTL);
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       "Generation 2 PCI interface, using max accessible memory\n");
+	    return aper_size * 2;
+    }
+
+    /* Older cards have all sorts of funny issues to deal with. First
+     * check if it's a multifunction card by reading the PCI config
+     * header type... Limit those to one aperture size
+     */
+    if (pciReadByte(info->PciTag, 0xe) & 0x80) {
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		   "Generation 1 PCI interface in multifunction mode"
+		   ", accessible memory limited to one aperture\n");
+	return aper_size;
+    }
+
+    /* Single function older card. We read HDP_APER_CNTL to see how the BIOS
+     * have set it up. We don't write this as it's broken on some ASICs but
+     * we expect the BIOS to have done the right thing (might be too optimistic...)
+     */
+    if (INREG(RADEON_HOST_PATH_CNTL) & RADEON_HDP_APER_CNTL)
+        return aper_size * 2;
+    
+    return aper_size;
+}
+
+static Bool RADEONPreInitVRAM(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr  info   = RADEONPTR(pScrn);
+    EntityInfoPtr  pEnt   = info->pEnt;
+    GDevPtr        dev    = pEnt->device;
+    unsigned char *RADEONMMIO = info->MMIO;
+    MessageType    from = X_PROBED;
+
+    if (info->FBDev)
+	pScrn->videoRam      = fbdevHWGetVidmem(pScrn) / 1024;
+    else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
+	     (info->ChipFamily == CHIP_FAMILY_RS200) ||
+	     (info->ChipFamily == CHIP_FAMILY_RS300)) {
+        CARD32 tom = INREG(RADEON_NB_TOM);
+
+	pScrn->videoRam = (((tom >> 16) -
+			    (tom & 0xffff) + 1) << 6);
+
+	OUTREG(RADEON_CONFIG_MEMSIZE, pScrn->videoRam * 1024);
+    } else {
+	CARD32 accessible;
+	CARD32 bar_size;
+
+	/* Read VRAM size from card */
+        pScrn->videoRam      = INREG(RADEON_CONFIG_MEMSIZE) / 1024;
+
+	/* Some production boards of m6 will return 0 if it's 8 MB */
+	if (pScrn->videoRam == 0) {
+	    pScrn->videoRam = 8192;
+	    OUTREG(RADEON_CONFIG_MEMSIZE, 0x800000);
+	}
+
+	/* Get accessible memory */
+	accessible = RADEONGetAccessibleVRAM(pScrn);
+
+	/* Crop it to the size of the PCI BAR */
+	bar_size = (1ul << info->PciInfo->size[0]) / 1024;
+	if (bar_size == 0)
+	    bar_size = 0x20000;
+	if (accessible > bar_size)
+	    accessible = bar_size;
+
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	       "Detected total video RAM=%dK, accessible=%dK "
+		   "(PCI BAR=%dK)\n",
+	       pScrn->videoRam, accessible, bar_size);
+	if (pScrn->videoRam > accessible)
+	    pScrn->videoRam = accessible;
+    }
+
+    info->MemCntl            = INREG(RADEON_SDRAM_MODE_REG);
+    info->BusCntl            = INREG(RADEON_BUS_CNTL);
+
+    RADEONGetVRamType(pScrn);
+
+    if (dev->videoRam) {
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		   "Video RAM override, using %d kB instead of %d kB\n",
+		   dev->videoRam,
+		   pScrn->videoRam);
+	from             = X_CONFIG;
+	pScrn->videoRam  = dev->videoRam;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, from,
+	       "Mapped VideoRAM: %d kByte (%d bit %s SDRAM)\n", pScrn->videoRam, info->RamWidth, info->IsDDR?"DDR":"SDR");
+
+    /* FIXME: For now, split FB into two equal sections. This should
+     * be able to be adjusted by user with a config option. */
+    if (info->IsPrimary) {
+        pScrn->videoRam /= 2;
+	info->MergedFB = FALSE;
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
+		"Using %dk of videoram for primary head\n",
+		pScrn->videoRam);
+    }
+
+    if (info->IsSecondary) {  
+        pScrn->videoRam /= 2;
+        info->LinearAddr += pScrn->videoRam * 1024;
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
+		"Using %dk of videoram for secondary head\n",
+		pScrn->videoRam);
+    }
+
+    pScrn->videoRam  &= ~1023;
+    info->FbMapSize  = pScrn->videoRam * 1024;
+
+    /* if the card is PCI Express reserve the last 32k for the gart table */
+#ifdef XF86DRI
+    if (info->cardType == CARD_PCIE && info->directRenderingEnabled)
+        info->FbSecureSize = RADEON_PCIGART_TABLE_SIZE;
+    else
+#endif
+	info->FbSecureSize = 0;
+
+    return TRUE;
+}
+
+
 /* This is called by RADEONPreInit to handle config file overrides for
  * things like chipset and memory regions.  Also determine memory size
  * and type.  If memory type ever needs an override, put it in this
  * routine.
  */
-static Bool RADEONPreInitConfig(ScrnInfoPtr pScrn)
+static Bool RADEONPreInitChipType(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info   = RADEONPTR(pScrn);
     EntityInfoPtr  pEnt   = info->pEnt;
     GDevPtr        dev    = pEnt->device;
-    MessageType    from;
     unsigned char *RADEONMMIO = info->MMIO;
+    MessageType    from = X_PROBED;
 #ifdef XF86DRI
     const char *s;
 #endif
 
-				/* Chipset */
+    /* Chipset */
     from = X_PROBED;
     if (dev->chipset && *dev->chipset) {
 	info->Chipset  = xf86StringToToken(RADEONChipsets, dev->chipset);
@@ -2423,10 +2632,11 @@
 	info->ChipFamily = CHIP_FAMILY_RV100;
 	break;
 
-    case PCI_CHIP_RV100_QY:
-    case PCI_CHIP_RV100_QZ:
     case PCI_CHIP_RN50_515E:  /* RN50 is based on the RV100 but 3D isn't guaranteed to work.  YMMV. */
     case PCI_CHIP_RN50_5969:
+        info->HasCRTC2 = FALSE;
+    case PCI_CHIP_RV100_QY:
+    case PCI_CHIP_RV100_QZ:
 	info->ChipFamily = CHIP_FAMILY_RV100;
 
 	/* DELL triple-head configuration. */
@@ -2554,6 +2764,7 @@
         break;
 
     case PCI_CHIP_RV380_3150:
+    case PCI_CHIP_RV380_3152:
     case PCI_CHIP_RV380_3154:
         info->IsMobility = TRUE;
     case PCI_CHIP_RV380_3E50:
@@ -2562,10 +2773,12 @@
         break;
 
     case PCI_CHIP_RV370_5460:
+    case PCI_CHIP_RV370_5462:
     case PCI_CHIP_RV370_5464:
         info->IsMobility = TRUE;
     case PCI_CHIP_RV370_5B60:
     case PCI_CHIP_RV370_5B62:
+    case PCI_CHIP_RV370_5B63:
     case PCI_CHIP_RV370_5B64:
     case PCI_CHIP_RV370_5B65:
         info->ChipFamily = CHIP_FAMILY_RV380;
@@ -2580,13 +2793,14 @@
     case PCI_CHIP_RC410_5A61:
     case PCI_CHIP_RS480_5954:
     case PCI_CHIP_RS482_5974:
-	info->ChipFamily = CHIP_FAMILY_RV380; /*CHIP_FAMILY_RS400*/
-	/*info->IsIGP = TRUE;*/ /* ??? */
+	info->ChipFamily = CHIP_FAMILY_RS400;
+	info->IsIGP = TRUE;
 	/*info->HasSingleDAC = TRUE;*/ /* ??? */
         break;
 
     case PCI_CHIP_RV410_564A:
     case PCI_CHIP_RV410_564B:
+    case PCI_CHIP_RV410_564F:
     case PCI_CHIP_RV410_5652:
     case PCI_CHIP_RV410_5653:
         info->IsMobility = TRUE;
@@ -2596,7 +2810,7 @@
     case PCI_CHIP_RV410_5E4D:
     case PCI_CHIP_RV410_5E4C:
     case PCI_CHIP_RV410_5E4F:
-        info->ChipFamily = CHIP_FAMILY_R420; /* CHIP_FAMILY_RV410*/
+        info->ChipFamily = CHIP_FAMILY_RV410;
         break;
 
     case PCI_CHIP_R420_JN:
@@ -2654,7 +2868,6 @@
 	info->HasCRTC2 = FALSE;
     }
 
-				/* Framebuffer */
 
     from               = X_PROBED;
     info->LinearAddr   = info->PciInfo->memBase[0] & 0xfe000000;
@@ -2691,36 +2904,6 @@
     }
 
 				/* Read registers used to determine options */
-    from                     = X_PROBED;
-    if (info->FBDev)
-	pScrn->videoRam      = fbdevHWGetVidmem(pScrn) / 1024;
-    else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
-	     (info->ChipFamily == CHIP_FAMILY_RS200) ||
-	     (info->ChipFamily == CHIP_FAMILY_RS300)) {
-        CARD32 tom = INREG(RADEON_NB_TOM);
-
-	pScrn->videoRam = (((tom >> 16) -
-			    (tom & 0xffff) + 1) << 6);
-
-	OUTREG(RADEON_CONFIG_MEMSIZE, pScrn->videoRam * 1024);
-    } else {
-        /* There are different HDP mapping schemes depending on single/multi funciton setting,
-         * chip family, HDP mode, and the generation of HDP mapping scheme.
-         * To make things simple, we only allow maximum 128M addressable FB. Anything more than
-         * 128M is configured as invisible FB to CPU that can only be accessed from chip side.
-         */
-        pScrn->videoRam      = INREG(RADEON_CONFIG_MEMSIZE) / 1024;
-        if (pScrn->videoRam > 128*1024) pScrn->videoRam = 128*1024;
-        if ((info->ChipFamily == CHIP_FAMILY_RV350) ||
-            (info->ChipFamily == CHIP_FAMILY_RV380) ||
-            (info->ChipFamily == CHIP_FAMILY_R420)) {
-	    OUTREGP (RADEON_HOST_PATH_CNTL, (1<<23), ~(1<<23));
-        }
-    }
-
-    /* Some production boards of m6 will return 0 if it's 8 MB */
-    if (pScrn->videoRam == 0) pScrn->videoRam = 8192;
-
     /* Check chip errata */
     info->ChipErrata = 0;
 
@@ -2738,46 +2921,6 @@
 	info->ChipFamily == CHIP_FAMILY_RS200)
 	    info->ChipErrata |= CHIP_ERRATA_PLL_DELAY;
 
-    info->MemCntl            = INREG(RADEON_SDRAM_MODE_REG);
-    info->BusCntl            = INREG(RADEON_BUS_CNTL);
-
-    RADEONGetVRamType(pScrn);
-
-    if (dev->videoRam) {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "Video RAM override, using %d kB instead of %d kB\n",
-		   dev->videoRam,
-		   pScrn->videoRam);
-	from             = X_CONFIG;
-	pScrn->videoRam  = dev->videoRam;
-    }
-
-    xf86DrvMsg(pScrn->scrnIndex, from,
-	       "VideoRAM: %d kByte (%d bit %s SDRAM)\n", pScrn->videoRam, info->RamWidth, info->IsDDR?"DDR":"SDR");
-
-    /* FIXME: For now, split FB into two equal sections. This should
-     * be able to be adjusted by user with a config option. */
-    if (info->IsPrimary) {
-        pScrn->videoRam /= 2;
-	info->MergedFB = FALSE;
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
-		"Using %dk of videoram for primary head\n",
-		pScrn->videoRam);
-    }
-
-    if (info->IsSecondary) {  
-        pScrn->videoRam /= 2;
-        info->LinearAddr += pScrn->videoRam * 1024;
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
-		"Using %dk of videoram for secondary head\n",
-		pScrn->videoRam);
-    }
-
-    pScrn->videoRam  &= ~1023;
-    info->FbMapSize  = pScrn->videoRam * 1024;
-
-    info->FbSecureSize = 0;
-
 #ifdef XF86DRI
 				/* AGP/PCI */
     /* Proper autodetection of an AGP capable device requires examining
@@ -2861,10 +3004,6 @@
 		       "Invalid BusType option, using detected type\n");
 	}
     }
-
-    /* if the card is PCI Express reserve the last 32k for the gart table */
-    if (info->cardType == CARD_PCIE)
-        info->FbSecureSize = RADEON_PCIGART_TABLE_SIZE;
 #endif
     xf86GetOptValBool(info->Options, OPTION_SHOWCACHE, &info->showCache);
     if (info->showCache)
@@ -4185,6 +4324,7 @@
 	        xfree(info->CRT2pScrn->monitor);
 	     }
              xfree(info->CRT2pScrn);
+	     info->CRT2pScrn = NULL;
 	  }
 	  pScrn->modes = info->CRT1Modes;
 	  info->CRT1Modes = NULL;
@@ -4338,6 +4478,44 @@
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     MessageType    from;
 
+    info->directRenderingEnabled = FALSE;
+    info->directRenderingInited = FALSE;
+    info->CPInUse = FALSE;
+    info->CPStarted = FALSE;
+    info->pLibDRMVersion = NULL;
+    info->pKernelDRMVersion = NULL;
+
+    if (xf86IsEntityShared(info->pEnt->index)) {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "Direct Rendering Disabled -- "
+		   "Dual-head configuration is not working with "
+		   "DRI at present.\n"
+		   "Please use the radeon MergedFB option if you "
+		   "want Dual-head with DRI.\n");
+	return FALSE;
+    }
+    if (info->IsSecondary)
+        return FALSE;
+
+    if (xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE)) {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "[dri] Acceleration disabled, not initializing the DRI\n");
+	return FALSE;
+    }
+
+    if (!RADEONDRIGetVersion(pScrn))
+	return FALSE;
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	       "[dri] Found DRI library version %d.%d.%d and kernel"
+	       " module version %d.%d.%d\n",
+	       info->pLibDRMVersion->version_major,
+	       info->pLibDRMVersion->version_minor,
+	       info->pLibDRMVersion->version_patchlevel,
+	       info->pKernelDRMVersion->version_major,
+	       info->pKernelDRMVersion->version_minor,
+	       info->pKernelDRMVersion->version_patchlevel);
+
     if (xf86ReturnOptValBool(info->Options, OPTION_CP_PIO, FALSE)) {
 	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forcing CP into PIO mode\n");
 	info->CPMode = RADEON_DEFAULT_CP_PIO_MODE;
@@ -4454,6 +4632,7 @@
 					      OPTION_NO_BACKBUFFER,
 					      FALSE);
 
+#ifdef XF86DRI
     if (info->noBackBuffer) {
 	info->allowPageFlip = 0;
     } else if (!xf86LoadSubModule(pScrn, "shadowfb")) {
@@ -4475,6 +4654,7 @@
 
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Page flipping %sabled\n",
 	       info->allowPageFlip ? "en" : "dis");
+#endif
 
     info->DMAForXv = TRUE;
     from = xf86GetOptValBool(info->Options, OPTION_XV_DMA, &info->DMAForXv)
@@ -4485,26 +4665,82 @@
 
     return TRUE;
 }
-#endif
+#endif /* XF86DRI */
 
-static Bool RADEONPreInitXv(ScrnInfoPtr pScrn)
+static void RADEONPreInitColorTiling(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
-    CARD16 mm_table;
-    CARD16 bios_header;
-    CARD16 pll_info_block;
-
-    /* Rescue MM_TABLE before VBIOS is freed */
-    info->MM_TABLE_valid = FALSE;
-    
-    if((info->VBIOS==NULL)||(info->VBIOS[0]!=0x55)||(info->VBIOS[1]!=0xaa)){
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Cannot access BIOS or it is not valid.\n"
-               "\t\tIf your card is TV-in capable you will need to specify options RageTheatreCrystal, RageTheatreTunerPort, \n"
-               "\t\tRageTheatreSVideoPort and TunerType in /etc/X11/xorg.conf.\n"
-               );
-       info->MM_TABLE_valid = FALSE;
-       return TRUE;
-       }
+
+    if (IS_R300_VARIANT) {
+        /* false by default on R3/4xx */
+        info->allowColorTiling = xf86ReturnOptValBool(info->Options,
+					        OPTION_COLOR_TILING, FALSE);
+	info->MaxSurfaceWidth = 3968; /* one would have thought 4096...*/
+	info->MaxLines = 4096;
+    } else {
+        info->allowColorTiling = xf86ReturnOptValBool(info->Options,
+						OPTION_COLOR_TILING, TRUE);
+	info->MaxSurfaceWidth = 2048;
+	info->MaxLines = 2048;
+    }
+
+    if (!info->allowColorTiling)
+	return;
+
+#ifdef XF86DRI
+    if (info->directRenderingEnabled &&
+	info->pKernelDRMVersion->version_minor < 14) {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "[dri] color tiling disabled because of version "
+		   "mismatch.\n"
+		   "[dri] radeon.o kernel module version is %d.%d.%d but "
+		   "1.14.0 or later is required for color tiling.\n",
+		   info->pKernelDRMVersion->version_major,
+		   info->pKernelDRMVersion->version_minor,
+		   info->pKernelDRMVersion->version_patchlevel);
+	   info->allowColorTiling = FALSE;
+	   return;	   
+    }
+#endif /* XF86DRI */
+
+    if ((info->allowColorTiling) && (info->IsSecondary)) {
+	/* can't have tiling on the 2nd head (as long as it can't use drm).
+	 * We'd never get the surface save/restore (vt switching) right...
+	 */
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Color tiling disabled for 2nd head\n");
+	info->allowColorTiling = FALSE;
+    }
+    else if ((info->allowColorTiling) && (info->FBDev)) {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "Color tiling not supported with UseFBDev option\n");
+	info->allowColorTiling = FALSE;
+    }
+    else if (info->allowColorTiling) {
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Color tiling enabled by default\n");
+    } else {
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Color tiling disabled\n");
+    }
+}
+
+
+static Bool RADEONPreInitXv(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr  info = RADEONPTR(pScrn);
+    CARD16 mm_table;
+    CARD16 bios_header;
+    CARD16 pll_info_block;
+
+    /* Rescue MM_TABLE before VBIOS is freed */
+    info->MM_TABLE_valid = FALSE;
+    
+    if((info->VBIOS==NULL)||(info->VBIOS[0]!=0x55)||(info->VBIOS[1]!=0xaa)){
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Cannot access BIOS or it is not valid.\n"
+               "\t\tIf your card is TV-in capable you will need to specify options RageTheatreCrystal, RageTheatreTunerPort, \n"
+               "\t\tRageTheatreSVideoPort and TunerType in /etc/X11/xorg.conf.\n"
+               );
+       info->MM_TABLE_valid = FALSE;
+       return TRUE;
+       }
 
     bios_header=info->VBIOS[0x48];
     bios_header+=(((int)info->VBIOS[0x49]+0)<<8);           
@@ -4847,38 +5083,20 @@
 
     RADEONPostInt10Check(pScrn, int10_save);
 
-    if (!RADEONPreInitConfig(pScrn))
+    if (!RADEONPreInitChipType(pScrn))
 	goto fail;
 
-    if (IS_R300_VARIANT) {
-        /* false by default on R3/4xx */
-        info->allowColorTiling = xf86ReturnOptValBool(info->Options,
-					        OPTION_COLOR_TILING, FALSE);
-	info->MaxSurfaceWidth = 3968; /* one would have thought 4096...*/
-	info->MaxLines = 4096;
-    } else {
-        info->allowColorTiling = xf86ReturnOptValBool(info->Options,
-						OPTION_COLOR_TILING, TRUE);
-	info->MaxSurfaceWidth = 2048;
-	info->MaxLines = 2048;
-    }
+#ifdef XF86DRI
+    /* PreInit DRI first of all since we need that for getting a proper
+     * memory map
+     */
+    info->directRenderingEnabled = RADEONPreInitDRI(pScrn);
+#endif
 
-    if ((info->allowColorTiling) && (info->IsSecondary)) {
-	/* can't have tiling on the 2nd head (as long as it can't use drm). We'd never
-	   get the surface save/restore (vt switching) right... */
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Color tiling disabled for 2nd head\n");
-	info->allowColorTiling = FALSE;
-    }
-    else if ((info->allowColorTiling) && (info->FBDev)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Color tiling not supported with UseFBDev option\n");
-	info->allowColorTiling = FALSE;
-    }
-    else if (info->allowColorTiling) {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Color tiling enabled by default\n");
-    } else {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Color tiling disabled\n");
-    }
+    if (!RADEONPreInitVRAM(pScrn))
+	goto fail;
+
+    RADEONPreInitColorTiling(pScrn);
 
     RADEONPreInitDDC(pScrn);
 
@@ -4901,13 +5119,9 @@
 
     if (!RADEONPreInitAccel(pScrn))              goto fail;
 
-#ifdef XF86DRI
-    if (!RADEONPreInitDRI(pScrn))                goto fail;
-#endif
-
     if (!RADEONPreInitXv(pScrn))                 goto fail;
 
-				/* Free the video bios (if applicable) */
+    /* Free the video bios (if applicable) */
     if (info->VBIOS) {
 	xfree(info->VBIOS);
 	info->VBIOS = NULL;
@@ -4968,7 +5182,7 @@
     unsigned char  r, g, b;
 
 #ifdef XF86DRI
-    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
+    if (info->CPStarted && pScrn->pScreen) DRILock(pScrn->pScreen, 0);
 #endif
 
     if (info->accelOn && pScrn->pScreen)
@@ -5083,7 +5297,7 @@
     }
 
 #ifdef XF86DRI
-    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
+    if (info->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
 #endif
 }
 
@@ -5095,7 +5309,7 @@
     RADEONInfoPtr  info    = RADEONPTR(pScrn);
 
 #ifdef XF86DRI
-    if (info->directRenderingEnabled) {
+    if (info->directRenderingInited) {
 	FLUSH_RING();
     }
 #endif
@@ -5128,6 +5342,7 @@
     int            depthSize;
     int            l;
     int            scanlines;
+    int            texsizerequest;
     BoxRec         MemBox;
     FBAreaPtr      fbarea;
 
@@ -5178,18 +5393,31 @@
     /* Try for front, back, depth, and three framebuffers worth of
      * pixmap cache.  Should be enough for a fullscreen background
      * image plus some leftovers.
-     */
+     * If the FBTexPercent option was used, try to achieve that percentage instead,
+     * but still have at least one pixmap buffer (get problems with xvideo/render
+     * otherwise probably), and never reserve more than 3 offscreen buffers as it's
+     * probably useless for XAA.
+     */
+    if (info->textureSize >= 0) {
+	texsizerequest = ((int)info->FbMapSize - 2 * bufferSize - depthSize
+			 - 2 * width_bytes - 16384 - info->FbSecureSize)
+	/* first divide, then multiply or we'll get an overflow (been there...) */
+			 / 100 * info->textureSize;
+    }
+    else {
+	texsizerequest = (int)info->FbMapSize / 2;
+    }
     info->textureSize = info->FbMapSize - info->FbSecureSize - 5 * bufferSize - depthSize;
 
-    /* If that gives us less than half the available memory, let's
+    /* If that gives us less than the requested memory, let's
      * be greedy and grab some more.  Sorry, I care more about 3D
      * performance than playing nicely, and you'll get around a full
      * framebuffer's worth of pixmap cache anyway.
      */
-    if (info->textureSize < (int)info->FbMapSize / 2) {
+    if (info->textureSize < texsizerequest) {
         info->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
     }
-    if (info->textureSize < (int)info->FbMapSize / 2) {
+    if (info->textureSize < texsizerequest) {
         info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
     }
 
@@ -5199,7 +5427,7 @@
      */
     if (info->textureSize < 0) {
 	info->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
- 	                    - 2 * width_bytes - 16384 - info->FbSecureSize;
+	                    - 2 * width_bytes - 16384 - info->FbSecureSize;
     }
 
     /* Check to see if there is more room available after the 8192nd
@@ -5448,13 +5676,8 @@
     RADEONTRACE(("RADEONScreenInit %x %d\n",
 		 pScrn->memPhysBase, pScrn->fbOffset));
 
-#ifdef XF86DRI
-				/* Turn off the CP for now. */
-    info->CPInUse      = FALSE;
-    info->CPStarted    = FALSE;
-    info->directRenderingEnabled = FALSE;
-#endif
     info->accelOn      = FALSE;
+    info->accel        = NULL;
     pScrn->fbOffset    = 0;
     if (info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
     if (!RADEONMapMem(pScrn)) return FALSE;
@@ -5476,13 +5699,6 @@
         }
     }
 
-#if 0
-    if (info->allowColorTiling && info->useEXA) {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "Color tiling not supported yet with EXA, disabling\n");
-	info->allowColorTiling = FALSE;
-    }
-#endif
     if (info->allowColorTiling && (pScrn->virtualX > info->MaxSurfaceWidth)) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Color tiling not supported with virtual x resolutions larger than %d, disabling\n",
@@ -5503,31 +5719,7 @@
 	}
     }
 
-    if (!info->IsSecondary) {
-	/* empty the surfaces */
-	unsigned char *RADEONMMIO = info->MMIO;
-	unsigned int i;
-	for (i = 0; i < 8; i++) {
-	    OUTREG(RADEON_SURFACE0_INFO + 16 * i, 0);
-	    OUTREG(RADEON_SURFACE0_LOWER_BOUND + 16 * i, 0);
-	    OUTREG(RADEON_SURFACE0_UPPER_BOUND + 16 * i, 0);
-	}
-    }
-
-    if (info->FBDev) {
-	unsigned char *RADEONMMIO = info->MMIO;
-
-	if (!fbdevHWModeInit(pScrn, pScrn->currentMode)) return FALSE;
-	info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);
-    } else {
-	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;
-    }
-
-    RADEONSaveScreen(pScreen, SCREEN_SAVER_ON);
-
-    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
-
-				/* Visual setup */
+    /* Visual setup */
     miClearVisualTypes();
     if (!miSetVisualTypes(pScrn->depth,
 			  miGetDefaultVisualMask(pScrn->depth),
@@ -5536,12 +5728,10 @@
     miSetPixmapDepths ();
 
 #ifdef XF86DRI
-				/* Setup DRI after visuals have been
-				   established, but before fbScreenInit is
-				   called.  fbScreenInit will eventually
-				   call the driver's InitGLXVisuals call
-				   back. */
-    {
+    /* Setup DRI after visuals have been established, but before fbScreenInit is
+     * called.  fbScreenInit will eventually call the driver's InitGLXVisuals
+     * call back. */
+    if (info->directRenderingEnabled) {
 	/* FIXME: When we move to dynamic allocation of back and depth
 	 * buffers, we will want to revisit the following check for 3
 	 * times the virtual size of the screen below.
@@ -5550,11 +5740,7 @@
 			    info->CurrentLayout.pixel_bytes);
 	int  maxy        = info->FbMapSize / width_bytes;
 
-	if (xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE)) {
-	    xf86DrvMsg(scrnIndex, X_WARNING,
-		       "Acceleration disabled, not initializing the DRI\n");
-	    info->directRenderingEnabled = FALSE;
-	} else if (maxy <= pScrn->virtualY * 3) {
+	if (maxy <= pScrn->virtualY * 3) {
 	    xf86DrvMsg(scrnIndex, X_ERROR,
 		       "Static buffer allocation failed.  Disabling DRI.\n");
 	    xf86DrvMsg(scrnIndex, X_ERROR,
@@ -5572,22 +5758,63 @@
 		      "\t*** This message has been last modified on 2005-08-07.\n\n"
 		      );
                info->directRenderingEnabled = RADEONDRIScreenInit(pScreen);
-	} else if (info->IsSecondary) {
-	    info->directRenderingEnabled = FALSE;
-	} else if (xf86IsEntityShared(info->pEnt->index)) {
-	    /* Xinerama has sync problem with DRI, disable it for now */
-	    info->directRenderingEnabled = FALSE;
-	    xf86DrvMsg(scrnIndex, X_WARNING,
-			"Direct Rendering Disabled -- "
-			"Dual-head configuration is not working with "
-			"DRI at present.\n"
-			"Please use the radeon MergedFB option if you "
-			"want Dual-head with DRI.\n");
 	} else {
 	    info->directRenderingEnabled = RADEONDRIScreenInit(pScreen);
 	}
     }
 
+    /* Tell DRI about new memory map */
+    if (info->directRenderingEnabled && info->newMemoryMap) {
+	drmRadeonSetParam  radeonsetparam;
+	RADEONTRACE(("DRI New memory map param\n"));
+	memset(&radeonsetparam, 0, sizeof(drmRadeonSetParam));
+	radeonsetparam.param = RADEON_SETPARAM_NEW_MEMMAP;
+	radeonsetparam.value = 1;
+	if (drmCommandWrite(info->drmFD, DRM_RADEON_SETPARAM,
+			    &radeonsetparam, sizeof(drmRadeonSetParam)) < 0) {
+		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			   "[drm] failed to enable new memory map\n");
+		RADEONDRICloseScreen(pScreen);
+		info->directRenderingEnabled = FALSE;		
+	}
+    }
+
+    hasDRI = info->directRenderingEnabled;
+#endif /* XF86DRI */
+
+    /* Initialize the memory map, this basically calculates the values
+     * we'll use later on for MC_FB_LOCATION & MC_AGP_LOCATION
+     */
+    RADEONInitMemoryMap(pScrn);
+
+    if (!info->IsSecondary) {
+	/* empty the surfaces */
+	unsigned char *RADEONMMIO = info->MMIO;
+	unsigned int i;
+	for (i = 0; i < 8; i++) {
+	    OUTREG(RADEON_SURFACE0_INFO + 16 * i, 0);
+	    OUTREG(RADEON_SURFACE0_LOWER_BOUND + 16 * i, 0);
+	    OUTREG(RADEON_SURFACE0_UPPER_BOUND + 16 * i, 0);
+	}
+    }
+
+    if (info->FBDev) {
+	unsigned char *RADEONMMIO = info->MMIO;
+
+	if (!fbdevHWModeInit(pScrn, pScrn->currentMode)) return FALSE;
+	RADEONSaveMemMapRegisters(pScrn, &info->ModeReg);
+	info->fbLocation = (info->ModeReg.mc_fb_location & 0xffff) << 16;
+	info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);
+	info->ModeReg.surface_cntl &= ~RADEON_SURF_TRANSLATION_DIS;
+    } else {
+	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;
+    }
+
+    RADEONSaveScreen(pScreen, SCREEN_SAVER_ON);
+
+    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+
+#ifdef XF86DRI
     /* Depth moves are disabled by default since they are extremely slow */
     info->depthMoves = xf86ReturnOptValBool(info->Options,
 						 OPTION_DEPTH_MOVE, FALSE);
@@ -5601,12 +5828,17 @@
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Depth moves disabled by default\n");
     }
-
-    hasDRI = info->directRenderingEnabled;
 #endif
 
-    RADEONSetFBLocation(pScrn);
+    /* Initial setup of surfaces */
+    if (!info->IsSecondary) {
+	RADEONTRACE(("Setting up initial surfaces\n"));
+	RADEONChangeSurfaces(pScrn);
+    }
 
+    RADEONTRACE(("Initializing fb layer\n"));
+
+    /* Init fb layer */
     if (!fbScreenInit(pScreen, info->FB,
 		      pScrn->virtualX, pScrn->virtualY,
 		      pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
@@ -5653,14 +5885,49 @@
     }
 #endif
 				/* Memory manager setup */
+
+    RADEONTRACE(("Setting up accel memmap\n"));
+
 #ifdef USE_EXA
-    if (info->useEXA && !RADEONSetupMemEXA(pScreen))
-	return FALSE;
+    if (info->useEXA) {
+#ifdef XF86DRI
+	/* Reserve approx. half of offscreen memory for local textures by
+	 * default, can be overridden with Option "FBTexPercent".
+	 * Round down to a whole number of texture regions.
+	 */
+	info->textureSize = 50;
+
+	if (xf86GetOptValInteger(info->Options, OPTION_FBTEX_PERCENT,
+				 &(info->textureSize))) {
+	    if (info->textureSize < 0 || info->textureSize > 100) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			   "Illegal texture memory percentage: %dx, setting to default 50%\n",
+			   info->textureSize);
+		info->textureSize = 50;
+	    }
+	}
+#endif /* XF86DRI */
+
+	if (!RADEONSetupMemEXA(pScreen))
+	    return FALSE;
+    }
 #endif
 
 #if defined(XF86DRI) && defined(USE_XAA)
-    if (!info->useEXA && hasDRI && !RADEONSetupMemXAA_DRI(scrnIndex, pScreen))
-	return FALSE;
+    if (!info->useEXA && hasDRI) {
+	info->textureSize = -1;
+	if (xf86GetOptValInteger(info->Options, OPTION_FBTEX_PERCENT,
+				 &(info->textureSize))) {
+	    if (info->textureSize < 0 || info->textureSize > 100) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			   "Illegal texture memory percentage: %dx, using default behaviour\n",
+			   info->textureSize);
+		info->textureSize = -1;
+	    }
+	}
+	if (!RADEONSetupMemXAA_DRI(scrnIndex, pScreen))
+	    return FALSE;
+    }
 #endif
 
 #ifdef USE_XAA
@@ -5671,8 +5938,73 @@
     info->dst_pitch_offset = (((pScrn->displayWidth * info->CurrentLayout.pixel_bytes / 64)
 			       << 22) | ((info->fbLocation + pScrn->fbOffset) >> 10));
 
-    /* Acceleration setup */
+    /* Backing store setup */
+    RADEONTRACE(("Initializing backing store\n"));
+    miInitializeBackingStore(pScreen);
+    xf86SetBackingStore(pScreen);
+
+    /* DRI finalisation */
+#ifdef XF86DRI
+    if (info->directRenderingEnabled && info->cardType==CARD_PCIE &&
+	info->pciGartOffset && info->pKernelDRMVersion->version_minor >= 19)
+    {
+      drmRadeonSetParam  radeonsetparam;
+      RADEONTRACE(("DRI PCIGART param\n"));
+      memset(&radeonsetparam, 0, sizeof(drmRadeonSetParam));
+      radeonsetparam.param = RADEON_SETPARAM_PCIGART_LOCATION;
+      radeonsetparam.value = info->pciGartOffset;
+      if (drmCommandWrite(info->drmFD, DRM_RADEON_SETPARAM,
+			  &radeonsetparam, sizeof(drmRadeonSetParam)) < 0)
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "[drm] failed set pci gart location\n");
+    }
+    if (info->directRenderingEnabled) {
+        RADEONTRACE(("DRI Finishing init !\n"));
+	info->directRenderingEnabled = RADEONDRIFinishScreenInit(pScreen);
+    }
+    if (info->directRenderingEnabled) {
+	/* DRI final init might have changed the memory map, we need to adjust
+	 * our local image to make sure we restore them properly on mode
+	 * changes or VT switches
+	 */
+	RADEONAdjustMemMapRegisters(pScrn, &info->ModeReg);
+
+	if ((info->DispPriority == 1) && (info->cardType==CARD_AGP)) {
+	    /* we need to re-calculate bandwidth because of AGPMode difference. */ 
+	    RADEONInitDispBandwidth(pScrn);
+	}
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
+
+	/* we might already be in tiled mode, tell drm about it */
+	if (info->directRenderingEnabled && info->tilingEnabled) {
+	    drmRadeonSetParam  radeonsetparam;
+	    memset(&radeonsetparam, 0, sizeof(drmRadeonSetParam));
+	    radeonsetparam.param = RADEON_SETPARAM_SWITCH_TILING;
+	    radeonsetparam.value = info->tilingEnabled ? 1 : 0; 
+	    if (drmCommandWrite(info->drmFD, DRM_RADEON_SETPARAM,
+		&radeonsetparam, sizeof(drmRadeonSetParam)) < 0)
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		    "[drm] failed changing tiling status\n");
+	}
+    } else {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
+		   "Direct rendering disabled\n");
+    }
+#endif
+
+    /* Make sure surfaces are allright since DRI setup may have changed them */
+    if (!info->IsSecondary) {
+	RADEONTRACE(("Setting up final surfaces\n"));
+	RADEONChangeSurfaces(pScrn);
+    }
+
+    if(info->MergedFB)
+	/* need this here to fix up sarea values */
+	RADEONAdjustFrameMerged(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+
+    /* Enable aceleration */
     if (!xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE)) {
+	 RADEONTRACE(("Initializing Acceleration\n"));
 	if (RADEONAccelInit(pScreen)) {
 	    xf86DrvMsg(scrnIndex, X_INFO, "Acceleration enabled\n");
 	    info->accelOn = TRUE;
@@ -5687,12 +6019,19 @@
 	info->accelOn = FALSE;
     }
 
-    /* DGA setup */
-    RADEONDGAInit(pScreen);
+#ifdef XF86DRI
+    /* Init page flipping if enabled now */
+    if (info->allowPageFlip) {
+	RADEONTRACE(("Initializing Page Flipping\n"));
+	RADEONDRIInitPageFlip(pScreen);
+    }
+#endif
 
-    /* Backing store setup */
-    miInitializeBackingStore(pScreen);
-    xf86SetBackingStore(pScreen);
+    /* Init DPMS */
+    RADEONTRACE(("Initializing DPMS\n"));
+    xf86DPMSInit(pScreen, RADEONDisplayPowerManagementSet, 0);
+
+    RADEONTRACE(("Initializing Cursor\n"));
 
     /* Set Silken Mouse */
     xf86SetSilkenMouse(pScreen);
@@ -5729,7 +6068,8 @@
 	xf86DrvMsg(scrnIndex, X_INFO, "Using software cursor\n");
     }
 
-				/* Colormap setup */
+    /* Colormap setup */
+    RADEONTRACE(("Initializing color map\n"));
     if (!miCreateDefColormap(pScreen)) return FALSE;
     if (!xf86HandleColormaps(pScreen, 256, info->dac6bits ? 6 : 8,
 			     RADEONLoadPalette, NULL,
@@ -5739,17 +6079,9 @@
 #endif
 			     | CMAP_RELOAD_ON_MODE_SWITCH)) return FALSE;
 
-				/* DPMS setup */
-    xf86DPMSInit(pScreen, RADEONDisplayPowerManagementSet, 0);
-
-    RADEONInitVideo(pScreen);
-
-				/* Provide SaveScreen */
-    pScreen->SaveScreen  = RADEONSaveScreen;
-
-				/* Wrap CloseScreen */
-    info->CloseScreen    = pScreen->CloseScreen;
-    pScreen->CloseScreen = RADEONCloseScreen;
+    /* DGA setup */
+    RADEONTRACE(("Initializing DGA\n"));
+    RADEONDGAInit(pScreen);
 
     /* Wrap some funcs for MergedFB */
     if(info->MergedFB) {
@@ -5764,80 +6096,219 @@
        }
     }
 
-				/* Note unused options */
+    /* Init Xv */
+    RADEONTRACE(("Initializing Xv\n"));
+    RADEONInitVideo(pScreen);
+
+    if(info->MergedFB)
+	/* need this here to fix up sarea values */
+	RADEONAdjustFrameMerged(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+
+    /* Provide SaveScreen & wrap BlockHandler and CloseScreen */
+    /* Wrap CloseScreen */
+    info->CloseScreen    = pScreen->CloseScreen;
+    pScreen->CloseScreen = RADEONCloseScreen;
+    pScreen->SaveScreen  = RADEONSaveScreen;
+    info->BlockHandler = pScreen->BlockHandler;
+    pScreen->BlockHandler = RADEONBlockHandler;
+
+    /* Note unused options */
     if (serverGeneration == 1)
 	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
 
-#ifdef XF86DRI
-    if (info->cardType==CARD_PCIE && info->pciGartOffset && info->drmMinor>=19)
-    {
-      drmRadeonSetParam  radeonsetparam;
-      memset(&radeonsetparam, 0, sizeof(drmRadeonSetParam));
-      radeonsetparam.param = RADEON_SETPARAM_PCIGART_LOCATION;
-      radeonsetparam.value = info->pciGartOffset;
-      if (drmCommandWrite(info->drmFD, DRM_RADEON_SETPARAM,
-			  &radeonsetparam, sizeof(drmRadeonSetParam)) < 0)
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "[drm] failed set pci gart location\n");
-    }
+    RADEONTRACE(("RADEONScreenInit finished\n"));
 
-      /* DRI finalization */
-    if (info->directRenderingEnabled) {
-				/* Now that mi, fb, drm and others have
-				   done their thing, complete the DRI
-				   setup. */
-	if (!(info->directRenderingEnabled = RADEONDRIFinishScreenInit(pScreen))) {
-#ifdef USE_EXA
-	    if (info->useEXA) {
-		RADEONDrawInitMMIO(pScreen);
+    return TRUE;
+}
+
+/* Write memory mapping registers */
+static void RADEONRestoreMemMapRegisters(ScrnInfoPtr pScrn,
+					 RADEONSavePtr restore)
+{
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+    int i, timeout;
+
+    RADEONTRACE(("RADEONRestoreMemMapRegisters() : \n"));
+    RADEONTRACE(("  MC_FB_LOCATION   : 0x%08lx\n", restore->mc_fb_location));
+    RADEONTRACE(("  MC_AGP_LOCATION  : 0x%08lx\n", restore->mc_agp_location));
+
+    /* Write memory mapping registers only if their value change
+     * since we must ensure no access is done while they are
+     * reprogrammed
+     */
+    if (INREG(RADEON_MC_FB_LOCATION) != restore->mc_fb_location ||
+	INREG(RADEON_MC_AGP_LOCATION) != restore->mc_agp_location) {
+	CARD32 crtc_ext_cntl, crtc_gen_cntl, crtc2_gen_cntl=0, ov0_scale_cntl;
+	CARD32 old_mc_status, status_idle;
+
+	RADEONTRACE(("  Map Changed ! Applying ...\n"));
+
+	/* Make sure engine is idle. We assume the CCE is stopped
+	 * at this point
+	 */
+	RADEONWaitForIdleMMIO(pScrn);
+
+	if (info->IsIGP)
+		goto igp_no_mcfb;
+
+	/* Capture MC_STATUS in case things go wrong ... */
+	old_mc_status = INREG(RADEON_MC_STATUS);
+
+	/* Stop display & memory access */
+	ov0_scale_cntl = INREG(RADEON_OV0_SCALE_CNTL);
+	OUTREG(RADEON_OV0_SCALE_CNTL, ov0_scale_cntl & ~RADEON_SCALER_ENABLE);
+	crtc_ext_cntl = INREG(RADEON_CRTC_EXT_CNTL);
+	OUTREG(RADEON_CRTC_EXT_CNTL, crtc_ext_cntl | RADEON_CRTC_DISPLAY_DIS);
+	crtc_gen_cntl = INREG(RADEON_CRTC_GEN_CNTL);
+	RADEONWaitForVerticalSync(pScrn);
+	OUTREG(RADEON_CRTC_GEN_CNTL,
+	       (crtc_gen_cntl
+		& ~(RADEON_CRTC_CUR_EN | RADEON_CRTC_ICON_EN))
+	       | RADEON_CRTC_DISP_REQ_EN_B | RADEON_CRTC_EXT_DISP_EN);
+
+ 	if (info->HasCRTC2) {
+	    crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL);
+	    RADEONWaitForVerticalSync2(pScrn);
+	    OUTREG(RADEON_CRTC2_GEN_CNTL,
+		   (crtc2_gen_cntl
+		    & ~(RADEON_CRTC2_CUR_EN | RADEON_CRTC2_ICON_EN))
+		   | RADEON_CRTC2_DISP_REQ_EN_B);
+	}
+
+ 	/* Make sure the chip settles down (paranoid !) */ 
+ 	usleep(100000);
+
+	/* Wait for MC idle */
+	if (IS_R300_VARIANT)
+	    status_idle = R300_MC_IDLE;
+	else
+	    status_idle = RADEON_MC_IDLE;
+
+	timeout = 0;
+	while (!(INREG(RADEON_MC_STATUS) & status_idle)) {
+	    if (++timeout > 1000000) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		    "Timeout trying to update memory controller settings !\n");
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		    "MC_STATUS = 0x%08x (on entry = 0x%08x)\n",
+		    INREG(RADEON_MC_STATUS), old_mc_status);
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		    "You will probably crash now ... \n");
+		/* Nothing we can do except maybe try to kill the server,
+		 * let's wait 2 seconds to leave the above message a chance
+		 * to maybe hit the disk and continue trying to setup despite
+		 * the MC being non-idle
+		 */
+		usleep(2000000);
 	    }
-#endif /* USE_EXA */
-#ifdef USE_XAA
-	    if (!info->useEXA)
-		RADEONAccelInitMMIO(pScreen, info->accel);
-#endif /* USE_XAA */
+	    usleep(10);
 	}
+
+	/* Update maps, first clearing out AGP to make sure we don't get
+	 * a temporary overlap
+	 */
+ 	OUTREG(RADEON_MC_AGP_LOCATION, 0xfffffffc);
+	OUTREG(RADEON_MC_FB_LOCATION, restore->mc_fb_location);
+    igp_no_mcfb:
+ 	OUTREG(RADEON_MC_AGP_LOCATION, restore->mc_agp_location);
+	/* Make sure map fully reached the chip */
+	(void)INREG(RADEON_MC_FB_LOCATION);
+
+	RADEONTRACE(("  Map applied, resetting engine ...\n"));
+
+	/* Reset the engine and HDP */
+	RADEONEngineReset(pScrn);
+
+	RADEONTRACE(("  All done.\n"));
     }
-    if (info->directRenderingEnabled) {
-	if ((info->DispPriority == 1) && (info->cardType==CARD_AGP)) {
-	    /* we need to re-calculate bandwidth because of AGPMode difference. */ 
-	    RADEONInitDispBandwidth(pScrn);
-	}
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
 
-	/* we might already be in tiled mode, tell drm about it */
-	if (info->directRenderingEnabled && info->tilingEnabled) {
-	    drmRadeonSetParam  radeonsetparam;
-	    memset(&radeonsetparam, 0, sizeof(drmRadeonSetParam));
-	    radeonsetparam.param = RADEON_SETPARAM_SWITCH_TILING;
-	    radeonsetparam.value = info->tilingEnabled ? 1 : 0; 
-	    if (drmCommandWrite(info->drmFD, DRM_RADEON_SETPARAM,
-		&radeonsetparam, sizeof(drmRadeonSetParam)) < 0)
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		    "[drm] failed changing tiling status\n");
+    RADEONTRACE(("Updating base addresses...\n"));
+
+    /* Make sure we have sane offsets before enabling, disable
+     * stereo and wait for offsets to catch up with hw
+     */
+    OUTREG(RADEON_CRTC_OFFSET_CNTL, RADEON_CRTC_OFFSET_FLIP_CNTL);
+    OUTREG(RADEON_CRTC_OFFSET, 0);
+    OUTREG(RADEON_CRTC_OFFSET_CNTL, 0);
+    OUTREG(RADEON_CUR_OFFSET, 0);
+    timeout = 0;
+    while(INREG(RADEON_CRTC_OFFSET) & RADEON_CRTC_OFFSET__GUI_TRIG_OFFSET) {
+        if (timeout++ > 1000000) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+	       "Timeout waiting for CRTC offset to update !\n");
+	    break;
 	}
+	usleep(1000);
+    }
+    OUTREG(RADEON_DISPLAY_BASE_ADDR, restore->display_base_addr);
 
-    } else {
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
-		   "Direct rendering disabled\n");
+    if (info->HasCRTC2) {
+        /* Make sure we have sane offsets before enabling, disable
+	 * stereo and wait for offsets to catch up with hw
+	 */
+        OUTREG(RADEON_CRTC2_OFFSET_CNTL, RADEON_CRTC2_OFFSET_FLIP_CNTL);
+	OUTREG(RADEON_CRTC2_OFFSET, 0);
+	OUTREG(RADEON_CRTC2_OFFSET_CNTL, 0);
+	OUTREG(RADEON_CUR2_OFFSET, 0);
+	timeout = 0;
+	while(INREG(RADEON_CRTC2_OFFSET) & RADEON_CRTC2_OFFSET__GUI_TRIG_OFFSET) {
+	    if (timeout++ > 1000000) {
+	        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		  "Timeout waiting for CRTC2 offset to update !\n");
+		break;
+	    }
+	    usleep(1000);
+	}
+        OUTREG(RADEON_DISPLAY2_BASE_ADDR, restore->display2_base_addr);
     }
-#endif
 
-    if (!info->IsSecondary)
-	RADEONChangeSurfaces(pScrn);
+    OUTREG(RADEON_OV0_BASE_ADDR, restore->ov0_base_addr);
+    (void)INREG(RADEON_OV0_BASE_ADDR);
 
-    if(info->MergedFB) {
-	/* need this here to fix up sarea values */
-	RADEONAdjustFrameMerged(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
-    }
+    /* More paranoia delays, wait 100ms */
+    usleep(100000);
 
-    info->BlockHandler = pScreen->BlockHandler;
-    pScreen->BlockHandler = RADEONBlockHandler;
+    RADEONTRACE(("Done updating base addresses.\n"));
+ }
 
-    return TRUE;
+static void RADEONAdjustMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
+{
+    RADEONInfoPtr  info   = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+    CARD32 fb, agp;
+    int fb_loc_changed;
+
+    fb = INREG(RADEON_MC_FB_LOCATION);
+    agp = INREG(RADEON_MC_AGP_LOCATION);
+    fb_loc_changed = (fb != info->mc_fb_location);
+
+    if (fb_loc_changed || agp != info->mc_agp_location) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "DRI init changed memory map, adjusting ...\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "  MC_FB_LOCATION  was: 0x%08lx is: 0x%08lx\n",
+		       info->mc_fb_location, fb);
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "  MC_AGP_LOCATION was: 0x%08lx is: 0x%08lx\n",
+		       info->mc_agp_location, agp);
+	    info->mc_fb_location = fb;
+	    info->mc_agp_location = agp;
+	    info->fbLocation = (save->mc_fb_location & 0xffff) << 16;
+	    info->dst_pitch_offset =
+		    (((pScrn->displayWidth * info->CurrentLayout.pixel_bytes / 64)
+		      << 22) | ((info->fbLocation + pScrn->fbOffset) >> 10));
+
+
+	    RADEONInitMemMapRegisters(pScrn, save, info);
+
+	    /* If MC_FB_LOCATION was changed, adjust the various offsets */
+	    if (fb_loc_changed)
+		    RADEONRestoreMemMapRegisters(pScrn, save);
+    }
 }
 
-/* Write common registers (initialized to 0) */
+/* Write common registers */
 static void RADEONRestoreCommonRegisters(ScrnInfoPtr pScrn,
 					 RADEONSavePtr restore)
 {
@@ -5908,7 +6379,14 @@
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
 
-    OUTREG(RADEON_CRTC_GEN_CNTL, restore->crtc_gen_cntl);
+    RADEONTRACE(("Programming CRTC1, offset: 0x%08x\n",
+		 restore->crtc_offset));
+
+    /* We prevent the CRTC from hitting the memory controller until
+     * fully programmed
+     */
+    OUTREG(RADEON_CRTC_GEN_CNTL, restore->crtc_gen_cntl |
+	   RADEON_CRTC_DISP_REQ_EN_B);
 
     OUTREGP(RADEON_CRTC_EXT_CNTL,
 	    restore->crtc_ext_cntl,
@@ -5937,6 +6415,8 @@
 	OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);
 	OUTREG(RADEON_CRTC2_GEN_CNTL, restore->crtc2_gen_cntl);
     }
+
+    OUTREG(RADEON_CRTC_GEN_CNTL, restore->crtc_gen_cntl);
 }
 
 /* Write CRTC2 registers */
@@ -5945,12 +6425,22 @@
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
+    CARD32	   crtc2_gen_cntl;
 
-    OUTREGP(RADEON_CRTC2_GEN_CNTL,
-	    restore->crtc2_gen_cntl,
-	    RADEON_CRTC2_VSYNC_DIS |
-	    RADEON_CRTC2_HSYNC_DIS |
-	    RADEON_CRTC2_DISP_DIS);
+    RADEONTRACE(("Programming CRTC2, offset: 0x%08x\n",
+		 restore->crtc2_offset));
+
+    crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL) &
+	    (RADEON_CRTC2_VSYNC_DIS |
+	     RADEON_CRTC2_HSYNC_DIS |
+	     RADEON_CRTC2_DISP_DIS);
+    crtc2_gen_cntl |= restore->crtc2_gen_cntl;
+
+    /* We prevent the CRTC from hitting the memory controller until
+     * fully programmed
+     */
+    OUTREG(RADEON_CRTC2_GEN_CNTL,
+	   crtc2_gen_cntl | RADEON_CRTC2_DISP_REQ_EN_B);
 
     OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);
 
@@ -5977,6 +6467,9 @@
 	OUTREG(RADEON_FP_V2_SYNC_STRT_WID, restore->fp2_v_sync_strt_wid);
 	OUTREG(RADEON_FP2_GEN_CNTL,        restore->fp2_gen_cntl);
     }
+
+    OUTREG(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);
+
 #if 0
     /* Hack for restoring text mode -- fixed elsewhere */
     usleep(100000);
@@ -6255,6 +6748,35 @@
 	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));
 }
 
+
+/* restore original surface info (for fb console). */
+static void RADEONRestoreSurfaces(ScrnInfoPtr pScrn, RADEONSavePtr restore)
+{
+    RADEONInfoPtr      info = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+    unsigned int surfnr;
+    
+    for ( surfnr = 0; surfnr < 8; surfnr++ ) {
+	OUTREG(RADEON_SURFACE0_INFO + 16 * surfnr, restore->surfaces[surfnr][0]);
+	OUTREG(RADEON_SURFACE0_LOWER_BOUND + 16 * surfnr, restore->surfaces[surfnr][1]);
+	OUTREG(RADEON_SURFACE0_UPPER_BOUND + 16 * surfnr, restore->surfaces[surfnr][2]);
+    }
+}
+
+/* save original surface info (for fb console). */
+static void RADEONSaveSurfaces(ScrnInfoPtr pScrn, RADEONSavePtr save)
+{
+    RADEONInfoPtr      info = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+    unsigned int surfnr;
+    
+    for ( surfnr = 0; surfnr < 8; surfnr++ ) {
+	save->surfaces[surfnr][0] = INREG(RADEON_SURFACE0_INFO + 16 * surfnr);
+	save->surfaces[surfnr][1] = INREG(RADEON_SURFACE0_LOWER_BOUND + 16 * surfnr);
+	save->surfaces[surfnr][2] = INREG(RADEON_SURFACE0_UPPER_BOUND + 16 * surfnr);
+    }
+}
+
 void RADEONChangeSurfaces(ScrnInfoPtr pScrn)
 {
    /* the idea here is to only set up front buffer as tiled, and back/depth buffer when needed.
@@ -6273,6 +6795,9 @@
         + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN);
     unsigned int depth_pattern, color_pattern, swap_pattern;
 
+    if (!info->allowColorTiling)
+	return;
+
     swap_pattern = 0;
 #if X_BYTE_ORDER == X_BIG_ENDIAN
     switch (pScrn->bitsPerPixel) {
@@ -6305,8 +6830,9 @@
 	    depth_pattern = R200_SURF_TILE_DEPTH_32BPP;
     }   
 #ifdef XF86DRI
-    if (info->directRenderingEnabled && info->allowColorTiling) {
+    if (info->directRenderingInited) {
 	drmRadeonSurfaceFree drmsurffree;
+	drmRadeonSurfaceAlloc drmsurfalloc;
 	int retvalue;
 
 	drmsurffree.address = info->frontOffset;
@@ -6327,31 +6853,31 @@
 		&drmsurffree, sizeof(drmsurffree));
 	}
 
-	if (info->tilingEnabled) {
-	    drmRadeonSurfaceAlloc drmsurfalloc;
-	    drmsurfalloc.size = bufferSize;
-	    drmsurfalloc.address = info->frontOffset;
+	drmsurfalloc.size = bufferSize;
+	drmsurfalloc.address = info->frontOffset;
+	drmsurfalloc.flags = swap_pattern;
 
+	if (info->tilingEnabled) {
 	    if (IS_R300_VARIANT)
-		drmsurfalloc.flags = swap_pattern | (width_bytes / 8) | color_pattern;
+		drmsurfalloc.flags |= (width_bytes / 8) | color_pattern;
 	    else
-		drmsurfalloc.flags = swap_pattern | (width_bytes / 16) | color_pattern;
-
+		drmsurfalloc.flags |= (width_bytes / 16) | color_pattern;
+	}
+	retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
+				   &drmsurfalloc, sizeof(drmsurfalloc));
+	if (retvalue < 0)
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		       "drm: could not allocate surface for front buffer!\n");
+	
+	if ((info->have3DWindows) && (!info->noBackBuffer)) {
+	    drmsurfalloc.address = info->backOffset;
 	    retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
-		&drmsurfalloc, sizeof(drmsurfalloc));
+				       &drmsurfalloc, sizeof(drmsurfalloc));
 	    if (retvalue < 0)
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		    "drm: could not allocate surface for front buffer!\n");
-
-	    if ((info->have3DWindows) && (!info->noBackBuffer)) {
-		drmsurfalloc.address = info->backOffset;
-		retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
-		    &drmsurfalloc, sizeof(drmsurfalloc));
-		if (retvalue < 0)
-		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			"drm: could not allocate surface for back buffer!\n");
-	    }
+			   "drm: could not allocate surface for back buffer!\n");
 	}
+
 	/* rv100 and probably the derivative igps don't have depth tiling on all the time? */
 	if (info->have3DWindows && ((info->ChipFamily != CHIP_FAMILY_RV100) || 
 	    (info->ChipFamily != CHIP_FAMILY_RS100) ||
@@ -6372,16 +6898,16 @@
     }
     else
 #endif
-    if (info->allowColorTiling) {
-	unsigned int surf_info = 0;
+    {
+	unsigned int surf_info = swap_pattern;
 	unsigned char *RADEONMMIO = info->MMIO;
 	/* we don't need anything like WaitForFifo, no? */
 	if (!info->IsSecondary) {
 	    if (info->tilingEnabled) {
 		if (IS_R300_VARIANT)
-		   surf_info = swap_pattern | (width_bytes / 8) | color_pattern;
+		   surf_info |= (width_bytes / 8) | color_pattern;
 		else
-		   surf_info = swap_pattern | (width_bytes / 16) | color_pattern;
+		   surf_info |= (width_bytes / 16) | color_pattern;
 	    }
 	    OUTREG(RADEON_SURFACE0_INFO, surf_info);
 	    OUTREG(RADEON_SURFACE0_LOWER_BOUND, 0);
@@ -6391,6 +6917,9 @@
 		surf_info, 0, bufferSize - 1024);*/
 	}
     }
+
+    /* Update surface images */
+    RADEONSaveSurfaces(pScrn, &info->ModeReg);
 }
 
 #if 0
@@ -6419,35 +6948,6 @@
 }
 #endif
 
-/* restore original surface info (for fb console). */
-static void RADEONRestoreSurfaces(ScrnInfoPtr pScrn, RADEONSavePtr restore)
-{
-    RADEONInfoPtr      info = RADEONPTR(pScrn);
-    unsigned char *RADEONMMIO = info->MMIO;
-    unsigned int surfnr;
-    
-    for ( surfnr = 0; surfnr < 8; surfnr++ ) {
-	OUTREG(RADEON_SURFACE0_INFO + 16 * surfnr, restore->surfaces[surfnr][0]);
-	OUTREG(RADEON_SURFACE0_LOWER_BOUND + 16 * surfnr, restore->surfaces[surfnr][1]);
-	OUTREG(RADEON_SURFACE0_UPPER_BOUND + 16 * surfnr, restore->surfaces[surfnr][2]);
-    }
-}
-
-/* save original surface info (for fb console). */
-static void RADEONSaveSurfaces(ScrnInfoPtr pScrn, RADEONSavePtr save)
-{
-    RADEONInfoPtr      info = RADEONPTR(pScrn);
-    unsigned char *RADEONMMIO = info->MMIO;
-    unsigned int surfnr;
-    
-    for ( surfnr = 0; surfnr < 8; surfnr++ ) {
-	save->surfaces[surfnr][0] = INREG(RADEON_SURFACE0_INFO + 16 * surfnr);
-	save->surfaces[surfnr][1] = INREG(RADEON_SURFACE0_LOWER_BOUND + 16 * surfnr);
-	save->surfaces[surfnr][2] = INREG(RADEON_SURFACE0_UPPER_BOUND + 16 * surfnr);
-    }
-}
-
-
 /* Write out state to define a new video mode */
 static void RADEONRestoreMode(ScrnInfoPtr pScrn, RADEONSavePtr restore)
 {
@@ -6455,8 +6955,11 @@
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
     static RADEONSaveRec  restore0;
 
+    RADEONTRACE(("RADEONRestoreMode()\n"));
+
     /* For Non-dual head card, we don't have private field in the Entity */
     if (!info->HasCRTC2) {
+	RADEONRestoreMemMapRegisters(pScrn, restore);
 	RADEONRestoreCommonRegisters(pScrn, restore);
 	RADEONRestoreCrtcRegisters(pScrn, restore);
 	RADEONRestoreFPRegisters(pScrn, restore);
@@ -6474,14 +6977,18 @@
      * order. Regardless the order of X server issuing the calls, we
      * have to ensure we set registers in the right order!!!  Otherwise
      * we may get a blank screen.
+     *
+     * We always restore MemMap first, the saverec should be up to date
+     * in all cases
      */
     if (info->IsSecondary) {
-	if (!pRADEONEnt->RestorePrimary  && !info->IsSwitching)
-	    RADEONRestoreCommonRegisters(pScrn, restore);
+	RADEONRestoreMemMapRegisters(pScrn, restore);
+	RADEONRestoreCommonRegisters(pScrn, &restore0);
 	RADEONRestoreCrtc2Registers(pScrn, restore);
 	RADEONRestorePLL2Registers(pScrn, restore);
 
-	if(info->IsSwitching) return;
+	if (info->IsSwitching)
+	    return;
 
 	pRADEONEnt->IsSecondaryRestored = TRUE;
 
@@ -6494,9 +7001,8 @@
 	    pRADEONEnt->IsSecondaryRestored = FALSE;
 	}
     } else {
-	if (!pRADEONEnt->IsSecondaryRestored)
-	    RADEONRestoreCommonRegisters(pScrn, restore);
-
+	RADEONRestoreMemMapRegisters(pScrn, restore);
+	RADEONRestoreCommonRegisters(pScrn, &restore0);
 	if (info->MergedFB) {
 	    RADEONRestoreCrtc2Registers(pScrn, restore);
 	    RADEONRestorePLL2Registers(pScrn, restore);
@@ -6520,6 +7026,19 @@
 #endif
 }
 
+/* Read memory map */
+static void RADEONSaveMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
+{
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+
+    save->mc_fb_location     = INREG(RADEON_MC_FB_LOCATION);
+    save->mc_agp_location    = INREG(RADEON_MC_AGP_LOCATION);
+    save->display_base_addr  = INREG(RADEON_DISPLAY_BASE_ADDR);
+    save->display2_base_addr = INREG(RADEON_DISPLAY2_BASE_ADDR);
+    save->ov0_base_addr      = INREG(RADEON_OV0_BASE_ADDR);
+}
+
 /* Read common registers */
 static void RADEONSaveCommonRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
 {
@@ -6703,6 +7222,7 @@
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
     RADEONTRACE(("RADEONSaveMode(%p)\n", save));
+    RADEONSaveMemMapRegisters(pScrn, save);
     RADEONSaveCommonRegisters(pScrn, save);
     if (info->IsSecondary) {
 	RADEONSaveCrtc2Registers(pScrn, save);
@@ -6731,6 +7251,7 @@
 
     RADEONTRACE(("RADEONSave\n"));
     if (info->FBDev) {
+	RADEONSaveMemMapRegisters(pScrn, save);
 	fbdevHWSave(pScrn);
 	return;
     }
@@ -6914,8 +7435,24 @@
     int stop_req, max_stop_req;
     float read_return_rate, time_disp1_drop_priority;
 
-    /* R420 family not supported yet */
-    if (info->ChipFamily == CHIP_FAMILY_R420) return; 
+    /* 
+     * Set display0/1 priority up on r3/4xx in the memory controller for 
+     * high res modes if the user specifies HIGH for displaypriority 
+     * option.
+     */
+    if ((info->DispPriority == 2) && IS_R300_VARIANT) {
+        CARD32 mc_init_misc_lat_timer = INREG(R300_MC_INIT_MISC_LAT_TIMER);
+	if (info->MergedFB || pRADEONEnt->HasSecondary) {
+	    mc_init_misc_lat_timer |= 0x1100; /* display 0 and 1 */
+	} else {
+	    mc_init_misc_lat_timer |= 0x0100; /* display 0 only */
+	}
+	OUTREG(R300_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
+    }
+
+
+    /* R420 and RV410 family not supported yet */
+    if (info->ChipFamily == CHIP_FAMILY_R420 || info->ChipFamily == CHIP_FAMILY_RV410) return; 
 
     if (pRADEONEnt->pSecondaryScrn) {
 	if (info->IsSecondary) return;
@@ -7298,7 +7835,7 @@
 				     ? RADEON_CRTC_V_SYNC_POL
 				     : 0));
 
-    save->crtc_offset      = 0;
+    save->crtc_offset      = pScrn->fbOffset;
     save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);
     if (info->tilingEnabled) {
        if (IS_R300_VARIANT)
@@ -7336,7 +7873,9 @@
     save->disp_merge_cntl &= ~RADEON_DISP_RGB_OFFSET_EN;
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
-    /* Alhought we current onlu use aperture 0, also setting aperture 1 should not harm -ReneR */
+    /* We must set both apertures as they can be both used to map the entire
+     * video memory. -BenH.
+     */
     switch (pScrn->bitsPerPixel) {
     case 16:
 	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
@@ -7493,7 +8032,7 @@
 
     /* It seems all fancy options apart from pflip can be safely disabled
      */
-    save->crtc2_offset      = 0;
+    save->crtc2_offset      = pScrn->fbOffset;
     save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL) & RADEON_CRTC_OFFSET_FLIP_CNTL;
     if (info->tilingEnabled) {
        if (IS_R300_VARIANT)
@@ -7557,7 +8096,9 @@
     /* We must set SURFACE_CNTL properly on the second screen too */
     save->surface_cntl = 0;
 #if X_BYTE_ORDER == X_BIG_ENDIAN
-    /* Alhought we current onlu use aperture 0, also setting aperture 1 should not harm -ReneR */
+    /* We must set both apertures as they can be both used to map the entire
+     * video memory. -BenH.
+     */
     switch (pScrn->bitsPerPixel) {
     case 16:
        save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
@@ -7822,8 +8363,9 @@
 }
 
 /* Define PLL registers for requested video mode */
-static void RADEONInitPLLRegisters(RADEONInfoPtr info, RADEONSavePtr save,
-                                  RADEONPLLPtr pll, double dot_clock)
+static void RADEONInitPLLRegisters(ScrnInfoPtr pScrn, RADEONInfoPtr info,
+				   RADEONSavePtr save, RADEONPLLPtr pll,
+				   double dot_clock)
 {
     unsigned long  freq = dot_clock * 100;
 
@@ -7887,8 +8429,9 @@
 }
 
 /* Define PLL2 registers for requested video mode */
-static void RADEONInitPLL2Registers(RADEONSavePtr save, RADEONPLLPtr pll,
-                                   double dot_clock, int no_odd_postdiv)
+static void RADEONInitPLL2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save,
+				    RADEONPLLPtr pll, double dot_clock,
+				    int no_odd_postdiv)
 {
     unsigned long  freq = dot_clock * 100;
 
@@ -8016,11 +8559,12 @@
 
     info->Flags = mode->Flags;
 
+    RADEONInitMemMapRegisters(pScrn, save, info);
     RADEONInitCommonRegisters(save, info);
     if (info->IsSecondary) {
 	if (!RADEONInitCrtc2Registers(pScrn, save, mode, info))
 	    return FALSE;
-       RADEONInitPLL2Registers(save, &info->pll, dot_clock, info->DisplayType != MT_CRT);
+	RADEONInitPLL2Registers(pScrn, save, &info->pll, dot_clock, info->DisplayType != MT_CRT);
     } else if (info->MergedFB) {
         RADEONInitCommonRegisters(save, info);
         if (!RADEONInitCrtcRegisters(pScrn, save, 
@@ -8028,7 +8572,7 @@
             return FALSE;
         dot_clock = (((RADEONMergedDisplayModePtr)mode->Private)->CRT1)->Clock / 1000.0;
         if (dot_clock) {
-            RADEONInitPLLRegisters(info, save, &info->pll, dot_clock);
+		RADEONInitPLLRegisters(pScrn, info, save, &info->pll, dot_clock);
         } else {
             save->ppll_ref_div = info->SavedReg.ppll_ref_div;
             save->ppll_div_3   = info->SavedReg.ppll_div_3;
@@ -8037,13 +8581,13 @@
         RADEONInitCrtc2Registers(pScrn, save, 
 			((RADEONMergedDisplayModePtr)mode->Private)->CRT2, info);
         dot_clock = (((RADEONMergedDisplayModePtr)mode->Private)->CRT2)->Clock / 1000.0;
-        RADEONInitPLL2Registers(save, &info->pll, dot_clock, info->MergeType != MT_CRT);
+        RADEONInitPLL2Registers(pScrn, save, &info->pll, dot_clock, info->MergeType != MT_CRT);
     } else {
 	if (!RADEONInitCrtcRegisters(pScrn, save, mode, info))
 	    return FALSE;
 	dot_clock = mode->Clock/1000.0;
 	if (dot_clock) {
-           RADEONInitPLLRegisters(info, save, &info->pll, dot_clock);
+		RADEONInitPLLRegisters(pScrn, info, save, &info->pll, dot_clock);
 	} else {
 	    save->ppll_ref_div = info->SavedReg.ppll_ref_div;
 	    save->ppll_div_3   = info->SavedReg.ppll_div_3;
@@ -8079,6 +8623,8 @@
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
+    RADEONTRACE(("RADEONModeInit()\n"));
+
     if (!RADEONInit(pScrn, mode, &info->ModeReg)) return FALSE;
 
     pScrn->vtSema = TRUE;
@@ -8099,6 +8645,8 @@
     ScrnInfoPtr  pScrn = xf86Screens[pScreen->myNum];
     Bool         unblank;
 
+    RADEONTRACE(("RADEONSaveScreen(%d)\n", mode));
+
     unblank = xf86IsUnblank(mode);
     if (unblank) SetTimeSinceLastInputEvent();
 
@@ -8124,6 +8672,8 @@
     }
 #endif
 
+    RADEONTRACE(("RADEONSwitchMode() !n"));
+
     if (info->allowColorTiling) {
 	if (info->MergedFB) {
 	    if ((((RADEONMergedDisplayModePtr)mode->Private)->CRT1->Flags &
@@ -8237,6 +8787,10 @@
     XF86DRISAREAPtr pSAREA;
 #endif
 
+#if 0 /* Verbose */
+    RADEONTRACE(("RADEONDoAdjustFrame(%d,%d,%d)\n", x, y, clone));
+#endif
+
     if (info->showCache && y) {
 	        int lastline = info->FbMapSize /
 		    ((pScrn->displayWidth * pScrn->bitsPerPixel) / 8);
@@ -8288,19 +8842,20 @@
          }
     }
     else {
-       Base += y * info->CurrentLayout.displayWidth + x;
+       int offset = y * info->CurrentLayout.displayWidth + x;
        switch (info->CurrentLayout.pixel_code) {
        case 15:
-       case 16: Base *= 2; break;
-       case 24: Base *= 3; break;
-       case 32: Base *= 4; break;
+       case 16: offset *= 2; break;
+       case 24: offset *= 3; break;
+       case 32: offset *= 4; break;
        }
+       Base += offset;
     }
 
     Base &= ~7;                 /* 3 lower bits are always 0 */
 
 #ifdef XF86DRI
-    if (info->directRenderingEnabled) {
+    if (info->directRenderingInited) {
 	/* note cannot use pScrn->pScreen since this is unitialized when called from
 	   RADEONScreenInit, and we need to call from there to get mergedfb + pageflip working */
         /*** NOTE: r3/4xx will need sarea and drm pageflip updates to handle the xytile regs for
@@ -8344,7 +8899,7 @@
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
 
 #ifdef XF86DRI
-    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
+    if (info->CPStarted && pScrn->pScreen) DRILock(pScrn->pScreen, 0);
 #endif
 
     if (info->accelOn)
@@ -8359,7 +8914,7 @@
     }
 
 #ifdef XF86DRI
-	if (info->CPStarted) DRIUnlock(pScrn->pScreen);
+	if (info->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
 #endif
 }
 
@@ -8386,6 +8941,9 @@
        }
     }
 
+    /* Makes sure the engine is idle before doing anything */
+    RADEONWaitForIdleMMIO(pScrn);
+
     if (info->FBDev) {
 	unsigned char *RADEONMMIO = info->MMIO;
 	if (!fbdevHWEnterVT(scrnIndex,flags)) return FALSE;
@@ -8396,13 +8954,13 @@
     } else
 	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;
 
-    RADEONSetFBLocation(pScrn);
     if (!info->IsSecondary)
 	RADEONRestoreSurfaces(pScrn, &info->ModeReg);
 #ifdef XF86DRI
     if (info->directRenderingEnabled) {
-	/* get the Radeon back into shape after resume */
+	/* get the DRI back into shape after resume */
 	RADEONDRIResume(pScrn->pScreen);
+	RADEONAdjustMemMapRegisters(pScrn, &info->ModeReg);
     }
 #endif
     /* this will get XVideo going again, but only if XVideo was initialised
@@ -8436,7 +8994,7 @@
 
     RADEONTRACE(("RADEONLeaveVT\n"));
 #ifdef XF86DRI
-    if (RADEONPTR(pScrn)->directRenderingEnabled) {
+    if (RADEONPTR(pScrn)->directRenderingInited) {
 	DRILock(pScrn->pScreen, 0);
 	RADEONCP_STOP(pScrn, info);
     }
@@ -8451,9 +9009,9 @@
 	fbdevHWLeaveVT(scrnIndex,flags);
     }
 
-    if (!info->IsSecondary)
-	RADEONSaveSurfaces(pScrn, save);
     RADEONRestore(pScrn);
+
+    RADEONTRACE(("Ok, leaving now...\n"));
 }
 
 /* Called at the end of each server generation.  Restore the original
@@ -8467,12 +9025,13 @@
 
     RADEONTRACE(("RADEONCloseScreen\n"));
 
+    /* Mark acceleration as stopped or we might try to access the engine at
+     * wrong times, especially if we had DRI, after DRI has been stopped
+     */
+    info->accelOn = FALSE;
+
 #ifdef XF86DRI
-				/* Disable direct rendering */
-    if (info->directRenderingEnabled) {
-	RADEONDRICloseScreen(pScreen);
-	info->directRenderingEnabled = FALSE;
-    }
+    RADEONDRIStop(pScreen);
 #endif
 
 #ifdef USE_XAA
@@ -8486,8 +9045,8 @@
 	RADEONDisplayPowerManagementSet(pScrn, DPMSModeOn, 0);
 	RADEONRestore(pScrn);
     }
-    RADEONUnmapMem(pScrn);
 
+    RADEONTRACE(("Disposing accel...\n"));
 #ifdef USE_EXA
     if (info->useEXA && info->accelOn)
 	exaDriverFini(pScreen);
@@ -8504,11 +9063,15 @@
     }
 #endif /* USE_XAA */
 
+    RADEONTRACE(("Disposing cusor info\n"));
     if (info->cursor) xf86DestroyCursorInfoRec(info->cursor);
     info->cursor = NULL;
 
+    RADEONTRACE(("Disposing DGA\n"));
     if (info->DGAModes) xfree(info->DGAModes);
     info->DGAModes = NULL;
+    RADEONTRACE(("Unmapping memory\n"));
+    RADEONUnmapMem(pScrn);
 
     pScrn->vtSema = FALSE;
 
@@ -8647,6 +9210,8 @@
 
     if (!pScrn->vtSema) return;
 
+    RADEONTRACE(("RADEONDisplayPowerManagementSet(%d,0x%x)\n", PowerManagementMode, flags));
+
 #ifdef XF86DRI
     if (info->CPStarted) DRILock(pScrn->pScreen, 0);
 #endif
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_exa.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_exa.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_exa.c	2005-10-09 12:36:50.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_exa.c	2006-03-03 17:41:41.000000000 +0100
@@ -438,11 +438,9 @@
 		       depth_size / 1024, info->depthOffset);
 	}
 	
-	/* Reserve approx. half of remaining offscreen memory for local
-	* textures.  Round down to a whole number of texture regions.
-	*/
-	info->textureSize = (info->exa.card.memorySize -
-			     info->exa.card.offScreenBase) / 2;
+	info->textureSize *= (info->exa.card.memorySize -
+			      info->exa.card.offScreenBase) / 100;
+
 	l = RADEONLog2(info->textureSize / RADEON_NR_TEX_REGIONS);
 	if (l < RADEON_LOG_TEX_GRANULARITY)
 	    l = RADEON_LOG_TEX_GRANULARITY;
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_exa_render.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_exa_render.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_exa_render.c	2005-09-28 01:34:11.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_exa_render.c	2006-02-13 06:30:13.000000000 +0100
@@ -116,8 +116,8 @@
 static struct formatinfo R200TexFormats[] = {
     {PICT_a8r8g8b8,	0, R200_TXFORMAT_ARGB8888 | R200_TXFORMAT_ALPHA_IN_MAP},
     {PICT_x8r8g8b8,	0, R200_TXFORMAT_ARGB8888},
-    {PICT_a8r8g8b8,	1, R200_TXFORMAT_RGBA8888 | R200_TXFORMAT_ALPHA_IN_MAP},
-    {PICT_x8r8g8b8,	1, R200_TXFORMAT_RGBA8888},
+    {PICT_a8b8g8r8,	1, R200_TXFORMAT_RGBA8888 | R200_TXFORMAT_ALPHA_IN_MAP},
+    {PICT_x8b8g8r8,	1, R200_TXFORMAT_RGBA8888},
     {PICT_r5g6b5,	0, R200_TXFORMAT_RGB565},
     {PICT_a1r5g5b5,	0, R200_TXFORMAT_ARGB1555 | R200_TXFORMAT_ALPHA_IN_MAP},
     {PICT_x1r5g5b5,	0, R200_TXFORMAT_ARGB1555},
@@ -223,6 +223,11 @@
     txpitch = exaGetPixmapPitch(pPix);
     txoffset = exaGetPixmapOffset(pPix) + info->fbLocation;
 
+    if ((txoffset & 0x1f) != 0)
+	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
+    if ((txpitch & 0x1f) != 0)
+	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));
+    
     for (i = 0; i < sizeof(R100TexFormats) / sizeof(R100TexFormats[0]); i++)
     {
 	if (R100TexFormats[i].fmt == pPict->format)
@@ -241,11 +246,6 @@
 	txformat |= RADEON_TXFORMAT_NON_POWER2;
     txformat |= unit << 24; /* RADEON_TXFORMAT_ST_ROUTE_STQX */
  
-    if ((txoffset & 0x1f) != 0)
-	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
-    if ((txpitch & 0x1f) != 0)
-	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));
-
     switch (pPict->filter) {
     case PictFilterNearest:
 	txfilter = (RADEON_MAG_FILTER_NEAREST | RADEON_MIN_FILTER_NEAREST);
@@ -466,6 +466,11 @@
     txpitch = exaGetPixmapPitch(pPix);
     txoffset = exaGetPixmapOffset(pPix) + info->fbLocation;
 
+    if ((txoffset & 0x1f) != 0)
+	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
+    if ((txpitch & 0x1f) != 0)
+	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));
+    
     for (i = 0; i < sizeof(R200TexFormats) / sizeof(R200TexFormats[0]); i++)
     {
 	if (R200TexFormats[i].fmt == pPict->format)
@@ -484,11 +489,6 @@
 	txformat |= R200_TXFORMAT_NON_POWER2;
     txformat |= unit << R200_TXFORMAT_ST_ROUTE_SHIFT;
 
-    if ((txoffset & 0x1f) != 0)
-	RADEON_FALLBACK(("Bad texture offset 0x%x\n", (int)txoffset));
-    if ((txpitch & 0x1f) != 0)
-	RADEON_FALLBACK(("Bad texture pitch 0x%x\n", (int)txpitch));
-
     switch (pPict->filter) {
     case PictFilterNearest:
 	txfilter = (R200_MAG_FILTER_NEAREST |
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon.h xf86-video-ati-X11R7.0-6.5.7.3/src/radeon.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon.h	2005-11-09 08:30:03.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon.h	2006-03-15 05:12:43.000000000 +0100
@@ -41,6 +41,7 @@
 #include "xf86str.h"
 #include "xf86_ansic.h"
 #include "compiler.h"
+#include "xf86fbman.h"
 
 				/* PCI support */
 #include "xf86Pci.h"
@@ -50,7 +51,6 @@
 #endif
 #ifdef USE_XAA
 #include "xaa.h"
-#include "xf86fbman.h"
 #endif
 
 				/* Exa and Cursor Support */
@@ -102,7 +102,7 @@
 
 /* ------------------------------------- */
 
-#define RADEON_DEBUG            0 /* Turn off debugging output               */
+#define RADEON_DEBUG            1 /* Turn off debugging output               */
 #define RADEON_IDLE_RETRY      16 /* Fall out of idle loops after this count */
 #define RADEON_TIMEOUT    2000000 /* Fall out of wait loops after this count */
 #define RADEON_MMIOSIZE   0x80000
@@ -116,13 +116,13 @@
 				   */
 
 #if RADEON_DEBUG
-#define RADEONTRACE(x)							\
+#define RADEONTRACE(x)						\
 do {									\
     ErrorF("(**) %s(%d): ", RADEON_NAME, pScrn->scrnIndex);		\
     ErrorF x;								\
-} while (0);
+} while(0)
 #else
-#define RADEONTRACE(x)
+#define RADEONTRACE(x) do { } while(0)
 #endif
 
 
@@ -147,10 +147,16 @@
     CARD32            cap0_trig_cntl;
     CARD32            cap1_trig_cntl;
     CARD32            bus_cntl;
-    CARD32            surface_cntl;
     CARD32            bios_4_scratch;
     CARD32            bios_5_scratch;
     CARD32            bios_6_scratch;
+    CARD32            surface_cntl;
+    CARD32            surfaces[8][3];
+    CARD32            mc_agp_location;
+    CARD32            mc_fb_location;
+    CARD32            display_base_addr;
+    CARD32            display2_base_addr;
+    CARD32            ov0_base_addr;
 
 				/* Other registers to save for VT switches */
     CARD32            dp_datatype;
@@ -158,8 +164,6 @@
     CARD32            clock_cntl_index;
     CARD32            amcgpio_en_reg;
     CARD32            amcgpio_mask;
-    
-    CARD32            surfaces[8][3];
 
 				/* CRTC registers */
     CARD32            crtc_gen_cntl;
@@ -274,6 +278,8 @@
     CHIP_FAMILY_RV350,
     CHIP_FAMILY_RV380,    /* RV370/RV380/M22/M24 */
     CHIP_FAMILY_R420,     /* R420/R423/M18 */
+    CHIP_FAMILY_RV410,    /* RV410, M26 */
+    CHIP_FAMILY_RS400,    /* xpress 200, 200m (RS400/410/480) */
     CHIP_FAMILY_LAST
 } RADEONChipFamily;
 
@@ -290,7 +296,9 @@
         (info->ChipFamily == CHIP_FAMILY_RV350) ||  \
         (info->ChipFamily == CHIP_FAMILY_R350)  ||  \
         (info->ChipFamily == CHIP_FAMILY_RV380) ||  \
-        (info->ChipFamily == CHIP_FAMILY_R420))
+        (info->ChipFamily == CHIP_FAMILY_R420)  ||  \
+        (info->ChipFamily == CHIP_FAMILY_RV410) ||  \
+        (info->ChipFamily == CHIP_FAMILY_RS400))
 
 /*
  * Errata workarounds
@@ -326,6 +334,8 @@
     unsigned long     MMIOAddr;         /* MMIO region physical address      */
     unsigned long     BIOSAddr;         /* BIOS physical address             */
     unsigned int      fbLocation;
+    CARD32            mc_fb_location;
+    CARD32            mc_agp_location;
 
     unsigned char     *MMIO;            /* Map of MMIO region                */
     unsigned char     *FB;              /* Map of frame buffer               */
@@ -338,7 +348,8 @@
     CARD32            MemCntl;
     CARD32            BusCntl;
     unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
-    unsigned long     FbSecureSize;     /* Size of secured fb area at end of framebuffer */
+    unsigned long     FbSecureSize;     /* Size of secured fb area at end of
+                                           framebuffer */
     int               Flags;            /* Saved copy of mode flags          */
 
 				/* VE/M6 support */
@@ -399,14 +410,14 @@
 
 #ifdef USE_EXA
     ExaDriverRec      exa;
-#endif
-#ifdef USE_XAA
-    XAAInfoRecPtr     accel;
     int               engineMode;
 #define EXA_ENGINEMODE_UNKNOWN 0
 #define EXA_ENGINEMODE_2D      1
 #define EXA_ENGINEMODE_3D      2
 #endif
+#ifdef USE_XAA
+    XAAInfoRecPtr     accel;
+#endif
     Bool              accelOn;
     xf86CursorInfoPtr cursor;
 #ifdef USE_EXA
@@ -480,13 +491,18 @@
     RADEONFBLayout    CurrentLayout;
     CARD32            dst_pitch_offset;
 #ifdef XF86DRI
-    Bool              noBackBuffer;
+    Bool              noBackBuffer;	
     Bool              directRenderingEnabled;
+    Bool              directRenderingInited;
+    Bool              newMemoryMap;
+    drmVersionPtr     pLibDRMVersion;
+    drmVersionPtr     pKernelDRMVersion;
     DRIInfoPtr        pDRIInfo;
     int               drmFD;
     int               numVisualConfigs;
     __GLXvisualConfig *pVisualConfigs;
     RADEONConfigPrivPtr pVisualConfigsPriv;
+    Bool             (*DRICloseScreen)(int, ScreenPtr);
 
     drm_handle_t         fbHandle;
 
@@ -501,7 +517,6 @@
     Bool              depthMoves;       /* Enable depth moves -- slow! */
     Bool              allowPageFlip;    /* Enable 3d page flipping */
     Bool              have3DWindows;    /* Are there any 3d clients? */
-    int               drmMinor;
 
     drmSize           gartSize;
     drm_handle_t         agpMemHandle;     /* Handle from drmAgpAlloc */
@@ -766,11 +781,14 @@
 #ifdef USE_XAA
 extern void        RADEONAccelInitCP(ScreenPtr pScreen, XAAInfoRecPtr a);
 #endif
+extern Bool        RADEONDRIGetVersion(ScrnInfoPtr pScrn);
 extern Bool        RADEONDRIScreenInit(ScreenPtr pScreen);
 extern void        RADEONDRICloseScreen(ScreenPtr pScreen);
 extern void        RADEONDRIResume(ScreenPtr pScreen);
 extern Bool        RADEONDRIFinishScreenInit(ScreenPtr pScreen);
 extern void        RADEONDRIAllocatePCIGARTTable(ScreenPtr pScreen);
+extern void	   RADEONDRIInitPageFlip(ScreenPtr pScreen);
+extern void        RADEONDRIStop(ScreenPtr pScreen);
 
 extern drmBufPtr   RADEONCPGetBuffer(ScrnInfoPtr pScrn);
 extern void        RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard);
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_mm_i2c.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_mm_i2c.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_mm_i2c.c	2005-08-25 05:07:50.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_mm_i2c.c	2006-03-12 07:57:12.000000000 +0100
@@ -8,9 +8,9 @@
 #include "radeon_probe.h"
 #include <X11/extensions/Xv.h>
 #include "radeon_video.h"
+#include "atipciids.h"
 
 #include "xf86.h"
-#include "xf86PciInfo.h"
 
 /* i2c stuff */
 #include "xf86i2c.h"
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_probe.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_probe.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_probe.c	2005-12-14 20:41:28.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_probe.c	2006-03-12 07:57:12.000000000 +0100
@@ -44,8 +44,7 @@
 
 #include "radeon_probe.h"
 #include "radeon_version.h"
-
-#include "xf86PciInfo.h"
+#include "atipciids.h"
 
 #include "xf86.h"
 #include "xf86_ansic.h"
@@ -129,12 +128,15 @@
     { PCI_CHIP_RV380_3E50, PCI_CHIP_RV380_3E50, RES_SHARED_VGA },
     { PCI_CHIP_RV380_3E54, PCI_CHIP_RV380_3E54, RES_SHARED_VGA },
     { PCI_CHIP_RV380_3150, PCI_CHIP_RV380_3150, RES_SHARED_VGA },
+    { PCI_CHIP_RV380_3152, PCI_CHIP_RV380_3152, RES_SHARED_VGA },
     { PCI_CHIP_RV380_3154, PCI_CHIP_RV380_3154, RES_SHARED_VGA },
     { PCI_CHIP_RV370_5B60, PCI_CHIP_RV370_5B60, RES_SHARED_VGA },
     { PCI_CHIP_RV370_5B62, PCI_CHIP_RV370_5B62, RES_SHARED_VGA },
+    { PCI_CHIP_RV370_5B63, PCI_CHIP_RV370_5B63, RES_SHARED_VGA },
     { PCI_CHIP_RV370_5B64, PCI_CHIP_RV370_5B64, RES_SHARED_VGA },
     { PCI_CHIP_RV370_5B65, PCI_CHIP_RV370_5B65, RES_SHARED_VGA },
     { PCI_CHIP_RV370_5460, PCI_CHIP_RV370_5460, RES_SHARED_VGA },
+    { PCI_CHIP_RV370_5462, PCI_CHIP_RV370_5462, RES_SHARED_VGA },
     { PCI_CHIP_RV370_5464, PCI_CHIP_RV370_5464, RES_SHARED_VGA },
     { PCI_CHIP_RS400_5A41, PCI_CHIP_RS400_5A41, RES_SHARED_VGA },
     { PCI_CHIP_RS400_5A42, PCI_CHIP_RS400_5A42, RES_SHARED_VGA },
@@ -147,6 +149,7 @@
     { PCI_CHIP_RV410_5E48, PCI_CHIP_RV410_5E48, RES_SHARED_VGA },
     { PCI_CHIP_RV410_564A, PCI_CHIP_RV410_564A, RES_SHARED_VGA },
     { PCI_CHIP_RV410_564B, PCI_CHIP_RV410_564B, RES_SHARED_VGA },
+    { PCI_CHIP_RV410_564F, PCI_CHIP_RV410_564F, RES_SHARED_VGA },
     { PCI_CHIP_RV410_5652, PCI_CHIP_RV410_5652, RES_SHARED_VGA },
     { PCI_CHIP_RV410_5653, PCI_CHIP_RV410_5653, RES_SHARED_VGA },
     { PCI_CHIP_RV410_5E4B, PCI_CHIP_RV410_5E4B, RES_SHARED_VGA },
@@ -163,6 +166,7 @@
     { PCI_CHIP_R420_JN, PCI_CHIP_R420_JN, RES_SHARED_VGA },
     { PCI_CHIP_R420_JP, PCI_CHIP_R420_JP, RES_SHARED_VGA },
     { PCI_CHIP_R420_4A4F, PCI_CHIP_R420_4A4F, RES_SHARED_VGA },
+    { PCI_CHIP_R420_4A54, PCI_CHIP_R420_4A54, RES_SHARED_VGA },
     { PCI_CHIP_R423_UH, PCI_CHIP_R423_UH, RES_SHARED_VGA },
     { PCI_CHIP_R423_UI, PCI_CHIP_R423_UI, RES_SHARED_VGA },
     { PCI_CHIP_R423_UJ, PCI_CHIP_R423_UJ, RES_SHARED_VGA },
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_reg.h xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_reg.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_reg.h	2005-09-17 09:47:51.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_reg.h	2006-03-23 19:07:10.000000000 +0100
@@ -307,9 +307,9 @@
 #       define RADEON_CRTC_DBL_SCAN_EN      (1 <<  0)
 #       define RADEON_CRTC_INTERLACE_EN     (1 <<  1)
 #       define RADEON_CRTC_CSYNC_EN         (1 <<  4)
+#       define RADEON_CRTC_ICON_EN          (1 << 15)
 #       define RADEON_CRTC_CUR_EN           (1 << 16)
 #       define RADEON_CRTC_CUR_MODE_MASK    (7 << 17)
-#       define RADEON_CRTC_ICON_EN          (1 << 20)
 #       define RADEON_CRTC_EXT_DISP_EN      (1 << 24)
 #       define RADEON_CRTC_EN               (1 << 25)
 #       define RADEON_CRTC_DISP_REQ_EN_B    (1 << 26)
@@ -364,6 +364,8 @@
 #	define RADEON_CRTC_OFFSET__OFFSET_LOCK 	   (1<<31)
 
 #define RADEON_CRTC2_OFFSET                 0x0324
+#	define RADEON_CRTC2_OFFSET__GUI_TRIG_OFFSET (1<<30)
+#	define RADEON_CRTC2_OFFSET__OFFSET_LOCK	    (1<<31)
 #define RADEON_CRTC_OFFSET_CNTL             0x0228
 #       define RADEON_CRTC_TILE_LINE_SHIFT              0
 #       define RADEON_CRTC_TILE_LINE_RIGHT_SHIFT        4
@@ -392,6 +394,7 @@
 #define R300_CRTC2_TILE_X0_Y0	            0x0358
 
 #define RADEON_CRTC2_OFFSET_CNTL            0x0328
+#       define RADEON_CRTC2_OFFSET_FLIP_CNTL (1 << 16)
 #       define RADEON_CRTC2_TILE_EN         (1 << 15)
 #define RADEON_CRTC_PITCH                   0x022c
 #	define RADEON_CRTC_PITCH__SHIFT		 0
@@ -812,6 +815,7 @@
 #define RADEON_HOST_DATA_LAST               0x17e0
 #define RADEON_HOST_PATH_CNTL               0x0130
 #       define RADEON_HDP_SOFT_RESET        (1 << 26)
+#       define RADEON_HDP_APER_CNTL         (1 << 23)
 #define RADEON_HTOTAL_CNTL                  0x0009 /* PLL */
 #define RADEON_HTOTAL2_CNTL                 0x002e /* PLL */
 
@@ -848,6 +852,9 @@
 #define RADEON_MAX_LATENCY                  0x0f3f /* PCI */
 #define RADEON_MC_AGP_LOCATION              0x014c
 #define RADEON_MC_FB_LOCATION               0x0148
+#define RADEON_MC_STATUS                    0x0150
+#       define RADEON_MC_IDLE               (1 << 2)
+#       define R300_MC_IDLE                 (1 << 4)
 #define RADEON_DISPLAY_BASE_ADDR            0x23c
 #define RADEON_DISPLAY2_BASE_ADDR           0x33c
 #define RADEON_OV0_BASE_ADDR                0x43c
@@ -925,6 +932,14 @@
 #       define  RADEON_EXCL_VERT_START_MASK        0x000003ff
 #       define  RADEON_EXCL_VERT_END_MASK          0x03ff0000
 #define RADEON_OV0_FILTER_CNTL              0x04A0
+#       define RADEON_FILTER_PROGRAMMABLE_COEF            0x0
+#       define RADEON_FILTER_HC_COEF_HORZ_Y               0x1
+#       define RADEON_FILTER_HC_COEF_HORZ_UV              0x2
+#       define RADEON_FILTER_HC_COEF_VERT_Y               0x4
+#       define RADEON_FILTER_HC_COEF_VERT_UV              0x8
+#       define RADEON_FILTER_HARDCODED_COEF               0xf
+#       define RADEON_FILTER_COEF_MASK                    0xf
+
 #define RADEON_OV0_FOUR_TAP_COEF_0          0x04B0
 #define RADEON_OV0_FOUR_TAP_COEF_1          0x04B4
 #define RADEON_OV0_FOUR_TAP_COEF_2          0x04B8
@@ -1012,14 +1027,15 @@
 #       define  RADEON_SCALER_SOURCE_YVYU422       0x00000C00L
 #       define  RADEON_SCALER_ADAPTIVE_DEINT       0x00001000L
 #       define  RADEON_SCALER_TEMPORAL_DEINT       0x00002000L
+#       define  RADEON_SCALER_CRTC_SEL             0x00004000L
 #       define  RADEON_SCALER_SMART_SWITCH         0x00008000L
 #       define  RADEON_SCALER_BURST_PER_PLANE      0x007F0000L
 #       define  RADEON_SCALER_DOUBLE_BUFFER        0x01000000L
 #       define  RADEON_SCALER_DIS_LIMIT            0x08000000L
+#       define  RADEON_SCALER_LIN_TRANS_BYPASS     0x10000000L
 #       define  RADEON_SCALER_INT_EMU              0x20000000L
 #       define  RADEON_SCALER_ENABLE               0x40000000L
 #       define  RADEON_SCALER_SOFT_RESET           0x80000000L
-#       define  RADEON_SCALER_ADAPTIVE_DEINT       0x00001000L
 #define RADEON_OV0_STEP_BY                  0x0484
 #define RADEON_OV0_TEST                     0x04F8
 #define RADEON_OV0_V_INC                    0x0424
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_render.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_render.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_render.c	2005-12-09 19:15:31.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_render.c	2006-02-17 00:27:44.000000000 +0100
@@ -315,29 +315,27 @@
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
+    CARD32 swapper = info->ModeReg.surface_cntl;
+
+    swapper &= ~(RADEON_NONSURF_AP0_SWP_16BPP | RADEON_NONSURF_AP1_SWP_16BPP |
+		 RADEON_NONSURF_AP0_SWP_32BPP | RADEON_NONSURF_AP1_SWP_32BPP);
 
     /* Set up byte swapping for the framebuffer aperture as needed */
     switch (tex_bytepp) {
     case 1:
-	OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl &
-				    ~(RADEON_NONSURF_AP0_SWP_32BPP
-				    | RADEON_NONSURF_AP0_SWP_16BPP));
 	break;
     case 2:
-	OUTREG(RADEON_SURFACE_CNTL, (info->ModeReg.surface_cntl &
-				     ~RADEON_NONSURF_AP0_SWP_32BPP)
-				   | RADEON_NONSURF_AP0_SWP_16BPP);
+	swapper |= RADEON_NONSURF_AP0_SWP_16BPP | RADEON_NONSURF_AP1_SWP_16BPP;
 	break;
     case 4:
-	OUTREG(RADEON_SURFACE_CNTL, (info->ModeReg.surface_cntl &
-				     ~RADEON_NONSURF_AP0_SWP_16BPP)
-				   | RADEON_NONSURF_AP0_SWP_32BPP);
+	swapper |= RADEON_NONSURF_AP0_SWP_32BPP | RADEON_NONSURF_AP1_SWP_32BPP;
 	break;
     default:
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "%s: Don't know what to do for "
 		   "tex_bytepp == %d!\n", __func__, tex_bytepp);
 	return FALSE;
     }
+    OUTREG(RADEON_SURFACE_CNTL, swapper);
     return TRUE;
 }
 
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_video.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_video.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_video.c	2005-09-11 22:58:53.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_video.c	2006-03-23 19:07:10.000000000 +0100
@@ -13,7 +13,7 @@
 
 #include "xf86.h"
 #include "dixstruct.h"
-#include "xf86PciInfo.h"
+#include "atipciids.h"
 #include "xf86fbman.h"
 
 #include <X11/extensions/Xv.h>
@@ -928,7 +928,7 @@
     dwOvGOff = ((INT32)(OvGOff * 2.0)) & 0x1fff;
     dwOvBOff = ((INT32)(OvBOff * 2.0)) & 0x1fff;
 
-    if(info->ChipFamily < CHIP_FAMILY_RADEON)
+    if(info->ChipFamily == CHIP_FAMILY_RADEON)
     {
 	dwOvLuma =(((INT32)(OvLuma * 2048.0))&0x7fff)<<17;
 	dwOvRCb = (((INT32)(OvRCb * 2048.0))&0x7fff)<<1;
@@ -1115,10 +1115,10 @@
     sprintf(tmp, "INSTANCE:%d", pScrn->scrnIndex);
     pPriv->instance_id = MAKE_ATOM(tmp);
 
-    OUTREG(RADEON_OV0_SCALE_CNTL, 0x80000000);
+    OUTREG(RADEON_OV0_SCALE_CNTL, RADEON_SCALER_SOFT_RESET);
     OUTREG(RADEON_OV0_AUTO_FLIP_CNTL, 0);   /* maybe */
     OUTREG(RADEON_OV0_EXCLUSIVE_HORZ, 0);
-    OUTREG(RADEON_OV0_FILTER_CNTL, 0x0000000f);
+    OUTREG(RADEON_OV0_FILTER_CNTL, RADEON_FILTER_PROGRAMMABLE_COEF);
     OUTREG(RADEON_OV0_KEY_CNTL, RADEON_GRAPHIC_KEY_FN_EQ |
 				RADEON_VIDEO_KEY_FN_FALSE |
 				RADEON_CMP_MIX_OR);
@@ -2533,12 +2533,17 @@
     /* the only place it is documented in is in ATI source code */
     /* we need twice as much space for 4 tap filtering.. */
     /* under special circumstances turn on 4 tap filtering */
-    if(!is_rgb && (step_by_y==1) && (step_by_uv==1) && (h_inc < (1<<12)) && (deinterlacing_method!=METHOD_WEAVE) 
+    /* disable this code for now as it has a DISASTROUS effect on image quality when upscaling
+       at least on rv250 (only as long as the drw_w*2 <=... requirement is still met of course) */
+#if 0
+    if(!is_rgb && (step_by_y==1) && (step_by_uv==1) && (h_inc < (1<<12))
+       && (deinterlacing_method!=METHOD_WEAVE)
        && (drw_w*2 <= pPriv->overlay_scaler_buffer_width)){
         step_by_y=0;
         step_by_uv=1;
         h_inc_uv = h_inc;
         }
+#endif
 
     /* keep everything in 16.16 */
 
@@ -2569,22 +2574,11 @@
     left = (left >> 16) & 7;
 
     RADEONWaitForFifo(pScrn, 2);
-    OUTREG(RADEON_OV0_REG_LOAD_CNTL, 1);
+    OUTREG(RADEON_OV0_REG_LOAD_CNTL, RADEON_REG_LD_CTL_LOCK);
     if (info->accelOn) RADEON_SYNC(info, pScrn);
-    while(!(INREG(RADEON_OV0_REG_LOAD_CNTL) & (1 << 3)));
+    while(!(INREG(RADEON_OV0_REG_LOAD_CNTL) & RADEON_REG_LD_CTL_LOCK_READBACK));
 
-    dsr=(double)(1<<0xC)/h_inc;
-    if(dsr<0.25)dsr=0.25;
-    if(dsr>1.0)dsr=1.0;
-    tap_set=(int)((dsr-0.25)*100);
-    for(i=0;i<5;i++){
-	    OUTREG(RADEON_OV0_FOUR_TAP_COEF_0+i*4, (TapCoeffs[tap_set].coeff[i][0] &0xf) | 
-	    	((TapCoeffs[tap_set].coeff[i][1] &0x7f)<<8) | 
-	    	((TapCoeffs[tap_set].coeff[i][2] &0x7f)<<16) | 
-	    	((TapCoeffs[tap_set].coeff[i][3] &0xf)<<24));
-		}
-
-    RADEONWaitForFifo(pScrn, 14);
+    RADEONWaitForFifo(pScrn, 10);
     OUTREG(RADEON_OV0_H_INC, h_inc | ((h_inc_uv >> 1) << 16));
     OUTREG(RADEON_OV0_STEP_BY, step_by_y | (step_by_uv << 8));
 
@@ -2623,7 +2617,7 @@
                                       ((dstBox->y1*y_mult) << 16)));
         OUTREG(RADEON_OV1_Y_X_END,   ((dstBox->x2 + x_off) |
                                       ((dstBox->y2*y_mult) << 16)));
-        scaler_src = (1 << 14);
+        scaler_src = RADEON_SCALER_CRTC_SEL;
     } else {
 	OUTREG(RADEON_OV0_Y_X_START, ((dstBox->x1 + x_off) |
 				      (((dstBox->y1*y_mult) + y_off) << 16)));
@@ -2632,7 +2626,9 @@
 	scaler_src = 0;
     }
 
-
+    /* program the tap coefficients for better downscaling quality.
+       Could do slightly better by using hardcoded coefficients for one axis
+       in case only the other axis is downscaled (see RADEON_OV0_FILTER_CNTL) */
     dsr=(double)(1<<0xC)/h_inc;
     if(dsr<0.25)dsr=0.25;
     if(dsr>1.0)dsr=1.0;
@@ -2669,31 +2665,26 @@
         | RADEON_SCALER_ENABLE | RADEON_SCALER_SMART_SWITCH | (0x7f<<16) | scaler_src;
    switch(id){
         case FOURCC_UYVY:
-                OUTREG(RADEON_OV0_SCALE_CNTL, RADEON_SCALER_SOURCE_YVYU422 | scale_cntl);
-                break;
+		scale_cntl |= RADEON_SCALER_SOURCE_YVYU422;
         case FOURCC_RGB24:
         case FOURCC_RGBA32:
-                OUTREG(RADEON_OV0_SCALE_CNTL, RADEON_SCALER_SOURCE_32BPP | scale_cntl | 0x10000000);
-                break;
-        case FOURCC_RGBT16:
-                OUTREG(RADEON_OV0_SCALE_CNTL, RADEON_SCALER_SOURCE_16BPP 
-                        | 0x10000000 
-                        | scale_cntl);
-                break;
+		scale_cntl |= RADEON_SCALER_SOURCE_32BPP | RADEON_SCALER_LIN_TRANS_BYPASS;
+		break;
         case FOURCC_RGB16:
-                OUTREG(RADEON_OV0_SCALE_CNTL, RADEON_SCALER_SOURCE_16BPP 
-                        | 0x10000000 
-                        | scale_cntl);
-                break;
+		scale_cntl |= RADEON_SCALER_SOURCE_16BPP | RADEON_SCALER_LIN_TRANS_BYPASS;
+		break;
+        case FOURCC_RGBT16:
+		scale_cntl |= RADEON_SCALER_SOURCE_15BPP | RADEON_SCALER_LIN_TRANS_BYPASS;
+		break;
         case FOURCC_YUY2:
         case FOURCC_YV12:
         case FOURCC_I420:
         default:
-                OUTREG(RADEON_OV0_SCALE_CNTL,  RADEON_SCALER_SOURCE_VYUY422 
-                        | ((info->ChipFamily>=CHIP_FAMILY_R200) ? RADEON_SCALER_TEMPORAL_DEINT :0) 
-                        | scale_cntl);
-        }
-
+		scale_cntl |= RADEON_SCALER_SOURCE_VYUY422
+			| ((info->ChipFamily >= CHIP_FAMILY_R200) ? RADEON_SCALER_TEMPORAL_DEINT : 0);
+		break;
+    }
+    OUTREG(RADEON_OV0_SCALE_CNTL, scale_cntl);
     OUTREG(RADEON_OV0_REG_LOAD_CNTL, 0);
 }
 
@@ -2783,11 +2774,8 @@
    	dstPitch=(width*4+0x0f)&(~0x0f);
 	srcPitch=width*4;
 	break;
-   case FOURCC_RGBT16:
-   	dstPitch=(width*2+0x0f)&(~0x0f);
-	srcPitch=(width*2+3)&(~0x03);
-	break;
    case FOURCC_RGB16:
+   case FOURCC_RGBT16:
    	dstPitch=(width*2+0x0f)&(~0x0f);
 	srcPitch=(width*2+3)&(~0x03);
 	break;
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_vip.c xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_vip.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/radeon_vip.c	2005-09-06 12:03:19.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/radeon_vip.c	2006-03-12 07:57:12.000000000 +0100
@@ -10,7 +10,7 @@
 #include "radeon_video.h"
 
 #include "xf86.h"
-#include "xf86PciInfo.h"
+#include "atipciids.h"
 
 #include "generic_bus.h"
 #include "theatre_reg.h"
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre200.c xf86-video-ati-X11R7.0-6.5.7.3/src/theatre200.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre200.c	2005-11-07 20:28:40.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/theatre200.c	2005-11-07 20:28:40.000000000 +0100
@@ -1,5 +1,5 @@
 /*************************************************************************************
- * $Id: theatre200.c,v 1.5 2005/11/07 19:28:40 bogdand Exp $
+ * $Id: theatre200.c,v 1.4 2005/08/28 18:00:23 bogdand Exp $
  * 
  * Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
  *
@@ -23,9 +23,6 @@
  * authorization from the author.
  *
  * $Log: theatre200.c,v $
- * Revision 1.5  2005/11/07 19:28:40  bogdand
- * Replaced the variadic macros(gcc) by macros according to C99 standard
- *
  * Revision 1.4  2005/08/28 18:00:23  bogdand
  * Modified the licens type from GPL to a X/MIT one
  *
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre200.h xf86-video-ati-X11R7.0-6.5.7.3/src/theatre200.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre200.h	2005-12-08 18:54:40.000000000 +0100
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/theatre200.h	2005-12-08 18:54:40.000000000 +0100
@@ -1,5 +1,5 @@
 /*************************************************************************************
- * $Id: theatre200.h,v 1.5 2005/12/08 17:54:40 kem Exp $
+ * $Id: theatre200.h,v 1.4 2005/11/07 19:28:40 bogdand Exp $
  * 
  * Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
  *
@@ -23,9 +23,6 @@
  * authorization from the author.
  *
  * $Log: theatre200.h,v $
- * Revision 1.5  2005/12/08 17:54:40  kem
- * 	Allow hard-coded paths to be configurable.
- *
  * Revision 1.4  2005/11/07 19:28:40  bogdand
  * Replaced the variadic macros(gcc) by macros according to C99 standard
  *
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre200_module.c xf86-video-ati-X11R7.0-6.5.7.3/src/theatre200_module.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre200_module.c	2005-07-11 04:29:45.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/theatre200_module.c	2006-01-13 02:37:43.000000000 +0100
@@ -13,7 +13,7 @@
         MODULEVENDORSTRING,
         MODINFOSTRING1,
         MODINFOSTRING2,
-        XF86_VERSION_CURRENT,
+        XORG_VERSION_CURRENT,
         1, 0, 0,
         ABI_CLASS_VIDEODRV,             /* This needs the video driver ABI */
         ABI_VIDEODRV_VERSION,
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre_detect.c xf86-video-ati-X11R7.0-6.5.7.3/src/theatre_detect.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre_detect.c	2005-08-28 20:00:23.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/theatre_detect.c	2005-08-28 20:00:23.000000000 +0200
@@ -1,5 +1,5 @@
 /*************************************************************************************
- * $Id: theatre_detect.c,v 1.4 2005/08/28 18:00:23 bogdand Exp $
+ * $Id: theatre_detect.c,v 1.3 2005/07/11 02:29:45 ajax Exp $
  * 
  * Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
  *
@@ -23,9 +23,6 @@
  * authorization from the author.
  *
  * $Log: theatre_detect.c,v $
- * Revision 1.4  2005/08/28 18:00:23  bogdand
- * Modified the licens type from GPL to a X/MIT one
- *
  * Revision 1.3  2005/07/11 02:29:45  ajax
  * Prep for modular builds by adding guarded #include "config.h" everywhere.
  *
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre_detect.h xf86-video-ati-X11R7.0-6.5.7.3/src/theatre_detect.h
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre_detect.h	2005-08-28 20:00:23.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/theatre_detect.h	2005-08-28 20:00:23.000000000 +0200
@@ -1,5 +1,5 @@
 /*************************************************************************************
- * $Id: theatre_detect.h,v 1.3 2005/08/28 18:00:23 bogdand Exp $
+ * $Id: theatre_detect.h,v 1.2 2005/07/01 22:43:11 daniels Exp $
  * 
  * Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
  *
@@ -23,9 +23,6 @@
  * authorization from the author.
  *
  * $Log: theatre_detect.h,v $
- * Revision 1.3  2005/08/28 18:00:23  bogdand
- * Modified the licens type from GPL to a X/MIT one
- *
  * Revision 1.2  2005/07/01 22:43:11  daniels
  * Change all misc.h and os.h references to <X11/foo.h>.
  *
diff -ru xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre_detect_module.c xf86-video-ati-X11R7.0-6.5.7.3/src/theatre_detect_module.c
--- xf86-video-ati-X11R7.0-6.5.7.3.orig/src/theatre_detect_module.c	2005-07-11 04:29:45.000000000 +0200
+++ xf86-video-ati-X11R7.0-6.5.7.3/src/theatre_detect_module.c	2006-01-13 02:37:43.000000000 +0100
@@ -17,7 +17,7 @@
         MODULEVENDORSTRING,
         MODINFOSTRING1,
         MODINFOSTRING2,
-        XF86_VERSION_CURRENT,
+        XORG_VERSION_CURRENT,
         1, 0, 0,
         ABI_CLASS_VIDEODRV,             /* This needs the video driver ABI */
         ABI_VIDEODRV_VERSION,
