Index: tcpdump-3.9.5-trunk/interface.h
===================================================================
--- tcpdump-3.9.5-trunk.orig/interface.h
+++ tcpdump-3.9.5-trunk/interface.h
@@ -197,6 +197,8 @@ extern u_int arcnet_if_print(const struc
 extern u_int arcnet_linux_if_print(const struct pcap_pkthdr *, const u_char *);
 extern void ether_print(const u_char *, u_int, u_int);
 extern u_int ether_if_print(const struct pcap_pkthdr *, const u_char *);
+extern void can_print(const u_char *, u_int, u_int);
+extern u_int can_if_print(const struct pcap_pkthdr *, const u_char *);
 extern u_int token_print(const u_char *, u_int, u_int);
 extern u_int token_if_print(const struct pcap_pkthdr *, const u_char *);
 extern void fddi_print(const u_char *, u_int, u_int);
Index: tcpdump-3.9.5-trunk/ipproto.h
===================================================================
--- tcpdump-3.9.5-trunk.orig/ipproto.h
+++ tcpdump-3.9.5-trunk/ipproto.h
@@ -37,6 +37,8 @@
  * $FreeBSD: src/sys/netinet/in.h,v 1.38.2.3 1999/08/29 16:29:34 peter Exp $
  */
 
+#include "netdissect.h"
+
 extern struct tok ipproto_values[];
 
 #ifndef IPPROTO_IP
Index: tcpdump-3.9.5-trunk/Makefile.in
===================================================================
--- tcpdump-3.9.5-trunk.orig/Makefile.in
+++ tcpdump-3.9.5-trunk/Makefile.in
@@ -87,7 +87,7 @@ CSRC =	addrtoname.c cpack.c gmpls.c oui.
 	print-slow.c print-snmp.c print-stp.c print-sunatm.c print-sunrpc.c \
 	print-symantec.c print-syslog.c print-tcp.c print-telnet.c print-tftp.c \
 	print-timed.c print-token.c print-udp.c print-vjc.c print-vrrp.c \
-	print-wb.c print-zephyr.c setsignal.c tcpdump.c util.c
+	print-wb.c print-zephyr.c setsignal.c tcpdump.c util.c print-can.c
 
 LOCALSRC = @LOCALSRC@
 GENSRC = version.c
Index: tcpdump-3.9.5-trunk/print-can.c
===================================================================
--- /dev/null
+++ tcpdump-3.9.5-trunk/print-can.c
@@ -0,0 +1,441 @@
+/*
+ * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#ifndef lint
+static const char rcsid[] _U_ =
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ether.c,v 1.95 2005/04/06 21:32:39 mcr Exp $ (LBL)";
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <tcpdump-stdinc.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pcap.h>
+
+#include "interface.h"
+#include "addrtoname.h"
+#include "ethertype.h"
+
+#include "ether.h"
+#include "sll.h"
+#include "extract.h"
+
+void
+can_print(const u_char *p, u_int length, u_int caplen)
+{
+	int payloadlen;
+	int n;
+
+	/* 32 bit ID, this can be an 29 bit extended address, or a 9 bit address */
+	printf("ID:%08x ", *((u_int*)p));
+	p += 4;
+
+	/* 32bit ??? payload len */
+	payloadlen = *((u_int*)p);
+	printf("PL_LEN:%d ", payloadlen);
+	p += 4;
+
+	if (payloadlen > 8)
+		payloadlen = 8;
+
+	printf("PAYLOAD: ");
+	/* payload */
+	for (n=0;n < payloadlen; n++) {
+		printf("0x%02x ", *p);
+		p++;
+	}
+}
+
+static const struct tok sll_pkttype_values[] = {
+    { LINUX_SLL_HOST, "In" },
+    { LINUX_SLL_BROADCAST, "B" },
+    { LINUX_SLL_MULTICAST, "M" },
+    { LINUX_SLL_OTHERHOST, "P" },
+    { LINUX_SLL_OUTGOING, "Out" },
+    { 0, NULL}
+};
+
+/*
+ * This is the top level routine of the printer.  'p' points
+ * to the ether header of the packet, 'h->ts' is the timestamp,
+ * 'h->len' is the length of the packet off the wire, and 'h->caplen'
+ * is the number of bytes actually captured.
+ */
+u_int
+can_if_print(const struct pcap_pkthdr *h, const u_char *p)
+{
+	u_int len, caplen;
+
+/*
+        u_int16_t       sll_pkttype;    / * packet type * /
+        u_int16_t       sll_hatype;     / * link-layer address type * /
+        u_int16_t       sll_halen;      / * link-layer address length * /
+        u_int8_t        sll_addr[SLL_ADDRLEN];  / * link-layer address * /
+        u_int16_t       sll_protocol;   / * protocol * /
+*/
+
+
+	printf("CAN %3s ",tok2str(sll_pkttype_values,"?",EXTRACT_16BITS(p)));
+	p += 16;
+	len = h->len - 16;
+	caplen = h->len - 16;
+
+	can_print(p, h->len, h->caplen);
+
+	return 0;
+}
+
+
+struct can_filter_range {
+	u_int start_id;
+	u_int end_id;
+};
+
+struct can_filter_onchange_entry {
+	u_int id;
+	u_int payload_len;
+	u_char payload[8];
+};
+
+static struct can_filter_onchange_entry* onchange_entry_table = NULL;
+static size_t onchange_entry_table_size = 0;
+
+static struct can_filter_range* range_table = NULL;
+static size_t range_table_size = 0;
+
+static struct can_filter_range* onchange_range_table = NULL;
+static size_t onchange_range_table_size = 0;
+
+static struct can_filter_range* discard_range_table = NULL;
+static size_t discard_range_table_size = 0;
+
+static int entry_compare(const void* p_key, const void* p_list)
+{
+	const struct can_filter_onchange_entry* e_key = (const struct can_filter_onchange_entry*)p_key;
+	const struct can_filter_onchange_entry* e_list = (const struct can_filter_onchange_entry*)p_list;
+
+	if (e_key->id < e_list->id)
+		return -1;
+
+	if (e_key->id > e_list->id)
+		return 1;
+
+	return 0;
+}
+
+
+static int search_range_compare(const void* p_key, const void* p_list)
+{
+	const struct can_filter_range* r_key = (const struct can_filter_range*)p_key;
+	const struct can_filter_range* r_list = (const struct can_filter_range*)p_list;
+
+	if (r_key->start_id < r_list->start_id)
+		return -1;
+
+	if (r_key->start_id > r_list->end_id)
+		return 1;
+
+	return 0;
+}
+
+static int sort_range_compare(const void* p_key, const void* p_list)
+{
+	const struct can_filter_range* r_key = (const struct can_filter_range*)p_key;
+	const struct can_filter_range* r_list = (const struct can_filter_range*)p_list;
+
+	if (r_key->start_id < r_list->start_id)
+		return -1;
+
+	if (r_key->start_id > r_list->start_id)
+		return 1;
+
+	if (r_key->end_id < r_list->end_id)
+		return -1;
+
+	if (r_key->end_id > r_list->end_id)
+		return 1;
+
+	return 0;
+}
+
+
+static int count_args(const char* filter)
+{
+	int i;
+	int count = 1;
+
+	/* count the number of ID's */
+	for (i=0;i < strlen(filter);i++)
+		if (filter[i] == ':')
+			count++;
+
+	return count;
+}
+
+static int parse_args(const char* filter, struct can_filter_range* range_table, size_t range_table_size)
+{
+	int len = strlen(filter);
+	int i,b,r,single;
+	char buffer[16];
+	char* tmp;
+	char c;
+	u_int id;
+
+	r = 0;
+	b = 0;
+	single = 1;
+	for (i=0; i <= len && r < range_table_size; i++) {
+		c = filter[i];
+
+		switch(c) {
+		case '\0':
+		case ':':
+			buffer[b] = 0;
+			id = strtol(buffer, &tmp, 0);
+			if (tmp[0] != '\0' || tmp == buffer) {
+				error("CAN filter parse error in: %s\n                                    % *s\n", filter, i, "^");
+				return -1;
+			}
+
+			if (single)
+				range_table[r].start_id = id;
+
+			if (id < range_table[r].start_id) {
+				range_table[r].end_id = range_table[r].start_id;
+				range_table[r].start_id = id;
+			} else {
+				range_table[r].end_id = id;
+			}
+			single = 1;
+			b = 0;
+			r++;
+			break;
+
+		case '-':
+			if (!single) {
+				error("CAN filter parse error in: %s\n                                    % *s\n", filter, i+1, "^");
+				return -1;
+			}
+
+			buffer[b] = 0;
+			id = strtol(buffer, &tmp, 0);
+			if (tmp[0] != '\0' || tmp == buffer) {
+				error("CAN filter parse error in: %s\n                                    % *s\n", filter, i, "^");
+				return -1;
+			}
+			range_table[r].start_id = id;
+			b = 0;
+			single = 0;
+			break;
+
+		default:
+			buffer[b++] = c;
+			if (b > 15) {
+				error("CAN filter parse error in: %s\n                                    % *s\n", filter, i, "^");
+				return -1;
+			}
+
+			break;
+		}
+	}
+
+	/* now sort the lookup table */
+
+	qsort(range_table, range_table_size, sizeof(struct can_filter_range), sort_range_compare );
+
+	return 0;
+}
+
+
+/* filter should be in the format x:x:x:x:x  */
+int
+init_can_filter(const char* filter)
+{
+	if (range_table != 0)
+		return -1;
+
+	range_table_size = count_args(filter);
+
+	range_table = (struct can_filter_range*) malloc( range_table_size * sizeof(struct can_filter_range));
+
+	if (range_table == NULL)
+		return -1;
+
+	return parse_args(filter, range_table, range_table_size);
+}
+
+int
+init_can_filter_onchange(const char* filter)
+{
+	if (onchange_range_table != 0)
+		return -1;
+
+	onchange_range_table_size = count_args(filter);
+
+	onchange_range_table = (struct can_filter_range*) malloc( onchange_range_table_size * sizeof(struct can_filter_range));
+
+	if (onchange_range_table == NULL)
+		return -1;
+
+	return parse_args(filter, onchange_range_table, onchange_range_table_size);
+}
+
+int
+init_can_filter_discard(const char* filter)
+{
+	if (discard_range_table != 0)
+		return -1;
+
+	discard_range_table_size = count_args(filter);
+
+	discard_range_table = (struct can_filter_range*) malloc( discard_range_table_size * sizeof(struct can_filter_range));
+
+	if (discard_range_table == NULL)
+		return -1;
+
+	return parse_args(filter, discard_range_table, discard_range_table_size);
+}
+
+static struct can_filter_onchange_entry*
+find_entry(u_int id)
+{
+	struct can_filter_onchange_entry* res = NULL;
+	struct can_filter_onchange_entry key;
+
+	/* set search key */
+	key.id = id;
+
+	if (onchange_entry_table != NULL)
+		res = (struct can_filter_onchange_entry*)bsearch(&key, onchange_entry_table,
+			onchange_entry_table_size, sizeof(struct can_filter_onchange_entry), entry_compare );
+
+	if (res != NULL)
+		return res;
+
+	/* not found, so add it */
+
+	onchange_entry_table_size++;
+	onchange_entry_table = realloc(onchange_entry_table, onchange_entry_table_size );
+	if (onchange_entry_table == NULL) {
+		/* error */
+		exit(-1);
+	}
+
+	res = &(onchange_entry_table[onchange_entry_table_size-1]);
+	res->id = id;
+	res->payload_len = 0xFFFFFFFF;
+
+	/* now resort the list again */
+	qsort(onchange_entry_table, onchange_entry_table_size, sizeof(struct can_filter_onchange_entry), entry_compare );
+
+
+	/* after the sorting the pointers have changed, so res isn't valid anymore */
+
+	res = (struct can_filter_onchange_entry*)bsearch(&key, onchange_entry_table,
+			onchange_entry_table_size, sizeof(struct can_filter_onchange_entry), entry_compare );
+
+	return res;
+}
+
+static id_in_range(u_int id, struct can_filter_range* range_table, size_t range_table_size)
+{
+	struct can_filter_range* res;
+	struct can_filter_range key;
+
+	if (range_table == NULL)
+		return 0;
+
+	key.start_id = id;
+	key.end_id = id;
+
+	res = (struct can_filter_range*)bsearch(&key, range_table, range_table_size,
+						sizeof(struct can_filter_range), search_range_compare );
+
+	return (res == NULL) ? 0 : 1;
+}
+
+
+
+/* filter CAN  messages, return 1 when the packet should be filtered out (ignored) */
+int
+filter_can(const struct pcap_pkthdr *h, const u_char *p)
+{
+	struct can_filter_onchange_entry* e;
+	u_int id;
+	u_int payload_len;
+
+	/* skip the header */
+	p += 16;
+	/* get ID */
+	id = *((u_int*)p);
+	p += 4;
+
+	payload_len = *((u_int*)p);
+	p += 4;
+
+	if (payload_len > 8)
+		payload_len = 8;
+
+
+	if (discard_range_table != NULL && id_in_range(id, discard_range_table, discard_range_table_size) == 1)
+		return 1;
+
+	if (id_in_range(id, onchange_range_table, onchange_range_table_size) == 1) {
+		e = find_entry(id);
+		if (e == NULL)
+			return 0;
+
+		/* compare payload len */
+		if (payload_len != e->payload_len) {
+			e->payload_len = payload_len;
+			memcpy(e->payload, p, payload_len);
+			/* packets not the same, so do not filter */
+			return 0;
+		}
+
+		/* len is the same, check payload */
+		if (memcmp(e->payload, p, payload_len) != 0) {
+			memcpy(e->payload, p, payload_len);
+			/* packets not the same, so do not filter */
+			return 0;
+		}
+
+		return 1;
+	}
+
+	if (range_table == NULL || id_in_range(id, range_table, range_table_size) == 1)
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * Local Variables:
+ * c-style: whitesmith
+ * c-basic-offset: 8
+ * End:
+ */
+
Index: tcpdump-3.9.5-trunk/tcpdump.c
===================================================================
--- tcpdump-3.9.5-trunk.orig/tcpdump.c
+++ tcpdump-3.9.5-trunk/tcpdump.c
@@ -65,6 +65,7 @@ extern int SIZE_BUF;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <getopt.h>
 #ifndef WIN32
 #include <pwd.h>
 #include <grp.h>
@@ -79,6 +80,8 @@ extern int SIZE_BUF;
 #include "gmt2local.h"
 #include "pcap-missing.h"
 
+#include "sll.h"
+
 netdissect_options Gndo;
 netdissect_options *gndo = &Gndo;
 
@@ -113,6 +116,15 @@ static void droproot(const char *, const
 static void ndo_error(netdissect_options *ndo, const char *fmt, ...);
 static void ndo_warning(netdissect_options *ndo, const char *fmt, ...);
 
+/* filter CAN  messages, return 1 when the packet should be filtered out (ignored) */
+extern int filter_can(const struct pcap_pkthdr *, const u_char *);
+/* setup table */
+extern int init_can_filter(const char* filter);
+extern int init_can_filter_onchange(const char* filter);
+extern int init_can_filter_discard(const char* filter);
+
+
+
 #ifdef SIGINFO
 RETSIGTYPE requestinfo(int);
 #endif
@@ -268,6 +280,9 @@ static struct printer printers[] = {
 #ifdef DLT_MFR
 	{ mfr_if_print, DLT_MFR },
 #endif
+#ifdef DLT_LINUX_CAN
+	{ can_if_print,		DLT_LINUX_CAN },
+#endif
 	{ NULL,			0 },
 };
 
@@ -377,7 +392,7 @@ droproot(const char *username, const cha
 		fprintf(stderr, "tcpdump: Chroot without dropping root is insecure\n");
 		exit(1);
 	}
-	
+
 	pw = getpwnam(username);
 	if (pw) {
 		if (chroot_dir) {
@@ -390,7 +405,7 @@ droproot(const char *username, const cha
 		if (initgroups(pw->pw_name, pw->pw_gid) != 0 ||
 		    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0) {
 			fprintf(stderr, "tcpdump: Couldn't change to '%.32s' uid=%lu gid=%lu: %s\n",
-			    username, 
+			    username,
 			    (unsigned long)pw->pw_uid,
 			    (unsigned long)pw->pw_gid,
 			    pcap_strerror(errno));
@@ -432,7 +447,7 @@ MakeFilename(char *buffer, char *orig_na
 static int tcpdump_printf(netdissect_options *ndo _U_,
 			  const char *fmt, ...)
 {
-  
+
   va_list args;
   int ret;
 
@@ -479,7 +494,7 @@ main(int argc, char **argv)
 	gndo->ndo_error=ndo_error;
 	gndo->ndo_warning=ndo_warning;
 	gndo->ndo_snaplen = DEFAULT_SNAPLEN;
-  
+
 	cnt = -1;
 	device = NULL;
 	infile = NULL;
@@ -498,9 +513,39 @@ main(int argc, char **argv)
 #endif
 
 	opterr = 0;
-	while (
-	    (op = getopt(argc, argv, "aA" B_FLAG "c:C:d" D_FLAG "eE:fF:i:lLm:M:nNOpqr:Rs:StT:u" U_FLAG "vw:W:xXy:YZ:")) != -1)
+	while (1) {
+		int option_index = 0;
+		static struct option long_options[] = {
+			{"canfilter", 1, NULL, 0},
+			{"canfilter-discard", 1, NULL, 0},
+			{"canfilter-onchange", 1, NULL, 0},
+			{NULL, 0, NULL, 0}
+		};
+
+		op = getopt_long(argc, argv, "aA" B_FLAG "c:C:d" D_FLAG "eE:fF:i:lLm:M:nNOpqr:Rs:StT:u" U_FLAG "vw:W:xXy:YZ:",
+					long_options, &option_index);
+		if (op == -1)
+			break;
+
 		switch (op) {
+		case 0:	/* a long option */
+			switch (option_index) {
+			case 0: /* canfilter */
+				if (init_can_filter(optarg) < 0)
+					error("Could not initialize CAN filters");
+				break;
+			case 1: /*canfilter-discard */
+				if (init_can_filter_discard(optarg) < 0)
+					error("Could not initialize CAN discard filters");
+				break;
+			case 2: /* canfilter-onchange */
+				if (init_can_filter_onchange(optarg) < 0)
+					error("Could not initialize CAN onchange filters ");
+				break;
+			default:
+				break;
+			};
+			break;
 
 		case 'a':
 			/* compatibility for old -a */
@@ -576,7 +621,7 @@ main(int argc, char **argv)
 		case 'i':
 			if (optarg[0] == '0' && optarg[1] == 0)
 				error("Invalid adapter index");
-			
+
 #ifdef HAVE_PCAP_FINDALLDEVS
 			/*
 			 * If the argument is a number, treat it as
@@ -742,7 +787,7 @@ main(int argc, char **argv)
 
 		case 'W':
 			Wflag = atoi(optarg);
-			if (Wflag < 0) 
+			if (Wflag < 0)
 				error("invalid number of output files %s", optarg);
 			WflagChars = getWflagChars(Wflag);
 			break;
@@ -793,6 +838,7 @@ main(int argc, char **argv)
 			usage();
 			/* NOTREACHED */
 		}
+	}
 
 	switch (tflag) {
 
@@ -823,7 +869,7 @@ main(int argc, char **argv)
 #ifdef WITH_USER
 	/* if run as root, prepare for dropping root privileges */
 	if (getuid() == 0 || geteuid() == 0) {
-		/* Run with '-Z root' to restore old behaviour */ 
+		/* Run with '-Z root' to restore old behaviour */
 		if (!username)
 			username = WITH_USER;
 	}
@@ -880,7 +926,7 @@ main(int argc, char **argv)
 			fprintf(stderr, "%s: listening on %s\n", program_name, device);
 		}
 
-		fflush(stderr);	
+		fflush(stderr);
 #endif /* WIN32 */
 		*ebuf = '\0';
 		pd = pcap_open_live(device, snaplen, !pflag, 1000, ebuf);
@@ -947,13 +993,13 @@ main(int argc, char **argv)
 	}
 	init_addrtoname(localnet, netmask);
 
-#ifndef WIN32	
+#ifndef WIN32
 	(void)setsignal(SIGPIPE, cleanup);
 #endif /* WIN32 */
 	(void)setsignal(SIGTERM, cleanup);
 	(void)setsignal(SIGINT, cleanup);
 	/* Cooperate with nohup(1) */
-#ifndef WIN32	
+#ifndef WIN32
 	if ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)
 		(void)setsignal(SIGHUP, oldhandler);
 #endif /* WIN32 */
@@ -1156,6 +1202,10 @@ dump_packet_and_trunc(u_char *user, cons
 	struct dump_info *dump_info;
 	char *name;
 
+	/* filter CAN messages */
+	if (filter_can(h, sp))
+		return;
+
 	++packets_captured;
 
 	++infodelay;
@@ -1204,6 +1254,10 @@ dump_packet_and_trunc(u_char *user, cons
 static void
 dump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 {
+	/* filter CAN messages */
+	if (filter_can(h, sp))
+		return;
+
 	++packets_captured;
 
 	++infodelay;
@@ -1225,6 +1279,10 @@ print_packet(u_char *user, const struct 
 	struct print_info *print_info;
 	u_int hdrlen;
 
+	/* filter CAN messages */
+	if (filter_can(h, sp))
+		return;
+
 	++packets_captured;
 
 	++infodelay;
@@ -1417,6 +1475,12 @@ usage(void)
 	(void)fprintf(stderr,
 "\t\t[ -W filecount ] [ -y datalinktype ] [ -Z user ]\n");
 	(void)fprintf(stderr,
+"\t\t[ --canfilter <0xIDa:0xIDb:0xIDn-0xIDm...> ]\n");
+	(void)fprintf(stderr,
+"\t\t[ --canfilter-onchange <0xIDa:0xIDb:0xIDn-0xIDm...> ]\n");
+	(void)fprintf(stderr,
+"\t\t[ --canfilter-discard <0xIDa:0xIDb:0xIDn-0xIDm...> ]\n");
+	(void)fprintf(stderr,
 "\t\t[ expression ]\n");
 	exit(1);
 }
Index: tcpdump-3.9.5-trunk/VERSION
===================================================================
--- tcpdump-3.9.5-trunk.orig/VERSION
+++ tcpdump-3.9.5-trunk/VERSION
@@ -1 +1 @@
-3.9.5
+3.9.5-can3
