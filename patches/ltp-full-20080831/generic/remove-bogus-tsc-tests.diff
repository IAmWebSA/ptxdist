---
 testcases/realtime/func/Makefile                          |    1 
 testcases/realtime/func/async_handler/async_handler_tsc.c |  233 --------------
 testcases/realtime/func/measurement/Makefile              |   16 
 testcases/realtime/func/measurement/README                |    9 
 testcases/realtime/func/measurement/preempt_timing.c      |  166 ---------
 testcases/realtime/func/measurement/rdtsc-latency.c       |  153 ---------
 testcases/realtime/func/measurement/run.sh                |   19 -
 testcases/realtime/include/librttest.h                    |   28 -
 8 files changed, 625 deletions(-)

Index: ltp-full-20080831/testcases/realtime/func/Makefile
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/Makefile
+++ ltp-full-20080831/testcases/realtime/func/Makefile
@@ -7,7 +7,6 @@ SUBDIRS = \
 	gtod_latency \
 	hrtimer-prio \
 	matrix_mult \
-	measurement \
 	periodic_cpu_load \
 	pi-tests \
 	pi_perf \
Index: ltp-full-20080831/testcases/realtime/func/measurement/Makefile
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/measurement/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-
-srcdir := ../..
-include $(srcdir)/config.mk
-
-
-SRCS    = $(wildcard *.c)
-TARGETS = $(SRCS:%.c=%)
-
-all: $(TARGETS)
-
-install:
-	@set -e; for i in $(TARGETS); do ln -f $$i ../../../bin/$$i; done
-
-clean:
-	rm -f $(TARGETS) *~
-
Index: ltp-full-20080831/testcases/realtime/func/measurement/preempt_timing.c
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/measurement/preempt_timing.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/******************************************************************************
- *
- *   Copyright © International Business Machines  Corp., 2006, 2008
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * NAME
- *      preempt_timing.c
- *
- * DESCRIPTION
- *      This program indicated the preemption delays that may be encountered
- *      by realtime apps. The program runs with the scheduling policy of
- *      SCHED_FIFO at a maximum SCHED_FIFO priority. It is bound to a single
- *      processor and its address space is locked as well. It makes successive
- *      calls to the gettimeofday() function(via inlined assembly to read the
- *      TSC).The value returned between two such consecutive calls is reported 
- *	as the latency.
- *      The maximum, minimum and average delays are reported for x pairs of such
- *      calls.
- *
- * USAGE:
- *      Use run_auto.sh script in current directory to build and run test.
- *      Use "-j" to enable jvm simulator.
- *
- * AUTHOR
- *
- *
- * HISTORY
- *
- *
- *****************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sched.h>
-#include <string.h>
-#include <errno.h>
-#include <sys/mman.h>
-#include <stdint.h>
-#include <librttest.h>
-#include <libjvmsim.h>
-
-
-#define ITERATIONS 1000000ULL
-#define INTERVALS 10
-
-static int run_jvmsim=0;
-
-void usage(void)
-{
-        rt_help();
-        printf("preempt_timing specific options:\n");
-        printf("  -j            enable jvmsim\n");
-}
-
-int parse_args(int c, char *v)
-{
-
-        int handled = 1;
-        switch (c) {
-                case 'j':
-                        run_jvmsim = 1;
-                        break;
-                case 'h':
-                        usage();
-                        exit(0);
-                default:
-                        handled = 0;
-                        break;
-        }
-        return handled;
-}
-
-unsigned long long sample_list[ITERATIONS];
-int main(int argc, char *argv[])
-{
-	unsigned long long i,j, delta, min, max, avg;
-	struct sched_param param;
-	cpu_set_t mask;
-	int err;
-	max = avg = 0;
-	min = -1;
-	setup();
-
-	rt_init("jh",parse_args,argc,argv);
-
-	if (run_jvmsim) {
-		printf("jvmsim enabled\n");
-		jvmsim_init();  // Start the JVM simulation
-	} else {
-		printf("jvmsim disabled\n");
-	}
-
-	/* switch to SCHED_FIFO 99 */
-	param.sched_priority = sched_get_priority_max(SCHED_FIFO);
-	err = sched_setscheduler(0, SCHED_FIFO, &param);
-
-	/* Check that the user has the appropriate privileges */
-	if (err) {
-		if (errno == EPERM) {
-			fprintf(stderr, "This program runs with a scheduling policy of SCHED_FIFO at priority %d\n", param.sched_priority);
-			fprintf(stderr, "You don't have the necessary privileges to create such a real-time process.\n");
-		} else {
-                	fprintf(stderr, "Failed to set scheduler, errno %d\n", errno);
-		}
-		exit(1);
-	}
-
-	/* BIND TO A SINGLE CPU */
-	CPU_ZERO(&mask);
-	CPU_SET(0, &mask);
-	err = sched_setaffinity(0, sizeof(mask), &mask);
-	if (err < 0) {
-		printf("Can't set affinity: %d %s\n", err, strerror(err));
-		exit(-1);
-	}
-
-	if (mlockall(MCL_CURRENT)) {
-		fprintf(stderr, "Couldn't lock memory\n");
-		exit(1);
-	}
-
-
-	for(j=0; j < INTERVALS; j++){
-		/* Collect samples */
-		for(i = 0; i < ITERATIONS; i++)
-			rdtscll(sample_list[i]);
-
-		/* Process samples */
-		for(i = 0; i < (ITERATIONS-1); i++) {
-			delta = sample_list[i+1] - sample_list[i];
-			if (delta < min) min = delta;
-			if (delta > max) max = delta;
-			if(delta > 100000)
-				printf("maxd(%llu:%llu): %llu %llu = %llu\n", j, i,
-					sample_list[i], sample_list[i+1],
-					delta);
-			avg += delta;
-		}
-		usleep(100); /*let necessary things happen*/
-	}
-	avg /= (ITERATIONS * INTERVALS);
-
-	printf("%lld pairs of gettimeofday() calls completed\n", ITERATIONS*INTERVALS);
-	printf("Time between calls:\n");
-	printf("Minimum: %llu \n", min);
-	printf("Maximum: %llu \n", max);
-	printf("Average: %llu \n", avg);
-
-	return 0;
-}
Index: ltp-full-20080831/testcases/realtime/func/measurement/rdtsc-latency.c
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/measurement/rdtsc-latency.c
+++ /dev/null
@@ -1,153 +0,0 @@
-/******************************************************************************
- *
- *   Copyright © International Business Machines  Corp., 2006, 2008
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * NAME
- *      rdtsc-latency.c
- *
- * DESCRIPTION
- *       Simple program to measure the time between several pairs of calls to
- *       rdtsc().  Based off of gtod-latency.c
- *
- * USAGE:
- *      Use run_auto.sh script in current directory to build and run test.
- *      Use "-j" to enable jvm simulator.
- *
- * AUTHOR
- *      Darren Hart <dvhltc@us.ibm.com>
- *
- * HISTORY
- *      2006-Nov-15: Initial version by Darren Hart <dvhltc@us.ibm.com>
- *
- *****************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sched.h>
-#include <errno.h>
-#include <stdint.h>
-#include <librttest.h>
-
-#define ITERATIONS 1000000
-
-void usage(void)
-{
-        rt_help();
-        printf("rdtsc-latency specific options:\n");
-        printf(" This testcase don't expect any commandline options\n");
-}
-
-int parse_args(int c, char *v)
-{
-
-        int handled = 1;
-        switch (c) {
-                case 'h':
-                        usage();
-                        exit(0);
-                default:
-                        handled = 0;
-                        break;
-        }
-        return handled;
-}
-
-/* return difference in nanoseconds */
-unsigned long long tv_minus(struct timeval *tv_start, struct timeval *tv_end)
-{
-	unsigned long long nsecs;
-	nsecs = (tv_end->tv_sec - tv_start->tv_sec) * 1000000000ULL;
-	nsecs += (tv_end->tv_usec - tv_start->tv_usec) * 1000;
-	return nsecs;
-}
-
-
-/* calculate the tsc period */
-unsigned long long tsc_period_ps(void)
-{
-	struct timeval tv_start;
-	struct timeval tv_end;
-	unsigned long long tsc_start, tsc_end;
-
-	rdtscll(tsc_start);
-	gettimeofday(&tv_start, NULL);
-	sleep(1);
-	rdtscll(tsc_end);
-	gettimeofday(&tv_end, NULL);
-
-	return (1000*tv_minus(&tv_start, &tv_end)) / tsc_minus(tsc_start, tsc_end);
-}
-
-int main(int argc, char *argv[])
-{
-	int i, err;
-	unsigned long long deltas[ITERATIONS];
-	unsigned long long max, min, avg, tsc_a, tsc_b, tsc_period;
-	struct sched_param param;
-	setup();
-
-	rt_init("h",parse_args,argc,argv);
-
-	/* no arguments */
-	if (argc > 1) {
-		fprintf(stderr, "%s accepts no arguments\n", argv[0]);
-		exit(1);
-	}
-
-	/* switch to SCHED_FIFO 99 */
-	param.sched_priority = sched_get_priority_max(SCHED_FIFO);
-	err = sched_setscheduler(0, SCHED_FIFO, &param);
-
-	/* Check that the user has the appropriate privileges */
-	if (err) {
-		if (errno == EPERM) {
-			fprintf(stderr, "This program runs with a scheduling policy of SCHED_FIFO at priority %d\n", param.sched_priority);
-			fprintf(stderr, "You don't have the necessary privileges to create such a real-time process.\n");
-		} else {
-                	fprintf(stderr, "Failed to set scheduler, errno %d\n", errno);
-		}
-		exit(1);
-	}
-
-	/* calculate the tsc period in picoseconds */
-	tsc_period = tsc_period_ps();
-
-	/* collect ITERATIONS pairs of gtod calls */
-	max = min = avg = 0;
-	for (i = 0; i < ITERATIONS; i++) {
-		rdtscll(tsc_a);
-		rdtscll(tsc_b);
-		deltas[i] = (tsc_minus(tsc_a, tsc_b) * tsc_period) / 1000; /* tsc period is in ps */
-		if (i == 0 || deltas[i] < min) min = deltas[i];
-		if (deltas[i] > max) max = deltas[i];
-		avg += deltas[i];
-	}
-	avg /= ITERATIONS;
-
-	/* report on deltas */
-	printf("Calculated tsc period = %llu ps\n", tsc_period);
-	printf("%d pairs of rdtsc() calls completed\n", ITERATIONS);
-	printf("Time between calls:\n");
-	printf("     Max: %llu ns\n", max);
-	printf("     Min: %llu ns\n", min);
-	printf("     Avg: %llu ns\n", avg);
-
-	return 0;
-}
Index: ltp-full-20080831/testcases/realtime/func/measurement/README
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/measurement/README
+++ /dev/null
@@ -1,9 +0,0 @@
-These tests (preempt_timing and rdtsc_latency) are intended
-to be tools to diagnose problems if gtod_latency results are
-problematic.
-
-We don't run these tests by default (top level run.sh script
-will not list them, as it won't find run_auto.sh).
-
-They can be run from this test directly by invoking the
-local run.sh script.
Index: ltp-full-20080831/testcases/realtime/func/measurement/run.sh
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/measurement/run.sh
+++ /dev/null
@@ -1,19 +0,0 @@
-#! /bin/bash
-
-if [ ! $SCRIPTS_DIR ]; then
-        # assume we're running standalone
-        export SCRIPTS_DIR=../../scripts/
-fi
-
-source $SCRIPTS_DIR/setenv.sh
-
-
-# This is a temporary workaround for previous
-# loop support patch which seems to be having
-# issues right now.
-
-LOG_FILE="$LOG_DIR/$LOG_FORMAT-rdtsc-latency.log"
-$SCRIPTS_DIR/run_c_files.sh "rdtsc-latency"
-
-LOG_FILE="$LOG_DIR/$LOG_FORMAT-preempt_timing.log"
-$SCRIPTS_DIR/run_c_files.sh "preempt_timing"
Index: ltp-full-20080831/testcases/realtime/include/librttest.h
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/include/librttest.h
+++ ltp-full-20080831/testcases/realtime/include/librttest.h
@@ -96,35 +96,7 @@ typedef struct { volatile int counter; }
 
 #define PRINT_BUFFER_SIZE (1024*1024*4)
 
-/* TSC macros */
 #define ULL_MAX 18446744073709551615ULL // (1 << 64) - 1
-#if defined(__i386__)
-#define rdtscll(val) __asm__ __volatile__("rdtsc" : "=A" (val))
-#elif defined(__x86_64__)
-#define rdtscll(val)					\
-	do {						\
-		uint32_t low, high;			\
-		__asm__ __volatile__ ("rdtsc" : "=a" (low), "=d" (high)); \
-		val = (uint64_t)high << 32 | low;	\
-	} while(0)
-#elif defined(__powerpc__)
-#if defined(__powerpc64__)	/* 64bit version */
-#define rdtscll(val)					\
-	do {								\
-		__asm__ __volatile__ ("mfspr %0, 268" : "=r" (val));	\
-	} while(0)
-#else	/*__powerpc__ 32bit version */
-#define rdtscll(val)							\
-	 do {								\
-		uint32_t tbhi, tblo ;					\
-		__asm__ __volatile__ ("mftbu %0" : "=r" (tbhi));	\
-		__asm__ __volatile__ ("mftbl %0" : "=r" (tblo));	\
-		val = 1000 * ((uint64_t) tbhi << 32) | tblo;		\
-	} while(0)
-#endif
-#else
-#error
-#endif
 
 extern pthread_mutex_t _buffer_mutex;
 extern char * _print_buffer;
Index: ltp-full-20080831/testcases/realtime/func/async_handler/async_handler_tsc.c
===================================================================
--- ltp-full-20080831.orig/testcases/realtime/func/async_handler/async_handler_tsc.c
+++ /dev/null
@@ -1,233 +0,0 @@
-/******************************************************************************
- *
- *   Copyright © International Business Machines  Corp., 2006, 2008
- *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * NAME
- *     async_handler_tsc.c
- *
- * DESCRIPTION
- *     This test mimics an async event handler in a real-time JVM
- *     An async event server thread is created that goes to sleep waiting
- *     to be woken up to do some work.
- *
- *     A user thread is created that simulates the firing of an event by
- *     signalling the async handler thread to do some work.
- *
- * USAGE:
- *     Use run_auto.sh script in current directory to build and run test.
- *     Use "-j" to enable jvm simulator.
- *
- * AUTHOR
- *      Darren Hart <dvhltc@us.ibm.com> 
- *
- * HISTORY
- *    2006-Oct-20: Initial version by Darren Hart <dvhltc@us.ibm.com>
- *
- *****************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <stdint.h>
-#include <pthread.h>
-#include <librttest.h>
-#include <libjvmsim.h>
-#include <libstats.h>
-
-#define HANDLER_PRIO 98
-#define SIGNAL_PRIO 99
-#define ITERATIONS 10000000
-#define HIST_BUCKETS 100
-#define PASS_US 100
-
-nsec_t start;
-nsec_t end;
-unsigned long long tsc_period; /* in picoseconds */
-int over_20 = 0;
-int over_25 = 0;
-int over_30 = 0;
-
-#define CHILD_START   0
-#define CHILD_WAIT    1
-#define CHILD_HANDLED 2
-#define CHILD_QUIT    3
-atomic_t step;
-
-pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
-pthread_mutex_t mutex;
-
-
-static int run_jvmsim=0;
-
-void usage(void)
-{
-        rt_help();
-        printf("async_handler_tsc specific options:\n");
-        printf("  -j            enable jvmsim\n");
-}
-
-int parse_args(int c, char *v)
-{
-
-        int handled = 1;
-        switch (c) {
-                case 'j':
-                        run_jvmsim = 1;
-                        break;
-                case 'h':
-                        usage();
-                        exit(0);
-                default:
-                        handled = 0;
-                        break;
-        }
-        return handled;
-}
-
-
-/* calculate the tsc period */
-unsigned long long tsc_period_ps(void)
-{
-	nsec_t ns_start;
-	nsec_t ns_end;
-	unsigned long long tsc_start, tsc_end;
-
-	rdtscll(tsc_start);
-	ns_start = rt_gettime();
-	sleep(1);
-	rdtscll(tsc_end);
-	ns_end = rt_gettime();
-
-	return (1000*(ns_end - ns_start)) / tsc_minus(tsc_start, tsc_end);
-}
-
-void *handler_thread(void *arg)
-{
-	while (atomic_get(&step) != CHILD_QUIT) {
-		pthread_mutex_lock(&mutex);
-		atomic_set(CHILD_WAIT, &step);
-		if (pthread_cond_wait(&cond, &mutex) != 0) {
-			perror("pthead_cond_wait");
-			break;
-		}
-		rdtscll(end);
-		atomic_set(CHILD_HANDLED, &step);
-		pthread_mutex_unlock(&mutex);
-		while (atomic_get(&step) == CHILD_HANDLED)
-			usleep(10);
-	}
-	printf("handler thread exiting\n");
-	return NULL;
-}
-
-void *signal_thread(void *arg)
-{
-	int i;
-	long delta, max, min;
-	stats_container_t dat;
-	stats_container_t hist;
-
-	stats_container_init(&dat, ITERATIONS);
-	stats_container_init(&hist, HIST_BUCKETS);
-
-	min = max = 0;
-	for (i = 0; i < ITERATIONS; i++) {
-		/* wait for child to wait on cond, then signal the event */
-		while (atomic_get(&step) != CHILD_WAIT)
-			usleep(10);
-		pthread_mutex_lock(&mutex);
-		rdtscll(start);
-		if (pthread_cond_signal(&cond) != 0) {
-			perror("pthread_cond_signal");
-			atomic_set(CHILD_QUIT, &step);
-			break;
-		}
-		pthread_mutex_unlock(&mutex);
-
-		/* wait for the event handler to schedule */
-		while (atomic_get(&step) != CHILD_HANDLED)
-			usleep(10);
-		delta = (long)(tsc_period * (end - start) / 1000000);
-		if (delta > 30) {
-			over_30++;
-		} else if (delta > 25) {
-			over_25++;
-		} else if (delta > 20) {
-			over_20++;
-		}
-		dat.records[i].x = i;
-		dat.records[i].y = delta;
-		if (i == 0)
-			min = max = delta;
-		else {
-			min = MIN(min, delta);
-			max = MAX(max, delta);
-		}
-		atomic_set((i == ITERATIONS-1) ? CHILD_QUIT : CHILD_START, &step);
-	}
-	printf("recording statistics...\n");
-	printf("Minimum: %ld\n", min);
-	printf("Maximum: %ld\n", max);
-	printf("Average: %f\n", stats_avg(&dat));
-	printf("Standard Deviation: %f\n", stats_stddev(&dat));
-	stats_hist(&hist, &dat);
-	stats_container_save("samples", "Asynchronous Event Handling Latency (TSC) Scatter Plot",\
-			     "Iteration", "Latency (us)", &dat, "points");
-	stats_container_save("hist", "Asynchronous Event Handling Latency (TSC) Histogram",\
-			     "Latency (us)", "Samples", &hist, "steps");
-	printf("signal thread exiting\n");
-
-	return NULL;
-}
-
-int main(int argc, char *argv[])
-{
-	int signal_id, handler_id;
-	setup();
-
-	rt_init("jh", parse_args, argc, argv);
-
-	printf("-------------------------------\n");
-	printf("Asynchronous Event Handling Latency\n");
-	printf("-------------------------------\n\n");
-	printf("Running %d iterations\n", ITERATIONS);
-	printf("Calculating tsc period...");
-	fflush(stdout);
-	tsc_period = tsc_period_ps();
-	printf("%llu ps\n", tsc_period);
-
-	init_pi_mutex(&mutex);
-
-	atomic_set(CHILD_START, &step);
-	if (run_jvmsim) {
-                printf("jvmsim enabled\n");
-                jvmsim_init();  // Start the JVM simulation
-        } else {
-                printf("jvmsim disabled\n");
-        }
-
-	handler_id = create_fifo_thread(handler_thread, (void*)0, HANDLER_PRIO);
-	signal_id = create_fifo_thread(signal_thread, (void*)0, SIGNAL_PRIO);
-
-	join_threads();
-
-	printf("%d samples over 20 us latency\n", over_20);
-	printf("%d samples over 25 us latency\n", over_25);
-	printf("%d samples over 30 us latency\n", over_30);
-
-	return 0;
-}
