From: Robert Schwebel <r.schwebel@pengutronix.de>
Subject: [PATCH] fix mtrr.h detection for cross compilation

When cross compiling libpciaccess, we get the following error:

linux_sysfs.c:50:22: error: asm/mtrr.h: No such file or directory

This is because the handcrafted test in configure.ac incorrectly assumes
that the header file is in /usr/include, which is not the case for cross
scenarios. So the patch below uses the standard autoconf test for header
files. While being there, it fixes HAVE_MTRR to the standard
nomenclature, which is HAVE_ASM_MTRR_H.

This was reported as https://bugs.freedesktop.org/show_bug.cgi?id=17585

Signed-off-by: Robert Schwebel <r.schwebel@pengutronix.de>

---
 configure.ac      |    6 +-----
 src/linux_sysfs.c |   12 ++++++------
 2 files changed, 7 insertions(+), 11 deletions(-)

Index: libpciaccess-0.10.3/configure.ac
===================================================================
--- libpciaccess-0.10.3.orig/configure.ac
+++ libpciaccess-0.10.3/configure.ac
@@ -91,11 +91,7 @@ AM_CONDITIONAL(FREEBSD, [test "x$freebsd
 AM_CONDITIONAL(OPENBSD, [test "x$openbsd" = xyes])
 AM_CONDITIONAL(SOLARIS, [test "x$solaris" = xyes])
 
-AC_CHECK_FILE([/usr/include/asm/mtrr.h],
-              [have_mtrr_h="yes"], [have_mtrr_h="no"])
-if test "x$have_mtrr_h" = xyes; then
-    AC_DEFINE(HAVE_MTRR, 1, [Use MTRRs on mappings])
-fi
+AC_CHECK_HEADERS([asm/mtrr.h])
 
 AC_SUBST(PCIACCESS_CFLAGS)
 AC_SUBST(PCIACCESS_LIBS)
Index: libpciaccess-0.10.3/src/linux_sysfs.c
===================================================================
--- libpciaccess-0.10.3.orig/src/linux_sysfs.c
+++ libpciaccess-0.10.3/src/linux_sysfs.c
@@ -46,7 +46,7 @@
 
 #include "config.h"
 
-#ifdef HAVE_MTRR
+#ifdef HAVE_ASM_MTRR_H
 #include <asm/mtrr.h>
 #include <sys/ioctl.h>
 #endif
@@ -114,7 +114,7 @@ pci_system_linux_sysfs_create( void )
 	pci_sys = calloc( 1, sizeof( struct pci_system ) );
 	if ( pci_sys != NULL ) {
 	    pci_sys->methods = & linux_sysfs_methods;
-#ifdef HAVE_MTRR
+#ifdef HAVE_ASM_MTRR_H
 	    pci_sys->mtrr_fd = open("/proc/mtrr", O_WRONLY);
 #endif
 	    err = populate_entries(pci_sys);
@@ -513,7 +513,7 @@ pci_device_linux_sysfs_map_range(struct 
     const int open_flags = ((map->flags & PCI_DEV_MAP_FLAG_WRITABLE) != 0) 
         ? O_RDWR : O_RDONLY;
     const off_t offset = map->base - dev->regions[map->region].base_addr;
-#ifdef HAVE_MTRR
+#ifdef HAVE_ASM_MTRR_H
     struct mtrr_sentry sentry = {
 	.base = map->base,
         .size = map->size,
@@ -542,7 +542,7 @@ pci_device_linux_sysfs_map_range(struct 
 	return errno;
     }
 
-#ifdef HAVE_MTRR
+#ifdef HAVE_ASM_MTRR_H
     if ((map->flags & PCI_DEV_MAP_FLAG_CACHABLE) != 0) {
         sentry.type = MTRR_TYPE_WRBACK;
     } else if ((map->flags & PCI_DEV_MAP_FLAG_WRITE_COMBINE) != 0) {
@@ -605,7 +605,7 @@ pci_device_linux_sysfs_unmap_range(struc
 				   struct pci_device_mapping *map)
 {
     int err = 0;
-#ifdef HAVE_MTRR
+#ifdef HAVE_ASM_MTRR_H
     struct mtrr_sentry sentry = {
 	.base = map->base,
         .size = map->size,
@@ -617,7 +617,7 @@ pci_device_linux_sysfs_unmap_range(struc
     if (err)
 	return err;
     
-#ifdef HAVE_MTRR
+#ifdef HAVE_ASM_MTRR_H
     if ((map->flags & PCI_DEV_MAP_FLAG_CACHABLE) != 0) {
         sentry.type = MTRR_TYPE_WRBACK;
     } else if ((map->flags & PCI_DEV_MAP_FLAG_WRITE_COMBINE) != 0) {
