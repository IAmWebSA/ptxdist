Index: include/asm-arm/arch-h720x/hardware.h
===================================================================
--- a/include/asm-arm/arch-h720x/hardware.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/include/asm-arm/arch-h720x/hardware.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -145,9 +145,31 @@
 #define LCD_INTERRUPT		0x0C
 #define LCD_DBAR		0x10
 #define LCD_DCAR		0x14
+
 #define LCD_TIMING0 		0x20
+#define TM0_HBP(x)  (((x) & 0xff) << 24)
+#define TM0_HFP(x)  (((x) & 0xff) << 16)
+#define TM0_HSPW(x) (((x) & 0xff) << 8)
+#define TM0_PPL(x)  (((x) & 0x3f) << 2)
+
 #define LCD_TIMING1 		0x24
+#define TM1_VBP(x)  (((x) & 0xff) << 24)
+#define TM1_VFP(x)  (((x) & 0xff) << 16)
+#define TM1_VSPW(x) (((x) & 0x3f) << 10)
+#define TM1_LPS(x)  (((x) & 0x1ff) << 0)
+
 #define LCD_TIMING2 		0x28
+#define TM2_SKIP4  (1<<27)
+#define TM2_BCD    (1<<26)
+#define TM2_CPL(x) (((x) & 0x3ff) << 16)
+#define TM2_SLV    (1<<15)
+#define TM2_IEO    (1<<14)
+#define TM2_IPC    (1<<13)
+#define TM2_IHS    (1<<12)
+#define TM2_IVS    (1<<11)
+#define TM2_ACB(x) (((x) & 0x1f) << 6)
+#define TM2_LCS    (1<<5)
+#define TM2_PCD(x) ((x) & 0x1f)
 #define LCD_TEST		0x40
 
 /* LCD Control Bits */
Index: include/asm-arm/arch-h720x/h7202-regs.h
===================================================================
--- a/include/asm-arm/arch-h720x/h7202-regs.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/include/asm-arm/arch-h720x/h7202-regs.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -104,6 +104,7 @@
 #define ADC_BT_CTRL 		0x08
 #define ADC_MC_CTRL		0x0C
 #define ADC_STATUS		0x10
+#define ADC_ADCTDCSR		0x1c
 
 /* ADC control register bits */
 #define ADC_CR_PW_CTRL 		0x80
@@ -125,11 +126,22 @@
 #define ADC_TSCTRL_S50    	0x00
 
 /* ADC Interrupt Status Register bits */
-#define ADC_STATUS_TS_BIT	0x80
-#define ADC_STATUS_MBT_BIT	0x40
-#define ADC_STATUS_BBT_BIT	0x20
-#define ADC_STATUS_MIC_BIT	0x10
+#define ADC_STATUS_INTTB	0x80
+#define ADC_STATUS_INTMBT	0x40
+#define ADC_STATUS_INTBB	0x20
+#define ADC_STATUS_INTSD	0x10
+#define ADC_STATUS_INTTD	0x02
+#define ADC_STATUS_INTTU	0x01
 
+/* ADC tip down control status register */
+#define ADC_ADCTDCSR_TDEN	0x80
+#define ADC_ADCTDCSR_TDMSK	0x40
+#define ADC_ADCTDCSR_TUEN	0x20
+#define ADC_ADCTDCSR_TUMSK	0x10
+#define ADC_ADCTDCSR_TPSEL	0x08
+#define ADC_ADCTDCSR_TP_X	0x02
+#define ADC_ADCTDCSR_TP_Y	0x01
+
 /* Touch data registers */
 #define ADC_TS_X0X1  		0x30
 #define ADC_TS_X2X3		0x34
Index: include/asm-arm/arch-h720x/boards.h
===================================================================
--- a/include/asm-arm/arch-h720x/boards.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/include/asm-arm/arch-h720x/boards.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -25,16 +25,26 @@
 
 /* onboard LAN controller */
 # define ETH0_PHYS		0x08000000
+#endif
 
+/* Kurz Futurre Unit board specific device defines */
+#ifdef CONFIG_ARCH_KURZFU
+
+/* FLASH */
+#define FLASH_VIRT		0xd0000000
+#define FLASH_PHYS		0x00000000
+#define FLASH_SIZE		0x01000000
+
+/* onboard LAN controller */
+# define ETH0_PHYS		0x08000000
+#endif
+
+#ifdef CONFIG_CPU_H7202
 /* Touch screen defines */
-/* GPIO Port */
-#define PEN_GPIO		GPIO_B_VIRT
-/* Bitmask for pen down interrupt */
-#define PEN_INT_BIT		(1<<7)
-/* Bitmask for pen up interrupt */
-#define PEN_ENA_BIT		(1<<6)
-/* pen up interrupt */
-#define IRQ_PEN			IRQ_MUX_GPIOB(7)
+#define PEN_GPIO		GPIO_B_VIRT	/* GPIO Port */
+#define PEN_INT_BIT		(1<<7)		/* Bitmask for pen down interrupt */
+#define PEN_ENA_BIT		(1<<6)		/* Bitmask for pen up interrupt */
+#define IRQ_PEN			IRQ_CHAINED_GPIOB(7) /* pen up interrupt */
 
 #endif
 
Index: include/asm-arm/arch-h720x/serial.h
===================================================================
--- a/include/asm-arm/arch-h720x/serial.h	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/include/asm-arm/arch-h720x/serial.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,108 @@
+/*
+ * linux/include/asm-arm/arch-h72x/serial.h
+ *
+ * Copyright (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *               2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *
+ * Serial port setup for Hynix boards
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/arch/irqs.h>
+
+/*
+ * Standard COM flags
+ */
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#define RS_TABLE_SIZE
+
+/* Base clock is 3.6864 MHz */
+#define BASE_BAUD       (115200*2)
+#define EXTRA_SERIAL_PORT_DEFNS
+
+/*
+ * Board dependend defines
+ */
+#if defined (CONFIG_CPU_H7201)
+#define BASE_BAUD_P3C 	(115200)
+
+#define STD_SERIAL_PORT_DEFNS \
+	{ \
+	.baud_base	= BASE_BAUD, \
+	.port		= SERIAL0_BASE, \
+	.iomem_base     = (u8*)SERIAL0_VIRT, \
+	.io_type        = UPIO_MEM, \
+	.irq		= IRQ_UART0, \
+	.flags		= STD_COM_FLAGS, \
+	.iomem_reg_shift = 2,\
+	}, \
+	{ \
+	.baud_base	= BASE_BAUD, \
+	.port		= SERIAL1_BASE, \
+	.iomem_base     = (u8*)SERIAL1_VIRT, \
+	.io_type        = UPIO_MEM, \
+	.irq		= IRQ_UART1, \
+	.flags		= STD_COM_FLAGS, \
+	.iomem_reg_shift = 2,\
+	}
+
+#elif defined (CONFIG_CPU_H7202)
+
+#define STD_SERIAL_PORT_DEFNS_01 \
+	{ \
+	.baud_base	= BASE_BAUD, \
+	.port		= SERIAL0_BASE, \
+	.iomem_base     = (u8*)SERIAL0_VIRT, \
+	.io_type        = UPIO_MEM, \
+	.irq		= IRQ_UART0, \
+	.flags		= STD_COM_FLAGS, \
+	.iomem_reg_shift = 2,\
+	}, \
+	{ \
+	.baud_base	= BASE_BAUD, \
+	.port		= SERIAL1_BASE, \
+	.iomem_base     = (u8*)SERIAL1_VIRT, \
+	.io_type        = UPIO_MEM, \
+	.irq		= IRQ_UART1, \
+	.flags		= STD_COM_FLAGS, \
+	.iomem_reg_shift = 2,\
+	}
+#define STD_SERIAL_PORT_DEFNS_23 \
+	{ \
+	.baud_base	= BASE_BAUD, \
+	.port		= SERIAL2_BASE, \
+	.iomem_base     = (u8*)SERIAL2_VIRT, \
+	.io_type        = UPIO_MEM, \
+	.irq		= IRQ_UART2, \
+	.flags		= STD_COM_FLAGS, \
+	.iomem_reg_shift = 2,\
+	}, \
+	{ \
+	.baud_base	= BASE_BAUD, \
+	.port		= SERIAL3_BASE, \
+	.iomem_base     = (u8*)SERIAL3_VIRT, \
+	.io_type        = UPIO_MEM, \
+	.irq		= IRQ_UART3, \
+	.flags		= STD_COM_FLAGS, \
+	.iomem_reg_shift = 2,\
+	}
+
+#ifdef CONFIG_H7202_SERIAL23
+#define STD_SERIAL_PORT_DEFNS STD_SERIAL_PORT_DEFNS_01,STD_SERIAL_PORT_DEFNS_23
+#else
+#define STD_SERIAL_PORT_DEFNS STD_SERIAL_PORT_DEFNS_01
+#endif
+
+#else
+#error machine definition mismatch
+#endif
+
+/* __ASM_ARCH_SERIAL_H */
+#endif
Index: include/asm-arm/arch-h720x/h720xfb.h
===================================================================
--- a/include/asm-arm/arch-h720x/h720xfb.h	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/include/asm-arm/arch-h720x/h720xfb.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,32 @@
+/*
+ * This structure describes the machine which we are running on.
+ */
+struct h720xfb_mach_info {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	u_int pll_ctrl;
+	u_int control;
+	u_int tm2;
+
+	void (*lcd_power)(int);
+	void (*backlight_power)(int);
+};
+void set_h7202_fb_info(struct h720xfb_mach_info *hard_h720x_fb_info);
Index: include/asm-arm/arch-h720x/system.h
===================================================================
--- a/include/asm-arm/arch-h720x/system.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/include/asm-arm/arch-h720x/system.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -16,13 +16,18 @@
 
 static void arch_idle(void)
 {
+#ifdef CONFIG_H7202_USE_IDLE
 	CPU_REG (PMU_BASE, PMU_MODE) = PMU_MODE_IDLE;
-	__asm__ __volatile__(
-	"mov	r0, r0\n\t"
-	"mov	r0, r0");
+	nop();
+	nop();
+        CPU_REG (PMU_BASE, PMU_MODE) = PMU_MODE_RUN;
+	nop();
+	nop();
+#else
+	cpu_do_idle();
+#endif
 }
 
-
 static __inline__ void arch_reset(char mode)
 {
 	CPU_REG (PMU_BASE, PMU_STAT) |= PMU_WARMRESET;
Index: include/linux/serio.h
===================================================================
--- a/include/linux/serio.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/include/linux/serio.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -216,5 +216,6 @@
 #define SERIO_LKKBD	0x28
 #define SERIO_ELO	0x29
 #define SERIO_MICROTOUCH	0x30
+#define SERIO_H7202	0x31
 
 #endif
Index: include/linux/serial_core.h
===================================================================
--- a/include/linux/serial_core.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/include/linux/serial_core.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -52,6 +52,7 @@
 #define PORT_CLPS711X	33
 #define PORT_SA1100	34
 #define PORT_UART00	35
+#define PORT_H7202USB	36	/* FIXME: right here? */
 #define PORT_21285	37
 
 /* Sparc type numbers.  */
Index: README.host
===================================================================
--- a/README.host	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/README.host	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,26 @@
+Normaly this is an ARM-Kernel, because HMS720x is ARM.
+To build the whatever(i.e. mostly x86)-hostside Multiser-driver please
+apply the patch below to build the kernel in your familiar way.
+
+Benedikt "get crazy on TTY" Spranger
+
+
+Index: Makefile
+===================================================================
+--- Makefile	(revision 337)
++++ Makefile	(working copy)
+@@ -190,9 +190,12 @@
+ # Default value for CROSS_COMPILE is not to prefix executables
+ # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
+ 
+-ARCH		?= arm
+-CROSS_COMPILE	?= arm-softfloat-linux-gnu-
++ARCH		?= $(SUBARCH)
++CROSS_COMPILE	?=
+ 
++# ARCH		?= arm
++# CROSS_COMPILE	?= arm-softfloat-linux-gnu-
++
+ # Architecture as present in compile.h
+ UTS_MACHINE := $(ARCH)
+ 
Index: arch/arm/kernel/vmlinux.lds.S
===================================================================
--- a/arch/arm/kernel/vmlinux.lds.S	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/kernel/vmlinux.lds.S	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -161,7 +161,3 @@
 	.stab.indexstr 0 : { *(.stab.indexstr) }
 	.comment 0 : { *(.comment) }
 }
-
-/* those must never be empty */
-ASSERT((__proc_info_end - __proc_info_begin), "missing CPU support")
-ASSERT((__arch_info_end - __arch_info_begin), "no machine record defined")
Index: arch/arm/configs/kurzfu_defconfig
===================================================================
--- a/arch/arm/configs/kurzfu_defconfig	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/arch/arm/configs/kurzfu_defconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,782 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.13-hnx2
+# Thu Oct 13 10:23:00 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+CONFIG_ARCH_H720X=y
+# CONFIG_ARCH_AAEC2000 is not set
+
+#
+# h720x Implementations
+#
+# CONFIG_ARCH_H7201 is not set
+# CONFIG_ARCH_H7202 is not set
+CONFIG_ARCH_KURZFU=y
+CONFIG_CPU_H7202=y
+# CONFIG_H7202_SERIAL23 is not set
+# CONFIG_H7202_USE_IDLE is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM720T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_LV4T=y
+CONFIG_CPU_CACHE_V4=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WT=y
+CONFIG_CPU_TLB_V4WT=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_CAN=m
+CONFIG_CAN_RAW=m
+
+#
+# CAN Device Drivers
+#
+CONFIG_CAN_LOOPCAN=m
+# CONFIG_CAN_NIOSCAN is not set
+CONFIG_CAN_H7202=m
+# CONFIG_CAN_SJA1000 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x0
+CONFIG_MTD_PHYSMAP_LEN=0x2000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+CONFIG_CIRRUS=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=240
+CONFIG_INPUT_TSDEV_SCREEN_Y=320
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_H7202=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_H7202=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_RTC_SM8580=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_I2C_SENSOR is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_H720X=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_H7202 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+
+#
+# XFS support
+#
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
Index: arch/arm/mach-h720x/Kconfig
===================================================================
--- a/arch/arm/mach-h720x/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/mach-h720x/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -16,6 +16,13 @@
 	help
 	  Say Y here if you are using the Hynix HMS30C7202 Reference Board
 
+config ARCH_KURZFU
+	bool "Kurz Future Unit"
+	select CPU_H7202
+	depends on ARCH_H720X
+	help
+	  Say Y here if you are using the Kurz Future Unit
+
 endmenu
 
 config CPU_H7201
@@ -34,5 +41,11 @@
 	  Say Y here if you wish to use serial ports 2+3. They share their
 	  pins with the keyboard matrix controller, so you have to decide.
 
-
+config H7202_USE_IDLE
+	depends on CPU_H7202
+	bool "use idle feature on the h7202 chip"
+	help
+	  On some boards the display flickers when this feature is enabled.
+	  If you do not have such a board or do not have a display at all,
+	  say yes here
 endif
Index: arch/arm/mach-h720x/kurz-fu.c
===================================================================
--- a/arch/arm/mach-h720x/kurz-fu.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/arch/arm/mach-h720x/kurz-fu.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,186 @@
+/*
+ * linux/arch/arm/mach-h720x/h7202-eval.c
+ *
+ * Copyright (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *               2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *		 2004 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * Architecture specific stuff for Hynix HMS30C7202 development board
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/device.h>
+
+#include <asm/setup.h>
+#include <asm/types.h>
+#include <asm/mach-types.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/mach/arch.h>
+#include <asm/hardware.h>
+#include "common.h"
+
+#include <asm/arch/h720xfb.h>
+
+extern void __init init_hw_h7202(void);
+extern void __init h7202_init_irq (void);
+extern void __init h7202_init_time(void);
+extern void __init h720x_map_io(void);
+
+static struct resource cirrus_resources[] = {
+	[0] = {
+		.start	= ETH0_PHYS + 0x300,
+		.end	= ETH0_PHYS + 0x300 + 0x10,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_CHAINED_GPIOB(8),
+		.end	= IRQ_CHAINED_GPIOB(8),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cirrus_device = {
+	.name		= "cirrus-cs89x0",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(cirrus_resources),
+	.resource	= cirrus_resources,
+};
+
+static struct platform_device ts_device = {
+	.name		= "h7202ts",
+	.id		= -1,
+	.num_resources	= 0,
+	.resource	= NULL,
+};
+
+static struct resource can0_resources[] = {
+	[0] = {
+		.start	= 0x8002F000,
+		.end	= 0x8002F000 + 0x200,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_CAN0,
+		.end	= IRQ_CAN0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device can0_device = {
+	.name		= "h7202can",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(can0_resources),
+	.resource	= can0_resources,
+};
+
+static struct resource can1_resources[] = {
+	[0] = {
+		.start	= 0x80030000,
+		.end	= 0x80030000 + 0x200,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_CAN1,
+		.end	= IRQ_CAN1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device can1_device = {
+	.name		= "h7202can",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(can1_resources),
+	.resource	= can1_resources,
+};
+
+static struct resource sm8580_rtc_resources[] = {
+	[0] = {
+		.start	= 0x0c000000,
+		.end	= 0x0c00003f,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device sm8580_rtc_device = {
+	.name		= "sm8580-rtc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(sm8580_rtc_resources),
+	.resource	= sm8580_rtc_resources,
+};
+static struct platform_device *devices[] __initdata = {
+	&cirrus_device,
+	&ts_device,
+	&can0_device,
+	&can1_device,
+	&sm8580_rtc_device,
+};
+
+static void h7202_lcd_power(int on)
+{
+	printk("%s\n",__FUNCTION__);
+}
+
+static struct h720xfb_mach_info hs720x_fb_info __initdata = {
+	.pixclock	= 157500, 	.bpp		= 16,
+	.xres		= 320,		.yres		= 240,
+
+	.hsync_len	= 47,		.vsync_len	= 9,
+	.left_margin	= 19,		.upper_margin	= 15,
+	.right_margin	= 2,		.lower_margin	= 15,
+
+	.pll_ctrl = 0x00006000,
+	.control = 0x01880014,
+	.tm2 = 0x013f0023,
+
+	.lcd_power = h7202_lcd_power,
+};
+
+/*
+ * Hardware init. This is called early in initcalls
+ * Place pin inits here. So you avoid adding ugly
+ * #ifdef stuff to common drivers.
+ * Use this only, if your bootloader is not able
+ * to initialize the pins proper.
+ */
+static void __init init_kurzfu(void)
+{
+	init_hw_h7202();
+	(void) platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	/* Enable interrupt on portb bit 8 (ethernet) */
+	CPU_REG (GPIO_B_VIRT, GPIO_POL) &= ~(1 << 8);
+	CPU_REG (GPIO_B_VIRT, GPIO_EN) |= (1 << 8);
+	
+	set_h7202_fb_info(&hs720x_fb_info);
+
+	/* CAN gpios */
+	CPU_REG (GPIO_C_VIRT, GPIO_EN) &= ~(3<<1);
+	CPU_REG (GPIO_C_VIRT, GPIO_DIR) &= ~(1<<1);
+	CPU_REG (GPIO_C_VIRT, GPIO_DIR) |= (1<<2);
+	
+	CPU_REG (GPIO_E_VIRT, GPIO_EN) &= ~(3<<22);
+	CPU_REG (GPIO_E_VIRT, GPIO_DIR) |= (1<<22);
+	CPU_REG (GPIO_E_VIRT, GPIO_DIR) &= ~(1<<23);
+}
+
+MACHINE_START(FU7202, "Hynix HMS30C7202")
+	/* Maintainer: Robert Schwebel, Pengutronix */
+	.phys_ram	= 0x40000000,
+	.phys_io	= 0x80000000,
+	.io_pg_offst	= ((0xf0000000) >> 18) & 0xfffc,
+	.boot_params	= 0x40000100,
+	.map_io		= h720x_map_io,
+	.init_irq	= h7202_init_irq,
+	.timer		= &h7202_timer,
+	.init_machine	= init_kurzfu,
+MACHINE_END
Index: arch/arm/mach-h720x/h7202-eval.c
===================================================================
--- a/arch/arm/mach-h720x/h7202-eval.c	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/mach-h720x/h7202-eval.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -29,6 +29,13 @@
 #include <asm/hardware.h>
 #include "common.h"
 
+#include <asm/arch/h720xfb.h>
+
+extern void __init init_hw_h7202(void);
+extern void __init h7202_init_irq (void);
+extern void __init h7202_init_time(void);
+extern void __init h720x_map_io(void);
+
 static struct resource cirrus_resources[] = {
 	[0] = {
 		.start	= ETH0_PHYS + 0x300,
@@ -53,6 +60,27 @@
 	&cirrus_device,
 };
 
+static void h7202_lcd_power(int on)
+{
+	printk("%s\n",__FUNCTION__);
+}
+
+// FIXME: pixclock
+static struct h720xfb_mach_info hs720x_fb_info __initdata = {
+	.pixclock	= 62500, 	.bpp		= 8,
+	.xres		= 640,		.yres		= 480,
+
+	.hsync_len	= 39,		.vsync_len	= 2,
+	.left_margin	= 112,		.upper_margin	= 16,
+	.right_margin	= 15,		.lower_margin	= 0,
+
+	.pll_ctrl = 0x00006d00,
+	.control = 0x01880002,
+	.tm2 = 0x00EF0021,
+
+	.lcd_power = h7202_lcd_power,
+};
+
 /*
  * Hardware init. This is called early in initcalls
  * Place pin inits here. So you avoid adding ugly
@@ -68,6 +96,8 @@
 	/* Enable interrupt on portb bit 8 (ethernet) */
 	CPU_REG (GPIO_B_VIRT, GPIO_POL) &= ~(1 << 8);
 	CPU_REG (GPIO_B_VIRT, GPIO_EN) |= (1 << 8);
+	
+	set_h7202_fb_info(&hs720x_fb_info);
 }
 
 MACHINE_START(H7202, "Hynix HMS30C7202")
Index: arch/arm/mach-h720x/cpu-h7202.c
===================================================================
--- a/arch/arm/mach-h720x/cpu-h7202.c	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/mach-h720x/cpu-h7202.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -16,16 +16,27 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/device.h>
+#include <linux/serial_8250.h>
+
 #include <asm/types.h>
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/arch/irqs.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
-#include <linux/device.h>
-#include <linux/serial_8250.h>
+#include <asm/arch/h720xfb.h>
+
 #include "common.h"
 
+static struct h720xfb_mach_info h7202_fb_info;
+
+void __init set_h7202_fb_info(struct h720xfb_mach_info *hard_h7202_fb_info)
+{
+	memcpy(&h7202_fb_info,hard_h7202_fb_info,sizeof(struct h720xfb_mach_info));
+}
+EXPORT_SYMBOL(set_h7202_fb_info);
+
 static struct resource h7202ps2_resources[] = {
 	[0] = {
 		.start	= 0x8002c000,
@@ -46,6 +57,7 @@
 	.resource	= h7202ps2_resources,
 };
 
+/* FIXME: RSC: this one is new, check! */
 static struct plat_serial8250_port serial_platform_data[] = {
 	{
 		.membase	= (void*)SERIAL0_VIRT,
@@ -96,9 +108,39 @@
 	},
 };
 
+/* FIXME: RSC: end of new part */
+
+static struct resource h7202fb_resources[] = {
+	[0] = {
+		.start	= 0x80010000,
+		.end	= 0x800107ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_LCD,
+		.end	= IRQ_LCD,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 fb_dma_mask = ~(u64)0;
+
+static struct platform_device h720xfb_device = {
+	.name		= "h720xfb",
+	.id		= -1,
+	.dev		= {
+ 		.platform_data	= &h7202_fb_info,
+		.dma_mask	= &fb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(h7202fb_resources),
+	.resource	= h7202fb_resources,
+};
+
 static struct platform_device *devices[] __initdata = {
 	&h7202ps2_device,
 	&serial_device,
+	&h720xfb_device,
 };
 
 /* Although we have two interrupt lines for the timers, we only have one
Index: arch/arm/mach-h720x/common.c
===================================================================
--- a/arch/arm/mach-h720x/common.c	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/mach-h720x/common.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -16,6 +16,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/mman.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 
Index: arch/arm/mach-h720x/Makefile
===================================================================
--- a/arch/arm/mach-h720x/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/mach-h720x/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -12,5 +12,6 @@
 
 obj-$(CONFIG_ARCH_H7201)		+= h7201-eval.o
 obj-$(CONFIG_ARCH_H7202)		+= h7202-eval.o
+obj-$(CONFIG_ARCH_KURZFU)		+= kurz-fu.o
 obj-$(CONFIG_CPU_H7201) 		+= cpu-h7201.o
 obj-$(CONFIG_CPU_H7202) 		+= cpu-h7202.o
Index: arch/arm/mach-h720x/common.h
===================================================================
--- a/arch/arm/mach-h720x/common.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/arch/arm/mach-h720x/common.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -17,13 +17,13 @@
 extern void __init h720x_init_irq (void);
 extern void __init h720x_map_io(void);
 
-#ifdef CONFIG_ARCH_H7202
+#ifdef CONFIG_CPU_H7202
 extern struct sys_timer h7202_timer;
 extern void __init init_hw_h7202(void);
 extern void __init h7202_init_irq (void);
 extern void __init h7202_init_time(void);
 #endif
 
-#ifdef CONFIG_ARCH_H7201
+#ifdef CONFIG_CPU_H7201
 extern struct sys_timer h7201_timer;
 #endif
Index: Makefile
===================================================================
--- a/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION =
+EXTRAVERSION = -hnx3
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
@@ -190,8 +190,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= arm
+CROSS_COMPILE	?= arm-softfloat-linux-gnu-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
Index: drivers/input/serio/Kconfig
===================================================================
--- a/drivers/input/serio/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/input/serio/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -96,6 +96,10 @@
 	tristate "Intel SA1111 keyboard controller"
 	depends on SA1111
 
+config SERIO_H7202
+ 	tristate "h7202 PS/2 controller"
+ 	depends on CPU_H7202 && SERIO
+
 config SERIO_GSCPS2
 	tristate "HP GSC PS/2 keyboard and PS/2 mouse controller"
 	depends on GSC
Index: drivers/input/serio/h7202ps2.c
===================================================================
--- a/drivers/input/serio/h7202ps2.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/input/serio/h7202ps2.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,225 @@
+/*
+ * drivers/input/serio/h7202ps2.c
+ *
+ *           (C) 2004 Pengutronix
+ *           (C) 2004 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This file contains the PS/2 port driver for Hynix h7202 processors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Do not add implementations specific defines here. This files contains
+ * only defines of the onchip peripherals. Add those defines to boards.h,
+ * which is included by this file.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/arch/hardware.h>
+
+#define DRIVERNAME "h7202ps2"
+
+#define RES_SIZE 0x40
+
+struct h7202ps2_port {
+	struct serio		io;
+	struct clk		*clk;
+	unsigned char		*base;
+	unsigned int		irq;
+	unsigned int		divisor;
+	unsigned int		open;
+};
+
+static irqreturn_t h7202ps2_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct h7202ps2_port *p = (struct h7202ps2_port *)dev_id;
+	unsigned char stat, intr, data, flag;
+
+	intr = inb(p->base + PSINTR);
+	stat = inb(p->base + PSSTAT);
+	data = inb(p->base + PSDATA);
+
+	flag = ((intr & PSINTR_PAR) ? SERIO_PARITY : 0) |
+	       ((intr & PSINTR_RXTO) ? SERIO_FRAME : 0);
+
+	if(flag) {
+		serio_interrupt(&p->io, data, flag, regs);
+		return IRQ_HANDLED;
+	}
+
+	if(intr & PSINTR_RXINT)
+		serio_interrupt(&p->io, data, flag, regs);
+
+	return IRQ_HANDLED;
+}
+
+static int h7202ps2_write(struct serio *io, unsigned char val)
+{
+	u_int irq;
+	struct h7202ps2_port *p = io->port_data;
+
+	outb(val, p->base + PSDATA);
+	while (1) {
+		irq = inb(p->base + PSINTR);
+		if( irq & PSINTR_TXTO ) 
+			return SERIO_TIMEOUT;
+		if( irq & PSINTR_TXINT )
+			return 0;
+		cpu_relax();
+	}
+}
+
+static int h7202ps2_open(struct serio *io)
+{
+	struct h7202ps2_port *p = io->port_data;
+	int ret;
+
+	ret  = request_irq (p->irq, h7202ps2_irq, 0, "ps2", p);
+	if ( ret != 0) {
+		printk("%s: Could not allocate IRQ",DRIVERNAME);
+		return ret;
+	}
+	return 0;
+}
+
+static void h7202ps2_close(struct serio *io)
+{
+	struct h7202ps2_port *p = io->port_data;
+
+	free_irq(p->irq,p);
+}
+
+static int h7202ps2_probe(struct device *dev)
+{
+	struct h7202ps2_port *p;
+	int ret = 0;
+	struct resource *res;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	printk("h7202 PS/2 port driver\n");
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (!request_mem_region(res->start, RES_SIZE, DRIVERNAME)){
+		ret = -EBUSY;
+		goto out;
+	}
+	
+	p = kmalloc(sizeof(struct h7202ps2_port), GFP_KERNEL);
+	if (!p) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	memset(p, 0, sizeof(struct h7202ps2_port));
+
+	p->base	= ioremap(res->start, RES_SIZE);
+	if (!p->base) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	p->irq = platform_get_irq(pdev, 0);
+
+	dev_set_drvdata(dev, p);
+
+	int val = inl(0xf002305c);
+	outl(val & ~0x18, 0xf002305c);
+
+	outl(0xEB, p->base + PSTDLO);
+	outl(0x40, p->base + PSTPRI);
+	outl(0xff, p->base + PSTXMT);
+	outl(0xff, p->base + PSTREC);
+	outl(0x01, p->base + PSPWDN);
+
+	outl(PSCONF_LCE | PSCONF_ENABLE | PSCONF_RXINTEN, p->base + PSCONF);
+
+	p->io.id.type	= SERIO_8042;
+	p->io.write	= h7202ps2_write;
+	p->io.open	= h7202ps2_open;
+	p->io.close	= h7202ps2_close;
+	strlcpy(p->io.name, dev->bus_id, sizeof(p->io.name));
+	strlcpy(p->io.phys, dev->bus_id, sizeof(p->io.phys));
+	p->io.port_data	= p;
+	
+	serio_register_port(&p->io);
+	return 0;
+
+release:
+	release_mem_region(res->start, RES_SIZE);
+out:
+	return ret;
+}
+
+static int h7202ps2_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	struct h7202ps2_port *p = dev_get_drvdata(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	serio_unregister_port(&p->io);
+	iounmap(p->base);
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, RES_SIZE);
+	
+	kfree(p);
+
+	return 0;
+}
+
+static int h7202ps2_resume(struct device *dev, u32 level)
+{
+	struct h7202ps2_port *p = dev_get_drvdata(dev);
+
+	/* kick the serio layer to rescan this port */
+	serio_rescan(&p->io);
+
+	return 0;
+}
+
+static struct device_driver h7202ps2_driver = {
+	.name		= DRIVERNAME,
+	.bus		= &platform_bus_type,
+	.probe		= h7202ps2_probe,
+	.remove		= h7202ps2_remove,
+//	.suspend	= h7202ps2_suspend,
+	.resume		= h7202ps2_resume,
+};
+
+static int __init h7202ps2_init(void)
+{
+	return driver_register(&h7202ps2_driver);
+}
+
+static void __exit h7202ps2_exit(void)
+{
+	return driver_unregister(&h7202ps2_driver);
+}
+
+module_init(h7202ps2_init);
+module_exit(h7202ps2_exit);
+
+MODULE_AUTHOR("Sascha Hauer, Pengutronix");
+MODULE_DESCRIPTION("h7202 ps2 controller driver");
+MODULE_LICENSE("GPL");
Index: drivers/input/serio/Makefile
===================================================================
--- a/drivers/input/serio/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/input/serio/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -11,6 +11,7 @@
 obj-$(CONFIG_SERIO_CT82C710)	+= ct82c710.o
 obj-$(CONFIG_SERIO_RPCKBD)	+= rpckbd.o
 obj-$(CONFIG_SERIO_SA1111)	+= sa1111ps2.o
+obj-$(CONFIG_SERIO_H7202)	+= h7202ps2.o
 obj-$(CONFIG_SERIO_AMBAKMI)	+= ambakmi.o
 obj-$(CONFIG_SERIO_Q40KBD)	+= q40kbd.o
 obj-$(CONFIG_SERIO_98KBD)	+= 98kbd-io.o
Index: drivers/input/touchscreen/Kconfig
===================================================================
--- a/drivers/input/touchscreen/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/input/touchscreen/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -95,4 +95,17 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called hp680_ts_input.
 
+config TOUCHSCREEN_H7202
+	tristate "Hynix H7202 touchscreen driver"
+	depends on INPUT && INPUT_TOUCHSCREEN && CPU_H7202
+	select SERIO
+	help
+	  Say Y here if you have a touchscreen connected to your h7202
+	  device
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gunze.
+
 endif
Index: drivers/input/touchscreen/h7202_ts_input.c
===================================================================
--- a/drivers/input/touchscreen/h7202_ts_input.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/input/touchscreen/h7202_ts_input.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,274 @@
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/serio.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/arch/hardware.h>
+
+#define DRIVER_DESC	"Hynix h7202 touchscreen driver"
+
+struct h7202_ts {
+	struct input_dev input;
+	struct serio *serio;
+	int last_x, last_y;
+};
+
+/* Filter the adc-values, remove the peak and build average*/
+static u32 h720x_ts_filter_vals(u32 *x)
+{
+	u32 avg = x[0], tavg;
+	int i, min = 0, max = 0;;
+	
+	/* Find min / max, build total average*/
+	for (i = 1; i < 4; i++) {
+		if (x[i] > x[max]) 
+			max = i;
+		if (x[i] < x[min]) 
+			min = i;
+		avg += x[i];	
+	}
+	tavg = avg / 4;
+	/* Remove the peak value */
+	if ((x[max] - tavg) > (tavg - x[min]))
+		avg -= x[max];
+	else
+		avg -= x[min];
+		
+	return avg / 3;		
+}
+
+/* Shut down ADC, disable touch functions */
+static inline void h7202_ts_reset(void)
+{
+	CPU_REG(ADC_BASE, ADC_CR) |= ADC_CR_PW_CTRL;
+	CPU_REG(ADC_BASE, ADC_TSCTRL) &= ~(ADC_TSCTRL_INTR | ADC_TSCTRL_ENABLE);
+}
+
+static irqreturn_t h7202_pen_interrupt(int irq,
+		void *dev_id, struct pt_regs *regs)
+{
+	struct h7202_ts *ts = dev_id;
+	int x_now = 0, y_now = 0, x_rep, y_rep;
+	u32 val, x[4], y[4];
+	volatile u32 *p = (u32 *)(ADC_BASE + ADC_TS_X0X1);
+	unsigned int pressed = 1;
+
+//	printk("%s\n",__FUNCTION__);
+
+	/* Check, if this is a touch interrupt */
+	if (!(CPU_REG(ADC_BASE, ADC_STATUS) & ADC_STATUS_INTTB)) {
+		printk("%s: not for us\n",__FUNCTION__);
+		return IRQ_NONE;
+	}
+
+	/* Read adc values */
+	val = p[0];
+	x[0] = val & 0x3FF; x[1] = (val >> 16) & 0x3FF;
+	val = p[1];
+	x[2] = val & 0x3FF; x[3] = (val >> 16) & 0x3FF;
+	val = p[2];
+	y[0] = val & 0x3FF; y[1] = (val >> 16) & 0x3FF;
+	val = p[3];
+	y[2] = val & 0x3FF; y[3] = (val >> 16) & 0x3FF;
+
+	
+	/* Disable interrupt during pen down detection */
+	CPU_REG(ADC_BASE, ADC_TSCTRL) &= ~(ADC_TSCTRL_INTR | ADC_TSCTRL_ENABLE);
+	
+	/* Enable touch detection */
+	CPU_REG(PEN_GPIO, GPIO_DATA) |= PEN_ENA_BIT;
+
+	/* let it settle */
+	udelay(10);
+
+       /* Read status */
+	if (CPU_REG(PEN_GPIO, GPIO_DATA) & PEN_INT_BIT) {
+		/* Pen is up, stop adc and enable pen down interrupt */
+		CPU_REG(ADC_BASE, ADC_CR) |= ADC_CR_PW_CTRL;
+		CPU_REG(ADC_BASE, ADC_TSCTRL) &= ~(ADC_TSCTRL_INTR | ADC_TSCTRL_ENABLE);
+		CPU_REG(ADC_BASE, ADC_ADCTDCSR) = ADC_ADCTDCSR_TDEN | ADC_ADCTDCSR_TDMSK;
+		enable_irq(IRQ_PEN);
+		pressed = 0;
+	} else {
+		/* Pen is down, disable pen touch and reenable adc */
+		CPU_REG(PEN_GPIO, GPIO_DATA) &= ~PEN_ENA_BIT;
+		x_now = h720x_ts_filter_vals(x);
+		y_now = h720x_ts_filter_vals(y);
+		CPU_REG(ADC_BASE, ADC_TSCTRL) |= ADC_TSCTRL_INTR | ADC_TSCTRL_ENABLE;
+	}
+
+	/* Acknowledge the int */	
+	CPU_REG(ADC_BASE, ADC_STATUS) = ADC_STATUS_INTTB;
+
+	if(ts->last_x != -1 && abs(ts->last_x - x_now) > 80) {
+		x_rep = ts->last_x;
+	} else {
+		x_rep = x_now;
+		ts->last_x = x_now;
+	}
+
+	if(ts->last_y != -1 && abs(ts->last_y - y_now) > 80) {
+		y_rep = ts->last_y;
+	} else {
+		y_rep = y_now;
+		ts->last_y = y_now;
+	}
+
+	if(x_rep) {
+//		printk("x: %4d y %4d %s\n",x_rep,y_rep, pressed ? "pressed" : "");
+		input_report_abs(&ts->input, ABS_X, x_rep);
+		input_report_abs(&ts->input, ABS_Y, y_rep);
+		input_report_abs(&ts->input, ABS_PRESSURE, pressed ? 255 : 0);
+		input_sync(&ts->input);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t h7202_touch_interrupt(int irq,
+		void *dev_id, struct pt_regs *regs)
+{
+	struct h7202_ts *ts = dev_id;
+
+//	printk("%s\n",__FUNCTION__);
+	CPU_REG(PEN_GPIO, GPIO_DATA) &= ~PEN_ENA_BIT;
+
+	CPU_REG(ADC_BASE, ADC_STATUS) = ADC_STATUS_INTTD;
+	/* disable pen down interrupt */
+	CPU_REG(ADC_BASE, ADC_ADCTDCSR) = 0;
+	CPU_REG(ADC_BASE, ADC_CR) &= ~ADC_CR_PW_CTRL;
+	CPU_REG(ADC_BASE, ADC_TSCTRL) |= ADC_TSCTRL_INTR | ADC_TSCTRL_ENABLE;
+	disable_irq(IRQ_PEN);
+
+	ts->last_x = ts->last_y = -1;
+	
+	return IRQ_HANDLED;
+}
+
+static int h7202ts_probe(struct device *dev)
+{
+	struct h7202_ts *ts;
+
+	printk("%s\n",__FUNCTION__);
+
+	if (!(ts = kmalloc(sizeof(struct h7202_ts), GFP_KERNEL)))
+		return -ENOMEM;
+
+	memset(ts, 0, sizeof(struct h7202_ts));
+
+	dev_set_drvdata(dev, ts);
+
+	init_input_dev(&ts->input);
+
+	h7202_ts_reset();
+
+	/* Set pen down detection as output */
+	CPU_REG(PEN_GPIO, GPIO_EN) |= PEN_ENA_BIT;
+	CPU_REG(PEN_GPIO, GPIO_DIR) &= ~PEN_ENA_BIT;
+	CPU_REG(PEN_GPIO, GPIO_DATA) |= PEN_ENA_BIT;
+
+	/* Initialize interrupt pin */
+	CPU_REG(PEN_GPIO, GPIO_EN) |= PEN_INT_BIT;
+	CPU_REG(PEN_GPIO, GPIO_DIR) |= PEN_INT_BIT;
+	CPU_REG(PEN_GPIO, GPIO_EDGE) |= PEN_INT_BIT;
+	CPU_REG(PEN_GPIO, GPIO_POL) |= PEN_INT_BIT;
+
+	/* Initialize ADC converter */
+	CPU_REG(ADC_BASE, ADC_CR) = ADC_CR_CONTIME_4 | ADC_CR_PW_CTRL;
+	/* Enable driver outputs */	
+	CPU_REG(ADC_BASE,ADC_TSCTRL) = ADC_TSCTRL_SWBYPSS;
+
+	/* Enable sampling */
+	CPU_REG(ADC_BASE, ADC_CR) &= ~ADC_CR_PW_CTRL;
+	CPU_REG(ADC_BASE, ADC_TSCTRL) |= ADC_TSCTRL_INTR | ADC_TSCTRL_ENABLE;
+
+	ts->input.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	ts->input.keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);
+	input_set_abs_params(&ts->input, ABS_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(&ts->input, ABS_X, 60, 985, 0, 0);
+	input_set_abs_params(&ts->input, ABS_Y, 35, 1024, 0, 0);
+
+	ts->input.private = ts;
+	ts->input.name = "h7202 Touchscreen";
+	ts->input.dev = dev;
+	ts->input.phys = 0;
+	ts->input.id.bustype = BUS_HOST;
+	ts->input.id.vendor = 0x0001;
+	ts->input.id.product = 0x0002;
+	ts->input.id.version = 0x0100;
+
+	input_register_device(&ts->input);
+
+	CPU_REG(ADC_BASE, ADC_ADCTDCSR) = ADC_ADCTDCSR_TDEN | ADC_ADCTDCSR_TDMSK;
+
+	if (request_irq(IRQ_AIC, h7202_pen_interrupt, SA_INTERRUPT, "h7202_ts", ts)) {
+		printk("Couldn't request touch data IRQ.\n");
+		return -ENODEV;
+	}
+
+	if (request_irq(IRQ_PEN, h7202_touch_interrupt, SA_INTERRUPT, "h7202_ts", ts)) {
+		printk("Couldn't request pen touch IRQ.\n");
+		free_irq(IRQ_AIC, "h7202_ts");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int h7202ts_remove(struct device *dev)
+{
+	struct h7202_ts *ts = dev_get_drvdata(dev);
+
+	printk("%s\n",__FUNCTION__);
+
+	free_irq(IRQ_AIC, NULL);
+	free_irq(IRQ_PEN, NULL);
+	input_unregister_device(&ts->input);
+	dev_set_drvdata(dev, NULL);
+	kfree(ts);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h7202ts_suspend(struct device *dev, uint32_t state, uint32_t level)
+{
+	printk("%s\n",__FUNCTION__);
+	return 0;
+}
+
+static int h7202ts_resume(struct device *dev, uint32_t level)
+{
+	printk("%s\n",__FUNCTION__);
+	return 0;
+}
+#else
+#define h7202ts_suspend		NULL
+#define h7202ts_resume		NULL
+#endif
+
+static struct device_driver h7202ts_driver = {
+	.name		= "h7202ts",
+	.bus		= &platform_bus_type,
+	.probe		= h7202ts_probe,
+	.remove		= h7202ts_remove,
+	.suspend	= h7202ts_suspend,
+	.resume		= h7202ts_resume,
+};
+
+int __init h7202_init(void)
+{
+	printk("h7202 touchscreen driver\n");
+	return driver_register(&h7202ts_driver);
+}
+
+void __exit h7202_exit(void)
+{
+	driver_unregister(&h7202ts_driver);
+}
+
+module_init(h7202_init);
+module_exit(h7202_exit);
Index: drivers/input/touchscreen/Makefile
===================================================================
--- a/drivers/input/touchscreen/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/input/touchscreen/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -11,3 +11,4 @@
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH) += mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)	+= mk712.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)	+= hp680_ts_input.o
+obj-$(CONFIG_TOUCHSCREEN_H7202)	+= h7202_ts_input.o
Index: drivers/video/Makefile
===================================================================
--- a/drivers/video/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/video/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -92,6 +92,7 @@
 obj-$(CONFIG_FB_TX3912)		  += tx3912fb.o
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
+obj-$(CONFIG_FB_H720X)		  += h720xfb.o cfbimgblt.o cfbcopyarea.o cfbfillrect.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_VESA)             += vesafb.o
Index: drivers/video/Kconfig
===================================================================
--- a/drivers/video/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/video/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -1484,6 +1484,24 @@
 	  working with S1D13806). Product specs at
 	  <http://www.erd.epson.com/vdc/html/legacy_13xxx.htm>
 
+config FB_H720X
+	tristate "Hynix h720x LCD framebuffer support"
+	depends on FB && ARCH_H720X
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_SOFT_CURSOR
+	---help---
+	  Frame buffer driver for the built-in LCD controller in the Hynix
+	  h720x processor.
+
+	  This driver is also available as a module ( = code which can be
+	  inserted and removed from the running kernel whenever you want). The
+	  module will be called h720xfb. If you want to compile it as a module,
+	  say M here and read <file:Documentation/modules.txt>.
+
+	  If unsure, say N.
+
 config FB_VIRTUAL
 	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
 	depends on FB
Index: drivers/video/h720xfb.c
===================================================================
--- a/drivers/video/h720xfb.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/video/h720xfb.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,562 @@
+/*
+ * linux/drivers/video/h720x.c -- h720x Framebuffder device driver
+ *
+ * Copyright (C) 2000 Jungjun Kim, Hynix Semiconductor Inc. 
+ *           (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *           (C) 2004 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Framebuffer driver for Hynix h720x devices
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+
+#include "h720xfb.h"
+#include "asm/arch/h720xfb.h"
+
+static struct h720xfb_rgb def_rgb_8 = {
+	.red	= { .offset = 0,  .length = 8, },
+	.green	= { .offset = 0,  .length = 8, },
+	.blue	= { .offset = 0,  .length = 8, },
+	.transp	= { .offset = 0,  .length = 0, },
+};
+
+static struct h720xfb_rgb def_rgb_16 = {
+	.red	= { .offset = 11, .length = 5, },
+	.green	= { .offset = 5,  .length = 6, },
+	.blue	= { .offset = 0,  .length = 5, },
+	.transp	= { .offset = 0,  .length = 0, },
+};
+
+/*
+ * Shift color info to the appropriate bit position
+ */
+static inline u_int chan_to_field (u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+/*
+ *  h720xfb_check_var():
+ *    Round up in the following order: bits_per_pixel, xres,
+ *    yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
+ *    bitfields, horizontal timing, vertical timing.
+ */
+static int
+h720xfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct h720xfb_info *fbi = info->par;
+	int rgbidx;
+	pr_debug("%s\n",__FUNCTION__);
+
+	if (var->xres < MIN_XRES)
+		var->xres = MIN_XRES;
+	if (var->yres < MIN_YRES)
+		var->yres = MIN_YRES;
+	if (var->xres > fbi->max_xres)
+		var->xres = fbi->max_xres;
+	if (var->yres > fbi->max_yres)
+		var->yres = fbi->max_yres;
+	var->xres_virtual = max(var->xres_virtual, var->xres);
+	var->yres_virtual = max(var->yres_virtual, var->yres);
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		rgbidx = RGB_16;
+		break;
+	case 8:
+		rgbidx = RGB_8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * Copy the RGB parameters for this display
+	 * from the machine specific parameters.
+	 */
+	var->red    = fbi->rgb[rgbidx]->red;
+	var->green  = fbi->rgb[rgbidx]->green;
+	var->blue   = fbi->rgb[rgbidx]->blue;
+	var->transp = fbi->rgb[rgbidx]->transp;
+
+	pr_debug("RGBT length = %d:%d:%d:%d\n",
+		var->red.length, var->green.length, var->blue.length,
+		var->transp.length);
+
+	pr_debug("RGBT offset = %d:%d:%d:%d\n",
+		var->red.offset, var->green.offset, var->blue.offset,
+		var->transp.offset);
+
+	return 0;
+}
+
+/*
+ * imxfb_activate_var():
+ *	Configures LCD Controller based on entries in var parameter.  Settings are
+ *	only written to the controller if changes were made.
+ */
+static int h720xfb_activate_var(struct fb_var_screeninfo *var, struct h720xfb_info *fbi)
+{
+	u_int tm0,tm1;
+
+	pr_debug("var: xres=%d hslen=%d lm=%d rm=%d\n",
+		var->xres, var->hsync_len,
+		var->left_margin, var->right_margin);
+	pr_debug("var: yres=%d vslen=%d um=%d bm=%d\n",
+		var->yres, var->vsync_len,
+		var->upper_margin, var->lower_margin);
+
+#if DEBUG_VAR
+	if (var->xres < 16        || var->xres > 1024)
+		printk(KERN_ERR "%s: invalid xres %d\n",
+			fbi->fb.fix.id, var->xres);
+	if (var->hsync_len < 1    || var->hsync_len > 64)
+		printk(KERN_ERR "%s: invalid hsync_len %d\n",
+			fbi->fb.fix.id, var->hsync_len);
+	if (var->left_margin > 255)
+		printk(KERN_ERR "%s: invalid left_margin %d\n",
+			fbi->fb.fix.id, var->left_margin);
+	if (var->right_margin > 255)
+		printk(KERN_ERR "%s: invalid right_margin %d\n",
+			fbi->fb.fix.id, var->right_margin);
+	if (var->yres < 1 || var->yres > 511)
+		printk(KERN_ERR "%s: invalid yres %d\n",
+			fbi->fb.fix.id, var->yres);
+	if (var->vsync_len > 100)
+		printk(KERN_ERR "%s: invalid vsync_len %d\n",
+			fbi->fb.fix.id, var->vsync_len);
+	if (var->upper_margin > 63)
+		printk(KERN_ERR "%s: invalid upper_margin %d\n",
+			fbi->fb.fix.id, var->upper_margin);
+	if (var->lower_margin > 255)
+		printk(KERN_ERR "%s: invalid lower_margin %d\n",
+			fbi->fb.fix.id, var->lower_margin);
+#endif
+
+	tm0 = TM0_HBP(var->left_margin) | 
+	      TM0_HFP(var->right_margin) |
+	      TM0_HSPW(var->hsync_len) |
+	      TM0_PPL((var->xres >> 4) - 1);
+
+	tm1 = TM1_VBP(var->upper_margin) |
+	      TM1_VFP(var->lower_margin) |
+	      TM1_VSPW(var->vsync_len) |
+	      TM1_LPS(var->yres - 1);
+
+	CPU_REG (LCD_BASE, LCD_TIMING0) = tm0; 
+	CPU_REG (LCD_BASE, LCD_TIMING1) = tm1; 
+	CPU_REG (LCD_BASE, LCD_TIMING2) = fbi->tm2; 
+
+	return 0;
+}
+
+/*
+ * h720xfb_set_par():
+ *	Set the user defined part of the display for the specified console
+ */
+static int h720xfb_set_par(struct fb_info *info)
+{
+	struct h720xfb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+
+	pr_debug("%s\n",__FUNCTION__);
+
+	if (var->bits_per_pixel == 16)
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+	else if (!fbi->cmap_static)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else {
+		/*
+		 * Some people have weird ideas about wanting static
+		 * pseudocolor maps.  I suspect their user space
+		 * applications are broken.
+		 */
+		info->fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;
+	}
+
+	info->fix.line_length = var->xres_virtual *
+				  var->bits_per_pixel / 8;
+	fbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;
+
+	h720xfb_activate_var(var, fbi);
+
+	return 0;
+}
+
+/*
+ * Set palette register. 
+ */
+static int h720xfb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue, u_int trans, struct fb_info *info)
+{
+	struct h720xfb_info *fbi = info->par;
+	u_int val, ret = 1;
+
+	pr_debug("%s reg:%d red:%d green:%d blue:%d\n",__FUNCTION__,regno,red,green,blue);
+
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+	if (regno < fbi->palette_size) {
+		val = (CNVT_TOHW(blue, 5) << 19) |
+		      (CNVT_TOHW(green,6) << 10) |
+		      (CNVT_TOHW(red,  5) <<  3);
+		CPU_REG(LCD_PALETTE_BASE, (regno << 2)) = val;
+		ret = 0;
+	}
+	return ret;
+}
+
+/*
+ * Set a color register
+ */
+static int h720xfb_setcolreg (u_int regno, u_int red, u_int green, u_int blue, u_int trans, struct fb_info *info)
+{
+	struct h720xfb_info *fbi = info->par;
+	u_int val;
+	int ret = 1;
+
+//	printk("%s reg:%d red:%d green:%d blue:%d\n",__FUNCTION__,regno,red,green,blue);
+	/*
+	 * If inverse mode was selected, invert all the colours
+	 * rather than the register number.  The register number
+	 * is what you poke into the framebuffer to produce the
+	 * colour you requested.
+	 */
+	if (fbi->cmap_inverse) {
+		red = 0xffff - red;
+		green = 0xffff - green;
+		blue = 0xffff - blue;
+	}
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green + 7471 * blue) >> 16;
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 12 or 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = info->pseudo_palette;
+
+			val  = chan_to_field(red, &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue, &info->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		ret = h720xfb_setpalettereg (regno, red, green, blue, trans, info);
+		break;
+	}
+			
+	return ret;
+}
+
+    /*
+     *  Frame buffer operations
+     */
+
+static struct fb_ops h720xfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= h720xfb_setcolreg,
+	.fb_check_var	= h720xfb_check_var,
+	.fb_set_par	= h720xfb_set_par,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor	= soft_cursor,
+};
+
+/*
+ *      Allocates the DRAM memory for the frame buffer.  This buffer is  
+ *	remapped into a non-cached, non-buffered, memory region to  
+ *      allow palette and pixel writes to occur without flushing the 
+ *      cache.  Once this area is remapped, all virtual memory
+ *      access to the video memory should occur at the new region.
+ */
+static int __init h720xfb_map_video_memory(struct fb_info *info)
+{
+	struct h720xfb_info *fbi = info->par;
+
+	fbi->map_size = PAGE_ALIGN(info->fix.smem_len);
+	fbi->map_cpu = dma_alloc_writecombine(fbi->dev, fbi->map_size,
+					&fbi->map_dma,GFP_KERNEL);
+
+	if (fbi->map_cpu) {
+		info->screen_base = fbi->map_cpu;
+		fbi->screen_cpu = fbi->map_cpu;
+		fbi->screen_dma = fbi->map_dma;
+		info->fix.smem_start = fbi->screen_dma;
+	}
+
+	return fbi->map_cpu ? 0 : -ENOMEM;
+}
+
+static int __init h720xfb_init_fbinfo(struct device *dev)
+{
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct h720xfb_info *fbi = info->par;
+	struct h720xfb_mach_info *inf = dev->platform_data;
+
+	pr_debug("%s\n",__FUNCTION__);
+
+	info->pseudo_palette = kmalloc( sizeof(u32) * 16, GFP_KERNEL);
+	if (!info->pseudo_palette)
+		return -ENOMEM;
+
+	memset(fbi, 0, sizeof(struct h720xfb_info));
+	fbi->dev = dev;
+
+	strlcpy(info->fix.id, "h720xfb", sizeof(info->fix.id));
+
+	info->fix.type		= FB_TYPE_PACKED_PIXELS;
+	info->fix.type_aux	= 0;
+	info->fix.xpanstep	= 0;
+	info->fix.ypanstep	= 0;
+	info->fix.ywrapstep	= 0;
+	info->fix.accel		= FB_ACCEL_NONE;
+
+	info->var.nonstd	= 0;
+	info->var.activate	= FB_ACTIVATE_NOW;
+	info->var.height	= -1;
+	info->var.width		= -1;
+	info->var.accel_flags	= 0;
+	info->var.vmode		= FB_VMODE_NONINTERLACED;
+
+	info->fbops		= &h720xfb_ops;
+	info->flags		= FBINFO_DEFAULT;
+	info->node		= -1;
+
+	fbi->rgb[RGB_8]		= &def_rgb_8;
+	fbi->rgb[RGB_16]	= &def_rgb_16;
+
+	fbi->max_xres		= inf->xres;
+	info->var.xres		= inf->xres;
+	info->var.xres_virtual	= inf->xres;
+	fbi->max_yres		= inf->yres;
+	info->var.yres		= inf->yres;
+	info->var.yres_virtual	= inf->yres;
+	fbi->max_bpp		= inf->bpp;
+	info->var.bits_per_pixel= inf->bpp;
+	info->var.grayscale	= inf->cmap_greyscale;
+	fbi->cmap_inverse	= inf->cmap_inverse;
+	fbi->tm2		= inf->tm2;
+	fbi->control		= inf->control;
+	fbi->pll_ctrl		= inf->pll_ctrl;
+
+	info->var.pixclock	= inf->pixclock;
+	info->var.hsync_len	= inf->hsync_len;
+	info->var.left_margin	= inf->left_margin;
+	info->var.right_margin	= inf->right_margin;
+	info->var.vsync_len	= inf->vsync_len;
+	info->var.upper_margin	= inf->upper_margin;
+	info->var.lower_margin	= inf->lower_margin;
+	info->var.sync		= inf->sync;
+	info->fix.smem_len	= fbi->max_xres * fbi->max_yres *
+				  fbi->max_bpp / 8;
+	return 0;
+}
+
+/* PLL setting */
+static inline void h720xfb_pll_on(struct h720xfb_info *fbi, int mode)
+{
+	u_int val = CPU_REG(PMU_BASE, PMU_PLL_CTRL) &= PLL_CTRL_MASK23;
+	
+	if (mode)
+		val |= fbi->pll_ctrl;
+
+	CPU_REG(PMU_BASE, PMU_PLL_CTRL) = val;
+	/* Wait, until hardware is settled */	
+	udelay (50);	
+}	
+
+/*
+ * Hardware initialization
+ */
+static int h720xfb_enable(struct h720xfb_info *fbi)
+{	
+	h720xfb_pll_on (fbi, 1);
+
+	CPU_REG (LCD_BASE, LCD_DBAR) = fbi->screen_dma;
+	CPU_REG (LCD_BASE, LCD_CTRL) = fbi->control | LCD_CTRL_LCD_PWR | LCD_CTRL_LCD_ENABLE;
+
+	return 0;
+}
+
+static int h720xfb_probe(struct device *dev)
+{
+	struct h720xfb_mach_info *inf;
+	struct h720xfb_info *fbi = NULL;
+	struct fb_info *info;
+	int i,ret;
+
+	printk("h720x Framebuffer driver\n");
+
+	inf = dev->platform_data;
+	if(!inf) {
+		ret = -ENOMEM;
+		dev_err(dev,"No platform_data available\n");
+		goto failed;
+	}
+
+	info = framebuffer_alloc(sizeof(struct h720xfb_info), dev);
+	if(!info)
+		return -ENOMEM;
+
+	fbi = info->par;
+
+	dev_set_drvdata(dev, info);
+
+	ret = h720xfb_init_fbinfo(dev);
+	if( ret < 0 ) {
+		dev_err(dev,"Failed to initialize framenbuffer device\n");
+		ret = -ENOMEM;
+		goto failed_release;
+	}
+
+	ret = h720xfb_map_video_memory(info);
+	if(ret) {
+		dev_err(dev,"Failed to allocate video RAM\n");
+		ret = -ENOMEM;
+		goto failed_map;
+	}
+
+	for(i=0;i<256;i++)
+		CPU_REG(LCD_PALETTE_BASE, (i << 2)) = ((i & 0x1f) << 19) | ((i & 0x7e) << 9) | (i & 0xf8);
+
+	/*
+	 * This makes sure that our colour bitfield
+	 * descriptors are correctly initialised.
+	 */
+	h720xfb_check_var(&info->var, info);
+
+	ret = fb_alloc_cmap(&info->cmap, 1<<info->var.bits_per_pixel, 0);
+	if (ret < 0)
+		goto failed_cmap;
+
+	h720xfb_set_par(info);
+
+	ret = register_framebuffer(info);
+	if(ret<0) {
+		dev_err(dev, "Failed to register framebuffer\n");
+		goto failed_register;
+	}
+
+	h720xfb_enable(fbi);
+
+	return 0;
+
+failed_register:
+	fb_dealloc_cmap(&info->cmap);
+failed_cmap:
+	dma_free_writecombine(dev,fbi->map_size,fbi->map_cpu, fbi->map_dma);
+
+failed_map:
+	kfree(info->pseudo_palette);
+//failed_regs:
+//	release_mem_region(res->start, res->end - res->start);
+failed_release:
+	framebuffer_release(info);
+failed:
+	dev_set_drvdata(dev, NULL);
+	return ret;	
+}
+
+static int h720xfb_remove(struct device *dev)
+{
+	struct h720xfb_info *fbi = dev_get_drvdata(dev);
+	
+	dev_set_drvdata(dev, NULL);
+
+	if(fbi) {
+		CPU_REG (LCD_BASE, LCD_CTRL) &= ~LCD_CTRL_LCD_ENABLE;
+		dma_free_writecombine(dev, fbi->map_size, fbi->map_cpu,
+		                      fbi->map_dma);
+		kfree(fbi);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks.  Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+static int h720xfb_suspend(struct device *dev, u32 state, u32 level)
+{
+	return 0;
+}
+
+static int h720xfb_resume(struct device *dev, u32 level)
+{
+	return 0;
+}
+#else
+#define h720xfb_suspend	NULL
+#define h720xfb_resume	NULL
+#endif
+
+static struct device_driver h720xfb_driver = {
+	.name		= "h720xfb",
+	.bus		= &platform_bus_type,
+	.probe		= h720xfb_probe,
+	.remove		= h720xfb_remove,
+	.suspend	= h720xfb_suspend,
+	.resume		= h720xfb_resume,
+};
+
+int __init h720xfb_init(void)
+{
+	if (fb_get_options("h720xfb", NULL))
+		return -ENODEV;
+
+	return driver_register(&h720xfb_driver);
+}
+
+static void __exit h720xfb_cleanup(void)
+{
+	driver_unregister(&h720xfb_driver);
+}
+
+module_init(h720xfb_init);
+module_exit(h720xfb_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Hynix h720x framebuffer driver");
+MODULE_AUTHOR("Jungjun Kim, Thomas Gleixner, Robert Schwebel, Sascha Hauer");
Index: drivers/video/h720xfb.h
===================================================================
--- a/drivers/video/h720xfb.h	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/video/h720xfb.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,70 @@
+/*
+ * linux/drivers/video/fb-h720x.h
+ *
+ * Copyright (C) 2000 Jungjun Kim, Hynix Semiconductor Inc. 
+ *           (C) 2003 Thomas Gleixner <tglx@linutronix.de>
+ *           (C) 2003 Robert Schwebel <r.schwebel@pengutronix.de>
+ *           (C) 2004 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * Frame buffer for GMS30C7201/HMS30C7202 platforms
+ *
+ */
+#ifndef __FBH720X_H
+# define __FBH720X_H
+
+#define RGB_8	(0)
+#define RGB_16	(1)
+#define NR_RGB	2
+
+/*
+ * These are the bitfields for each
+ * display depth that we support.
+ */
+struct h720xfb_rgb {
+	struct fb_bitfield	red;
+	struct fb_bitfield	green;
+	struct fb_bitfield	blue;
+	struct fb_bitfield	transp;
+};
+
+/* Framebuffer structure */
+typedef struct h720xfb_info {
+	struct h720xfb_rgb	*rgb[NR_RGB];
+	struct device		*dev;
+
+	u_int			max_bpp;
+	u_int			max_xres;
+	u_int			max_yres;
+
+	/*
+	 * These are the addresses we mapped
+	 * the framebuffer memory region to.
+	 */
+	dma_addr_t		map_dma;
+	u_char *		map_cpu;
+	u_int			map_size;
+
+	u_char *		screen_cpu;
+	dma_addr_t		screen_dma;
+	u_int			palette_size;
+
+	u_int			cmap_greyscale:1,
+				cmap_inverse:1,
+				cmap_static:1,
+				unused:29;
+
+	u_int		tm2;
+	u_int		control;
+	u_int		pll_ctrl;	
+} h720xfb_info_t;
+
+#define H720X_NAME	"H720X"
+
+/*
+ * Minimum X and Y resolutions
+ */
+#define MIN_XRES	64
+#define MIN_YRES	64
+
+
+#endif
Index: drivers/char/Makefile
===================================================================
--- a/drivers/char/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/char/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -65,6 +65,7 @@
 obj-$(CONFIG_DS1302) += ds1302.o
 obj-$(CONFIG_S3C2410_RTC) += s3c2410-rtc.o
 obj-$(CONFIG_RTC_VR41XX) += vr41xx_rtc.o
+obj-$(CONFIG_RTC_SM8580) += sm8580_rtc.o
 ifeq ($(CONFIG_GENERIC_NVRAM),y)
   obj-$(CONFIG_NVRAM) += generic_nvram.o
 else
Index: drivers/char/sm8580_rtc.c
===================================================================
--- a/drivers/char/sm8580_rtc.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/char/sm8580_rtc.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2003 Mario Nagler <mario.nagler@kurz-elektronik.de>
+ *
+ * This file contains the driver for the NPC SM8580 parallel extern real time clock
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 20051210 Sascha Hauer <s.hauer@pengutronix.de>
+ *          support driver model
+ */
+
+/* #define DEBUG 1 */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+
+#include <asm/hardware.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/rtc.h>
+
+#include <asm/mach/time.h>
+
+#include <asm/hardware/clock.h>
+
+#define RTC_ADDR_SEC1           0x0             // RTC 1-second digit register
+#define RTC_ADDR_SEC10          0x1             // RTC 10-second digit register
+#define RTC_ADDR_MIN1           0x2             // RTC 1-minute digit register
+#define RTC_ADDR_MIN10          0x3             // RTC 10-minute digit register
+#define RTC_ADDR_HR1            0x4             // RTC 1-hour digit register
+#define RTC_ADDR_HR10           0x5             // RTC 10-hour digit register
+#define RTC_ADDR_WD             0x6             // RTC week day digit register
+#define RTC_ADDR_DA1            0x7             // RTC 1-day digit register
+#define RTC_ADDR_DA10           0x8             // RTC 10-day digit register
+#define RTC_ADDR_MON1           0x9             // RTC 1-month digit register
+#define RTC_ADDR_MON10          0xa             // RTC 10-month digit register
+#define RTC_ADDR_YR1            0xb             // RTC 1-year digit register
+#define RTC_ADDR_YR10           0xc             // RTC 10-year digit register
+#define RTC_ADDR_YR100          0xd             // RTC 100-year digit register
+#define RTC_ADDR_YR1000         0xe             // RTC 1000-year digit register
+#define RTC_ADDR_CTRL           0xf             // RTC control register F bank0
+
+//bank 1 (alarm, FOUT registers)
+#define RTC_ADDR_ALARM_SEC1             0x0             // RTC 1-second digit register
+#define RTC_ADDR_ALARM_SEC10            0x1             // RTC 10-second digit register
+#define RTC_ADDR_ALARM_MIN1             0x2             // RTC 1-minute digit register
+#define RTC_ADDR_ALARM_MIN10            0x3             // RTC 10-minute digit register
+#define RTC_ADDR_ALARM_HR1              0x4             // RTC 1-hour digit register
+#define RTC_ADDR_ALARM_HR10             0x5             // RTC 10-hour digit register
+#define RTC_ADDR_ALARM_WD               0x6             // RTC week day digit register
+#define RTC_ADDR_ALARM_DA1              0x7             // RTC 1-day digit register
+#define RTC_ADDR_ALARM_DA10             0x8             // RTC 10-day digit register
+#define RTC_ADDR_RAM0                   0x9             // RTC can used as RAM-Bit
+#define RTC_ADDR_RAM1                   0xa             // RTC can used as RAM-Bit
+#define RTC_ADDR_CE1                    0xb             // RTC CE1
+#define RTC_ADDR_FOUTD                  0xc             // RTC FOUTD devider set register
+#define RTC_ADDR_FOUTF                  0xd             // RTC FOUTF frequency set register
+#define RTC_ADDR_ALARM_CTRL             0xe             // RTC ALARM control register
+
+//bank 2 (digital correction, timer registers)
+#define RTC_ADDR_CORR_REG1              0x0             // RTC digital correction register
+#define RTC_ADDR_CORR_REG2              0x1             // RTC digital correction register
+#define RTC_ADDR_READ0                  0x2             // RTC read-only register
+#define RTC_ADDR_READ1                  0x3             // RTC read-only register
+#define RTC_ADDR_READ2                  0x4             // RTC read-only register
+#define RTC_ADDR_READ3                  0x5             // RTC read-only register
+#define RTC_ADDR_TC_SET                 0x6             // RTC timer counter set register
+#define RTC_ADDR_TC_OUT                 0x7             // RTC timer counter output register
+#define RTC_ADDR_TS                     0x8             // RTC timer settings register
+#define RTC_ADDR_READ4                  0x9             // RTC read-only register
+#define RTC_ADDR_READ5                  0xa             // RTC read-only register
+#define RTC_ADDR_RAM2                   0xb             // RTC can used as RAM-Bit
+#define RTC_ADDR_RAM3                   0xc             // RTC can used as RAM-Bit
+#define RTC_ADDR_RAM4                   0xd             // RTC can used as RAM-Bit
+#define RTC_ADDR_TIMERCRTL              0xe             // RTC timer control register
+
+static void __iomem *base_addr = NULL;
+static int regshift = 2;
+
+static inline unsigned char sm8580_readreg(int reg)
+{
+	unsigned char val = ioread8(base_addr + (reg<<regshift));
+
+	pr_debug("(%s), reg 0x%x, val 0x%02x\n",
+                 __FUNCTION__, reg, val);
+	return val;
+}
+
+static inline void sm8580_writereg(int reg, unsigned char val)
+{
+	pr_debug("(%s) reg 0x%x, val 0x%02x\n",
+		__FUNCTION__, reg, val);
+
+	iowrite8(val, base_addr + (reg<<regshift));
+}
+
+/* Read the current date and time from the real time clock */
+static int sm8580_rtc_gettime(struct rtc_time *tm)
+{
+	int year;
+
+	tm->tm_sec = (sm8580_readreg(RTC_ADDR_SEC10) & 0x07) * 10 + 
+		     (sm8580_readreg(RTC_ADDR_SEC1) & 0x0F);
+	tm->tm_min = (sm8580_readreg(RTC_ADDR_MIN10) & 0x07) * 10 +
+	             (sm8580_readreg(RTC_ADDR_MIN1) & 0x0F);
+	tm->tm_hour = (sm8580_readreg(RTC_ADDR_HR10) & 0x07) * 10 +
+	              (sm8580_readreg(RTC_ADDR_HR1) & 0x0F);
+	tm->tm_mday = (sm8580_readreg(RTC_ADDR_DA10) & 0x03) * 10 +
+		     (sm8580_readreg(RTC_ADDR_DA1) & 0x0F);
+	tm->tm_mon = (sm8580_readreg(RTC_ADDR_MON10) & 0x01) * 10 +
+	             (sm8580_readreg(RTC_ADDR_MON1) & 0x0F) - 1;
+	tm->tm_wday = (sm8580_readreg(RTC_ADDR_WD) & 0x07);
+	year = 	(sm8580_readreg(RTC_ADDR_YR1000) & 0x03) * 1000 + 
+		(sm8580_readreg(RTC_ADDR_YR100) & 0x0F) * 100 +
+		(sm8580_readreg(RTC_ADDR_YR10) & 0x0F) * 10 +
+	        (sm8580_readreg(RTC_ADDR_YR1) & 0x0F);
+	tm->tm_year = (year - 1900);
+
+	pr_debug("%02d:%02d:%02d %02d.%02d.%04d\n",tm->tm_hour, tm->tm_min, tm->tm_sec, tm->tm_mday, tm->tm_mon, tm->tm_year);
+	return 0;
+}
+
+
+/* Set the current date and time in the real time clock */
+static int sm8580_rtc_settime(struct rtc_time *tm)
+{
+	int yr, yr1, yr10, yr100, yr1000;
+
+
+	tm->tm_mon = tm->tm_mon + 1;
+	yr = tm->tm_year + 1900;
+	yr1 = yr % 10;
+	yr = (yr-yr1) / 10;
+	yr10 = yr % 10;
+	yr = (yr-yr10) / 10;
+	yr100 = yr % 10;
+	yr1000 = (yr-yr100) / 10;
+
+	sm8580_writereg( RTC_ADDR_SEC1, tm->tm_sec % 10 );
+	sm8580_writereg( RTC_ADDR_SEC10, tm->tm_sec / 10 );
+	sm8580_writereg( RTC_ADDR_MIN1, tm->tm_min % 10 );
+	sm8580_writereg( RTC_ADDR_MIN10, tm->tm_min / 10 );
+	sm8580_writereg( RTC_ADDR_HR1, tm->tm_hour % 10 );
+	sm8580_writereg( RTC_ADDR_HR10, tm->tm_hour / 10 );
+	sm8580_writereg( RTC_ADDR_DA1, tm->tm_mday % 10 );
+	sm8580_writereg( RTC_ADDR_DA10, tm->tm_mday / 10 );
+	sm8580_writereg( RTC_ADDR_MON1, tm->tm_mon % 10 );
+	sm8580_writereg( RTC_ADDR_MON10, tm->tm_mon / 10 );
+	sm8580_writereg( RTC_ADDR_YR1, yr1 );
+	sm8580_writereg( RTC_ADDR_YR10, yr10 );
+	sm8580_writereg( RTC_ADDR_YR100, yr100 );
+	sm8580_writereg( RTC_ADDR_YR1000, yr1000 );
+
+	return 0;
+}
+
+static int sm8580_rtc_ioctl(unsigned int cmd, unsigned long arg)
+{
+	return -EINVAL;
+}
+
+static int sm8580_rtc_open(void)
+{
+	return 0;
+}
+
+static void sm8580_rtc_release(void)
+{
+}
+
+static struct rtc_ops sm8580_rtcops = {
+	.owner		= THIS_MODULE,
+	.open		= sm8580_rtc_open,
+	.release	= sm8580_rtc_release,
+	.ioctl		= sm8580_rtc_ioctl,
+	.read_time	= sm8580_rtc_gettime,
+	.set_time	= sm8580_rtc_settime,
+	.read_alarm	= NULL,
+	.set_alarm	= NULL,
+	.proc	        = NULL,
+};
+
+static int sm8580_rtc_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	int ret;
+
+	pr_debug("%s: probe=%p, device=%p\n", __FUNCTION__, pdev, dev);
+
+	if(base_addr) {
+		dev_err(dev, "This driver supports only one RTC, sorry\n");
+		return -ENODEV;
+	}
+
+	/* get the memory region */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(dev, "failed to get memory region resource\n");
+		return -ENOENT;
+	}
+
+	if(!request_mem_region(res->start, res->end-res->start+1, pdev->name)) {
+		dev_err(dev, "failed to reserve memory region\n");
+		ret = -ENOENT;
+		goto exit_err;
+	}
+
+	base_addr = ioremap(res->start, res->end - res->start + 1);
+	if (base_addr == NULL) {
+		dev_err(dev, "failed ioremap()\n");
+		ret = -EINVAL;
+		goto exit_err;
+	}
+
+	/* switch to bank 0 */
+	sm8580_writereg( RTC_ADDR_CTRL, 0 );
+	/* register RTC and exit */
+	register_rtc(&sm8580_rtcops);
+	return 0;
+
+ exit_err:
+	return ret;
+}
+
+static int sm8580_rtc_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+
+	unregister_rtc(&sm8580_rtcops);
+
+	iounmap(base_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+	base_addr = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sm8580_rtc_suspend(struct device *dev, pm_message_t state, u32 level)
+{
+}
+
+static int sm8580_rtc_resume(struct device *dev, u32 level)
+{
+}
+#else
+#define sm8580_rtc_suspend NULL
+#define sm8580_rtc_resume  NULL
+#endif
+
+static struct device_driver sm8580_rtcdrv = {
+	.name		= "sm8580-rtc",
+	.bus		= &platform_bus_type,
+	.probe		= sm8580_rtc_probe,
+	.remove		= sm8580_rtc_remove,
+	.suspend	= sm8580_rtc_suspend,
+	.resume		= sm8580_rtc_resume,
+};
+
+static int __init sm8580_rtc_init(void)
+{
+	printk("SM8580 rtc driver\n");
+	return driver_register(&sm8580_rtcdrv);
+}
+
+static void __exit sm8580_rtc_exit(void)
+{
+	driver_unregister(&sm8580_rtcdrv);
+}
+
+module_init(sm8580_rtc_init);
+module_exit(sm8580_rtc_exit);
+
+MODULE_DESCRIPTION("SM8580 RTC Driver");
+MODULE_AUTHOR("Mario Nagler");
+MODULE_LICENSE("GPL");
Index: drivers/char/Kconfig
===================================================================
--- a/drivers/char/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/char/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -783,6 +783,9 @@
 	tristate "NEC VR4100 series Real Time Clock Support"
 	depends on CPU_VR41XX
 
+config RTC_SM8580
+	tristate "NPC SM8580 Real Time Clock Support"
+
 config COBALT_LCD
 	bool "Support for Cobalt LCD"
 	depends on MIPS_COBALT
Index: drivers/net/cirrus.c
===================================================================
--- a/drivers/net/cirrus.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/net/cirrus.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,775 @@
+
+/*
+ * linux/drivers/net/cirrus.c
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * At the moment the driver does not support memory mode operation.
+ * It is trivial to implement this, but not worth the effort.
+ */
+
+/*
+ * TODO:
+ *
+ *   1. If !ready in send_start(), queue buffer and send it in interrupt handler
+ *      when we receive a BufEvent with Rdy4Tx, send it again. dangerous!
+ *   2. how do we prevent interrupt handler destroying integrity of get_stats()?
+ *   3. Change reset code to check status.
+ *   4. Implement set_mac_address and remove fake mac address
+ *   5. Link status detection stuff
+ *   6. Write utility to write EEPROM, do self testing, etc.
+ *   7. Implement DMA routines (I need a board w/ DMA support for that)
+ *   8. Power management
+ *   9. Add support for multiple ethernet chips
+ *  10. Add support for other cs89xx chips (need hardware for that)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "cirrus.h"
+
+/* #define DEBUG */
+/* #define FULL_DUPLEX */
+
+#ifdef CONFIG_SA1100_FRODO
+#	define CIRRUS_DEFAULT_IO FRODO_ETH_IO + 0x300
+#	define CIRRUS_DEFAULT_IRQ FRODO_ETH_IRQ
+#elif CONFIG_SA1100_CERF
+#	define CIRRUS_DEFAULT_IO CERF_ETH_IO + 0x300
+#	define CIRRUS_DEFAULT_IRQ CERF_ETH_IRQ
+#elif CONFIG_ARCH_CDB89712
+#	define CIRRUS_DEFAULT_IO ETHER_BASE + 0x300
+#	define CIRRUS_DEFAULT_IRQ IRQ_EINT3
+#else
+#ifndef CIRRUS_DEFAULT_IO
+#	define CIRRUS_DEFAULT_IO	0
+#	define CIRRUS_DEFAULT_IRQ	0
+#endif
+#endif	/* #ifdef CONFIG_SA1100_CERF */
+
+typedef struct {
+	u16 io_base;		/* I/O Base Address			*/
+	u16 irq;			/* Interrupt Number			*/
+	u16 dma;			/* DMA Channel Numbers		*/
+	u32 mem_base;		/* Memory Base Address		*/
+	u32 rom_base;		/* Boot PROM Base Address	*/
+	u32 rom_mask;		/* Boot PROM Address Mask	*/
+	u8 mac[6];			/* Individual Address		*/
+} cirrus_eeprom_t;
+
+typedef struct {
+	struct		net_device_stats stats;
+	u16		txlen;
+	u16		txafter;	/* Default is After5 (0) */
+	spinlock_t	lock;
+	cirrus_eeprom_t	eeprom;
+} cirrus_t;
+
+/*
+ * I/O routines
+ */
+
+static inline u16 cirrus_read (struct net_device *dev,u16 reg)
+{
+	outw (reg,dev->base_addr + PP_Address);
+	return (inw (dev->base_addr + PP_Data));
+}
+
+static inline void cirrus_write (struct net_device *dev,u16 reg,u16 value)
+{
+	outw (reg,dev->base_addr + PP_Address);
+	outw (value,dev->base_addr + PP_Data);
+}
+
+static inline void cirrus_set (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) | value);
+}
+
+static inline void cirrus_clear (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) & ~value);
+}
+
+static inline void cirrus_frame_read (struct net_device *dev,struct sk_buff *skb,u16 length)
+{
+	insw (dev->base_addr,skb_put (skb,length),(length + 1) / 2);
+}
+
+static inline void cirrus_frame_write (struct net_device *dev,struct sk_buff *skb)
+{
+	outsw (dev->base_addr,skb->data,(skb->len + 1) / 2);
+}
+
+/*
+ * Debugging functions
+ */
+
+#ifdef DEBUG
+static inline int printable (int c)
+{
+	return ((c >= 32 && c <= 126) ||
+			(c >= 174 && c <= 223) ||
+			(c >= 242 && c <= 243) ||
+			(c >= 252 && c <= 253));
+}
+
+static void dump16 (struct net_device *dev,const u8 *s,size_t len)
+{
+	int i;
+	char str[128];
+
+	if (!len) return;
+
+	*str = '\0';
+
+	for (i = 0; i < len; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		sprintf (str,"%s%.2x ",str,s[i]);
+	}
+
+	for ( ; i < 16; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		strcat (str,"   ");
+	}
+
+	strcat (str," ");
+	for (i = 0; i < len; i++) sprintf (str,"%s%c",str,printable (s[i]) ? s[i] : '.');
+
+	printk (KERN_DEBUG "%s:     %s\n",dev->name,str);
+}
+
+static void hexdump (struct net_device *dev,const void *ptr,size_t size)
+{
+	const u8 *s = (u8 *) ptr;
+	int i;
+	for (i = 0; i < size / 16; i++, s += 16) dump16 (dev,s,16);
+	dump16 (dev,s,size % 16);
+}
+
+static void dump_packet (struct net_device *dev,struct sk_buff *skb,const char *type)
+{
+	printk (KERN_INFO "%s: %s %d byte frame %.2x:%.2x:%.2x:%.2x:%.2x:%.2x to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x type %.4x\n",
+			dev->name,
+			type,
+			skb->len,
+			skb->data[0],skb->data[1],skb->data[2],skb->data[3],skb->data[4],skb->data[5],
+			skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11],
+			(skb->data[12] << 8) | skb->data[13]);
+	if (skb->len < 0x100) hexdump (dev,skb->data,skb->len);
+}
+#endif	/* #ifdef DEBUG */
+
+/*
+ * Driver functions
+ */
+
+static void cirrus_receive (struct net_device *dev)
+{
+	cirrus_t *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+	u16 status,length;
+
+	status = cirrus_read (dev,PP_RxStatus);
+	length = cirrus_read (dev,PP_RxLength);
+
+	if (!(status & RxOK)) {
+		priv->stats.rx_errors++;
+		if ((status & (Runt | Extradata))) priv->stats.rx_length_errors++;
+		if ((status & CRCerror)) priv->stats.rx_crc_errors++;
+		return;
+	}
+
+	if ((skb = dev_alloc_skb (length + 4)) == NULL) {
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb->dev = dev;
+	skb_reserve (skb,2);
+
+	cirrus_frame_read (dev,skb,length);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"recv");
+#endif	/* #ifdef DEBUG */
+
+	skb->protocol = eth_type_trans (skb,dev);
+
+	netif_rx (skb);
+	dev->last_rx = jiffies;
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += length;
+}
+
+static int cirrus_send_start (struct sk_buff *skb,struct net_device *dev)
+{
+	cirrus_t *priv = netdev_priv(dev);
+	u16 status;
+
+	/* Tx start must be done with irq disabled
+	 * else status can be wrong */
+	spin_lock_irq(&priv->lock);
+
+	netif_stop_queue (dev);
+
+	cirrus_write (dev,PP_TxCMD,TxStart (priv->txafter));
+	cirrus_write (dev,PP_TxLength,skb->len);
+
+	status = cirrus_read (dev,PP_BusST);
+
+
+	if ((status & TxBidErr)) {
+		printk (KERN_WARNING "%s: Invalid frame size %d!\n",dev->name,skb->len);
+		priv->stats.tx_errors++;
+		priv->stats.tx_aborted_errors++;
+		priv->txlen = 0;
+		spin_unlock_irq(&priv->lock);
+		return (1);
+	}
+
+	if (!(status & Rdy4TxNOW)) {
+		priv->stats.tx_errors++;
+		priv->txlen = 0;
+		spin_unlock_irq(&priv->lock);
+		return (1);
+	}
+
+	cirrus_frame_write (dev,skb);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"send");
+#endif	/* #ifdef DEBUG */
+
+	dev->trans_start = jiffies;
+	spin_unlock_irq(&priv->lock);
+
+	dev_kfree_skb (skb);
+
+	priv->txlen = skb->len;
+
+	return (0);
+}
+
+static irqreturn_t cirrus_interrupt (int irq,void *id,struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) id;
+	cirrus_t *priv = netdev_priv(dev);
+	u16 status;
+
+	if (dev->priv == NULL) {
+		printk (KERN_WARNING "%s: irq %d for unknown device.\n",dev->name,irq);
+		return 0;
+	}
+
+	spin_lock(&priv->lock);
+
+	while ((status = cirrus_read (dev,PP_ISQ))) {
+		switch (RegNum (status)) {
+		case RxEvent:
+			cirrus_receive (dev);
+			break;
+
+		case TxEvent:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			if (!(RegContent (status) & TxOK)) {
+				priv->stats.tx_errors++;
+				if ((RegContent (status) & Out_of_window)) priv->stats.tx_window_errors++;
+				if ((RegContent (status) & Jabber)) priv->stats.tx_aborted_errors++;
+				break;
+			} else if (priv->txlen) {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += priv->txlen;
+			}
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			break;
+
+		case BufEvent:
+			if ((RegContent (status) & RxMiss)) {
+				u16 missed = MissCount (cirrus_read (dev,PP_RxMISS));
+				priv->stats.rx_errors += missed;
+				priv->stats.rx_missed_errors += missed;
+			}
+			if ((RegContent (status) & TxUnderrun)) {
+				priv->stats.tx_errors++;
+				/* Shift start tx, if underruns come too often */
+				switch (priv->stats.tx_fifo_errors++) {
+				case 3: priv->txafter = After381; break;
+				case 6: priv->txafter = After1021; break;
+				case 9: priv->txafter = AfterAll; break;
+				}
+			}
+			/* Wakeup only for tx events ! */
+			if ((RegContent (status) & (TxUnderrun | Rdy4Tx))) {
+				priv->txlen = 0;
+				netif_wake_queue (dev);
+			}	
+			break;
+
+		case TxCOL:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			break;
+
+		case RxMISS:
+			status = MissCount (cirrus_read (dev,PP_RxMISS));
+			priv->stats.rx_errors += status;
+			priv->stats.rx_missed_errors += status;
+			break;
+		}
+	}
+
+	spin_unlock(&priv->lock);
+	return IRQ_RETVAL(1);
+}
+
+static void cirrus_transmit_timeout (struct net_device *dev)
+{
+	cirrus_t *priv = netdev_priv(dev);
+	priv->stats.tx_errors++;
+	priv->stats.tx_heartbeat_errors++;
+	priv->txlen = 0;
+	netif_wake_queue (dev);
+}
+
+static int cirrus_start (struct net_device *dev)
+{
+	int result;
+	printk("%s\n",__FUNCTION__);
+	/* valid ethernet address? */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		printk(KERN_ERR "%s: invalid ethernet MAC address\n",dev->name);
+		return (-EINVAL);
+	}
+
+	/* install interrupt handler */
+	if ((result = request_irq (dev->irq,&cirrus_interrupt,0,dev->name,dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name,dev->irq);
+		return (result);
+	}
+
+	/* enable the ethernet controller */
+	cirrus_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cirrus_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cirrus_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cirrus_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cirrus_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cirrus_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cirrus_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+
+	/* start the queue */
+	netif_start_queue (dev);
+
+	return (0);
+}
+
+static int cirrus_stop (struct net_device *dev)
+{
+	/* disable ethernet controller */
+	cirrus_write (dev,PP_BusCTL,0);
+	cirrus_write (dev,PP_TestCTL,0);
+	cirrus_write (dev,PP_SelfCTL,0);
+	cirrus_write (dev,PP_LineCTL,0);
+	cirrus_write (dev,PP_BufCFG,0);
+	cirrus_write (dev,PP_TxCFG,0);
+	cirrus_write (dev,PP_RxCTL,0);
+	cirrus_write (dev,PP_RxCFG,0);
+
+	/* uninstall interrupt handler */
+	free_irq (dev->irq,dev);
+
+	/* stop the queue */
+	netif_stop_queue (dev);
+
+	return (0);
+}
+
+static int cirrus_set_mac_address (struct net_device *dev, void *p)
+{
+	cirrus_t *priv = netdev_priv(dev);
+	struct sockaddr *addr = (struct sockaddr *)p;
+	int i;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	spin_lock(&priv->lock);
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	spin_unlock(&priv->lock);
+
+	return 0;
+}
+
+static struct net_device_stats *cirrus_get_stats (struct net_device *dev)
+{
+	cirrus_t *priv = netdev_priv(dev);
+	return (&priv->stats);
+}
+
+static void cirrus_set_receive_mode (struct net_device *dev)
+{
+	cirrus_t *priv = netdev_priv(dev);
+
+	spin_lock(&priv->lock);
+
+	if ((dev->flags & IFF_PROMISC))
+		cirrus_set (dev,PP_RxCTL,PromiscuousA);
+	else
+		cirrus_clear (dev,PP_RxCTL,PromiscuousA);
+
+	if ((dev->flags & IFF_ALLMULTI) || dev->mc_list)
+		cirrus_set (dev,PP_RxCTL,MulticastA);
+	else
+		cirrus_clear (dev,PP_RxCTL,MulticastA);
+
+	spin_unlock(&priv->lock);
+}
+
+static int cirrus_eeprom_wait (struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < 200; i++) {
+		if (!(cirrus_read (dev,PP_SelfST) & SIBUSY))
+			return (0);
+		udelay (1);
+	}
+
+	return (-1);
+}
+
+static int cirrus_eeprom_read (struct net_device *dev,u16 *value,u16 offset)
+{
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	cirrus_write (dev,PP_EEPROMCommand,offset | EEReadRegister);
+
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	*value = cirrus_read (dev,PP_EEPROMData);
+
+	return (0);
+}
+
+static int cirrus_eeprom (struct net_device *dev,cirrus_eeprom_t *eeprom)
+{
+	u16 offset,buf[16],*word;
+	u8 checksum = 0,*byte;
+
+	if (cirrus_eeprom_read (dev,buf,0) < 0) {
+		read_timed_out:
+		printk (KERN_DEBUG "%s: EEPROM read timed out\n",dev->name);
+		return (-ETIMEDOUT);
+	}
+
+	if ((buf[0] >> 8) != 0xa1) {
+		printk (KERN_DEBUG "%s: No EEPROM present\n",dev->name);
+		return (-ENODEV);
+	}
+
+	if ((buf[0] & 0xff) < sizeof (buf)) {
+		eeprom_too_small:
+		printk (KERN_DEBUG "%s: EEPROM too small\n",dev->name);
+		return (-ENODEV);
+	}
+
+	for (offset = 1; offset < ((buf[0] & 0xff) >> 1); offset++) {
+		if (cirrus_eeprom_read (dev,buf + offset,offset) < 0)
+			goto read_timed_out;
+
+		if (buf[offset] == 0xffff)
+			goto eeprom_too_small;
+	}
+
+	if (buf[1] != 0x2020) {
+		printk (KERN_DEBUG "%s: Group Header #1 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[5] != 0x502c) {
+		printk (KERN_DEBUG "%s: Group Header #2 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[12] != 0x2158) {
+		printk (KERN_DEBUG "%s: Group Header #3 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	eeprom->io_base = buf[2];
+	eeprom->irq = buf[3];
+	eeprom->dma = buf[4];
+	eeprom->mem_base = (buf[7] << 16) | buf[6];
+	eeprom->rom_base = (buf[9] << 16) | buf[8];
+	eeprom->rom_mask = (buf[11] << 16) | buf[10];
+
+	word = (u16 *) eeprom->mac;
+	for (offset = 0; offset < 3; offset++) word[offset] = buf[13 + offset];
+
+	byte = (u8 *) buf;
+	for (offset = 0; offset < sizeof (buf); offset++) checksum += byte[offset];
+
+	if (cirrus_eeprom_read (dev,&offset,0x10) < 0)
+		goto read_timed_out;
+
+	if ((offset >> 8) != (u8) (0x100 - checksum)) {
+		printk (KERN_DEBUG "%s: Checksum mismatch (expected 0x%.2x, got 0x%.2x instead\n",
+				dev->name,
+				(u8) (0x100 - checksum),
+				offset >> 8);
+		return (-EIO);
+	}
+
+	return (0);
+}
+
+static int cirrus_remove(struct device *dev)
+{
+	printk("%s: not implemented\n",__FUNCTION__);
+	return 0;
+}
+
+static int cirrus_suspend(struct device *dev, u32 state, u32 level)
+{
+	printk("%s: not implemented\n",__FUNCTION__);
+	return 0;
+}
+
+static int cirrus_resume(struct device *dev, u32 level)
+{
+	printk("%s: not implemented\n",__FUNCTION__);
+	return 0;
+}
+
+/*
+ * Driver initialization routines
+ */
+
+static int io = 0;
+static int irq = 0;
+
+int __init cirrus_probe (struct net_device *dev,unsigned long ioaddr)
+{
+	cirrus_t *priv = netdev_priv(dev);
+	int i;
+	u16 value;
+
+	ether_setup (dev);
+
+	dev->open               = cirrus_start;
+	dev->stop               = cirrus_stop;
+	dev->hard_start_xmit    = cirrus_send_start;
+	dev->get_stats          = cirrus_get_stats;
+	dev->set_multicast_list = cirrus_set_receive_mode;
+	dev->set_mac_address	= cirrus_set_mac_address;
+	dev->tx_timeout         = cirrus_transmit_timeout;
+	dev->watchdog_timeo     = HZ;
+
+	/* FIXME */
+	dev->dev_addr[0] = 0x08;
+	dev->dev_addr[1] = 0x00;
+	dev->dev_addr[2] = 0x3e;
+	dev->dev_addr[3] = 0x21;
+	dev->dev_addr[4] = 0xc7;
+	dev->dev_addr[5] = 0xf7;
+
+	dev->if_port   = IF_PORT_10BASET;
+	dev->priv      = (void *)priv;
+
+	spin_lock_init(&priv->lock);
+
+	SET_MODULE_OWNER (dev);
+
+	dev->base_addr = ioaddr;
+
+	/* module parameters override everything */
+	if (io > 0) dev->base_addr = io;
+	if (irq > 0) dev->irq = irq;
+
+	if (!dev->base_addr) {
+		printk (KERN_ERR
+				"%s: No default I/O base address defined. Use io=... or\n"
+				"%s: define CIRRUS_DEFAULT_IO for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!dev->irq) {
+		printk (KERN_ERR
+				"%s: No default IRQ number defined. Use irq=... or\n"
+				"%s: define CIRRUS_DEFAULT_IRQ for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!request_region (dev->base_addr,16,dev->name))
+		return -EBUSY;
+
+	/* if an EEPROM is present, use it's MAC address */
+	if (!cirrus_eeprom(dev,&priv->eeprom))
+		for (i = 0; i < 6; i++)
+			dev->dev_addr[i] = priv->eeprom.mac[i];
+
+	/* verify EISA registration number for Cirrus Logic */
+	if ((value = cirrus_read (dev,PP_ProductID)) != EISA_REG_CODE) {
+		printk (KERN_ERR "%s: incorrect signature 0x%.4x\n",dev->name,value);
+		return (-ENXIO);
+	}
+
+	/* verify chip version */
+	value = cirrus_read (dev,PP_ProductID + 2);
+	if (VERSION (value) != CS8900A) {
+		printk (KERN_ERR "%s: unknown chip version 0x%.8x\n",dev->name,VERSION (value));
+		return (-ENXIO);
+	}
+	printk (KERN_INFO "%s: CS8900A rev %c detected\n",dev->name,'B' + REVISION (value) - REV_B);
+
+	/* setup interrupt number */
+	cirrus_write (dev,PP_IntNum,0);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return register_netdev(dev);
+}
+
+int __init cirrus_drv_probe (struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev;
+	struct resource *res, *ext = NULL;
+	int ret;
+	unsigned int *addr;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	/*
+	 * Request the regions.
+	 */
+	if (!request_mem_region(res->start, 16, "cirrus-cs89x0")) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ndev = alloc_etherdev(sizeof(cirrus_t));
+	if (!ndev) {
+		printk("cirrus-cs89x0: could not allocate device.\n");
+		ret = -ENOMEM;
+		goto release_1;
+	}
+
+	SET_NETDEV_DEV(ndev, dev);
+
+	ndev->irq = platform_get_irq(pdev, 0);
+
+	printk("cirrus: irq:%d\n",ndev->irq);
+	ext = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (ext) {
+		if (!request_mem_region(ext->start, 16, ndev->name)) {
+			ret = -EBUSY;
+			goto release_1;
+		}
+	}
+
+	addr = ioremap(res->start, 16);
+	if (!addr) {
+		ret = -ENOMEM;
+		goto release_both;
+	}
+
+	dev_set_drvdata(dev, ndev);
+
+	ret = cirrus_probe(ndev, (unsigned long)addr);
+	if (ret != 0) {
+		dev_set_drvdata(dev, NULL);
+		iounmap(addr);
+ release_both:
+		if (ext)
+			release_mem_region(ext->start, 16);
+		free_netdev(ndev);
+ release_1:
+		release_mem_region(res->start, 16);
+ out:
+		printk("cirrus-cs89x0: not found (%d).\n", ret);
+	}
+
+	return ret;
+
+}
+
+static struct device_driver cirrus_driver = {
+	.name		= "cirrus-cs89x0",
+	.bus		= &platform_bus_type,
+	.probe		= cirrus_drv_probe,
+	.remove		= cirrus_remove,
+	.suspend	= cirrus_suspend,
+	.resume		= cirrus_resume,
+};
+
+static int __init cirrus_init(void)
+{
+	printk ("Cirrus Logic CS8900A driver for Linux (V0.02)\n");
+	return driver_register(&cirrus_driver);
+}
+
+static void __exit cirrus_cleanup(void)
+{
+	driver_unregister(&cirrus_driver);
+}
+
+MODULE_AUTHOR ("Abraham van der Merwe <abraham@2d3d.co.za>");
+MODULE_DESCRIPTION ("Cirrus Logic CS8900A driver for Linux (V0.02)");
+MODULE_LICENSE ("GPL");
+MODULE_PARM_DESC (io,"I/O Base Address");
+MODULE_PARM (io,"i");
+MODULE_PARM_DESC (irq,"IRQ Number");
+MODULE_PARM (irq,"i");
+
+module_init (cirrus_init);
+module_exit (cirrus_cleanup);
+
Index: drivers/net/cirrus.h
===================================================================
--- a/drivers/net/cirrus.h	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/net/cirrus.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,235 @@
+#ifndef CIRRUS_H
+#define CIRRUS_H
+
+/*
+ * linux/drivers/net/cirrus.h
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * Ports
+ */
+
+#define PP_Address		0x0a	/* PacketPage Pointer Port (Section 4.10.10) */
+#define PP_Data			0x0c	/* PacketPage Data Port (Section 4.10.10) */
+
+/*
+ * Registers
+ */
+
+#define PP_ProductID		0x0000	/* Section 4.3.1   Product Identification Code */
+#define PP_MemBase			0x002c	/* Section 4.9.2   Memory Base Address Register */
+#define PP_IntNum			0x0022	/* Section 3.2.3   Interrupt Number */
+#define PP_EEPROMCommand	0x0040	/* Section 4.3.11  EEPROM Command */
+#define PP_EEPROMData		0x0042	/* Section 4.3.12  EEPROM Data */
+#define PP_RxCFG			0x0102	/* Section 4.4.6   Receiver Configuration */
+#define PP_RxCTL			0x0104	/* Section 4.4.8   Receiver Control */
+#define PP_TxCFG			0x0106	/* Section 4.4.9   Transmit Configuration */
+#define PP_BufCFG			0x010a	/* Section 4.4.12  Buffer Configuration */
+#define PP_LineCTL			0x0112	/* Section 4.4.16  Line Control */
+#define PP_SelfCTL			0x0114	/* Section 4.4.18  Self Control */
+#define PP_BusCTL			0x0116	/* Section 4.4.20  Bus Control */
+#define PP_TestCTL			0x0118	/* Section 4.4.22  Test Control */
+#define PP_ISQ				0x0120	/* Section 4.4.5   Interrupt Status Queue */
+#define PP_TxEvent			0x0128	/* Section 4.4.10  Transmitter Event */
+#define PP_BufEvent			0x012c	/* Section 4.4.13  Buffer Event */
+#define PP_RxMISS			0x0130	/* Section 4.4.14  Receiver Miss Counter */
+#define PP_TxCOL			0x0132	/* Section 4.4.15  Transmit Collision Counter */
+#define PP_SelfST			0x0136	/* Section 4.4.19  Self Status */
+#define PP_BusST			0x0138	/* Section 4.4.21  Bus Status */
+#define PP_TxCMD			0x0144	/* Section 4.4.11  Transmit Command */
+#define PP_TxLength			0x0146	/* Section 4.5.2   Transmit Length */
+#define PP_IA				0x0158	/* Section 4.6.2   Individual Address (IEEE Address) */
+#define PP_RxStatus			0x0400	/* Section 4.7.1   Receive Status */
+#define PP_RxLength			0x0402	/* Section 4.7.1   Receive Length (in bytes) */
+#define PP_RxFrame			0x0404	/* Section 4.7.2   Receive Frame Location */
+#define PP_TxFrame			0x0a00	/* Section 4.7.2   Transmit Frame Location */
+
+/*
+ * Values
+ */
+
+/* PP_IntNum */
+#define INTRQ0			0x0000
+#define INTRQ1			0x0001
+#define INTRQ2			0x0002
+#define INTRQ3			0x0003
+
+/* PP_ProductID */
+#define EISA_REG_CODE	0x630e
+#define REVISION(x)		(((x) & 0x1f00) >> 8)
+#define VERSION(x)		((x) & ~0x1f00)
+
+#define CS8900A			0x0000
+#define REV_B			7
+#define REV_C			8
+#define REV_D			9
+
+/* PP_RxCFG */
+#define Skip_1			0x0040
+#define StreamE			0x0080
+#define RxOKiE			0x0100
+#define RxDMAonly		0x0200
+#define AutoRxDMAE		0x0400
+#define BufferCRC		0x0800
+#define CRCerroriE		0x1000
+#define RuntiE			0x2000
+#define ExtradataiE		0x4000
+
+/* PP_RxCTL */
+#define IAHashA			0x0040
+#define PromiscuousA	0x0080
+#define RxOKA			0x0100
+#define MulticastA		0x0200
+#define IndividualA		0x0400
+#define BroadcastA		0x0800
+#define CRCerrorA		0x1000
+#define RuntA			0x2000
+#define ExtradataA		0x4000
+
+/* PP_TxCFG */
+#define Loss_of_CRSiE	0x0040
+#define SQErroriE		0x0080
+#define TxOKiE			0x0100
+#define Out_of_windowiE	0x0200
+#define JabberiE		0x0400
+#define AnycolliE		0x0800
+#define T16colliE		0x8000
+
+/* PP_BufCFG */
+#define SWint_X			0x0040
+#define RxDMAiE			0x0080
+#define Rdy4TxiE		0x0100
+#define TxUnderruniE	0x0200
+#define RxMissiE		0x0400
+#define Rx128iE			0x0800
+#define TxColOvfiE		0x1000
+#define MissOvfloiE		0x2000
+#define RxDestiE		0x8000
+
+/* PP_LineCTL */
+#define SerRxON			0x0040
+#define SerTxON			0x0080
+#define AUIonly			0x0100
+#define AutoAUI_10BT	0x0200
+#define ModBackoffE		0x0800
+#define PolarityDis		0x1000
+#define L2_partDefDis	0x2000
+#define LoRxSquelch		0x4000
+
+/* PP_SelfCTL */
+#define RESET			0x0040
+#define SWSuspend		0x0100
+#define HWSleepE		0x0200
+#define HWStandbyE		0x0400
+#define HC0E			0x1000
+#define HC1E			0x2000
+#define HCB0			0x4000
+#define HCB1			0x8000
+
+/* PP_BusCTL */
+#define ResetRxDMA		0x0040
+#define DMAextend		0x0100
+#define UseSA			0x0200
+#define MemoryE			0x0400
+#define DMABurst		0x0800
+#define IOCHRDYE		0x1000
+#define RxDMAsize		0x2000
+#define EnableRQ		0x8000
+
+/* PP_TestCTL */
+#define DisableLT		0x0080
+#define ENDECloop		0x0200
+#define AUIloop			0x0400
+#define DisableBackoff	0x0800
+#define FDX				0x4000
+
+/* PP_ISQ */
+#define RegNum(x) ((x) & 0x3f)
+#define RegContent(x) ((x) & ~0x3d)
+
+#define RxEvent			0x0004
+#define TxEvent			0x0008
+#define BufEvent		0x000c
+#define RxMISS			0x0010
+#define TxCOL			0x0012
+
+/* PP_RxStatus */
+#define IAHash			0x0040
+#define Dribblebits		0x0080
+#define RxOK			0x0100
+#define Hashed			0x0200
+#define IndividualAdr	0x0400
+#define Broadcast		0x0800
+#define CRCerror		0x1000
+#define Runt			0x2000
+#define Extradata		0x4000
+
+#define HashTableIndex(x) ((x) >> 0xa)
+
+/* PP_TxCMD */
+#define After5			0
+#define After381		1
+#define After1021		2
+#define AfterAll		3
+#define TxStart(x) ((x) << 6)
+
+#define Force			0x0100
+#define Onecoll			0x0200
+#define InhibitCRC		0x1000
+#define TxPadDis		0x2000
+
+/* PP_BusST */
+#define TxBidErr		0x0080
+#define Rdy4TxNOW		0x0100
+
+/* PP_TxEvent */
+#define Loss_of_CRS		0x0040
+#define SQEerror		0x0080
+#define TxOK			0x0100
+#define Out_of_window	0x0200
+#define Jabber			0x0400
+#define T16coll			0x8000
+
+#define TX_collisions(x) (((x) >> 0xb) & ~0x8000)
+
+/* PP_BufEvent */
+#define SWint			0x0040
+#define RxDMAFrame		0x0080
+#define Rdy4Tx			0x0100
+#define TxUnderrun		0x0200
+#define RxMiss			0x0400
+#define Rx128			0x0800
+#define RxDest			0x8000
+
+/* PP_RxMISS */
+#define MissCount(x) ((x) >> 6)
+
+/* PP_TxCOL */
+#define ColCount(x) ((x) >> 6)
+
+/* PP_SelfST */
+#define T3VActive		0x0040
+#define INITD			0x0080
+#define SIBUSY			0x0100
+#define EEPROMpresent	0x0200
+#define EEPROMOK		0x0400
+#define ELpresent		0x0800
+#define EEsize			0x1000
+
+/* PP_EEPROMCommand */
+#define EEWriteRegister	0x0100
+#define EEReadRegister	0x0200
+#define EEEraseRegister	0x0300
+#define ELSEL			0x0400
+
+#endif	/* #ifndef CIRRUS_H */
Index: drivers/net/Kconfig
===================================================================
--- a/drivers/net/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/net/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -1332,6 +1332,21 @@
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called cs89x.
 
+config CIRRUS
+	tristate "CS89x0 support alternative"
+	---help---
+	  This is an alternate version of the cirrus driver by
+	  Abraham van der Merwe.
+	  Support for CS89x0 chipset based Ethernet cards. If you have a
+	  network (Ethernet) card of this type, say Y and read the
+	  Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto> as well as
+	  <file:Documentation/networking/cs89x0.txt>.
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>.  The module will be
+	  called cirrus.
+
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && TOSHIBA_JMR3927
Index: drivers/net/Makefile
===================================================================
--- a/drivers/net/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/net/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -169,6 +169,7 @@
 obj-$(CONFIG_HYDRA) += hydra.o 8390.o
 obj-$(CONFIG_ARIADNE) += ariadne.o
 obj-$(CONFIG_CS89x0) += cs89x0.o
+obj-$(CONFIG_CIRRUS) += cirrus.o
 obj-$(CONFIG_MACSONIC) += macsonic.o
 obj-$(CONFIG_MACMACE) += macmace.o
 obj-$(CONFIG_MAC89x0) += mac89x0.o
Index: drivers/usb/serial/Makefile
===================================================================
--- a/drivers/usb/serial/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/serial/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -31,6 +31,7 @@
 obj-$(CONFIG_USB_SERIAL_KLSI)			+= kl5kusb105.o
 obj-$(CONFIG_USB_SERIAL_KOBIL_SCT)		+= kobil_sct.o
 obj-$(CONFIG_USB_SERIAL_MCT_U232)		+= mct_u232.o
+obj-$(CONFIG_USB_SERIAL_MULTISER)		+= multiser.o
 obj-$(CONFIG_USB_SERIAL_OMNINET)		+= omninet.o
 obj-$(CONFIG_USB_SERIAL_OPTION)			+= option.o
 obj-$(CONFIG_USB_SERIAL_PL2303)			+= pl2303.o
Index: drivers/usb/serial/usb-serial.c
===================================================================
--- a/drivers/usb/serial/usb-serial.c	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/serial/usb-serial.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -499,6 +499,8 @@
 
 	if (port->open_count == 1) {
 
+		printk ("port = %p\nserial = %p\n", port, serial);
+		
 		/* set up our port structure making the tty driver
 		 * remember our port object, and us it */
 		tty->driver_data = port;
@@ -515,8 +517,14 @@
 		/* only call the device specific open if this 
 		 * is the first time the port is opened */
 		retval = serial->type->open(port, filp);
-		if (retval)
+
+		printk ("retval = %d\n", retval);
+		if (retval) {
+			port->open_count = 0;
+			module_put(serial->type->owner);
+			kref_put(&serial->kref, destroy_serial);
 			goto bailout_module_put;
+		}
 	}
 
 	return 0;
@@ -821,6 +829,15 @@
 	kfree(port);
 }
 
+static void port_release_dummy (struct device *dev)
+{
+	struct usb_serial_port *port = to_usb_serial_port(dev);
+
+	dbg ("%s - %s", __FUNCTION__, dev->bus_id);
+
+	kfree(port);
+}
+
 static struct usb_serial * create_serial (struct usb_device *dev, 
 					  struct usb_interface *interface,
 					  struct usb_serial_device_type *type)
@@ -1237,6 +1254,270 @@
 	return -EIO;
 }
 
+int usb_multiserial_probe(struct usb_interface *interface,
+			       const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev (interface);
+	struct usb_serial *serial = NULL;
+	struct usb_serial_port *port;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_endpoint_descriptor *interrupt_in_endpoint[MAX_NUM_PORTS];
+	struct usb_endpoint_descriptor *bulk_in_endpoint[MAX_NUM_PORTS];
+	struct usb_endpoint_descriptor *bulk_out_endpoint[MAX_NUM_PORTS];
+	struct usb_serial_device_type *type = NULL;
+	struct list_head *tmp;
+	int retval;
+	int found;
+	int minor;
+	int buffer_size;
+	int i;
+	int num_interrupt_in = 0;
+	int num_bulk_in = 0;
+	int num_bulk_out = 0;
+	int num_ports = 0;
+	const struct usb_device_id *id_pattern = NULL;
+	struct urb *read_urb, *write_urb;
+	unsigned char *bulk_in_buffer, *bulk_out_buffer;
+
+	/* loop through our list of known serial converters, and see if this
+	   device matches. */
+	found = 0;
+	list_for_each (tmp, &usb_serial_driver_list) {
+		type = list_entry(tmp, struct usb_serial_device_type, driver_list);
+		id_pattern = usb_match_id(interface, type->id_table);
+		if (id_pattern != NULL) {
+			dbg("descriptor matches");
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		/* no match */
+		dbg("none matched");
+		return -ENODEV;
+	}
+
+	serial = create_serial (dev, interface, type);
+	if (!serial) {
+		dev_err(&interface->dev, "%s - out of memory\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	/* if this device type has a probe function, call it */
+	if (type->probe) {
+		if (!try_module_get(type->owner)) {
+			dev_err(&interface->dev, "module get failed, exiting\n");
+			kfree (serial);
+			return -EIO;
+		}
+		retval = type->probe (serial, id_pattern);
+		module_put(type->owner);
+
+		if (retval) {
+			dbg ("sub driver rejected device");
+			kfree (serial);
+			return retval;
+		}
+	}
+
+	/* descriptor matches, let's find the endpoints needed */
+	/* check out the endpoints */
+	iface_desc = interface->cur_altsetting;
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+		
+		if ((endpoint->bEndpointAddress & 0x80) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk in endpoint */
+			dbg("found bulk in");
+			bulk_in_endpoint[num_bulk_in] = endpoint;
+			++num_bulk_in;
+		}
+
+		if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
+		    ((endpoint->bmAttributes & 3) == 0x02)) {
+			/* we found a bulk out endpoint */
+			dbg("found bulk out");
+			bulk_out_endpoint[num_bulk_out] = endpoint;
+			++num_bulk_out;
+		}
+		
+		if ((endpoint->bEndpointAddress & 0x80) &&
+		    ((endpoint->bmAttributes & 3) == 0x03)) {
+			/* we found a interrupt in endpoint */
+			dbg("found interrupt in");
+			interrupt_in_endpoint[num_interrupt_in] = endpoint;
+			++num_interrupt_in;
+		}
+	}
+
+	/* found all that we need */
+	dev_info(&interface->dev, "%s converter detected\n", type->name);
+
+	num_ports = type->num_ports;
+	if (!num_ports) return -EIO;
+	
+	if (get_free_serial (serial, num_ports, &minor) == NULL) {
+		dev_err(&interface->dev, "No more free serial devices\n");
+		kfree (serial);
+		return -ENOMEM;
+	}
+
+	serial->minor = minor;
+	serial->num_ports = num_ports;
+	serial->num_bulk_in = num_bulk_in;
+	serial->num_bulk_out = num_bulk_out;
+	serial->num_interrupt_in = num_interrupt_in;
+
+	serial->num_port_pointers = num_ports;
+	dbg("%s - setting up %d port structures for this device", 
+	    __FUNCTION__, num_ports);
+
+	for (i = 0; i < num_ports; ++i) {
+		/* set up the endpoint information */
+		endpoint = bulk_in_endpoint[0];
+		buffer_size = endpoint->wMaxPacketSize;
+		read_urb = usb_alloc_urb (0, GFP_KERNEL);
+		if (!read_urb) {
+			dev_err(&interface->dev, "No free urbs available\n");
+			goto probe_error;
+		}
+		bulk_in_buffer = kmalloc (buffer_size, GFP_KERNEL);
+		if (!read_urb) {
+			dev_err(&interface->dev, "Couldn't allocate bulk_in_buffer\n");
+			goto probe_error;
+		}
+		
+		usb_fill_bulk_urb (read_urb, dev,
+				   usb_rcvbulkpipe (dev,
+						    endpoint->bEndpointAddress),
+				   bulk_in_buffer, buffer_size,
+				   serial->type->read_bulk_callback,
+				   serial->port);
+		
+		port = kmalloc(sizeof(struct usb_serial_port), GFP_KERNEL);
+		if (!port)
+			goto probe_error;
+		memset(port, 0x00, sizeof(struct usb_serial_port));
+		port->number = i + serial->minor;
+		port->serial = serial;
+		INIT_WORK(&port->work, usb_serial_port_softint, port);
+		serial->port[i] = port;
+		
+		port = serial->port [i];
+		
+		port->read_urb = read_urb;
+		port->bulk_in_endpointAddress = endpoint->bEndpointAddress;
+		port->bulk_in_buffer = bulk_in_buffer;
+	
+		/* set up the endpoint information */
+		endpoint = bulk_out_endpoint[0];
+		buffer_size = endpoint->wMaxPacketSize;
+		
+		
+		write_urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!write_urb) 
+		{
+			dev_err(&interface->dev, "No free urbs available\n");
+			goto probe_error;
+		}
+		
+		bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
+		if (!bulk_out_buffer) {
+			dev_err(&interface->dev, "Couldn't allocate bulk_out_buffer\n");
+			goto probe_error;
+		}
+		usb_fill_bulk_urb (write_urb, dev,
+				   usb_sndbulkpipe (dev,
+						    endpoint->bEndpointAddress),
+				   bulk_out_buffer, buffer_size, 
+				   serial->type->write_bulk_callback,
+				   serial->port);
+		
+		port = serial->port [i];
+		
+		port->write_urb = write_urb;
+		port->bulk_out_endpointAddress = endpoint->bEndpointAddress;
+		port->bulk_out_size = buffer_size;
+		port->bulk_out_buffer = bulk_out_buffer;
+	}
+	
+	/* if this device type has an attach function, call it */
+	if (type->attach) {
+		if (!try_module_get(type->owner)) {
+			dev_err(&interface->dev, "module get failed, exiting\n");
+			goto probe_error;
+		}
+		retval = type->attach (serial);
+		module_put(type->owner);
+		if (retval < 0)
+		    goto probe_error;
+		if (retval > 0) {
+			/* quietly accept this device, but don't bind to a serial port
+			 * as it's about to disappear */
+			goto exit;
+		}
+	}
+	
+	/* register all of the individual ports with the driver core */
+	for (i = 0; i < num_ports; ++i) {
+		port = serial->port [i];
+		port->dev.parent = &interface->dev;
+		port->dev.driver = NULL;
+		port->dev.bus = &usb_serial_bus_type;
+		port->dev.release = &port_release_dummy;
+
+		snprintf (&port->dev.bus_id[0], sizeof(port->dev.bus_id), "ttyUSB%d", port->number);
+		dbg ("%s - registering %s", __FUNCTION__, port->dev.bus_id);
+		device_register (&port->dev);
+	}
+	port = serial->port[0];
+	port->dev.release = &port_release;
+
+	usb_serial_console_init (debug, minor);
+
+exit:
+	/* success */
+	usb_set_intfdata (interface, serial);
+	return 0;
+
+probe_error:
+	for (i = 0; i < num_bulk_in; ++i) {
+		port = serial->port[i];
+		if (!port)
+			continue;
+		if (port->read_urb)
+			usb_free_urb (port->read_urb);
+		kfree(port->bulk_in_buffer);
+	}
+	for (i = 0; i < num_bulk_out; ++i) {
+		port = serial->port[i];
+		if (!port)
+			continue;
+		if (port->write_urb)
+			usb_free_urb (port->write_urb);
+		kfree(port->bulk_out_buffer);
+	}
+	for (i = 0; i < num_interrupt_in; ++i) {
+		port = serial->port[i];
+		if (!port)
+			continue;
+		if (port->interrupt_in_urb)
+			usb_free_urb (port->interrupt_in_urb);
+		kfree(port->interrupt_in_buffer);
+	}
+
+	/* return the minor range that this device had */
+	return_serial (serial);
+
+	/* free up any memory that we allocated */
+	for (i = 0; i < serial->num_port_pointers; ++i)
+		kfree(serial->port[i]);
+	kfree (serial);
+	return -EIO;
+}
+
 void usb_serial_disconnect(struct usb_interface *interface)
 {
 	int i;
@@ -1421,11 +1702,12 @@
    need these symbols to load properly as modules. */
 EXPORT_SYMBOL_GPL(usb_serial_register);
 EXPORT_SYMBOL_GPL(usb_serial_deregister);
+EXPORT_SYMBOL_GPL(usb_multiserial_probe);
 EXPORT_SYMBOL_GPL(usb_serial_probe);
 EXPORT_SYMBOL_GPL(usb_serial_disconnect);
 EXPORT_SYMBOL_GPL(usb_serial_port_softint);
+EXPORT_SYMBOL_GPL(usb_serial_tty_driver);
 
-
 /* Module information */
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
Index: drivers/usb/serial/usb-serial.h
===================================================================
--- a/drivers/usb/serial/usb-serial.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/serial/usb-serial.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -276,6 +276,7 @@
 extern void usb_serial_port_softint(void *private);
 
 extern int usb_serial_probe(struct usb_interface *iface, const struct usb_device_id *id);
+extern int usb_multiserial_probe(struct usb_interface *iface, const struct usb_device_id *id);
 extern void usb_serial_disconnect(struct usb_interface *iface);
 
 extern int ezusb_writememory (struct usb_serial *serial, int address, unsigned char *data, int length, __u8 bRequest);
Index: drivers/usb/serial/Kconfig
===================================================================
--- a/drivers/usb/serial/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/serial/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -394,6 +394,17 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called mct_u232.
 
+config USB_SERIAL_MULTISER
+	tristate "USB MultiSerial Driver"
+	depends on USB_SERIAL
+	help
+	  Say Y here if you want to use a device which speaks a simple "MultiSerial" 
+	  protocol. At the moment, only the Linux g_multiser gadget driver 
+	  does this.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called multiser. 
+
 config USB_SERIAL_PL2303
 	tristate "USB Prolific 2303 Single Port Serial Driver"
 	depends on USB_SERIAL
Index: drivers/usb/serial/generic.c
===================================================================
--- a/drivers/usb/serial/generic.c	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/serial/generic.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -17,6 +17,7 @@
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/types.h>
 #include <linux/usb.h>
 #include <asm/uaccess.h>
 #include "usb-serial.h"
@@ -112,7 +113,7 @@
 	int result = 0;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
-
+		
 	/* force low_latency on so that our tty_push actually forces the data through, 
 	   otherwise it is scheduled, and with high data rates (like with OHCI) data
 	   can get lost. */
Index: drivers/usb/serial/multiser.c
===================================================================
--- a/drivers/usb/serial/multiser.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/usb/serial/multiser.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,492 @@
+/*
+ * linux/drivers/usb/serial/multiser.c
+ *
+ * Copyright (C) 2004 Benedikt Spranger <b.spranger@pengutronix.de>
+ * Copyright (C) 2004 Robert Schwebel <r.schwebel@pengutronix.de>
+ * Copyright (C) 2001 Stuart Lynne <sl@lineo.com>, Tom Rushworth <tbr@lineo.com>
+ * Copyright (C) 2001 Hewlett-Packard
+ *
+ * Parts of this code are derived from the safe_serial driver. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License 
+ * as published by the Free Software Foundation. 
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ---
+ *
+ * This driver implements a very simple protocol for hardware with 
+ * bugs/restrictions. It can also be used on "dumb" devices which handle
+ * all endpoint 0 traffic in hardware, like the Hynix H7202 UDC.  
+ *
+ * Features: 
+ * 
+ * - we need two bulk endpoints
+ * - only complete buffer lengths are transferred, 
+ *   number of valid bytes is transmitted
+ * - works with the g_multiser driver on gadget side
+ *   
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/usb.h>
+
+#include <asm/uaccess.h>
+
+#include <asm/processor.h>
+
+#undef DEBUG_ECHO_TX
+#undef DEBUG_ECHO_RX
+#undef DBG_SHORT
+
+#ifndef CONFIG_USB_SERIAL_DEBUG
+#define CONFIG_USB_SERIAL_DEBUG 0
+#endif
+
+static int debug = CONFIG_USB_SERIAL_DEBUG;
+
+#include "usb-serial.h"
+
+#define DRIVER_VERSION "1.0.1"
+#define DRIVER_AUTHOR "Benedikt Spranger, Robert Schwebel, Stuart Lynnes, Tom Rushworth"
+#define DRIVER_DESC "USB Multiserial"
+#define DRIVER_SHORTNAME "multiser"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+static __u16 vendor = 0;
+static __u16 product = 0;
+
+static int ports = 4;		/* default number of ports          */
+
+module_param(debug, int, 666);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+module_param(vendor, ushort, 666);
+MODULE_PARM_DESC(vendor, "User specified USB idVendor");
+
+module_param(product, ushort, 666);
+MODULE_PARM_DESC(product, "User specified USB idProduct");
+
+module_param(ports, int, 666);
+MODULE_PARM_DESC(ports, "Number of ports (default=4)");
+
+#define MULTISER_VERSION 0x01;	/* change if header format changes! */
+struct multiser_header {
+	u32 crc;		/* crc32 check sum; FIXME: remove?  */
+	u8 version;		/* header format version            */
+	u8 hdr_bytes;		/* number of header bytes           */
+	u8 port_number;		/* port this package is for         */
+	u8 valid_bytes;		/* valid bytes in this packet       */
+};
+
+/* we support these devices */
+static struct usb_device_id id_table[] = {
+	{USB_DEVICE(0x0525, 0xa4a6)},	/* g_serial                                    */
+	{USB_DEVICE(0x0000, 0x0000)},	/* placeholder for command line vendor/product */
+	{}			/* termination entry                           */
+};
+
+MODULE_DEVICE_TABLE(usb, id_table);
+
+static struct usb_driver multiser_driver = {
+	.owner = THIS_MODULE,
+	.name = "multiser_serial",
+	.probe = usb_multiserial_probe,
+	.disconnect = usb_serial_disconnect,
+	.id_table = id_table,
+};
+
+/* port buffer state machine */
+
+#define PORT_BUFFER_EMPTY 0
+#define PORT_BUFFER_NOT_EMPTY 1
+static unsigned char port_state[MAX_NUM_PORTS];
+
+static void
+multiser_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial *serial = port->serial;
+	struct usb_serial_port *pport;
+	unsigned char *data = urb->transfer_buffer;
+	struct multiser_header *header;
+	int i;
+	int result;
+
+	if (!serial) {
+		dbg("%s: bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
+	if (urb->status) {
+		dbg("%s: nonzero read bulk status received: %d", __FUNCTION__,
+		    urb->status);
+		return;
+	}
+#ifdef DEBUG_ECHO_RX
+	{
+		int i;
+		unsigned char *cp = data;
+		for (i = 0; i < port->read_urb->actual_length; i++) {
+			if (!(i % 8))
+				printk("\nreadbuffer[%02x] ", i);
+			printk("%02x ", *cp++);
+		}
+		printk("\n");
+	}
+#endif
+	
+	header = (struct multiser_header *) port->read_urb->transfer_buffer;
+	
+#if DBG_SHORT
+	{
+		unsigned long long ret=0;
+		
+		rdtscll (ret);
+		printk ("->%d: %Ld\n", header->port_number, ret);
+	}
+#endif
+	
+	dbg("%s: length=%d valid=%d",
+	    __FUNCTION__, port->read_urb->actual_length, header->valid_bytes);
+
+	/* FIXME: check crc here */
+
+	pport = serial->port[header->port_number];
+	if (pport->tty) {
+		for (i = 0; i < header->valid_bytes - header->hdr_bytes; i++)
+			tty_insert_flip_char(pport->tty,
+					     *(data + header->hdr_bytes + i),
+					     0);
+
+		tty_flip_buffer_push(pport->tty);
+	}
+
+	/* Continue trying to always read  */
+	usb_fill_bulk_urb(port->read_urb, serial->dev,
+			  usb_rcvbulkpipe(serial->dev,
+					  port->bulk_in_endpointAddress),
+			  port->read_urb->transfer_buffer,
+			  port->read_urb->transfer_buffer_length,
+			  multiser_read_bulk_callback, port);
+
+	if ((result = usb_submit_urb(port->read_urb, GFP_ATOMIC))) {
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__,
+		    result);
+	}
+
+}
+
+static void multiser_write_urb(struct usb_serial_port *port);
+
+/**
+ * multiser_write - collect terminal bytes in buffer
+ *
+ * When there is no space left in the buffer or a timeout occurs, kickstart 
+ * "real" URB transfer by calling multiser_write_urb(). 
+ */
+static int
+multiser_write(struct usb_serial_port *port, int from_user,
+	       const unsigned char *buf, int count)
+{
+	struct multiser_header *header;
+	int bytes_to_write;
+	unsigned char *data;
+
+	dbg("%s: port_num=%d urb=%p count=%i", __FUNCTION__, port->number,
+	    port->write_urb, count);
+
+	if (!port->write_urb) {
+		dbg("%s: write_urb=NULL", __FUNCTION__);
+		return 0;
+	}
+	port->write_urb->context = port;
+	if (port->write_urb->transfer_buffer_length <
+	    sizeof (struct multiser_header)) {
+		dbg("%s: write urb transfer_buffer_length too small",
+		    __FUNCTION__);
+		return 0;
+	}
+	if (count == 0) {
+		dbg("%s: write request of 0 bytes", __FUNCTION__);
+		return 0;
+	}
+	if (port->write_urb->status == -EINPROGRESS) {
+		dbg("%s: already writing", __FUNCTION__);
+		return 0;
+	}
+
+	/* check for current position in buffer */
+	header = (struct multiser_header *) port->write_urb->transfer_buffer;
+
+	memset(port->write_urb->transfer_buffer, 0,
+	       port->write_urb->transfer_buffer_length);
+	header->crc = 0x0;
+	header->version = MULTISER_VERSION;
+	header->hdr_bytes = sizeof (struct multiser_header);
+	header->port_number = port->number;
+
+	bytes_to_write =
+	    min((port->write_urb->transfer_buffer_length -
+		 (int) sizeof (struct multiser_header)), count);
+	dbg("%s: trying to write %i bytes, writing %i\n", __FUNCTION__, count,
+	    port->write_urb->transfer_buffer_length -
+	    sizeof (struct multiser_header)
+	    );
+
+	data =
+	    (unsigned char *) port->write_urb->transfer_buffer +
+	    sizeof (struct multiser_header);
+	if (from_user) {
+		if (copy_from_user(data, buf, bytes_to_write))
+			return -EFAULT;
+	} else
+		memcpy(data, buf, bytes_to_write);
+
+	header->valid_bytes = bytes_to_write + header->hdr_bytes;
+
+	multiser_write_urb(port);
+
+	dbg("%s: valid_bytes=%i", __FUNCTION__, header->valid_bytes);
+	return bytes_to_write;
+}
+
+/**
+ * multiser_write_urb - when a buffer is full transfer it to the device
+ *
+ * transfer_buffer is filled, kickstart URB transfer.  
+ */
+static void
+multiser_write_urb(struct usb_serial_port *port)
+{
+	struct multiser_header *header =
+	    (struct multiser_header *) port->write_urb->transfer_buffer;
+	struct usb_serial *serial = port->serial;
+	int result;
+
+	dbg("%s: sending %i bytes", __FUNCTION__, header->valid_bytes);
+
+	header->crc = crc32(0xdeadbeef,
+			    port->write_urb->transfer_buffer,
+			    port->write_urb->transfer_buffer_length);
+
+	dbg("%s: crc32=0x%08x", __FUNCTION__, header->crc);
+
+#ifdef DEBUG_ECHO_TX
+	{
+		int i;
+		unsigned char *cp = port->write_urb->transfer_buffer;
+		for (i = 0; i < port->write_urb->transfer_buffer_length; i++) {
+			if (!(i % 8))
+				printk("\nwritebuffer[%02x] ", i);
+			printk("%02x ", *cp++);
+		}
+		printk("\n");
+	}
+#endif
+	dbg("%s: urb = %p port = %p\n", __FUNCTION__, port->write_urb, port);
+
+	port->write_urb->dev = serial->dev;
+	if ((result = usb_submit_urb(port->write_urb, GFP_KERNEL))) {
+		err("%s - failed submitting write urb, error %d", __FUNCTION__,
+		    result);
+		return;
+	}
+	
+#if DBG_SHORT
+	{
+		unsigned long long ret=0;
+		
+		rdtscll (ret);
+		printk ("%d->: %Ld\n", header->port_number, ret);
+	}
+#endif
+	
+	port_state[port->number] = PORT_BUFFER_EMPTY;
+	dbg("%s urb: %p submitted", __FUNCTION__, port->write_urb);
+}
+
+/**
+ * multiser_write_room 
+ */
+static int
+multiser_write_room(struct usb_serial_port *port)
+{
+	int room = 0;		/* default: no room */
+
+	if (port->write_urb->status != -EINPROGRESS)
+		room = port->bulk_out_size - sizeof (struct multiser_header);
+
+	if (room)
+		dbg("multiser_write_room returns %d", room);
+
+	return room;
+}
+
+static int
+multiser_startup(struct usb_serial *serial)
+{
+	dbg("%s:", __FUNCTION__);
+
+	/* FIXME: do we have some initialisation to do here? */
+
+	return 0;
+}
+
+void
+multiser_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial *serial = port->serial;
+
+	dbg("%s: urb = %p port = %p serial = %p\n", __FUNCTION__, urb,
+	       port, serial);
+
+#if DBG_SHORT
+	{
+		unsigned long long ret=0;
+		
+		rdtscll (ret);
+		printk ("%d->F: %Ld\n", port->number, ret);
+	}
+#endif
+	
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting", __FUNCTION__);
+		return;
+	}
+
+	if (urb->status) {
+		dbg("%s - nonzero write bulk status received: %d",
+		    __FUNCTION__, urb->status);
+		return;
+	}
+
+	usb_serial_port_softint((void *) port);
+
+	schedule_work(&port->work);
+
+	return;
+}
+
+static void
+multiser_close(struct usb_serial_port *port, struct file *filp)
+{
+	struct usb_serial *serial = port->serial;
+	if (!serial)
+		return;
+
+	dbg("%s port %d", __FUNCTION__, port->number);
+
+	if (serial->dev) {
+		/* shutdown our bulk reads */
+		usb_unlink_urb(port->read_urb);
+	}
+}
+
+static struct usb_serial_device_type multiser_device = {
+	.owner = THIS_MODULE,
+	.name = "MultiSerial Protocol",
+	.short_name = "multiser",
+	.id_table = id_table,
+	.num_interrupt_in = NUM_DONT_CARE,
+	.num_bulk_in = NUM_DONT_CARE,
+	.num_bulk_out = NUM_DONT_CARE,
+	.num_ports = 0,
+	.write = multiser_write,
+	.write_room = multiser_write_room,
+	.read_bulk_callback = multiser_read_bulk_callback,
+	.write_bulk_callback = multiser_write_bulk_callback,
+	.attach = multiser_startup,
+	.close = multiser_close,
+};
+
+static int __init
+multiser_init(void)
+{
+	int i = 0, retval;
+
+	info(DRIVER_VERSION " " DRIVER_AUTHOR);
+	info(DRIVER_DESC);
+
+	/* add command line vendor/product to predefined list */
+	if (vendor && product) {
+		while (id_table[i++].idVendor) ;
+		id_table[i].idVendor = vendor;
+		id_table[i].idProduct = product;
+	}
+
+	multiser_device.num_ports = ports;
+
+	dbg("%s: trying to register driver, max. %i port%s",
+	    __FUNCTION__, ports, (ports == 1) ? "" : "s");
+
+	usb_serial_tty_driver->init_termios.c_iflag
+	    &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR |
+		 IGNCR | ICRNL | IXON | IXOFF | IXANY | IUCLC | IMAXBEL);
+
+	usb_serial_tty_driver->init_termios.c_oflag
+	    &= ~(OPOST | OLCUC | OCRNL | ONOCR | ONLRET | OFILL | OFDEL |
+		 NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY);
+	usb_serial_tty_driver->init_termios.c_oflag
+	    |= ONLCR | NL0 | CR0 | TAB0 | BS0 | VT0 | FF0;
+
+	usb_serial_tty_driver->init_termios.c_cflag
+	    = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+
+	usb_serial_tty_driver->init_termios.c_lflag
+	    &= ~(ISIG | ICANON | ECHO | ECHONL | NOFLSH | XCASE | TOSTOP |
+		 ECHOPRT);
+
+	usb_serial_tty_driver->init_termios.c_lflag
+	    |= ECHOE | ECHOK | ECHOCTL | ECHOKE;
+
+	retval = usb_serial_register(&multiser_device);
+	if (retval)
+		goto failed_usb_serial_register;
+
+	retval = usb_register(&multiser_driver);
+	if (retval)
+		goto failed_usb_register;
+
+	return 0;
+
+      failed_usb_register:
+	usb_serial_deregister(&multiser_device);
+
+      failed_usb_serial_register:
+	return retval;
+}
+
+static void __exit
+multiser_exit(void)
+{
+	usb_deregister(&multiser_driver);
+	usb_serial_deregister(&multiser_device);
+}
+
+module_init(multiser_init);
+module_exit(multiser_exit);
Index: drivers/usb/gadget/inode.c
===================================================================
--- a/drivers/usb/gadget/inode.c	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/gadget/inode.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -268,7 +268,6 @@
 #define INFO(dev,fmt,args...) \
 	xprintk(dev , KERN_INFO , fmt , ## args)
 
-
 /*----------------------------------------------------------------------*/
 
 /* SYNCHRONOUS ENDPOINT OPERATIONS (bulk/intr/iso)
Index: drivers/usb/gadget/Kconfig
===================================================================
--- a/drivers/usb/gadget/Kconfig	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/gadget/Kconfig	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -188,6 +188,15 @@
 	   Select this only if your OMAP board has a Mini-AB connector.
 
 
+config USB_GADGET_H7202
+	boolean "Hynix h7202"
+	depends on ARCH_H7202
+	  
+config USB_H7202
+	tristate
+	depends on USB_GADGET_H7202
+	default USB_GADGET
+
 config USB_GADGET_DUMMY_HCD
 	boolean "Dummy HCD (DEVELOPMENT)"
 	depends on USB && EXPERIMENTAL
@@ -387,7 +396,19 @@
 	  which includes instructions and a "driver info file" needed to
 	  make MS-Windows work with this driver.
 
+config USB_G_MULTISER
+	tristate "MultiSerial Gadget"
+	help
+	  The Multiser Gadget talks to the Multiser Linux Host side driver.
+	  It's main use is for the Hynix h7202 gadget driver. The hynix h7202
+	  usb is very broken: We can only send packets of size zero or 32, so
+	  don't even try to use other gadget drivers than this one
 
+	  Say "y" to link the driver statically, or "m" to build a
+	  dynamically linked module called "multiser".
+
+
+
 # put drivers that need isochronous transfer support (for audio
 # or video class gadget drivers), or specific hardware, here.
 
Index: drivers/usb/gadget/h7202_udc.h
===================================================================
--- a/drivers/usb/gadget/h7202_udc.h	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/usb/gadget/h7202_udc.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,131 @@
+/*
+ * linux/drivers/usb/gadget/h7202_udc.h
+ *
+ * Copyright (C) 2003 Robert Schwebel, Benedikt Spranger
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_USB_GADGET_H7202_H
+#define __LINUX_USB_GADGET_H7202_H
+
+#include <linux/types.h>
+
+/* GCTRL */
+
+#define USBD_TRANDIS		0x08
+#define USBD_WBACK		0x04
+#define USBD_RESUME		0x02
+#define USBD_DMADIS		0x01
+
+/* EPCTRL */
+
+#define USBD_CLR2		(1<<20)
+#define USBD_CLR1		(1<<19)
+#define USBD_CLR0		(1<<18)
+#define USBD_E2SND		(1<<15)
+#define USBD_E2NK		(1<<14)
+#define USBD_E2ST		(1<<13)
+#define USBD_E2EN		(1<<12)
+#define USBD_E1RCV		(1<<11)
+#define USBD_E1NK		(1<<10)
+#define USBD_E1ST		(1<<9)
+#define USBD_E1EN		(1<<8)
+#define USBD_E0NK		(1<<4)
+#define USBD_E0ST		(1<<3)
+#define USBD_E0TR		(1<<2)
+#define USBD_E0EN		(1<<1)
+
+/* INTSTAT/INTMASK */
+
+#define USBD_E0STL		0x200
+#define USBD_SUS		0x100
+#define USBD_RESET		0x080
+#define USBD_E2EM		0x040
+#define USBD_E1OV		0x020
+#define USBD_E1FU		0x010
+#define USBD_E0EM		0x008
+#define USBD_E0OV		0x004
+#define USBD_E0FU		0x002
+#define USBD_SET		0x001
+
+#define USBD_INTMASK_DISABLE	0x3FF
+
+/* PWR */
+#define USBD_ENBCLK		0x8
+#define USBD_SWUPDATE		0x4
+#define USBD_FULLPOWER		0x2	
+#define USBD_POWERDOWN		0x1
+#define USBD_FULL_POWERDOWN	0x0
+
+/* FIFO */
+#define FIFO_SIZE		32
+
+struct h7202_ep 
+{
+	struct usb_ep				ep;
+	struct h7202_udc			*dev;
+	unsigned long				irqs;
+	
+	/* analogous to a host-side qh */
+	struct list_head                        queue;
+	const struct usb_endpoint_descriptor    *desc;
+	u32					*ep_rdaddr;
+	u32					*ep_wtaddr;
+	unsigned				num:8,
+	    					stopped : 1;
+};
+
+struct h7202_request 
+{
+	struct usb_request              req;
+	struct list_head                queue;
+};
+
+enum ep0state 
+{
+	EP0_OK,
+	EP0_SUSPEND,
+	EP0_STALL,
+	EP0_RESET,
+};
+
+struct udc_stats 
+{
+	struct ep0stats 
+	{
+		unsigned long		ops;
+		unsigned long		bytes;
+	} read, write;
+
+	unsigned long			irqs;
+};
+
+struct h7202_udc 
+{
+	struct usb_gadget		gadget;
+	spinlock_t			lock;
+	struct h7202_ep			ep [3];
+	struct usb_gadget_driver	*driver;
+	
+	enum ep0state			ep0state;
+	struct udc_stats		stats;
+	unsigned			got_irq : 1;
+};
+
+static struct h7202_udc *the_controller;
+
+#define dump_state(x)	do {} while(0)
+
+#endif /* __LINUX_USB_GADGET_H7202_H */
Index: drivers/usb/gadget/multiser.c
===================================================================
--- a/drivers/usb/gadget/multiser.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/usb/gadget/multiser.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,2488 @@
+/*
+ * multiser.c -- USB gadget multiport serial driver
+ *
+ * $Id: multiser.c,v 1.4 2004/05/21 19:21:44 robert Exp $
+ *
+ * Copyright 2004 (C) Robert Schwebel, Benedikt Spranger, Pengutronix
+ * Copyright 2003 (C) Al Borchers (alborchers@steinerpoint.com)
+ *
+ * This code is based in part on the Gadget Zero driver, which
+ * is Copyright (C) 2003 by David Brownell, all rights reserved.
+ *
+ * This code also borrows from usbserial.c, which is
+ * Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (c) 2000 Peter Berger (pberger@brimson.com)
+ * Copyright (c) 2000 Al Borchers (alborchers@steinerpoint.com)
+ *
+ * This software is distributed under the terms of the GNU General
+ * Public License ("GPL") as published by the Free Software Foundation,
+ * either version 2 of that License or (at your option) any later version.
+ *
+ */
+
+#ifndef __KERNEL__
+#define __KERNEL__
+#endif
+
+#ifndef MODULE
+#define MODULE
+#endif
+
+//#define G_SERIAL_DEBUG 1
+#undef G_SERIAL_DEBUG
+
+/* Includes */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/uts.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/crc32.h>
+#include <linux/device.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/uaccess.h>
+
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+#include "gadget_chips.h"
+
+/* FIXME: BSP: put these into header file */
+/* FIXME: RSC: implement crc :-)          */
+
+#define crc32(seed, data, length)  crc32_le(seed, (unsigned char const *)data, length)
+
+#define MULTISER_VERSION 0x01	/* change if header format changes! */
+struct multiser_header {
+	u32 crc;		/* crc32 check sum; FIXME: smaller? */
+	u8 version;		/* header format version            */
+	u8 hdr_bytes;		/* number of header bytes           */
+	u8 port_number;		/* port this package is for         */
+	u8 valid_bytes;		/* valid bytes in this packet       */
+};
+
+/* Wait Cond */
+
+#define __wait_cond_interruptible(wq, condition, lock, flags, ret)	\
+do {									\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			schedule();					\
+			spin_lock_irqsave(lock, flags);			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+
+#define wait_cond_interruptible(wq, condition, lock, flags)		\
+({									\
+	int __ret = 0;							\
+	if (!(condition))						\
+		__wait_cond_interruptible(wq, condition, lock, flags,	\
+						__ret);			\
+	__ret;								\
+})
+
+#define __wait_cond_interruptible_timeout(wq, condition, lock, flags, 	\
+						timeout, ret)		\
+do {									\
+	signed long __timeout = timeout;				\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (__timeout == 0)					\
+			break;						\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			__timeout = schedule_timeout(__timeout);	\
+			spin_lock_irqsave(lock, flags);			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+
+#define wait_cond_interruptible_timeout(wq, condition, lock, flags,	\
+						timeout)		\
+({									\
+	int __ret = 0;							\
+	if (!(condition))						\
+		__wait_cond_interruptible_timeout(wq, condition, lock,	\
+						flags, timeout, __ret);	\
+	__ret;								\
+})
+
+/* Defines */
+
+#define GS_VERSION_STR			"v0.1"
+#define GS_VERSION_NUM			0x0001
+
+#define GS_LONG_NAME			"Gadget Multiport Serial"
+#define GS_SHORT_NAME			"g_multiser"
+
+#define GS_MAJOR			127
+#define GS_MINOR_START			0
+
+#define GS_NUM_PORTS			8
+
+#define GS_NUM_CONFIGS			1
+#define GS_NO_CONFIG_ID			0
+#define GS_BULK_CONFIG_ID		2
+
+#define GS_NUM_INTERFACES		1
+#define GS_INTERFACE_ID			0
+#define GS_ALT_INTERFACE_ID		0
+
+#define GS_NUM_ENDPOINTS		2
+
+#define GS_MAX_DESC_LEN			256
+
+#define GS_DEFAULT_READ_Q_SIZE		32
+#define GS_DEFAULT_WRITE_Q_SIZE		32
+
+#define GS_DEFAULT_WRITE_BUF_SIZE	8192
+#define GS_TMP_BUF_SIZE			32
+
+#define GS_CLOSE_TIMEOUT		15
+
+/* debug macro */
+#if G_SERIAL_DEBUG
+
+static int debug = G_SERIAL_DEBUG;
+
+#define gs_debug(format, arg...) \
+	do { if(debug) printk( KERN_DEBUG format, ## arg ); } while(0)
+#define gs_debug_level(level, format, arg...) \
+	do { if(debug>=level) printk( KERN_DEBUG format, ## arg ); } while(0)
+
+#else
+
+#define gs_debug(format, arg...) \
+	do { } while(0)
+#define gs_debug_level(level, format, arg...) \
+	do { } while(0)
+
+#endif				/* G_SERIAL_DEBUG */
+
+/* USB Controllers */
+
+/*
+ * NetChip 2280, PCI based.
+ *
+ * This has half a dozen configurable endpoints, four with dedicated
+ * DMA channels to manage their FIFOs.  It supports high speed.
+ * Those endpoints can be arranged in any desired configuration.
+ */
+#ifdef	CONFIG_USB_GADGET_NET2280
+#define CHIP				"net2280"
+#define EP0_MAXPACKET			64
+static const char EP_OUT_NAME[] = "ep-a";
+#define EP_OUT_NUM			2
+static const char EP_IN_NAME[] = "ep-b";
+#define EP_IN_NUM			2
+#define HIGHSPEED
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+extern int net2280_set_fifo_mode(struct usb_gadget *gadget, int mode);
+
+static inline void
+hw_optimize(struct usb_gadget *gadget)
+{
+	/* we can have bigger ep-a/ep-b fifos (2KB each, 4 packets
+	 * for highspeed bulk) because we're not using ep-c/ep-d.
+	 */
+	net2280_set_fifo_mode(gadget, 1);
+}
+#endif
+
+/*
+ * PXA-2xx UDC:  widely used in second gen Linux-capable PDAs.
+ *
+ * This has fifteen fixed-function full speed endpoints, and it
+ * can support all USB transfer types.
+ *
+ * These supports three or four configurations, with fixed numbers.
+ * The hardware interprets SET_INTERFACE, net effect is that you
+ * can't use altsettings or reset the interfaces independently.
+ * So stick to a single interface.
+ */
+#ifdef	CONFIG_USB_GADGET_PXA2XX
+#define CHIP				"pxa2xx"
+#define EP0_MAXPACKET			16
+static const char EP_OUT_NAME[] = "ep2out-bulk";
+#define EP_OUT_NUM			2
+static const char EP_IN_NAME[] = "ep1in-bulk";
+#define EP_IN_NUM			1
+#define SELFPOWER 			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.
+ *
+ * This has only two fixed function endpoints, which can only
+ * be used for bulk (or interrupt) transfers.  (Plus control.)
+ *
+ * Since it can't flush its TX fifos without disabling the UDC,
+ * the current configuration or altsettings can't change except
+ * in special situations.  So this is a case of "choose it right
+ * during enumeration" ...
+ */
+#ifdef	CONFIG_USB_GADGET_SA1100
+#define CHIP				"sa1100"
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME[] = "ep1out-bulk";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME[] = "ep2in-bulk";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * Toshiba TC86C001 ("Goku-S") UDC
+ *
+ * This has three semi-configurable full speed bulk/interrupt endpoints.
+ */
+#ifdef	CONFIG_USB_GADGET_GOKU
+#define CHIP				"goku"
+#define DRIVER_VERSION_NUM		0x0116
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME[] = "ep1-bulk";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME[] = "ep2-bulk";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * SuperH UDC:  UDC built-in to some Renesas SH processors.
+ *
+ * This has 4 fixed-function full speed endpoints.
+ */
+#ifdef	CONFIG_USB_FILE_STORAGE_SUPERH
+#define CHIP			"superh"
+#define DRIVER_VERSION_NUM		0x0117
+#define EP0_MAXPACKET		8
+static const char EP_OUT_NAME[] = "ep1out-bulk";
+#define EP_OUT_NUM		1
+static const char EP_IN_NAME[] = "ep2in-bulk";
+#define EP_IN_NUM		2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+#undef GS_BULK_CONFIG_ID
+#define GS_BULK_CONFIG_ID		1
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * Hynix HMS 30C7202 UDC
+ * 
+ * This has 2 fixed-function full speed endpoints with some errata :-)
+ * 
+ */
+
+#ifdef CONFIG_USB_GADGET_H7202
+# define CHIP				"h7202"
+#define DRIVER_VERSION_NUM		0x001
+#define EP0_MAXPACKET			8
+static const char EP_OUT_NAME[] = "ep1";
+#define EP_OUT_NUM			1
+static const char EP_IN_NAME[] = "ep2";
+#define EP_IN_NUM			2
+#define SELFPOWER			USB_CONFIG_ATT_SELFPOWER
+
+/* no hw optimizations to apply */
+#define hw_optimize(g)			do {} while (0)
+#endif
+
+/*
+ * USB Controller Defaults
+ */
+#ifndef EP0_MAXPACKET
+#error Configure some USB peripheral controller for g_serial!
+#endif
+
+#ifndef SELFPOWER
+/* default: say we rely on bus power */
+#define SELFPOWER   			0
+/* else value must be USB_CONFIG_ATT_SELFPOWER */
+#endif
+
+#ifndef	MAX_USB_POWER
+/* any hub supports this steady state bus power consumption */
+#define MAX_USB_POWER			100	/* mA */
+#endif
+
+#ifndef	WAKEUP
+/* default: this driver won't do remote wakeup */
+#define WAKEUP				0
+/* else value must be USB_CONFIG_ATT_WAKEUP */
+#endif
+
+/* Thanks to NetChip Technologies for donating this product ID.
+ *
+ * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
+ * Instead:  allocate your own, using normal USB-IF procedures.
+ */
+#define GS_VENDOR_ID	0x0525	/* NetChip */
+#define GS_PRODUCT_ID	0xa4a6	/* Linux-USB Serial Gadget */
+
+/* Structures */
+
+struct gs_dev;
+
+/* circular buffer */
+struct gs_buf {
+	unsigned int buf_size;
+	char *buf_buf;
+	char *buf_get;
+	char *buf_put;
+};
+
+/* list of requests */
+struct gs_req_entry {
+	struct list_head re_entry;
+	struct usb_request *re_req;
+	struct gs_port *port;
+};
+
+/* the port structure holds info for each port, one for each minor number */
+struct gs_port {
+	struct gs_dev *port_dev;	/* pointer to device struct */
+	struct tty_struct *port_tty;	/* pointer to tty struct */
+	spinlock_t port_lock;
+	int port_num;
+	int port_open_count;
+	int port_in_use;	/* open/close in progress */
+	wait_queue_head_t port_write_wait;	/* waiting to write */
+	struct gs_buf *port_write_buf;
+};
+
+/* the device structure holds info for the USB device */
+struct gs_dev {
+	struct usb_gadget *dev_gadget;	/* gadget device pointer */
+	spinlock_t dev_lock;	/* lock for set/reset config */
+	int dev_config;		/* configuration number */
+	struct usb_ep *dev_in_ep;	/* address of in endpoint */
+	struct usb_ep *dev_out_ep;	/* address of out endpoint */
+	struct usb_request *dev_ctrl_req;	/* control request */
+	struct list_head dev_req_list;	/* list of write requests */
+	int dev_sched_port;	/* round robin port scheduled */
+	struct gs_port *dev_port[GS_NUM_PORTS];	/* the ports */
+};
+
+/* Functions */
+
+/* module */
+static int __init gs_module_init(void);
+static void __exit gs_module_exit(void);
+
+/* tty driver */
+static int gs_open(struct tty_struct *tty, struct file *file);
+static void gs_close(struct tty_struct *tty, struct file *file);
+static int gs_write(struct tty_struct *tty, int from_user,
+		    const unsigned char *buf, int count);
+static void gs_put_char(struct tty_struct *tty, unsigned char ch);
+static void gs_flush_chars(struct tty_struct *tty);
+static int gs_write_room(struct tty_struct *tty);
+static int gs_chars_in_buffer(struct tty_struct *tty);
+static void gs_throttle(struct tty_struct *tty);
+static void gs_unthrottle(struct tty_struct *tty);
+static void gs_break(struct tty_struct *tty, int break_state);
+static int gs_ioctl(struct tty_struct *tty, struct file *file,
+		    unsigned int cmd, unsigned long arg);
+static void gs_set_termios(struct tty_struct *tty, struct termios *old);
+static int gs_read_proc(char *page, char **start, off_t off, int count,
+			int *eof, void *data);
+
+static int gs_send(struct gs_port *port);
+static int gs_send_packet(struct gs_port *port, char *packet,
+			  unsigned int size);
+static int gs_recv_packet(struct gs_dev *dev, char *packet, unsigned int size);
+static void gs_read_complete(struct usb_ep *ep, struct usb_request *req);
+static void gs_write_complete(struct usb_ep *ep, struct usb_request *req);
+
+/* gadget driver */
+static int gs_bind(struct usb_gadget *gadget);
+static void gs_unbind(struct usb_gadget *gadget);
+static int gs_setup(struct usb_gadget *gadget,
+		    const struct usb_ctrlrequest *ctrl);
+static void gs_setup_complete(struct usb_ep *ep, struct usb_request *req);
+static void gs_disconnect(struct usb_gadget *gadget);
+static int gs_set_config(struct gs_dev *dev, unsigned config);
+static void gs_reset_config(struct gs_dev *dev);
+static int gs_build_config_desc(u8 * buf, enum usb_device_speed speed,
+				u8 type, unsigned int index);
+
+static struct usb_request *gs_alloc_req(struct usb_ep *ep, unsigned int len,
+					int kmalloc_flags);
+static void gs_free_req(struct usb_ep *ep, struct usb_request *req);
+
+static struct gs_req_entry *gs_alloc_req_entry(struct usb_ep *ep, unsigned len,
+					       int kmalloc_flags);
+static void gs_free_req_entry(struct usb_ep *ep, struct gs_req_entry *req);
+
+static int gs_alloc_ports(struct gs_dev *dev, int kmalloc_flags);
+static void gs_free_ports(struct gs_dev *dev);
+
+/* circular buffer */
+static struct gs_buf *gs_buf_alloc(unsigned int size, int kmalloc_flags);
+static void gs_buf_free(struct gs_buf *gb);
+static void gs_buf_clear(struct gs_buf *gb);
+static unsigned int gs_buf_data_avail(struct gs_buf *gb);
+static unsigned int gs_buf_space_avail(struct gs_buf *gb);
+static unsigned int gs_buf_put(struct gs_buf *gb, const char *buf,
+			       unsigned int count);
+static unsigned int gs_buf_get(struct gs_buf *gb, char *buf,
+			       unsigned int count);
+
+/* Globals */
+
+static struct semaphore gs_open_close_sem[GS_NUM_PORTS];
+
+static unsigned int read_q_size = GS_DEFAULT_READ_Q_SIZE;
+static unsigned int write_q_size = GS_DEFAULT_WRITE_Q_SIZE;
+
+static unsigned int write_buf_size = GS_DEFAULT_WRITE_BUF_SIZE;
+
+static unsigned char gs_tmp_buf[GS_TMP_BUF_SIZE];
+static struct semaphore gs_tmp_buf_sem;
+
+/* tty variables */
+static int gs_refcount;
+static struct tty_struct *gs_tty[GS_NUM_PORTS];
+static struct termios *gs_termios[GS_NUM_PORTS];
+static struct termios *gs_termios_locked[GS_NUM_PORTS];
+
+/* tty driver struct */
+
+static struct tty_driver gs_tty_driver = {
+	.magic = TTY_DRIVER_MAGIC,
+	.driver_name = GS_SHORT_NAME,
+	.devfs_name = "tts/USBD",
+	.name = "ttyUSBD",
+	.major = GS_MAJOR,
+	.minor_start = GS_MINOR_START,
+	.num = GS_NUM_PORTS,
+	.type = TTY_DRIVER_TYPE_SERIAL,
+	.subtype = SERIAL_TYPE_NORMAL,
+	.flags = TTY_DRIVER_REAL_RAW,
+	.refcount = &gs_refcount,
+	.ttys = gs_tty,
+	.termios = gs_termios,
+	.termios_locked = gs_termios_locked,
+
+	.open = gs_open,
+	.close = gs_close,
+	.write = gs_write,
+	.put_char = gs_put_char,
+	.flush_chars = gs_flush_chars,
+	.write_room = gs_write_room,
+	.ioctl = gs_ioctl,
+	.set_termios = gs_set_termios,
+	.throttle = gs_throttle,
+	.unthrottle = gs_unthrottle,
+	.break_ctl = gs_break,
+	.chars_in_buffer = gs_chars_in_buffer,
+	.read_proc = gs_read_proc,
+};
+
+static struct gs_dev *gs_tty_drv;
+
+/* gadget driver struct */
+static struct usb_gadget_driver gs_gadget_driver = {
+#ifdef HIGHSPEED
+	.speed = USB_SPEED_HIGH,
+#else
+	.speed = USB_SPEED_FULL,
+#endif
+	.function = GS_LONG_NAME,
+	.bind = gs_bind,
+	.unbind = gs_unbind,
+	.setup = gs_setup,
+	.disconnect = gs_disconnect,
+	.driver = {
+		   .name = GS_SHORT_NAME,
+		   /* .shutdown = ... */
+		   /* .suspend = ...  */
+		   /* .resume = ...   */
+		   },
+};
+
+/* USB descriptors */
+
+#define GS_MANUFACTURER_STR_ID	1
+#define GS_PRODUCT_STR_ID	2
+#define GS_SERIAL_STR_ID	3
+#define GS_CONFIG_STR_ID	4
+
+/* static strings, in iso 8859/1 */
+static struct usb_string gs_strings[] = {
+	{GS_MANUFACTURER_STR_ID, UTS_SYSNAME " " UTS_RELEASE " with " CHIP},
+	{GS_PRODUCT_STR_ID, GS_LONG_NAME},
+	{GS_SERIAL_STR_ID, "0"},
+	{GS_CONFIG_STR_ID, "Bulk"},
+	{}			/* end of list */
+};
+
+static struct usb_gadget_strings gs_string_table = {
+	.language = 0x0409,	/* en-us */
+	.strings = gs_strings,
+};
+
+static const struct usb_device_descriptor gs_device_desc = {
+	.bLength = USB_DT_DEVICE_SIZE,
+	.bDescriptorType = USB_DT_DEVICE,
+	.bcdUSB = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass = USB_CLASS_VENDOR_SPEC,
+	.bMaxPacketSize0 = EP0_MAXPACKET,
+	.idVendor = __constant_cpu_to_le16(GS_VENDOR_ID),
+	.idProduct = __constant_cpu_to_le16(GS_PRODUCT_ID),
+	.bcdDevice = __constant_cpu_to_le16(GS_VERSION_NUM),
+	.iManufacturer = GS_MANUFACTURER_STR_ID,
+	.iProduct = GS_PRODUCT_STR_ID,
+	.iSerialNumber = GS_SERIAL_STR_ID,
+	.bNumConfigurations = GS_NUM_CONFIGS,
+};
+
+static const struct usb_config_descriptor gs_config_desc = {
+	.bLength = USB_DT_CONFIG_SIZE,
+	.bDescriptorType = USB_DT_CONFIG,
+	/* .wTotalLength set by gs_build_config_desc */
+	.bNumInterfaces = GS_NUM_INTERFACES,
+	.bConfigurationValue = GS_BULK_CONFIG_ID,
+	.iConfiguration = GS_CONFIG_STR_ID,
+	.bmAttributes = USB_CONFIG_ATT_ONE | SELFPOWER | WAKEUP,
+	.bMaxPower = (MAX_USB_POWER + 1) / 2,
+};
+
+static const struct usb_interface_descriptor gs_interface_desc = {
+	.bLength = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType = USB_DT_INTERFACE,
+	.bNumEndpoints = GS_NUM_ENDPOINTS,
+	.bInterfaceClass = USB_CLASS_VENDOR_SPEC,
+	.iInterface = GS_CONFIG_STR_ID,
+};
+
+static const struct usb_endpoint_descriptor gs_fullspeed_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = EP_IN_NUM | USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(32),
+};
+
+static const struct usb_endpoint_descriptor gs_fullspeed_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = EP_OUT_NUM | USB_DIR_OUT,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(32),
+};
+
+static const struct usb_endpoint_descriptor gs_highspeed_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = EP_IN_NUM | USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(512),
+};
+
+static const struct usb_endpoint_descriptor gs_highspeed_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = EP_OUT_NUM | USB_DIR_OUT,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(512),
+};
+
+#ifdef HIGHSPEED
+static const struct usb_qualifier_descriptor gs_qualifier_desc = {
+	.bLength = sizeof (struct usb_qualifier_descriptor),
+	.bDescriptorType = USB_DT_DEVICE_QUALIFIER,
+	.bcdUSB = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass = USB_CLASS_VENDOR_SPEC,
+	/* assumes ep0 uses the same value for both speeds ... */
+	.bMaxPacketSize0 = EP0_MAXPACKET,
+	.bNumConfigurations = GS_NUM_CONFIGS,
+};
+#endif
+
+/* Module */
+
+MODULE_DESCRIPTION(GS_LONG_NAME);
+MODULE_AUTHOR("Robert Schwebel, Benedikt Spranger, Al Borchers");
+MODULE_LICENSE("GPL");
+
+#if G_SERIAL_DEBUG
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Enable debugging, 0=off, 1=on");
+#endif
+
+MODULE_PARM(read_q_size, "i");
+MODULE_PARM_DESC(read_q_size, "Read request queue size, default=32");
+
+MODULE_PARM(write_q_size, "i");
+MODULE_PARM_DESC(write_q_size, "Write request queue size, default=32");
+
+MODULE_PARM(write_buf_size, "i");
+MODULE_PARM_DESC(write_buf_size, "Write buffer size, default=8192");
+
+module_init(gs_module_init);
+module_exit(gs_module_exit);
+
+/**
+ * gs_module_init
+ *
+ * Register as a USB gadget driver and a tty driver.
+ */
+
+static int __init
+gs_module_init(void)
+{
+	int i, ret;
+
+	gs_debug_level(2, "%s\n", __FUNCTION__);
+
+	if ((ret = usb_gadget_register_driver(&gs_gadget_driver))) {
+		printk(KERN_ERR
+		       "gs_module_init: cannot register gadget driver, ret=%d\n",
+		       ret);
+		return (ret);
+	}
+
+	/* initial stty settings */
+	gs_tty_driver.init_termios = tty_std_termios;
+
+	/* set raw without echo */
+	gs_tty_driver.init_termios.c_iflag
+	    &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR |
+		 IGNCR | ICRNL | IXON | IXOFF | IXANY | IUCLC | IMAXBEL);
+
+	gs_tty_driver.init_termios.c_oflag
+	    &= ~(OPOST | OLCUC | OCRNL | ONOCR | ONLRET | OFILL | OFDEL |
+		 NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY);
+	gs_tty_driver.init_termios.c_oflag
+	    |= ONLCR | NL0 | CR0 | TAB0 | BS0 | VT0 | FF0;
+
+	gs_tty_driver.init_termios.c_cflag
+	    = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+
+	gs_tty_driver.init_termios.c_lflag
+	    &= ~(ISIG | ICANON | ECHO | ECHONL | NOFLSH | XCASE | TOSTOP |
+		 ECHOPRT);
+	gs_tty_driver.init_termios.c_lflag |= ECHOE | ECHOK | ECHOCTL | ECHOKE;
+
+	for (i = 0; i < GS_NUM_PORTS; i++)
+		sema_init(&gs_open_close_sem[i], 1);
+
+	sema_init(&gs_tmp_buf_sem, 1);
+
+	if ((ret = tty_register_driver(&gs_tty_driver))) {
+		usb_gadget_unregister_driver(&gs_gadget_driver);
+		printk(KERN_ERR
+		       "gs_module_init: cannot register tty driver, ret=%d\n",
+		       ret);
+		return (ret);
+	}
+
+	printk(KERN_INFO "%s: %s (%s) loaded\n",
+	       GS_SHORT_NAME, GS_LONG_NAME, GS_VERSION_STR);
+
+	return (0);
+
+}
+
+/**
+ * gs_module_exit
+ *
+ * Unregister as a tty driver and a USB gadget driver.
+ */
+static void __exit
+gs_module_exit(void)
+{
+	tty_unregister_driver(&gs_tty_driver);
+	usb_gadget_unregister_driver(&gs_gadget_driver);
+
+	printk(KERN_INFO "%s: %s (%s) unloaded\n",
+	       GS_SHORT_NAME, GS_LONG_NAME, GS_VERSION_STR);
+
+}
+
+/* TTY Driver */
+
+/*
+ * gs_open
+ */
+
+static int
+gs_open(struct tty_struct *tty, struct file *file)
+{
+	int port_num;
+	unsigned long flags;
+	struct gs_port *port;
+	struct gs_dev *dev;
+	struct gs_buf *buf;
+	struct semaphore *sem;
+
+	port_num = tty->index;
+
+	gs_debug_level(2, "%s: opening port (port=%d tty=%p file=%p)\n",
+		       __FUNCTION__, port_num, tty, file);
+
+	if (port_num < 0 || port_num >= GS_NUM_PORTS) {
+		printk(KERN_ERR "%s: invalid port number (port=%d)\n",
+		       __FUNCTION__, port_num);
+		return -ENODEV;
+	}
+
+	port = gs_tty_drv->dev_port[port_num];
+
+	if (!port) {
+		printk(KERN_ERR "%s: trying to use NULL port (port=%d)\n",
+		       __FUNCTION__, port_num);
+		spin_unlock_irqrestore(&dev->dev_lock, flags);
+		up(sem);
+		return -ENODEV;
+	}
+
+	dev = port->port_dev;
+
+	if (!dev) {
+		printk(KERN_ERR
+		       "%s: trying to use NULL device (port=%d tty=%p file=%p)\n",
+		       __FUNCTION__, port_num, tty, file);
+		return -ENODEV;
+	}
+
+	sem = &gs_open_close_sem[port_num];
+
+	if (down_interruptible(sem)) {
+		printk(KERN_ERR
+		       "%s: interrupted waiting for semaphore (port=%d tty=%p file=%p)\n",
+		       __FUNCTION__, port_num, tty, file);
+		return -ERESTARTSYS;
+	}
+
+	spin_lock_irqsave(&dev->dev_lock, flags);
+
+	if (dev->dev_config == GS_NO_CONFIG_ID) {
+		printk(KERN_ERR
+		       "%s: device is not connected (port=%d)\n",
+		       __FUNCTION__, port_num);
+		spin_unlock_irqrestore(&dev->dev_lock, flags);
+		up(sem);
+		return -ENODEV;
+	}
+
+	spin_lock(&port->port_lock);
+	spin_unlock(&dev->dev_lock);
+
+	if (port->port_dev == NULL) {
+		printk(KERN_ERR "%s: port disconnected (port=%d)\n",
+		       __FUNCTION__, port_num);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		up(sem);
+		return -EIO;
+	}
+
+	if (port->port_open_count > 0) {
+		++port->port_open_count;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		gs_debug("%s: already open (port=%d)\n",
+			 __FUNCTION__, port_num);
+		up(sem);
+		return 0;
+	}
+
+	/* mark port as in use, we can drop port lock and sleep if necessary */
+	port->port_in_use = 1;
+
+	/* allocate write buffer on first open */
+	if (!port->port_write_buf) {
+
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		buf = gs_buf_alloc(write_buf_size, GFP_KERNEL);
+		spin_lock_irqsave(&port->port_lock, flags);
+
+		/* might have been disconnected while asleep, check */
+		if (port->port_dev == NULL) {
+			printk(KERN_ERR
+			       "%s: not allocating write buffer, port disconnected (port=%d)\n",
+			       __FUNCTION__, port_num);
+			port->port_in_use = 0;
+			spin_unlock_irqrestore(&port->port_lock, flags);
+			up(sem);
+			return (-EIO);
+		}
+
+		if ((port->port_write_buf = buf) == NULL) {
+			printk(KERN_ERR
+			       "%s: alloc write buffer failed (port=%d)\n",
+			       __FUNCTION__, port_num);
+			port->port_in_use = 0;
+			spin_unlock_irqrestore(&port->port_lock, flags);
+			up(sem);
+			return (-ENOMEM);
+		}
+
+	}
+
+	/* might have been disconnected while asleep, check */
+	if (port->port_dev == NULL) {
+		printk(KERN_ERR "%s: lost port, disconnected? (port=%d)\n",
+		       __FUNCTION__, port_num);
+		port->port_in_use = 0;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		up(sem);
+		return (-EIO);
+	}
+
+	tty->driver_data = port;
+	port->port_tty = tty;
+	port->port_open_count = 1;
+	port->port_in_use = 0;
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+	up(sem);
+
+	gs_debug_level(2, "%s: completed (port=%d)\n", __FUNCTION__, port_num);
+
+	return (0);
+
+}
+
+/*
+ * gs_close
+ */
+
+static void
+gs_close(struct tty_struct *tty, struct file *file)
+{
+
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+	struct semaphore *sem;
+
+	if (port == NULL) {
+		printk(KERN_ERR "gs_close: NULL port pointer\n");
+		return;
+	}
+
+	gs_debug_level(2, "gs_close: (%d,%p,%p)\n", port->port_num, tty, file);
+
+	sem = &gs_open_close_sem[port->port_num];
+	down(sem);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	if (port->port_open_count == 0) {
+		printk(KERN_ERR
+		       "gs_close: (%d,%p,%p) port is already closed\n",
+		       port->port_num, tty, file);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		up(sem);
+		return;
+	}
+
+	if (port->port_open_count > 1) {
+		--port->port_open_count;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		up(sem);
+		return;
+	}
+#if 0
+	/* free disconnected port on final close */
+	if (port->port_dev == NULL) {
+		kfree(port);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		up(sem);
+		return;
+	}
+#endif
+
+	/* mark port as closed but in use, we can drop port lock */
+	/* and sleep if necessary */
+	port->port_in_use = 1;
+	port->port_open_count = 0;
+
+	/* wait for write buffer to drain, or */
+	/* at most GS_CLOSE_TIMEOUT seconds */
+	if (gs_buf_data_avail(port->port_write_buf) > 0) {
+		wait_cond_interruptible_timeout(port->port_write_wait,
+						port->port_dev == NULL
+						|| gs_buf_data_avail(port->
+								     port_write_buf)
+						== 0, &port->port_lock, flags,
+						GS_CLOSE_TIMEOUT * HZ);
+	}
+#if 0
+	/* free disconnected port on final close */
+	/* (might have happened during the above sleep) */
+	if (port->port_dev == NULL) {
+		kfree(port);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		up(sem);
+		return;
+	}
+#endif
+
+	gs_buf_clear(port->port_write_buf);
+
+	tty->driver_data = NULL;
+	port->port_tty = NULL;
+	port->port_in_use = 0;
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+	up(sem);
+
+	gs_debug("gs_close: (%d,%p,%p) completed\n", port->port_num, tty, file);
+}
+
+/**
+ * gs_write
+ */
+static int
+gs_write(struct tty_struct *tty, int from_user, const unsigned char *buf,
+	 int count)
+{
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+	if (port == NULL) {
+		printk(KERN_ERR "gs_write: NULL port pointer\n");
+		return (-EIO);
+	}
+
+	gs_debug_level(2, "%s: writing %d bytes to port %d\n",
+		       __FUNCTION__, count, port->port_num);
+
+	if (count == 0)
+		return 0;
+
+	/* copy from user into tmp buffer, get tmp_buf semaphore */
+	if (from_user) {
+		if (count > GS_TMP_BUF_SIZE)
+			count = GS_TMP_BUF_SIZE;
+		down(&gs_tmp_buf_sem);
+		if (copy_from_user(gs_tmp_buf, buf, count) != 0) {
+			up(&gs_tmp_buf_sem);
+			printk(KERN_ERR
+			       "gs_write: (%d,%p) cannot copy from user space\n",
+			       port->port_num, tty);
+			return -EFAULT;
+		}
+		buf = gs_tmp_buf;
+	}
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	if (!port->port_dev) {
+		printk(KERN_WARNING
+		       "%s: trying to write to port %i which is not connected\n",
+		       GS_SHORT_NAME, port->port_num);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		if (from_user)
+			up(&gs_tmp_buf_sem);
+		return -EIO;
+	}
+
+	if (port->port_open_count == 0) {
+		printk(KERN_ERR "gs_write: (%d,%p) port is closed\n",
+		       port->port_num, tty);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		if (from_user)
+			up(&gs_tmp_buf_sem);
+		return -EBADF;
+	}
+
+	count = gs_buf_put(port->port_write_buf, buf, count);
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	if (from_user)
+		up(&gs_tmp_buf_sem);
+
+	gs_send(port);
+
+	gs_debug("gs_write: (%d,%p) wrote %d bytes\n", port->port_num, tty,
+		 count);
+
+	return count;
+
+}
+
+/**
+ * gs_put_char
+ */
+static void
+gs_put_char(struct tty_struct *tty, unsigned char ch)
+{
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+	if (!port) {
+		printk(KERN_ERR "gs_put_char: NULL port pointer\n");
+		return;
+	}
+	gs_debug_level(2, "%s: ch = %02x\n", __FUNCTION__, ch);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	if (!port->port_dev) {
+		printk(KERN_ERR "gs_put_char: (%d,%p) port is not connected\n",
+		       port->port_num, tty);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		return;
+	}
+
+	if (port->port_open_count == 0) {
+		printk(KERN_ERR "gs_put_char: (%d,%p) port is closed\n",
+		       port->port_num, tty);
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		return;
+	}
+
+	gs_buf_put(port->port_write_buf, &ch, 1);
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+}
+
+/**
+ * gs_flush_chars
+ */
+static void
+gs_flush_chars(struct tty_struct *tty)
+{
+
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+	if (!port) {
+		printk(KERN_ERR "gs_flush_chars: NULL port pointer\n");
+		return;
+	}
+
+	gs_debug_level(2, "gs_flush_chars: port=%d tty=%p\n", port->port_num,
+		       tty);
+
+	if (!port->port_dev) {
+		printk(KERN_ERR
+		       "%s: trying to flush chars on not connected port %d\n",
+		       GS_SHORT_NAME, port->port_num);
+		return;
+	}
+
+	if (port->port_open_count == 0) {
+		printk(KERN_ERR "gs_flush_chars: (%d,%p) port is closed\n",
+		       port->port_num, tty);
+		return;
+	}
+
+	/* FIXME: nothing is done here...? */
+
+	gs_send(port);
+
+}
+
+/*
+ * gs_write_room
+ */
+
+static int
+gs_write_room(struct tty_struct *tty)
+{
+
+	int room = 0;
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+	if (port == NULL) {
+		printk(KERN_ERR "%s: port=NULL\n", __FUNCTION__);
+		return 0;
+	}
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	if (port->port_dev != NULL && port->port_open_count > 0
+	    && port->port_write_buf != NULL)
+		room = gs_buf_space_avail(port->port_write_buf);
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return room;
+}
+
+/**
+ * gs_chars_in_buffer
+ */
+static int
+gs_chars_in_buffer(struct tty_struct *tty)
+{
+
+	int chars = 0;
+	unsigned long flags;
+	struct gs_port *port = tty->driver_data;
+
+	if (port == NULL)
+		return 0;
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	if (port->port_dev != NULL && port->port_open_count > 0
+	    && port->port_write_buf != NULL)
+		chars = gs_buf_data_avail(port->port_write_buf);
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	gs_debug("gs_chars_in_buffer: (%d,%p) chars=%d\n",
+		 port->port_num, tty, chars);
+
+	return chars;
+
+}
+
+/*
+ * gs_throttle
+ */
+
+static void
+gs_throttle(struct tty_struct *tty)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+}
+
+/*
+ * gs_unthrottle
+ */
+
+static void
+gs_unthrottle(struct tty_struct *tty)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+}
+
+/*
+ * gs_break
+ */
+
+static void
+gs_break(struct tty_struct *tty, int break_state)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+}
+
+/*
+ * gs_ioctl
+ */
+
+static int
+gs_ioctl(struct tty_struct *tty, struct file *file,
+	 unsigned int cmd, unsigned long arg)
+{
+
+	struct gs_port *port = tty->driver_data;
+
+	if (!port) {
+		printk(KERN_ERR "gs_ioctl: NULL port pointer\n");
+		return -EIO;
+	}
+
+	gs_debug_level(2, "gs_ioctl: (%d,%p,%p) cmd=0x%4.4x, arg=%lu\n",
+		       port->port_num, tty, file, cmd, arg);
+
+	/* handle ioctls */
+
+	/* could not handle ioctl */
+	return -ENOIOCTLCMD;
+
+}
+
+/*
+ * gs_set_termios
+ */
+
+static void
+gs_set_termios(struct tty_struct *tty, struct termios *old)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+}
+
+/*
+ * gs_read_proc
+ */
+
+static int
+gs_read_proc(char *page, char **start, off_t off, int count,
+	     int *eof, void *data)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	return (0);
+
+}
+
+/**
+ * gs_send
+ *
+ * This function finds available write requests, calls
+ * gs_send_packet to fill these packets with data, and
+ * continues until either there are no more write requests
+ * available or no more data to send.  This function is
+ * run whenever data arrives or write requests are available.
+ */
+
+static int
+gs_send(struct gs_port *port)
+{
+	int ret, len;
+	unsigned long flags;
+	struct usb_ep *ep;
+	struct usb_request *req;
+	struct gs_req_entry *req_entry;
+	struct gs_dev *dev;
+
+	gs_debug_level(2, "%s: entered\n", __FUNCTION__);
+	if (!port) {
+		printk(KERN_ERR "gs_send: NULL port pointer\n");
+		return (-ENODEV);
+	}
+
+	dev = port->port_dev;
+	if (!port) {
+		printk(KERN_ERR "gs_send: NULL device pointer\n");
+		return (-ENODEV);
+	}
+
+	spin_lock_irqsave(&dev->dev_lock, flags);
+
+	ep = dev->dev_in_ep;
+
+	while (!list_empty(&dev->dev_req_list)) {
+		req_entry = list_entry(dev->dev_req_list.next,
+				       struct gs_req_entry, re_entry);
+		req = req_entry->re_req;
+		req_entry->port = port;
+		len = gs_send_packet(port, req->buf, ep->maxpacket);
+		if (len <= 0)
+			break;
+#if 0
+		printk("gs_send: len=%d, 0x%2.2x 0x%2.2x 0x%2.2x ...\n",
+		       len, *((unsigned char *) req->buf),
+		       *((unsigned char *) req->buf + 1),
+		       *((unsigned char *) req->buf + 2)
+		    );
+#endif
+		list_del(&req_entry->re_entry);
+		req->length = len;
+		req->actual = 0;
+		ret = usb_ep_queue(ep, req, GFP_ATOMIC);
+		if (ret) {
+			printk(KERN_ERR
+			       "gs_send: cannot queue read request, ret=%d\n",
+			       ret);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&dev->dev_lock, flags);
+	gs_debug_level(2, "%s: left\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * gs_send_packet
+ *
+ * @size: maximum number of bytes to be sent
+ *
+ * If there is data to send, a packet is built in the given
+ * buffer and the size is returned.  If there is no data to
+ * send, 0 is returned.  If there is any error a negative
+ * error number is returned.
+ *
+ * Called during USB completion routine, on interrupt time.
+ *
+ * We assume that disconnect will not happen until all completion
+ * routines have completed, so we can assume that the dev_port
+ * array does not change during the lifetime of this function.
+ */
+
+static int
+gs_send_packet(struct gs_port *port, char *packet, unsigned int size)
+{
+	unsigned int len;
+	struct multiser_header *header;
+
+	if (!port) {
+		printk(KERN_ERR "%s: trying to send packet on port=NULL\n",
+		       __FUNCTION__);
+		return (-EIO);
+	}
+
+	gs_debug_level(2, "%s: called, port=%i\n", __FUNCTION__,
+		       port->port_num);
+
+	spin_lock(&port->port_lock);
+
+	if (size < sizeof (struct multiser_header)) {
+		printk(KERN_ERR
+		       "%s: fifo size too small to hold even the header\n",
+		       __FUNCTION__);
+		return -1;
+	}
+
+	len = gs_buf_data_avail(port->port_write_buf);
+	if (len > size - sizeof (struct multiser_header))
+		len = size - sizeof (struct multiser_header);
+
+	if (len == 0) {
+		spin_unlock(&port->port_lock);
+		return 0;
+	}
+
+	header = (struct multiser_header *) packet;
+	header->crc = 0x0;
+	header->version = MULTISER_VERSION;
+	header->hdr_bytes = sizeof (struct multiser_header);
+	header->port_number = port->port_num;
+
+	len = gs_buf_get(port->port_write_buf,
+			 packet + sizeof (struct multiser_header), len);
+
+	header->valid_bytes = len + sizeof (struct multiser_header);
+
+	wake_up_interruptible(&port->port_tty->write_wait);
+
+	spin_unlock(&port->port_lock);
+
+	return size;
+}
+
+/**
+ * gs_recv_packet
+ *
+ * Called for each USB packet received. Reads the packet
+ * header and stuffs the data in the appropriate tty buffer.
+ * Returns 0 if successful, or a negative error number.
+ *
+ * Called during USB completion routine, on interrupt time.
+ *
+ * We assume that disconnect will not happen until all completion
+ * routines have completed, so we can assume that the dev_port
+ * array does not change during the lifetime of this function.
+ */
+
+static int
+gs_recv_packet(struct gs_dev *dev, char *packet, unsigned int size)
+{
+	unsigned int len, i;
+	unsigned long flags;
+	struct gs_port *port;
+	struct multiser_header *header = (struct multiser_header *) packet;
+	u32 crc;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!packet)
+		return -EIO;
+
+	if (header->version != MULTISER_VERSION) {
+		printk(KERN_ERR
+		       "%s: wrong protocol version #%d instead of %d\n",
+		       __FUNCTION__, header->version, MULTISER_VERSION);
+		return -EIO;
+	}
+
+	crc = header->crc;
+#if 0
+	header->crc = 0x0;
+	header->crc = crc32(0xdeadbeef, packet, size);
+#endif
+	if (header->crc != crc) {
+		printk(KERN_ERR "%s: crc failed (%08x/%08x)\n",
+		       __FUNCTION__, header->crc, crc);
+		return -EIO;
+	}
+
+	if (header->port_number > GS_NUM_PORTS) {
+		printk(KERN_ERR "%s: port #%d > max. ports (%d)\n",
+		       __FUNCTION__, header->port_number, GS_NUM_PORTS);
+		return -EIO;
+	}
+
+	port = dev->dev_port[header->port_number];
+
+	if (!port) {
+		printk(KERN_ERR "gs_recv_packet: NULL port pointer\n");
+		return -EIO;
+	}
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	if (!port->port_tty) {
+		printk(KERN_WARNING
+		       "%s: received data on port %d but nobody is listening\n",
+		       GS_SHORT_NAME, port->port_num);
+		spin_unlock(&port->port_lock);
+		return -EIO;
+	}
+
+	if (port->port_tty->magic != TTY_MAGIC) {
+		printk(KERN_ERR "gs_recv_packet: port=%d, bad tty magic\n",
+		       port->port_num);
+		spin_unlock(&port->port_lock);
+		return -EIO;
+	}
+
+	len = (unsigned int) (TTY_FLIPBUF_SIZE - port->port_tty->flip.count);
+	size = header->valid_bytes - header->hdr_bytes;
+
+	if (len < size)
+		size = len;
+
+	if (size > 0) {
+		int i;
+#if 0
+		printk("%s: dst=%8p src=%8p count=%i\n",
+		       __FUNCTION__,
+		       port->port_tty->flip.char_buf_ptr,
+		       packet + header->hdr_bytes, size);
+		for (i = 0; i < size; i++) {
+			printk("%02x ", *(packet + header->hdr_bytes + i));
+		}
+		printk("\n");
+#endif
+
+		memcpy(port->port_tty->flip.char_buf_ptr,
+		       packet + header->hdr_bytes, size);
+		port->port_tty->flip.char_buf_ptr += size;
+		port->port_tty->flip.count += size;
+		port->port_tty->low_latency = 1;
+		tty_flip_buffer_push(port->port_tty);
+		wake_up_interruptible(&port->port_tty->read_wait);
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return (0);
+}
+
+/**
+ * gs_read_complete
+ */
+
+static void
+gs_read_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	int ret;
+	struct gs_dev *dev = ep->driver_data;
+
+	if (!dev) {
+		printk(KERN_ERR "%s: dev=NULL\n", GS_SHORT_NAME);
+		return;
+	}
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	switch (req->status) {
+
+	case 0:
+		gs_recv_packet(dev, req->buf, req->actual);
+	      requeue:req->length = ep->maxpacket;
+		req->actual = 0;
+		if ((ret = usb_ep_queue(ep, req, GFP_ATOMIC)))
+			printk(KERN_ERR
+			       "gs_read_complete: cannot queue read request, ret=%d\n",
+			       ret);
+		break;
+
+	case -ESHUTDOWN:
+		gs_debug("%s: disconnect, shutdown\n", __FUNCTION__);
+		gs_free_req(ep, req);
+		break;
+
+	default:
+		printk(KERN_ERR
+		       "%s: unexpected status error, status=%d\n",
+		       __FUNCTION__, req->status);
+		goto requeue;
+		break;
+	}
+}
+
+/**
+ * gs_write_complete
+ */
+
+static void
+gs_write_complete(struct usb_ep *ep, struct usb_request *req)
+{
+
+	struct gs_dev *dev = ep->driver_data;
+	struct gs_req_entry *gs_req = req->context;
+
+	if (!dev) {
+		printk(KERN_ERR "gs_write_complete: NULL device pointer\n");
+		return;
+	}
+
+	gs_debug("%s: req->status=%i\n", __FUNCTION__, req->status);
+
+	switch (req->status) {
+
+	case 0:
+	      requeue:
+		if (gs_req == NULL) {
+			printk(KERN_ERR
+			       "gs_write_complete: NULL request pointer\n");
+			return;
+		}
+
+		spin_lock(&dev->dev_lock);
+		list_add(&gs_req->re_entry, &dev->dev_req_list);
+		spin_unlock(&dev->dev_lock);
+
+		gs_send(gs_req->port);
+
+		break;
+
+	case -ESHUTDOWN:
+		/* disconnect */
+		gs_free_req(ep, req);
+		break;
+
+	default:
+		printk(KERN_ERR
+		       "gs_write_complete: unexpected status error, status=%d\n",
+		       req->status);
+		goto requeue;
+		break;
+	}
+}
+
+/* Gadget Driver */
+
+/*
+ * gs_bind
+ *
+ * Called on module load.  Allocates and initializes the device
+ * structure and a control request.
+ */
+
+static int
+gs_bind(struct usb_gadget *gadget)
+{
+
+	int ret;
+	struct gs_dev *dev;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	dev = kmalloc(sizeof (struct gs_dev), GFP_KERNEL);
+	if (dev == NULL)
+		return -ENOMEM;
+
+	set_gadget_data(gadget, dev);
+
+	memset(dev, 0, sizeof (struct gs_dev));
+	dev->dev_gadget = gadget;
+	spin_lock_init(&dev->dev_lock);
+	INIT_LIST_HEAD(&dev->dev_req_list);
+
+	if ((ret = gs_alloc_ports(dev, GFP_KERNEL)) != 0) {
+		printk(KERN_ERR "gs_bind: cannot allocate ports\n");
+		gs_unbind(gadget);
+		return ret;
+	}
+
+	/* preallocate control response and buffer */
+	dev->dev_ctrl_req = gs_alloc_req(gadget->ep0, GS_MAX_DESC_LEN,
+					 GFP_KERNEL);
+	if (dev->dev_ctrl_req == NULL) {
+		gs_unbind(gadget);
+		return -ENOMEM;
+	}
+	dev->dev_ctrl_req->complete = gs_setup_complete;
+
+	gadget->ep0->driver_data = dev;
+
+	/* this has to set the vendor/product id manually */
+	if (gadget_is_h7202(gadget)) {
+		CPU_REG(USBD_BASE, USBD_DEVID) =
+		    (GS_PRODUCT_ID << 16) + GS_VENDOR_ID;
+	}
+
+	printk(KERN_INFO "%s: driver bound\n", GS_SHORT_NAME);
+
+	return 0;
+
+}
+
+/*
+ * gs_unbind
+ *
+ * Called on module unload.  Frees the control request and device
+ * structure.
+ */
+
+static void
+gs_unbind(struct usb_gadget *gadget)
+{
+	struct gs_dev *dev = get_gadget_data(gadget);
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	/* read/write requests already freed, only control request remains */
+	if (dev) {
+		if (dev->dev_ctrl_req != NULL)
+			gs_free_req(gadget->ep0, dev->dev_ctrl_req);
+		gs_free_ports(dev);
+		kfree(dev);
+		set_gadget_data(gadget, NULL);
+	}
+
+	printk(KERN_INFO "%s: driver unbound\n", GS_SHORT_NAME);
+}
+
+/**
+ * gs_setup
+ *
+ * Implements all the control endpoint functionality that's not
+ * handled in hardware or the hardware driver.
+ *
+ * Returns the size of the data sent to the host, or a negative
+ * error number.
+ */
+
+static int
+gs_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
+{
+
+	int ret = -EOPNOTSUPP;
+	unsigned int sv_config;
+	struct gs_dev *dev = get_gadget_data(gadget);
+	struct usb_request *req = dev->dev_ctrl_req;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	switch (ctrl->bRequest) {
+
+	case USB_REQ_GET_DESCRIPTOR:
+
+		if (ctrl->bRequestType != USB_DIR_IN)
+			break;
+
+		switch (ctrl->wValue >> 8) {
+
+		case USB_DT_DEVICE:
+			ret = min(ctrl->wLength,
+				  (u16) sizeof (struct usb_device_descriptor));
+			memcpy(req->buf, &gs_device_desc, ret);
+			break;
+
+#ifdef HIGHSPEED
+		case USB_DT_DEVICE_QUALIFIER:
+			ret = min(ctrl->wLength,
+				  (u16) sizeof (struct
+						usb_qualifier_descriptor));
+			memcpy(req->buf, &gs_qualifier_desc, ret);
+			break;
+
+		case USB_DT_OTHER_SPEED_CONFIG:
+#endif				/* HIGHSPEED */
+		case USB_DT_CONFIG:
+			ret = gs_build_config_desc(req->buf, gadget->speed,
+						   ctrl->wValue >> 8,
+						   ctrl->wValue & 0xff);
+			if (ret >= 0)
+				ret = min(ctrl->wLength, (u16) ret);
+			break;
+
+		case USB_DT_STRING:
+			/* wIndex == language code. */
+			ret = usb_gadget_get_string(&gs_string_table,
+						    ctrl->wValue & 0xff,
+						    req->buf);
+			if (ret >= 0)
+				ret = min(ctrl->wLength, (u16) ret);
+			break;
+		}
+		break;
+
+	case USB_REQ_SET_CONFIGURATION:
+		if (ctrl->bRequestType != 0)
+			break;
+		spin_lock(&dev->dev_lock);
+		ret = gs_set_config(dev, ctrl->wValue);
+		spin_unlock(&dev->dev_lock);
+		break;
+
+	case USB_REQ_GET_CONFIGURATION:
+		if (ctrl->bRequestType != USB_DIR_IN)
+			break;
+		*(u8 *) req->buf = dev->dev_config;
+		ret = min(ctrl->wLength, (u16) 1);
+		break;
+
+	case USB_REQ_SET_INTERFACE:
+		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
+			break;
+		spin_lock(&dev->dev_lock);
+		if (dev->dev_config == GS_BULK_CONFIG_ID
+		    && ctrl->wIndex == GS_INTERFACE_ID
+		    && ctrl->wValue == GS_ALT_INTERFACE_ID) {
+			sv_config = dev->dev_config;
+			/* since there is only one interface, setting the */
+			/* interface is equivalent to setting the config */
+			gs_reset_config(dev);
+			gs_set_config(dev, sv_config);
+			ret = 0;
+		}
+		spin_unlock(&dev->dev_lock);
+		break;
+
+	case USB_REQ_GET_INTERFACE:
+		if (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))
+			break;
+		if (dev->dev_config == GS_NO_CONFIG_ID)
+			break;
+		if (ctrl->wIndex != GS_INTERFACE_ID) {
+			ret = -EDOM;
+			break;
+		}
+		*(u8 *) req->buf = GS_ALT_INTERFACE_ID;
+		ret = min(ctrl->wLength, (u16) 1);
+		break;
+
+	default:
+		printk(KERN_ERR
+		       "gs_setup: unknown request, type=%02x, request=%02x, value=%04x, index=%04x, length=%d\n",
+		       ctrl->bRequestType, ctrl->bRequest, ctrl->wValue,
+		       ctrl->wIndex, ctrl->wLength);
+		break;
+
+	}
+
+	/* respond with data transfer before status phase? */
+	if (ret >= 0) {
+		req->length = ret;
+		ret = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);
+		if (ret < 0) {
+			printk(KERN_ERR
+			       "gs_setup: cannot queue response, ret=%d\n",
+			       ret);
+			req->status = 0;
+			gs_setup_complete(gadget->ep0, req);
+		}
+	}
+
+	/* device either stalls (ret < 0) or reports success */
+	return (ret);
+
+}
+
+/*
+ * gs_setup_complete
+ */
+
+static void
+gs_setup_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (req->status || req->actual != req->length) {
+		printk(KERN_ERR
+		       "gs_setup_complete: status error, status=%d, actual=%d, length=%d\n",
+		       req->status, req->actual, req->length);
+	}
+}
+
+/*
+ * gs_disconnect
+ *
+ * Called when the device is disconnected.  Frees the closed
+ * ports and disconnects open ports.  Open ports will be freed
+ * on close.  Then reallocates the ports for the next connection.
+ */
+
+static void
+gs_disconnect(struct usb_gadget *gadget)
+{
+
+	unsigned long flags;
+	struct gs_dev *dev = get_gadget_data(gadget);
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	spin_lock_irqsave(&dev->dev_lock, flags);
+
+	gs_reset_config(dev);
+
+	/* free closed ports and disconnect open ports */
+	/* (open ports will be freed when closed) */
+	gs_free_ports(dev);
+
+	/* re-allocate ports for the next connection */
+	if (gs_alloc_ports(dev, GFP_ATOMIC) != 0)
+		printk(KERN_ERR "gs_disconnect: cannot re-allocate ports\n");
+
+	spin_unlock_irqrestore(&dev->dev_lock, flags);
+
+	printk(KERN_INFO "gs_disconnect: %s disconnected\n", GS_LONG_NAME);
+
+}
+
+/*
+ * gs_set_config
+ *
+ * Configures the device by enabling device specific
+ * optimizations, setting up the endpoints, allocating
+ * read and write requests and queuing read requests.
+ *
+ * The device lock must be held when calling this function.
+ */
+
+static int
+gs_set_config(struct gs_dev *dev, unsigned config)
+{
+
+	int i;
+	int ret = 0;
+	struct usb_gadget *gadget = dev->dev_gadget;
+	struct usb_ep *ep;
+	struct usb_request *req;
+	struct gs_req_entry *req_entry;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (dev == NULL) {
+		printk(KERN_ERR "gs_set_config: NULL device pointer\n");
+		return (0);
+	}
+
+	if (config == dev->dev_config) {
+		printk(KERN_ERR "gs_set_config: got dev_config\n");
+		return (0);
+	}
+
+	gs_reset_config(dev);
+
+	if (config == GS_NO_CONFIG_ID) {
+		printk(KERN_ERR
+		       "%s: initialized with GS_NO_CONFIG_ID, stopping set_configuration\n",
+		       __FUNCTION__);
+		return (0);
+	}
+
+	if (config != GS_BULK_CONFIG_ID) {
+		printk(KERN_ERR "%s: didn't get expected GS_BULK_CONFIG_ID\n",
+		       __FUNCTION__);
+		return (-EINVAL);
+	}
+
+	hw_optimize(gadget);
+
+	gadget_for_each_ep(ep, gadget) {
+
+		if (strcmp(ep->name, EP_IN_NAME) == 0) {
+			ret = usb_ep_enable(ep,
+					    gadget->speed == USB_SPEED_HIGH ?
+					    &gs_highspeed_in_desc :
+					    &gs_fullspeed_in_desc);
+			if (ret == 0) {
+				ep->driver_data = dev;
+				dev->dev_in_ep = ep;
+			} else {
+				printk(KERN_ERR
+				       "gs_set_config: cannot enable in endpoint %s, ret=%d\n",
+				       ep->name, ret);
+				gs_reset_config(dev);
+				return (ret);
+			}
+		}
+
+		else if (strcmp(ep->name, EP_OUT_NAME) == 0) {
+			ret = usb_ep_enable(ep,
+					    gadget->speed == USB_SPEED_HIGH ?
+					    &gs_highspeed_out_desc :
+					    &gs_fullspeed_out_desc);
+			if (ret == 0) {
+				ep->driver_data = dev;
+				dev->dev_out_ep = ep;
+			} else {
+				printk(KERN_ERR
+				       "gs_set_config: cannot enable out endpoint %s, ret=%d\n",
+				       ep->name, ret);
+				gs_reset_config(dev);
+				return (ret);
+			}
+		}
+
+	}
+
+	if (dev->dev_in_ep == NULL || dev->dev_out_ep == NULL) {
+		gs_reset_config(dev);
+		printk(KERN_ERR "gs_set_config: cannot find endpoints\n");
+		return (-ENODEV);
+	}
+
+	/* allocate and queue read requests */
+	ep = dev->dev_out_ep;
+	for (i = 0; i < read_q_size && ret == 0; i++) {
+		if ((req = gs_alloc_req(ep, ep->maxpacket, GFP_ATOMIC))) {
+			req->complete = gs_read_complete;
+			if ((ret = usb_ep_queue(ep, req, GFP_ATOMIC))) {
+				printk(KERN_ERR
+				       "gs_set_config: cannot queue read request, ret=%d\n",
+				       ret);
+			}
+		} else {
+			gs_reset_config(dev);
+			printk(KERN_ERR
+			       "gs_set_config: cannot allocate read requests\n");
+			return (-ENOMEM);
+		}
+	}
+
+	/* allocate write requests, and put on free list */
+
+	ep = dev->dev_in_ep;
+	for (i = 0; i < write_q_size; i++) {
+		if ((req_entry = gs_alloc_req_entry(ep, ep->maxpacket,
+						    GFP_ATOMIC))) {
+			req_entry->re_req->complete = gs_write_complete;
+			list_add(&req_entry->re_entry, &dev->dev_req_list);
+		} else {
+			gs_reset_config(dev);
+			printk(KERN_ERR
+			       "gs_set_config: cannot allocate write requests\n");
+			return (-ENOMEM);
+		}
+	}
+
+	dev->dev_config = config;
+
+	printk(KERN_INFO "%s: configured for %s speed\n",
+	       GS_SHORT_NAME,
+	       gadget->speed == USB_SPEED_HIGH ? "high" : "full");
+
+	return (0);
+
+}
+
+/*
+ * gs_reset_config
+ *
+ * Mark the device as not configured, disable all endpoints,
+ * which forces completion of pending I/O and frees queued
+ * requests, and free the remaining write requests on the
+ * free list.
+ *
+ * The device lock must be held when calling this function.
+ */
+
+static void
+gs_reset_config(struct gs_dev *dev)
+{
+
+	struct gs_req_entry *req_entry;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!dev) {
+		printk(KERN_ERR "gs_reset_config: NULL device pointer\n");
+		return;
+	}
+
+	if (dev->dev_config == GS_NO_CONFIG_ID) {
+		printk(KERN_ERR "%s: GS_NO_CONFIG_ID\n", GS_SHORT_NAME);
+		return;
+	}
+
+	dev->dev_config = GS_NO_CONFIG_ID;
+
+	/* free write requests on the free list */
+	while (!list_empty(&dev->dev_req_list)) {
+		req_entry = list_entry(dev->dev_req_list.next,
+				       struct gs_req_entry, re_entry);
+		list_del(&req_entry->re_entry);
+		gs_free_req_entry(dev->dev_in_ep, req_entry);
+	}
+
+	/* disable endpoints, forcing completion of pending i/o; */
+	/* completion handlers free their requests in this case */
+	if (dev->dev_in_ep) {
+		usb_ep_disable(dev->dev_in_ep);
+		dev->dev_in_ep = NULL;
+	}
+	if (dev->dev_out_ep) {
+		usb_ep_disable(dev->dev_out_ep);
+		dev->dev_out_ep = NULL;
+	}
+
+}
+
+/*
+ * gs_build_config_desc
+ *
+ * Builds a config descriptor in the given buffer and returns the
+ * length, or a negative error number.
+ */
+
+static int
+gs_build_config_desc(u8 * buf, enum usb_device_speed speed, u8 type,
+		     unsigned int index)
+{
+	int high_speed;
+	int len = USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE
+	    + GS_NUM_ENDPOINTS * USB_DT_ENDPOINT_SIZE;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	/* only one config */
+	if (index != 0)
+		return -EINVAL;
+
+	memcpy(buf, &gs_config_desc, USB_DT_CONFIG_SIZE);
+	((struct usb_config_descriptor *) buf)->bDescriptorType = type;
+	((struct usb_config_descriptor *) buf)->wTotalLength =
+	    __constant_cpu_to_le16(len);
+	buf += USB_DT_CONFIG_SIZE;
+
+	memcpy(buf, &gs_interface_desc, USB_DT_INTERFACE_SIZE);
+	buf += USB_DT_INTERFACE_SIZE;
+
+	/* other speed switches high and full speed */
+	high_speed = (speed == USB_SPEED_HIGH);
+	if (type == USB_DT_OTHER_SPEED_CONFIG)
+		high_speed = !high_speed;
+
+	memcpy(buf,
+	       high_speed ? &gs_highspeed_in_desc : &gs_fullspeed_in_desc,
+	       USB_DT_ENDPOINT_SIZE);
+	buf += USB_DT_ENDPOINT_SIZE;
+	memcpy(buf,
+	       high_speed ? &gs_highspeed_out_desc : &gs_fullspeed_out_desc,
+	       USB_DT_ENDPOINT_SIZE);
+
+	return len;
+}
+
+/*
+ * gs_alloc_req
+ *
+ * Allocate a usb_request and its buffer.  Returns a pointer to the
+ * usb_request or NULL if there is an error.
+ */
+
+static struct usb_request *
+gs_alloc_req(struct usb_ep *ep, unsigned int len, int kmalloc_flags)
+{
+
+	struct usb_request *req;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!ep)
+		return NULL;
+
+	req = usb_ep_alloc_request(ep, kmalloc_flags);
+
+	if (req) {
+		req->length = len;
+		req->buf = usb_ep_alloc_buffer(ep, len, &req->dma,
+					       kmalloc_flags);
+		if (req->buf == NULL) {
+			usb_ep_free_request(ep, req);
+			return NULL;
+		}
+	}
+
+	return (req);
+}
+
+/*
+ * gs_free_req
+ *
+ * Free a usb_request and its buffer.
+ */
+
+static void
+gs_free_req(struct usb_ep *ep, struct usb_request *req)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (ep != NULL && req != NULL) {
+		if (req->buf != NULL)
+			usb_ep_free_buffer(ep, req->buf, req->dma, req->length);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/*
+ * gs_alloc_req_entry
+ *
+ * Allocates a request and its buffer, using the given
+ * endpoint, buffer len, and kmalloc flags.
+ */
+static struct gs_req_entry
+*
+gs_alloc_req_entry(struct usb_ep *ep, unsigned len, int kmalloc_flags)
+{
+
+	struct gs_req_entry *req;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	req = kmalloc(sizeof (struct gs_req_entry), kmalloc_flags);
+	if (!req)
+		return NULL;
+
+	req->re_req = gs_alloc_req(ep, len, kmalloc_flags);
+	if (!req->re_req) {
+		kfree(req);
+		return NULL;
+	}
+
+	req->re_req->context = req;
+
+	return req;
+}
+
+/*
+ * gs_free_req_entry
+ *
+ * Frees a request and its buffer.
+ */
+
+static void
+gs_free_req_entry(struct usb_ep *ep, struct gs_req_entry *req)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (ep != NULL && req != NULL) {
+		if (req->re_req != NULL)
+			gs_free_req(ep, req->re_req);
+		kfree(req);
+	}
+}
+
+/*
+ * gs_alloc_ports
+ *
+ * Allocate all ports and set the gs_dev struct to point to them.
+ * Return 0 if successful, or a negative error number.
+ *
+ * The device lock is normally held when calling this function.
+ */
+
+static int
+gs_alloc_ports(struct gs_dev *dev, int kmalloc_flags)
+{
+	int i;
+	struct gs_port *port;
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!dev)
+		return -EIO;
+
+	for (i = 0; i < GS_NUM_PORTS; i++) {
+
+		if ((port = (struct gs_port *) kmalloc(sizeof (struct gs_port),
+						       kmalloc_flags)) == NULL)
+			return -ENOMEM;
+
+		memset(port, 0, sizeof (struct gs_port));
+		port->port_dev = dev;
+		port->port_num = i;
+		spin_lock_init(&port->port_lock);
+		init_waitqueue_head(&port->port_write_wait);
+
+		dev->dev_port[i] = port;
+	}
+
+	gs_tty_drv = dev;
+
+	return 0;
+
+}
+
+/*
+ * gs_free_ports
+ *
+ * Free all closed ports.  Open ports are disconnected by
+ * freeing their write buffers, setting their device pointers
+ * and the pointers to them in the device to NULL.  These
+ * ports will be freed when closed.
+ *
+ * The device lock is normally held when calling this function.
+ */
+
+static void
+gs_free_ports(struct gs_dev *dev)
+{
+	int i;
+	unsigned long flags;
+	struct gs_port *port;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!dev)
+		return;
+
+	for (i = 0; i < GS_NUM_PORTS; i++) {
+
+		if ((port = dev->dev_port[i]) != NULL) {
+
+			dev->dev_port[i] = NULL;
+
+			spin_lock_irqsave(&port->port_lock, flags);
+
+			if (port->port_write_buf != NULL) {
+				gs_buf_free(port->port_write_buf);
+				port->port_write_buf = NULL;
+			}
+
+			if (port->port_open_count > 0 || port->port_in_use) {
+				port->port_dev = NULL;
+				wake_up_interruptible(&port->port_write_wait);
+				wake_up_interruptible(&port->port_tty->
+						      read_wait);
+				wake_up_interruptible(&port->port_tty->
+						      write_wait);
+			} else {
+				kfree(port);
+			}
+
+			spin_unlock_irqrestore(&port->port_lock, flags);
+		}
+	}
+}
+
+/* Circular Buffer */
+
+/*
+ * gs_buf_alloc
+ *
+ * Allocate a circular buffer and all associated memory.
+ */
+
+static struct gs_buf *
+gs_buf_alloc(unsigned int size, int kmalloc_flags)
+{
+	struct gs_buf *gb;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (size == 0)
+		return NULL;
+
+	gb = (struct gs_buf *) kmalloc(sizeof (struct gs_buf), kmalloc_flags);
+	if (!gb)
+		return NULL;
+
+	gb->buf_buf = kmalloc(size, kmalloc_flags);
+	if (!gb->buf_buf) {
+		kfree(gb);
+		return NULL;
+	}
+
+	gb->buf_size = size;
+	gb->buf_get = gb->buf_put = gb->buf_buf;
+
+	return (gb);
+}
+
+/*
+ * gs_buf_free
+ *
+ * Free the buffer and all associated memory.
+ */
+
+void
+gs_buf_free(struct gs_buf *gb)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (gb) {
+		if (gb->buf_buf)
+			kfree(gb->buf_buf);
+		kfree(gb);
+	}
+}
+
+/*
+ * gs_buf_clear
+ *
+ * Clear out all data in the circular buffer.
+ */
+
+void
+gs_buf_clear(struct gs_buf *gb)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (gb)
+		gb->buf_get = gb->buf_put;
+	/* equivalent to a get of all data available */
+}
+
+/*
+ * gs_buf_data_avail
+ *
+ * Return the number of bytes of data available in the circular
+ * buffer.
+ */
+
+unsigned int
+gs_buf_data_avail(struct gs_buf *gb)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (gb)
+		return ((gb->buf_size + gb->buf_put - gb->buf_get)
+			% gb->buf_size);
+	else
+		return 0;
+}
+
+/*
+ * gs_buf_space_avail
+ *
+ * Return the number of bytes of space available in the circular
+ * buffer.
+ */
+
+unsigned int
+gs_buf_space_avail(struct gs_buf *gb)
+{
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!gb)
+		return 0;
+
+	return ((gb->buf_size + gb->buf_get - gb->buf_put - 1)
+		% gb->buf_size);
+}
+
+/*
+ * gs_buf_put
+ *
+ * Copy data data from a user buffer and put it into the circular buffer.
+ * Restrict to the amount of space available.
+ *
+ * Return the number of bytes copied.
+ */
+
+unsigned int
+gs_buf_put(struct gs_buf *gb, const char *buf, unsigned int count)
+{
+	unsigned int len;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+	if (!gb) {
+		printk(KERN_ERR "%s: gb=NULL\n", __FUNCTION__);
+		return 0;
+	}
+
+	len = gs_buf_space_avail(gb);
+
+	if (count > len)
+		count = len;
+
+	if (count == 0) {
+		gs_debug("%s: no characters\n", __FUNCTION__);
+		return 0;
+	}
+
+	/* how many bytes left until end of buffer */
+	len = gb->buf_buf - gb->buf_put + gb->buf_size;
+
+	if (count > len) {
+		memcpy(gb->buf_put, buf, len);
+		memcpy(gb->buf_buf, buf + len, count - len);
+		gb->buf_put = gb->buf_buf + count - len;
+	} else {
+		memcpy(gb->buf_put, buf, count);
+		if (count == len)
+			gb->buf_put = gb->buf_buf;
+		else
+			gb->buf_put += count;
+	}
+
+	return count;
+}
+
+/*
+ * gs_buf_get
+ *
+ * Get data from the circular buffer and copy to the given buffer.
+ * Restrict to the amount of data available.
+ *
+ * Return the number of bytes copied.
+ */
+
+unsigned int
+gs_buf_get(struct gs_buf *gb, char *buf, unsigned int count)
+{
+	unsigned int len;
+
+	gs_debug_level(2, "%s: called\n", __FUNCTION__);
+
+	if (!gb)
+		return 0;
+
+	len = gs_buf_data_avail(gb);
+	if (count > len)
+		count = len;
+
+	if (count == 0)
+		return 0;
+
+	len = gb->buf_buf + gb->buf_size - gb->buf_get;
+	if (count > len) {
+		memcpy(buf, gb->buf_get, len);
+		memcpy(buf + len, gb->buf_buf, count - len);
+		gb->buf_get = gb->buf_buf + count - len;
+	} else {
+		memcpy(buf, gb->buf_get, count);
+		if (count < len)
+			gb->buf_get += count;
+		else		/* count == len */
+			gb->buf_get = gb->buf_buf;
+	}
+
+	return count;
+
+}
Index: drivers/usb/gadget/gadget_chips.h
===================================================================
--- a/drivers/usb/gadget/gadget_chips.h	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/gadget/gadget_chips.h	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -86,6 +86,12 @@
 #define gadget_is_at91(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_H7202
+#define	gadget_is_h7202(g)	!strcmp("h7202_udc", (g)->name)
+#else
+#define	gadget_is_h7202(g)	0
+#endif
+
 // CONFIG_USB_GADGET_SX2
 // CONFIG_USB_GADGET_AU1X00
 // ...
Index: drivers/usb/gadget/Makefile
===================================================================
--- a/drivers/usb/gadget/Makefile	(.../vanilla/linux-2.6.13)	(revision 1039)
+++ b/drivers/usb/gadget/Makefile	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -7,6 +7,7 @@
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
 obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o
+obj-$(CONFIG_USB_H7202) 	+= h7202_udc.o
 
 #
 # USB gadget drivers
@@ -17,6 +18,7 @@
 gadgetfs-objs			:= inode.o
 g_file_storage-objs		:= file_storage.o usbstring.o config.o \
 					epautoconf.o
+g_multiser-objs 		:= multiser.o usbstring.o
 
 ifeq ($(CONFIG_USB_ETH_RNDIS),y)
 	g_ether-objs		+= rndis.o
@@ -27,4 +29,4 @@
 obj-$(CONFIG_USB_GADGETFS)	+= gadgetfs.o
 obj-$(CONFIG_USB_FILE_STORAGE)	+= g_file_storage.o
 obj-$(CONFIG_USB_G_SERIAL)	+= g_serial.o
-
+obj-$(CONFIG_USB_G_MULTISER)	+= g_multiser.o
Index: drivers/usb/gadget/h7202_udc.c
===================================================================
--- a/drivers/usb/gadget/h7202_udc.c	(.../vanilla/linux-2.6.13)	(revision 0)
+++ b/drivers/usb/gadget/h7202_udc.c	(.../linux-hynix/releases/linux-2.6.13-hnx3)	(revision 1039)
@@ -0,0 +1,982 @@
+/* 
+ * Driver for the Hynix HMS30C7202 USB device cntroller.
+ * 
+ * Copyright (C) 2004 Robert Schwebel, Benedikt Spranger
+ * $Id: h7202_udc.c,v 1.4 2004/05/05 23:29:11 bsp Exp $
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#define       DEBUG           1       /* messages on error and most fault paths */
+//#define       VERBOSE         1       /* extra debug messages (success too)     */
+//#define       DEBUG_PACKETS   1       /* show transferred packets               */
+//#define       DEBUG_REQ       1       /* show request handling                  */
+//#define       DEBUG_IRQ       1       /* show interrupts                        */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+#include "h7202_udc.h"
+
+#define DRIVER_DESC		"Hynix HMS30C7202 USB Device Controller"
+#define DRIVER_VERSION		"2004-05-21"
+
+#define GS_BULK_CONFIG_ID	2	/* FIXME: fake! 7202 cannot decode ep0 traffic, but 
+					   we have to decide which configuration has to be 
+					   kickstarted from RESET. This needs to be brought
+					   to the controller dependend part of the gadget driver
+					 */
+
+static const char driver_name[] = "h7202_udc";
+static const char driver_desc[] = DRIVER_DESC;
+
+static const char ep0name[] = "ep0";
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Robert Schwebel, Benedikt Spranger");
+MODULE_LICENSE("GPL");
+
+static struct proc_dir_entry *proc_h7202_status;
+
+int
+h7202_status_read(char *page, char **start, off_t off, int count,
+		  int *eof, void *data)
+{
+	char *out = page;
+	int len;
+
+	u32 intstat = CPU_REG(USBD_BASE, USBD_INTSTAT);
+	u32 intmask = CPU_REG(USBD_BASE, USBD_INTMASK);
+	u32 epctrl = CPU_REG(USBD_BASE, USBD_EPCTRL);
+
+	out += sprintf(out, "intstat = 0x%08x\n", intstat);
+	out += sprintf(out, "intmask = 0x%08x\n", intmask);
+	out += sprintf(out, "epctrl  = 0x%08x\n", epctrl);
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+			return 0;
+	} else
+		len = count;
+	*start = page + off;
+	return len;
+}
+
+static inline void
+udc_ack_int(u32 mask)
+{
+	CPU_REG(USBD_BASE, USBD_INTSTAT) &= ~mask;
+}
+
+/* FIXME: this function should also work with EP0 (eliminate EP2 dependencies) */
+static int
+write_packet(volatile u32 * epaddr, struct h7202_request *req, unsigned max)
+{
+	u8 *buf;
+	u8 tmp[4];
+	unsigned length, i, t;
+
+	buf = req->req.buf + req->req.actual;
+
+	/* how many bytes do we have to send now? */
+	length = min(req->req.length - req->req.actual, max);
+
+#ifdef DEBUG_PACKETS
+	printk("%s: length=%i req.length=%i req.actual=%i max=%i\n",
+	       __FUNCTION__, length, req->req.length, req->req.actual, max);
+#endif
+	/* uggly hack: zero length packets don't seem to work */
+	if (length == 0)
+		return length;
+
+#if 0
+	struct multiser_header {
+		u32 crc;	/* crc32 check sum; FIXME: smaller? */
+		u8 version;	/* header format version            */
+		u8 hdr_bytes;	/* number of header bytes           */
+		u8 port_number;	/* port this package is for         */
+		u8 valid_bytes;	/* valid bytes in this packet       */
+	};
+#endif
+	i = 0;
+	for (t = 0; t < length; t += 4) {
+		for (i = 0; i < 4; i++) {
+			tmp[3 - i] = *buf++;
+			if (++req->req.actual == req->req.length)
+				break;
+		}
+
+		*epaddr = *((u32 *) tmp);
+	}
+
+	if (length != max) {
+		/* last 32 bit word written into fifo may not have to be
+		 * transferred completely, find out how many bytes to
+		 * send */
+		CPU_REG(USBD_BASE, USBD_EPCTRL) &= ~(3 << 16);
+		CPU_REG(USBD_BASE, USBD_EPCTRL) |= ((3 - i) << 16);
+
+		/* enable non-maximum packet length transfer */
+		CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_E2SND;
+	}
+
+	return length;
+}
+
+static void done(struct h7202_ep *ep, struct h7202_request *req, int status);
+
+static int
+read_fifo(struct h7202_ep *ep, struct h7202_request *req, u32 rxbytes)
+{
+	u8 *buf, *tbuf;
+	u32 tmp[8];
+	unsigned i;
+	unsigned long flags;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	if (!ep->ep_rdaddr) {
+		printk("%s: trying to read from invalid FIFO address!\n",
+		       driver_name);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	buf = req->req.buf + req->req.actual;
+	req->req.actual += rxbytes;
+
+	/* we always read the complete buffer */
+	for (i = 0; i < 8; i++)
+		tmp[i] = *ep->ep_rdaddr;
+
+	tbuf = (u8 *) tmp;
+
+	for (i = 0; i < rxbytes; i++)
+		*buf++ = *((u8 *) tmp + i);
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	done(ep, req, 0);
+	return 1;
+}
+
+static int
+write_fifo(struct h7202_ep *ep, struct h7202_request *req)
+{
+	unsigned l, max = le16_to_cpu(ep->desc->wMaxPacketSize);
+	unsigned long flags;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	if (!ep->ep_wtaddr) {
+		pr_debug("%s: error: trying to write to OUT endpoint!\n",
+			 __FUNCTION__);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	l = write_packet(ep->ep_wtaddr, req, max);
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	if (l < max)
+		done(ep, req, 0);
+
+	return 0;
+}
+
+static void
+handle_ep(struct h7202_ep *ep, u32 rxbytes)
+{
+	struct h7202_request *req;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	if (likely(!list_empty(&ep->queue)))
+		req = list_entry(ep->queue.next, struct h7202_request, queue);
+	else
+		req = 0;
+
+	switch (ep->num) {
+	case 0:
+		break;
+	case 1:
+		read_fifo(ep, req, rxbytes);
+		break;
+	case 2:
+		if (!req) {
+			CPU_REG(USBD_BASE, USBD_INTMASK) |= USBD_E2EM;
+			return;
+		}
+
+		write_fifo(ep, req);
+		break;
+	}
+}
+
+static irqreturn_t
+h7202_udc_irq(int irq, void *_dev, struct pt_regs *r)
+{
+	struct h7202_udc *dev = _dev;
+	u32 intstat = CPU_REG(USBD_BASE, USBD_INTSTAT);
+	u32 intmask = CPU_REG(USBD_BASE, USBD_INTMASK);
+	/* currently not needed - all ep0 traffic is done in hardware */
+	/* u32                  ep0rxbyte = (intstat & 0x3C00) >> 10; */
+	u32 ep1rxbyte = (intstat & 0xFC000) >> 14;
+
+#ifdef DEBUG_IRQ
+	printk("irq: ");
+	printk("E0STL=%i ", intstat & USBD_E0STL ? 1 : 0);
+	printk("SUS=%i ", intstat & USBD_SUS ? 1 : 0);
+	printk("RESET=%i ", intstat & USBD_RESET ? 1 : 0);
+	printk("E2EM=%i ", intstat & USBD_E2EM ? 1 : 0);
+	printk("E1OV=%i ", intstat & USBD_E1OV ? 1 : 0);
+	printk("E1FU=%i ", intstat & USBD_E1FU ? 1 : 0);
+	printk("E0EM=%i ", intstat & USBD_E0EM ? 1 : 0);
+	printk("E0OV=%i ", intstat & USBD_E0OV ? 1 : 0);
+	printk("E0FU=%i ", intstat & USBD_E0FU ? 1 : 0);
+	printk("SET=%i ", intstat & USBD_SET ? 1 : 0);
+	printk("\n");
+#endif
+
+	if (!dev) {
+		printk("%s: Entering interrupt without being initialized!\n",
+		       driver_name);
+		BUG();
+		return IRQ_HANDLED;;	/* FIXME: right for unhandled? */
+	}
+
+	/* hardware bug: mask doesn't seem to work correctly, we have to check. */
+
+	intstat &= ~intmask;
+
+	dev->stats.irqs++;
+
+	if (intstat & USBD_E0STL) {
+		printk("%s: EP0 STALL\n", __FUNCTION__);
+	}
+
+	if (intstat & USBD_SUS) {
+		switch (dev->ep0state) {
+		case EP0_OK:
+			if (dev->gadget.speed != USB_SPEED_UNKNOWN
+			    && dev->driver && dev->driver->suspend)
+				dev->driver->suspend(&dev->gadget);
+			dev->ep0state = EP0_SUSPEND;
+			break;
+
+		case EP0_SUSPEND:
+			if (dev->gadget.speed != USB_SPEED_UNKNOWN
+			    && dev->driver && dev->driver->resume)
+				dev->driver->resume(&dev->gadget);
+			dev->ep0state = EP0_OK;
+			break;
+
+		default:
+			printk("%s: warning: entering suspend state UNKNOWN\n",
+			       driver_name);
+			break;
+		}
+	}
+
+	if (intstat & USBD_RESET) {
+		struct usb_ctrlrequest r;
+#ifdef DEBUG_IRQ
+		printk("%s: RESET\n", __FUNCTION__);
+#endif
+		memset(&r, 0, sizeof (r));
+		dev->gadget.speed = USB_SPEED_FULL;
+
+		/* 
+		 * we cannot decode EP0 traffic, so call setup from here and
+		 * fake it
+		 */
+		r.bRequest = USB_REQ_SET_CONFIGURATION;
+		r.bRequestType = 0;
+		r.wValue = GS_BULK_CONFIG_ID;
+		if (dev->ep0state != EP0_RESET)
+			dev->driver->setup(&dev->gadget, &r);
+		dev->ep0state = EP0_RESET;
+	} else if (dev->ep0state == EP0_RESET)
+		dev->ep0state = EP0_OK;
+
+	if (intstat & USBD_E2EM) {
+		handle_ep(&dev->ep[2], 0);
+	}
+
+	if (intstat & USBD_E1OV) {
+		printk(KERN_ERR "%s: EP1 overflow! should not happen!\n",
+		       __FUNCTION__);
+	}
+
+	if (intstat & USBD_E1FU) {
+#ifdef DEBUG_IRQ
+		printk("%s: EP1 full\n", __FUNCTION__);
+		printk("%d bytes to read\n", ep1rxbyte);
+#endif
+		/* 
+		 * FIXME: hardware bug: counter doesn't work in non
+		 * maximum packet mode, but it seems we actually _see_
+		 * non-32 bytes packets! ???
+		 */
+		handle_ep(&dev->ep[1], ep1rxbyte);
+	}
+
+	if (intstat & USBD_E0EM) {
+		printk("%s: EP0 empty\n", __FUNCTION__);
+	}
+
+	if (intstat & USBD_E0OV) {
+		printk(KERN_ERR "%s: EP0 overflow! should not happen!\n",
+		       __FUNCTION__);
+	}
+
+	if (intstat & USBD_E0FU) {
+		printk("%s: EP0 full\n", __FUNCTION__);
+	}
+
+	if (intstat & USBD_SET) {
+		printk("%s: EP0 set\n", __FUNCTION__);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct usb_request
+*
+h7202_ep_alloc_request(struct usb_ep *_ep, int gfp_flags)
+{
+	struct h7202_request *req;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	req = kmalloc(sizeof *req, gfp_flags);
+
+	if (!req)
+		return 0;
+
+	memset(req, 0, sizeof *req);
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void
+h7202_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct h7202_request *req;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	req = container_of(_req, struct h7202_request, req);
+	kfree(req);
+
+}
+
+static void
+done(struct h7202_ep *ep, struct h7202_request *req, int status)
+{
+	unsigned stopped = ep->stopped;
+
+#ifdef DEBUG_PACKETS
+	printk("\n%s: ep=%s req.length=%i req.actual=%i\n", __FUNCTION__,
+	       ep->ep.name, req->req.length, req->req.actual);
+
+	for (i = 0; i < req->req.actual; i++) {
+		printk("%s", i % 16 ? "" : i ? "\n" : "");
+		buf = req->req.buf + i;
+		printk("%02x ", *buf++);
+	}
+	printk("%s", (i % 16 == 1) ? "\n" : "");
+#endif
+
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+		pr_debug("complete %s req %p stat %d len %u/%u\n",
+			 ep->ep.name, &req->req, status,
+			 req->req.actual, req->req.length);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+	pr_debug("%s: calling completion handler\n", __FUNCTION__);
+	req->req.complete(&ep->ep, &req->req);
+	ep->stopped = stopped;
+}
+
+static int
+h7202_ep_queue(struct usb_ep *_ep, struct usb_request *_req, int gfp_flags)
+{
+	struct h7202_request *req;
+	struct h7202_ep *ep;
+	struct h7202_udc *dev;
+
+#ifdef DEBUG_REQ
+	printk("%s: %s queue req %p, len %d buf %p\n", __FUNCTION__,
+	       _ep->name, _req, _req->length, _req->buf);
+#endif
+
+	req = container_of(_req, struct h7202_request, req);
+	if (unlikely(!_req || !_req->complete || !_req->buf
+		     || !list_empty(&req->queue))) {
+		pr_debug("%s, bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		pr_debug("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		pr_debug("%s, bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	if (likely(req))
+		list_add_tail(&req->queue, &ep->queue);
+	else
+		pr_debug("%s: can not queue request\n", __FUNCTION__);
+
+	if (ep->num == 2 && !ep->stopped) {
+		pr_debug("%s: start EP2\n", __FUNCTION__);
+		CPU_REG(USBD_BASE, USBD_INTMASK) &= ~USBD_E2EM;
+	}
+
+	return 0;
+}
+
+static int
+h7202_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct h7202_ep *ep;
+	struct h7202_request *req;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+
+	if (&req->req != _req)
+		return -EINVAL;
+
+	done(ep, req, -ECONNRESET);
+
+	return 0;
+}
+
+static void
+nuke(struct h7202_ep *ep, int status)
+{
+	struct h7202_request *req;
+
+	pr_debug("%s\n", __FUNCTION__);
+	ep->stopped = 1;
+
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct h7202_request, queue);
+		done(ep, req, status);
+	}
+}
+
+static int
+h7202_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct h7202_ep *ep;
+	struct h7202_udc *dev;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT) {
+		pr_debug("%s, bad ep or descriptor\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+	     && le16_to_cpu(desc->wMaxPacketSize) != FIFO_SIZE)
+	    || !desc->wMaxPacketSize) {
+		pr_debug("%s, bad %s maxpacket\n", __FUNCTION__, _ep->name);
+		printk("wMaxPacketSize=%i\n", desc->wMaxPacketSize);
+		printk("FIFO_SIZE=%i\n", FIFO_SIZE);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		pr_debug("%s, bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	ep->desc = desc;
+	ep->stopped = 0;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* FIXME: flush fifo? (mostly for OUT buffers) */
+
+	pr_debug("enabled %s\n", _ep->name);
+	return 0;
+}
+
+static int
+h7202_ep_disable(struct usb_ep *_ep)
+{
+	struct h7202_ep *ep;
+
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (!_ep || !ep->desc) {
+		pr_debug("%s, %s not enabled\n", __FUNCTION__,
+			 _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+	nuke(ep, -ESHUTDOWN);
+
+	/* flush fifo (mostly for IN buffers) */
+	/* BSP: TODO */
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	pr_debug("%s: %s disabled\n", __FUNCTION__, _ep->name);
+	return 0;
+}
+
+static int
+h7202_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct h7202_ep *ep;
+
+	pr_debug("%s\n", __FUNCTION__);
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		pr_debug("%s: bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (value == 0) {
+		pr_debug("%s: SET_INTERFACE is not supported\n", __FUNCTION__);
+		return -ENOTSUPP;
+	}
+
+	if (value) {
+		switch (ep->num) {
+		case 0:
+			ep->dev->ep0state = EP0_STALL;
+			CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_E0ST;
+			CPU_REG(USBD_BASE, USBD_EPCTRL) &= ~USBD_E0EN;
+			break;
+
+		case 1:
+			CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_E1ST;
+			CPU_REG(USBD_BASE, USBD_EPCTRL) &= ~USBD_E1EN;
+			break;
+
+		case 2:
+			CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_E2ST;
+			CPU_REG(USBD_BASE, USBD_EPCTRL) &= ~USBD_E2EN;
+			break;
+		}
+
+		ep->dev->ep[ep->num].stopped = 1;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+h7202_ep_fifo_status(struct usb_ep *_ep)
+{
+	struct h7202_ep *ep;
+
+	pr_debug("%s\n", __FUNCTION__);
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (!_ep) {
+		pr_debug("%s: bad ep\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	/* BSP: FIXME */
+	return -EOPNOTSUPP;
+}
+
+static void
+h7202_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct h7202_ep *ep;
+
+	pr_debug("%s\n", __FUNCTION__);
+	ep = container_of(_ep, struct h7202_ep, ep);
+	if (!_ep || !list_empty(&ep->queue)) {
+		pr_debug("%s: bad ep\n", __FUNCTION__);
+		return;
+	}
+
+	switch (ep->num) {
+	case 0:
+		CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_CLR0;
+		break;
+	case 1:
+		CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_CLR1;
+		break;
+	case 2:
+		CPU_REG(USBD_BASE, USBD_EPCTRL) |= USBD_CLR2;
+		break;
+	default:
+		pr_debug("%s: bad ep (#%d)\n", __FUNCTION__, ep->num);
+	}
+}
+
+/*
+ * h7202_disable - disable the chip
+ */
+
+static void
+h7202_disable(struct h7202_udc *dev)
+{
+	/* no power, no clock, no EP, no interrupts */
+	CPU_REG(USBD_BASE, USBD_PWR) = 0x0;
+	CPU_REG(USBD_BASE, USBD_EPCTRL) &= 0xFFC00000;
+	CPU_REG(USBD_BASE, USBD_INTMASK) = USBD_INTMASK_DISABLE;
+	CPU_REG(USBD_BASE, USBD_INTSTAT) = 0x0;
+
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+}
+
+/*
+ * h7202_reinit - 
+ */
+
+static void
+h7202_reinit(struct h7202_udc *dev)
+{
+	u32 i;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = EP0_OK;
+
+	/* basic endpoint records init */
+	for (i = 0; i < 3; i++) {
+		struct h7202_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+
+/*
+ * 
+ */
+
+static void
+h7202_enable(struct h7202_udc *dev)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	/* enable clock, power and clear all interupts */
+	CPU_REG(USBD_BASE, USBD_PWR) = (USBD_ENBCLK | USBD_FULLPOWER);
+	CPU_REG(USBD_BASE, USBD_GCTRL) = USBD_DMADIS;
+
+	/* enable EP0/1/2 */
+	CPU_REG(USBD_BASE, USBD_EPCTRL) = (USBD_E0EN | USBD_E1EN | USBD_E2EN);
+
+	CPU_REG(USBD_BASE, USBD_INTMASK) = ~(USBD_E0STL |
+					     USBD_RESET |
+					     USBD_E1FU | USBD_E0FU | USBD_SET);
+}
+
+/*
+ * 
+ */
+static void *
+h7202_ep_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
+		      dma_addr_t * dma, int gfp_flags)
+{
+	char *retval;
+
+	pr_debug("%s\n", __FUNCTION__);
+	retval = kmalloc(bytes, gfp_flags & ~(__GFP_DMA | __GFP_HIGHMEM));
+	if (retval)
+		*dma = virt_to_bus(retval);
+
+	return retval;
+}
+
+static void
+h7202_ep_free_buffer(struct usb_ep *_ep, void *buf, dma_addr_t dma,
+		     unsigned bytes)
+{
+	pr_debug("%s\n", __FUNCTION__);
+	kfree(buf);
+}
+
+/*
+ * structures
+ */
+
+static struct usb_ep_ops h7202_ep_ops = {
+	.enable = h7202_ep_enable,
+	.disable = h7202_ep_disable,
+
+	.alloc_request = h7202_ep_alloc_request,
+	.free_request = h7202_ep_free_request,
+
+	.alloc_buffer = h7202_ep_alloc_buffer,
+	.free_buffer = h7202_ep_free_buffer,
+
+	.queue = h7202_ep_queue,
+	.dequeue = h7202_ep_dequeue,
+
+	.set_halt = h7202_ep_set_halt,
+	.fifo_status = h7202_ep_fifo_status,
+	.fifo_flush = h7202_ep_fifo_flush,
+};
+
+static const struct usb_gadget_ops h7202_udc_ops = {
+	.get_frame = NULL,
+	.wakeup = NULL,
+	/* current versions must always be selfpowered */
+};
+
+static struct h7202_udc memory = {
+	.gadget = {
+		   .ops = &h7202_udc_ops,
+		   .ep0 = &memory.ep[0].ep,
+		   .name = driver_name,
+		   .dev = {
+			   .bus_id = "gadget",
+			   },
+		   },
+
+	.ep = {
+	       [0] = {
+		      .ep = {
+			     .name = ep0name,
+			     .ops = &h7202_ep_ops,
+			     .maxpacket = FIFO_SIZE,
+			     },
+		      .dev = &memory,
+		      .ep_rdaddr = (u32 *) (USBD_BASE + USBD_ENDP0RD),
+		      .ep_wtaddr = (u32 *) (USBD_BASE + USBD_ENDP0WT),
+		      .num = 0,
+		      },
+
+	       [1] = {
+		      .ep = {
+			     .name = "ep1",
+			     .ops = &h7202_ep_ops,
+			     .maxpacket = FIFO_SIZE,
+			     },
+		      .dev = &memory,
+		      .ep_rdaddr = (u32 *) (USBD_BASE + USBD_ENDP1RD),
+		      .ep_wtaddr = NULL,
+		      .num = 1,
+		      },
+
+	       [2] = {
+		      .ep = {
+			     .name = "ep2",
+			     .ops = &h7202_ep_ops,
+			     .maxpacket = FIFO_SIZE,
+			     },
+		      .dev = &memory,
+		      .ep_rdaddr = NULL,
+		      .ep_wtaddr = (u32 *) (USBD_BASE + USBD_ENDP2WT),
+		      .num = 2,
+		      },
+	       }
+};
+
+/*
+ * usb_gadget_X functions
+ */
+
+int
+usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct h7202_udc *dev = the_controller;
+	int retval;
+
+	pr_debug("%s\n", __FUNCTION__);
+	if (!driver
+	    || driver->speed != USB_SPEED_FULL
+	    || !driver->bind
+	    || !driver->unbind || !driver->disconnect || !driver->setup)
+		return -EINVAL;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first register the driver */
+	dev->driver = driver;
+
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		pr_debug("bind to driver %s --> error %d\n",
+			 driver->driver.name, retval);
+
+		dev->driver = 0;
+		return retval;
+	}
+
+	/* ... then enable host detection and ep0; and we're ready
+	 * for set_configuration as well as eventual disconnect.
+	 * NOTE:  this shouldn't power up until later.
+	 */
+	pr_debug("registered gadget driver '%s'\n", driver->driver.name);
+
+	h7202_enable(dev);
+	dump_state(dev);
+
+	return 0;
+}
+
+int
+usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct h7202_udc *dev = the_controller;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	h7202_disable(dev);
+
+	driver->unbind(&dev->gadget);
+	dev->driver = 0;
+
+	pr_debug("unregistered gadget driver '%s'\n", driver->driver.name);
+	dump_state(dev);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_register_driver);
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*
+ * cleanup - 
+ */
+
+static void __exit
+cleanup(void)
+{
+	struct h7202_udc *dev = the_controller;
+
+	remove_proc_entry("h7202_udc", proc_h7202_status);
+
+	usb_gadget_unregister_driver(dev->driver);
+	if (dev->got_irq) {
+		free_irq(IRQ_USB, dev);
+		dev->got_irq = 0;
+	}
+
+	the_controller = 0;
+	release_mem_region(USBD_BASE, USBD_LENGTH);
+}
+
+/*
+ *      init - allocate resources
+ */
+
+static int __init
+init(void)
+{
+	struct h7202_udc *dev;
+	int retval;
+
+	printk(KERN_INFO "%s: %s (%s)\n", driver_name, DRIVER_DESC,
+	       DRIVER_VERSION);
+
+	if (!request_mem_region(USBD_BASE, USBD_LENGTH, driver_name))
+		return -EBUSY;
+
+	dev = &memory;
+	the_controller = dev;
+
+	h7202_disable(dev);
+	h7202_reinit(dev);
+
+	retval = request_irq(IRQ_USB, h7202_udc_irq,
+			     SA_INTERRUPT, driver_name, dev);
+	if (retval != 0) {
+		printk(KERN_ERR "%s: can't get irq %i, err %d\n",
+		       driver_name, IRQ_USB, retval);
+		return -EBUSY;
+	}
+
+	dev->got_irq = 1;
+
+	proc_h7202_status = create_proc_entry("h7202_udc", 0660, NULL);
+
+	proc_h7202_status->nlink = 1;
+	proc_h7202_status->read_proc = h7202_status_read;
+
+	return 0;
+}
+
+module_init(init);
+module_exit(cleanup);
